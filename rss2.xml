<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>cosyer&#39;s Blog</title>
    <link>http://mydearest.cn/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>陈宇的博客</description>
    <pubDate>Thu, 09 Aug 2018 01:16:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>获取浏览器url参数方法总结</title>
      <link>http://mydearest.cn/%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</link>
      <guid>http://mydearest.cn/%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Wed, 08 Aug 2018 15:21:52 GMT</pubDate>
      <description>
      
        
        
          &lt;ol&gt;
&lt;li&gt;&lt;p&gt;正则(xxx?typeId=1)&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
        
      
      </description>
      
      <content:encoded><![CDATA[<ol><li><p>正则(xxx?typeId=1)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'(^|&amp;)'</span> + name + <span class="string">'=([^&amp;]*)(&amp;|$)'</span>, <span class="string">'i'</span>);</span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">getQueryString(<span class="string">"typeId"</span>) <span class="comment">// "2"</span></span><br></pre></td></tr></table></figure></li><li><p>split拆分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = location.search; <span class="comment">//获取url中"?"符后的字串</span></span><br><span class="line">    <span class="keyword">var</span> theRequest = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">"?"</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = url.substr(<span class="number">1</span>);</span><br><span class="line">        strs = str.split(<span class="string">"&amp;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; strs.length; i ++) &#123;</span><br><span class="line">            theRequest[strs[i].split(<span class="string">"="</span>)[<span class="number">0</span>]] = <span class="built_in">unescape</span>(strs[i].split(<span class="string">"="</span>)[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> theRequest;</span><br><span class="line">&#125;</span><br><span class="line">getQueryString(<span class="string">"typeId"</span>) <span class="comment">// &#123;typeId:"2&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>正则获值 和1一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params">name</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span> + name + <span class="string">"=([^&amp;]*)(&amp;|$)"</span>, <span class="string">"i"</span>);  </span><br><span class="line">    <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);  <span class="comment">//获取url中"?"符后的字符串并正则匹配</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="string">""</span>;  </span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>)  </span><br><span class="line">         context = r[<span class="number">2</span>];  </span><br><span class="line">    reg = <span class="literal">null</span>;  </span><br><span class="line">    r = <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">return</span> context == <span class="literal">null</span> || context == <span class="string">""</span> || context == <span class="string">"undefined"</span> ? <span class="string">""</span> : context;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单参数获取(?1)获取？后面的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url=<span class="built_in">window</span>.location.href</span><br><span class="line">url.substring(url.indexOf(<span class="string">'?'</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// url.substr(url.indexOf('?') + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url=<span class="built_in">window</span>.location.search</span><br><span class="line">url.substring(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// url.substr(1)</span></span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>http://mydearest.cn/%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>单页应用优缺点分析</title>
      <link>http://mydearest.cn/spa.html</link>
      <guid>http://mydearest.cn/spa.html</guid>
      <pubDate>Thu, 26 Jul 2018 13:24:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。</p><hr><a id="more"></a><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>1、分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；前后台分离开发模式。</p><p>2、减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；</p><p>3、同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；</p><ol start="4"><li>服务器压力变小，后台不需要负责模板渲染，输出页面工作。ajax实现页面刷新，不需要重新加载整个页面。</li></ol><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>1、SEO问题，现在可以通过Prerender等技术解决一部分；</p><p>2、前进、后退、地址栏等，需要自行实现；</p><p>3、初次加载时间较多；</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/spa.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>https加密通信流程解析</title>
      <link>http://mydearest.cn/https%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1.html</link>
      <guid>http://mydearest.cn/https%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1.html</guid>
      <pubDate>Wed, 25 Jul 2018 14:18:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;https其实是有两部分组成：http + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。&lt;/p&gt;
&lt;p&gt;https比http要占用更多的资源，http使用TCP 三次握手建立连接，客户端和服务器需要交换3个包，https除了 TCP 的三个包，还要加上 ssl握手需要的9个包，所以一共是12个包。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>https其实是有两部分组成：http + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p><p>https比http要占用更多的资源，http使用TCP 三次握手建立连接，客户端和服务器需要交换3个包，https除了 TCP 的三个包，还要加上 ssl握手需要的9个包，所以一共是12个包。</p><hr><a id="more"></a><h2 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h2><h3 id="客户端发起HTTPS请求"><a href="#客户端发起HTTPS请求" class="headerlink" title="客户端发起HTTPS请求"></a>客户端发起HTTPS请求</h3><p>用户在浏览器里输入一个https网址，然后连接到server的443端口。</p><h3 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h3><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><h3 id="传送证书"><a href="#传送证书" class="headerlink" title="传送证书"></a>传送证书</h3><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><h3 id="传送加密信息"><a href="#传送加密信息" class="headerlink" title="传送加密信息"></a>传送加密信息</h3><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><h3 id="服务段解密信息"><a href="#服务段解密信息" class="headerlink" title="服务段解密信息"></a>服务段解密信息</h3><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><h3 id="传输加密后的信息"><a href="#传输加密后的信息" class="headerlink" title="传输加密后的信息"></a>传输加密后的信息</h3><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><h3 id="客户端解密信息"><a href="#客户端解密信息" class="headerlink" title="客户端解密信息"></a>客户端解密信息</h3><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/https%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>网页埋点相关知识</title>
      <link>http://mydearest.cn/%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF.html</link>
      <guid>http://mydearest.cn/%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF.html</guid>
      <pubDate>Wed, 25 Jul 2018 06:04:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;埋点的需求：一个网站上线,开发者除了保证网站功能正常,体验优好之外,还有一项重要的工作是数据收集,通过收集用户的行为数据可以帮助了解网站的功能是否满足用户的需求,导流方式是否有效,新功能上线后是否效果是否达到设计初衷,根据数据指引有效优化产品体验以及发现新的产品方向是产品经理的必备技能,而如何采集准确并且足够的网站数据则应该是开发者的责任.在大数据处理能力越来越强下,以及机器学习等依赖数据哺育的工具进化下,采集足够多的数据往往是网站向着良性方向进化的必备条件&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>埋点的需求：一个网站上线,开发者除了保证网站功能正常,体验优好之外,还有一项重要的工作是数据收集,通过收集用户的行为数据可以帮助了解网站的功能是否满足用户的需求,导流方式是否有效,新功能上线后是否效果是否达到设计初衷,根据数据指引有效优化产品体验以及发现新的产品方向是产品经理的必备技能,而如何采集准确并且足够的网站数据则应该是开发者的责任.在大数据处理能力越来越强下,以及机器学习等依赖数据哺育的工具进化下,采集足够多的数据往往是网站向着良性方向进化的必备条件</p><hr><a id="more"></a><h2 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h2><p>网站的数据采集有很多现成的工具,如google Analytics, 百度统计, 友盟+等,往往通过在页面上接入js SDK代码。</p><p>而在实际采集过程中,数据是如何传递过去的呢,,我们随便打开一个埋有百度统计的网站, 打开chrome的开发者工具,勾选Preserve log,可以发现在页面点击一个链接或者做一些其他操作,在Networking tab下可以看到hm.gif的网络请求, 这里由于统计的数据发送涉及到第三方网址,涉及跨域问题,而图片请求天然是跨域的,所以业界的通用做法是构造一个空的gif用于向第三方网站, 而真正需要统计的参数往往是通过url进行传递。</p><h2 id="数据采集-生成图片Url参数挂在-上"><a href="#数据采集-生成图片Url参数挂在-上" class="headerlink" title="数据采集(生成图片Url参数挂在?上)"></a>数据采集(生成图片Url参数挂在?上)</h2><ul><li><p>基本的发送函数，创建Img发送统计请求导数据采集后台。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendUrl</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> Image();  <span class="comment">// 创建一个img对象</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="string">'project_log_'</span> <span class="comment">// 为本次数据请求创建一个唯一id</span></span><br><span class="line">        + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">2147483648</span>).toString(<span class="number">36</span>); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">window</span>[key] = img;   <span class="comment">// 用一个数组维护img对象</span></span><br><span class="line"> </span><br><span class="line">    img.onload = img.onerror = img.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        img.onload = img.onerror = img.onabort = <span class="literal">null</span>;  <span class="comment">// 清除img元素</span></span><br><span class="line">        <span class="built_in">window</span>[key] = <span class="literal">null</span>;</span><br><span class="line">        img = <span class="literal">null</span>;  </span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = url;  <span class="comment">// img对象赋值url后自动发送请求,无需插入到页面元素中去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据格式约定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据格式规则,如:<span class="number">1.</span>gif?q=xxx&amp;fr=xxx&amp;refer=xxx&amp;p=xxxx&amp;xxxxx</span><br><span class="line">q表示页面搜索词; fr表示页面的上游页面时什么, refer是指从来源页面, p表示事件类型等;</span><br></pre></td></tr></table></figure></li></ul><h2 id="访问时长的计算"><a href="#访问时长的计算" class="headerlink" title="访问时长的计算"></a>访问时长的计算</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> st = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();  <span class="comment">// 在页面加载运行js时记录当前时间</span></span><br><span class="line"></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'beforeunload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> et = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">var</span> stayTime = et - st;</span><br><span class="line">    </span><br><span class="line">&#125;); <span class="comment">// 在页面要unload触发'beforeunload'事件时进行时间差计算得到访问时长</span></span><br></pre></td></tr></table></figure><h2 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h2><h3 id="PV-pageview"><a href="#PV-pageview" class="headerlink" title="PV pageview"></a>PV pageview</h3><p>传统意义上每次页面刷新代表着一次新的pv, 也就是每次统计js执行时都+1, 而现在页面很多都用到了ajax技术来进行无刷新获取展现页面来替代翻页,如瀑布流页面通过下来加载新的页面,这时候页面不重新刷新,因此可以在ajax请求接口处进行埋点进行pv累加;</p><h3 id="单项PV"><a href="#单项PV" class="headerlink" title="单项PV"></a>单项PV</h3><p>页面上部分元素有单独统计pv的需要,有些页面元素不是页面展现都展现,或者需要统计类似于某一广告的展现次数,这种需要需要在url里单独定义参数来标识;</p><h3 id="聚焦时间"><a href="#聚焦时间" class="headerlink" title="聚焦时间"></a>聚焦时间</h3><p>与访问时长不同,由于页面可以通过tab切换导致虽然页面没有unload但实际处于失去焦点状态, 因此需要订阅focusIn与focusOut两个事件,在focusIn时开始计时, 在focusOut时停止计时,在页面unload时将focus时间进行累加得到聚焦时间;</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>export/export default/import的区别以及用法</title>
      <link>http://mydearest.cn/es6export.html</link>
      <guid>http://mydearest.cn/es6export.html</guid>
      <pubDate>Fri, 06 Jul 2018 06:41:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;ES6模块主要有两个功能：export和import&lt;/p&gt;
&lt;p&gt;export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口&lt;/p&gt;
&lt;p&gt;import用于在一个模块中加载另一个含有export接口的模块。&lt;/p&gt;
&lt;p&gt;也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>ES6模块主要有两个功能：export和import</p><p>export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口</p><p>import用于在一个模块中加载另一个含有export接口的模块。</p><p>也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p><hr><a id="more"></a><h2 id="export和import（一个导出一个导入）"><a href="#export和import（一个导出一个导入）" class="headerlink" title="export和import（一个导出一个导入）"></a>export和import（一个导出一个导入）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a 文件 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name=<span class="string">"cosyer"</span> <span class="comment">// 导出单个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用a文件 </span></span><br><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">'./a'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    howl:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// cosyer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出多个变量 </span></span><br><span class="line"><span class="keyword">let</span> name1=<span class="string">'张三'</span>;</span><br><span class="line"><span class="keyword">let</span> name2=<span class="string">'李四'</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name1,name2&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用多个变量</span></span><br><span class="line"><span class="keyword">import</span> &#123;name1,name2&#125; <span class="keyword">from</span> <span class="string">'./a'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mini</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;mini&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;mini&#125; <span class="keyword">from</span> <span class="string">'./a'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    howl:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        mini(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="export和export-default"><a href="#export和export-default" class="headerlink" title="export和export default"></a>export和export default</h2><ol><li><p>export与export default均可用于导出常量、函数、文件、模块等。</p></li><li><p>你可以在其它文件或模块中通过import + (常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用。</p></li><li><p>在一个文件或模块中，export、import可以有多个，export default仅有一个。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> name1;</span><br><span class="line"><span class="keyword">export</span> name2;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过export方式导出，在导入时要加{}，export default则不需要。</li></ol><p>其实很多时候export与export default可以实现同样的目的，但使用export default命令，为模块指定默认输出，这样就不需要知道加载模块的变量名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">'./a'</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://mydearest.cn/es6export.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>mobx -- 走进观察者模式</title>
      <link>http://mydearest.cn/mobx.html</link>
      <guid>http://mydearest.cn/mobx.html</guid>
      <pubDate>Fri, 06 Jul 2018 02:09:29 GMT</pubDate>
      <description>
      
        
        
          &lt;h4 id=&quot;React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。&quot;&gt;&lt;a href=&quot;#React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。&quot; class=&quot;headerlink&quot; title=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h4 id="React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。"><a href="#React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。" class="headerlink" title="React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。"></a>React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。</h4><h4 id="React-提供了优化UI渲染的机制，-这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。"><a href="#React-提供了优化UI渲染的机制，-这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。" class="headerlink" title="React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。"></a>React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。</h4><h4 id="MobX-提供了优化应用状态与-React-组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。"><a href="#MobX-提供了优化应用状态与-React-组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。" class="headerlink" title="MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。"></a>MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。</h4><h4 id="redux缓存机制-时间回溯适用于撤销操作-操作状态"><a href="#redux缓存机制-时间回溯适用于撤销操作-操作状态" class="headerlink" title="redux缓存机制 时间回溯适用于撤销操作 操作状态"></a>redux缓存机制 时间回溯适用于撤销操作 操作状态</h4><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save mobx mobx-react</span><br></pre></td></tr></table></figure></li><li><p>核心概念</p></li></ol><ul><li>state(状态) 状态是驱动应用的数据。</li><li>observable(value) &amp;&amp; @observable Observable 值可以是JS基本数据类型、引用类型、普通对象、类实例、数组和映射。其修饰的state会暴露出来供观察者使用。</li><li>observer(观察者)被observer修饰的组件，将会根据组件内使用到的被observable修饰的state的变化而自动重新渲染。</li><li>action(动作)只有在 actions 中，才可以修改 Mobx 中 state 的值。action–&gt;state–&gt;view</li><li>computed 计算值(computed values)是可以根据现有的状态或其它计算值衍生出的值。(可以看成公式)getter：获得计算得到的新state并返回。setter： 不能用来直接改变计算属性的值，但是它们可以用来作”逆向”衍生。</li><li>autorun这通常是当你需要从反应式代码桥接到命令式代码的情况，例如打印日志、持久化或者更新UI的代码。</li><li>如果你有一个函数应该自动运行，但不会产生一个新的值，请使用autorun。 其余情况都应该使用 computed。</li><li>reactionsReactions 和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新 React 组件树以修补DOM、等等。 简而言之，reactions 在 响应式编程和命令式编程之间建立沟通的桥梁。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// component</span><br><span class="line">import &#123;inject, observer&#125; from &quot;mobx-react&quot;;</span><br><span class="line"></span><br><span class="line">// 观察者 注入store添加到属性上</span><br><span class="line">@inject(&quot;store&quot;) @observer</span><br><span class="line"></span><br><span class="line">this.props.store.xxStore.num</span><br><span class="line">this.props.store.xxStore.plus() // num+=1</span><br><span class="line">this.props.store.xxStore.total</span><br><span class="line"></span><br><span class="line">// homeStore</span><br><span class="line"></span><br><span class="line">@observable num;</span><br><span class="line">construtor()&#123;</span><br><span class="line">    this.name=&apos;&apos;</span><br><span class="line">    this.items=[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@computed get total() &#123;</span><br><span class="line">    return this.items.length;</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">@action plus=()=&gt;&#123;</span><br><span class="line">    this.num+=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">autorun((e)=&gt;&#123;&#125;)</span><br><span class="line"></span><br><span class="line">const homeStore =new HomeStore()</span><br><span class="line">export &#123;homeStore&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch</span><br><span class="line">router render=&#123;(props)=&gt;&lt;Item &#123;...props&#125;/&gt;&#125;</span><br><span class="line">router component=&#123;Index&#125;</span><br><span class="line">react-route-dom</span><br><span class="line">withRouter</span><br><span class="line">Linking</span><br><span class="line">// Provider 传递stores</span><br><span class="line">Privider store=&#123;stores&#125;</span><br><span class="line">create-react-app react-scripts</span><br></pre></td></tr></table></figure><p>基本就这两种方法:immutable/observablemobx: oopredux: 函数式</p><p>ssr:流模式、字符串</p><p><a href="https://github.com/cosyer/mobx-demo" target="_blank" rel="noopener">demo地址</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/mobx.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>主流浏览器的内核和渲染方式解读</title>
      <link>http://mydearest.cn/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E8%A7%A3%E8%AF%BB.html</link>
      <guid>http://mydearest.cn/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E8%A7%A3%E8%AF%BB.html</guid>
      <pubDate>Thu, 05 Jul 2018 13:24:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;浏览器内核&quot;&gt;&lt;a href=&quot;#浏览器内核&quot; class=&quot;headerlink&quot; title=&quot;浏览器内核&quot;&gt;&lt;/a&gt;浏览器内核&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Trident:IE，360，搜狗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Gecko：firefox&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><ul><li><p>Trident:IE，360，搜狗</p></li><li><p>Gecko：firefox</p></li><li><p>webkit:safari，旧版chrome</p></li><li><p>presto：旧版opera</p></li><li><p>blink：新版chrome，新版opera</p></li></ul><h2 id="浏览器的渲染方式"><a href="#浏览器的渲染方式" class="headerlink" title="浏览器的渲染方式"></a>浏览器的渲染方式</h2><ol><li><p>构建DOM树浏览器请求到html代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求。</p></li><li><p>构建CSSOMcss文件加载完成，开始构建CSSOM</p></li><li><p>生成渲染树（Render Tree）CSSOM构建结束后，和DOM一起生成Render Tree</p></li><li><p>布局（Layout）有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义以及他们的从属关系。开始布局，计算出各个节点在屏幕中的位置。</p></li><li><p>Paint绘制布局之后，浏览器知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置。所以接下来按照算出来的规则，通过显卡，把内容画在屏幕上。</p></li></ol>]]></content:encoded>
      
      <comments>http://mydearest.cn/%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E8%A7%A3%E8%AF%BB.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>flex布局</title>
      <link>http://mydearest.cn/flex.html</link>
      <guid>http://mydearest.cn/flex.html</guid>
      <pubDate>Thu, 05 Jul 2018 13:04:18 GMT</pubDate>
      <description>
      
        &lt;p&gt;芮 rui 四声&lt;/p&gt;
&lt;p&gt;浏览器前缀 -webkit/chrome、safari -moz/firefox -ms/ie -o/opera&lt;/p&gt;
&lt;p&gt;弹性伸缩flexbox布局 &lt;/p&gt;
&lt;p&gt;任何一个容器都可设为display:flex&lt;/p&gt;
&lt;p&gt;行内元素 display:inline-flex&lt;/p&gt;
&lt;p&gt;webkit内核浏览器（Safari） display:-webkit-flex; display:flex&lt;/p&gt;
&lt;p&gt;设为flex布局以后，子元素的float、clear、vertival-align属性将失效。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>芮 rui 四声</p><p>浏览器前缀 -webkit/chrome、safari -moz/firefox -ms/ie -o/opera</p><p>弹性伸缩flexbox布局 </p><p>任何一个容器都可设为display:flex</p><p>行内元素 display:inline-flex</p><p>webkit内核浏览器（Safari） display:-webkit-flex; display:flex</p><p>设为flex布局以后，子元素的float、clear、vertival-align属性将失效。</p><hr><a id="more"></a><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><h3 id="flex-direction-决定主轴的方向"><a href="#flex-direction-决定主轴的方向" class="headerlink" title="flex-direction 决定主轴的方向"></a>flex-direction 决定主轴的方向</h3><p>flex-direction:row;  /<em>默认：从左到右</em>/</p><p>flex-direction:row-reverse;  /<em>从右到左</em>/</p><p>flex-direction:column;  /<em>从上到下</em>/</p><p>flex-direction:column-reverse;  /<em>从下到上</em>/</p><h3 id="flex-wrap-一条轴排列不下，如何换行"><a href="#flex-wrap-一条轴排列不下，如何换行" class="headerlink" title="flex-wrap:一条轴排列不下，如何换行"></a>flex-wrap:一条轴排列不下，如何换行</h3><p>flex-wrap:nowrap;  /<em>默认:不换行</em>/</p><p>flex-wrap:wrap;  /<em>换行，第一行在上方</em>/</p><p>flex-wrap:wrap-reverse;  /<em>换行，第一行在下方</em>/</p><h3 id="flex-flow：上面两个的简写"><a href="#flex-flow：上面两个的简写" class="headerlink" title="flex-flow：上面两个的简写"></a>flex-flow：上面两个的简写</h3><p>flex-flow:fiex-direction flex-wrap;  /<em>默认 row no-wrap</em>/</p><h3 id="justify-content-主轴上的对齐方式"><a href="#justify-content-主轴上的对齐方式" class="headerlink" title="justify-content:主轴上的对齐方式"></a>justify-content:主轴上的对齐方式</h3><p>justify-content:flex-start;  /<em>默认：左对齐</em>/</p><p>justify-content:flex-end;  /<em>右对齐</em>/</p><p>justify-content:center;  /<em>居中</em>/</p><p>justify-content:space-between;  /<em>两端对齐，项目之间的间隔相同，边缘项目紧贴边框</em>/</p><p>justify-content:space-around;  /<em>项目两侧的间隔相同，所以，项目之间的间隔比项目与边框的间隔大一倍</em>/</p><h3 id="align-items-交叉轴上如何对齐"><a href="#align-items-交叉轴上如何对齐" class="headerlink" title="align-items:交叉轴上如何对齐"></a>align-items:交叉轴上如何对齐</h3><p>align-items:flex-start;  /<em>起点对齐</em>/</p><p>align-items:flex-end;  /<em>终点对齐</em>/</p><p>align-items:center;  /<em>中点对齐</em>/</p><p>align-items:baseline;  /<em>项目的第一行文字的基线对齐</em>/</p><p>align-items:stretch;  /<em>默认：项目未设高度或auto，占满整个容器高度</em>/</p><h3 id="align-content：多根轴线的对齐方式，只有一根轴线时，不起作用。"><a href="#align-content：多根轴线的对齐方式，只有一根轴线时，不起作用。" class="headerlink" title="align-content：多根轴线的对齐方式，只有一根轴线时，不起作用。"></a>align-content：多根轴线的对齐方式，只有一根轴线时，不起作用。</h3><p>aling-content:flex-start;  /<em>与交叉轴的起点对齐</em>/</p><p>aling-content:flex-end;  /<em>与交叉轴的终点对齐</em>/</p><p>aling-content:center;  /<em>与交叉轴的中点对齐</em>/</p><p>aling-content:space-between;  /<em>与交叉轴两端对齐，轴线之间的间隔平均分布。</em>/</p><p>aling-content:space-around;  /<em>每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</em>/</p><p>aling-content:stretch;  /<em>默认：轴线占满整个交叉轴</em>/</p><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><h3 id="order-定义项目的排列顺序。数值越小，排列越靠前，默认为0。"><a href="#order-定义项目的排列顺序。数值越小，排列越靠前，默认为0。" class="headerlink" title="order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。"></a>order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。</h3><p>order:1;</p><p>order:99;</p><p>order:-1;   </p><p>/<em>-1 1 99的顺序排列</em>/</p><h3 id="flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。"><a href="#flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。" class="headerlink" title="flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。"></a>flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</h3><p>flex-grow: <number>; /<em> default 0 </em>/</number></p><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。</p><p>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"><a href="#flex-shrink-定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。" class="headerlink" title="flex-shrink:定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。"></a>flex-shrink:定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</h3><p>flex-shrink: <number>; /<em> default 1 </em>/</number></p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。</p><p>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="flex-basis-定义了在分配多余空间之前，项目占据的主轴空间（main-size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。"><a href="#flex-basis-定义了在分配多余空间之前，项目占据的主轴空间（main-size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。" class="headerlink" title="flex-basis:定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。"></a>flex-basis:定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</h3><p>flex-basis: <length> | auto; /<em> default auto </em>/</length></p><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex-是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。"><a href="#flex-是flex-grow-flex-shrink-和-flex-basis的简写，默认值为0-1-auto。后两个属性可选。" class="headerlink" title="flex:是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。"></a>flex:是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</h3><p>flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]</p><h3 id="align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。"><a href="#align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。" class="headerlink" title="align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。"></a>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</h3><p>align-self: auto | flex-start | flex-end | center | baseline | stretch;</p><h2 id="react-native使用flex布局注意点"><a href="#react-native使用flex布局注意点" class="headerlink" title="react-native使用flex布局注意点"></a>react-native使用flex布局注意点</h2><ul><li>样式对象需要驼峰式写法</li><li>React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。</li></ul><p>首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。</p><h2 id="扩展阅读："><a href="#扩展阅读：" class="headerlink" title="扩展阅读："></a>扩展阅读：</h2><p><a href="http://www.w3cplus.com/css3/a-guide-to-flexbox-new.html" target="_blank" rel="noopener">w3cplus指南</a><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a><a href="http://blog.csdn.net/magneto7/article/details/70854472" target="_blank" rel="noopener">思维图</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/flex.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>前端工程化</title>
      <link>http://mydearest.cn/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html</link>
      <guid>http://mydearest.cn/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html</guid>
      <pubDate>Thu, 05 Jul 2018 13:04:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;前端的工程化、模块化、组件化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;广义的前端工程化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前端工程是软件工程的一个子类，指的是将软件工程的方法和原理运用在前端开发中, 目的是实现高效开发，有效协同，质量可控。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;狭义
        
      
      </description>
      
      <content:encoded><![CDATA[<p>前端的工程化、模块化、组件化。</p><ol><li>广义的前端工程化</li></ol><p>前端工程是软件工程的一个子类，指的是将软件工程的方法和原理运用在前端开发中, 目的是实现高效开发，有效协同，质量可控。</p><ol start="2"><li>狭义的前端工程化</li></ol><p>前端工程是指将开发阶段代码转变成生产环境的代码的一系列步骤。主要包括构建，分支管理，自动化测试，部署等。</p><p>前端工程化的具体内容</p><ol><li><p>代码规范：保证团队所有成员以同样的规范开发代码。</p></li><li><p>分支管理：不同的开发人员开发不同的功能或组件，按照统一的流程合并到主干。</p></li><li><p>模块管理：一方面，团队引用的模块应该是规范的；另一方面，必须保证这些模块可以正确的加入到最终编译好的包文件中。</p></li><li><p>自动化测试：为了保证和并进主干的代码达到质量标准，必须有测试，而且测试应该是自动化的，可以回归的。</p></li><li><p>构建：主干更新以后，自动将代码编译为最终的目标格式，并且准备好各种静态资源，</p></li><li><p>部署：将构建好的代码部署到生产环境。</p></li></ol>]]></content:encoded>
      
      <comments>http://mydearest.cn/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>服务器推技术</title>
      <link>http://mydearest.cn/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E6%8A%80%E6%9C%AF.html</link>
      <guid>http://mydearest.cn/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E6%8A%80%E6%9C%AF.html</guid>
      <pubDate>Thu, 05 Jul 2018 12:33:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;在做前端页面渲染时，经常会遇到有的组件需要跟随数据的变化而实时的变化，例如：一个线上报名系统，总人数有一定限制，所以要实时的展现已经报名的人数，应该怎么实现呢？最基本有如下3种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ajax轮询&lt;/li&gt;
&lt;li&gt;Ajax长轮询(comet)&lt;/li&gt;
&lt;li&gt;websocket长连接&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在做前端页面渲染时，经常会遇到有的组件需要跟随数据的变化而实时的变化，例如：一个线上报名系统，总人数有一定限制，所以要实时的展现已经报名的人数，应该怎么实现呢？最基本有如下3种方案：</p><ul><li>Ajax轮询</li><li>Ajax长轮询(comet)</li><li>websocket长连接</li></ul><hr><a id="more"></a><h2 id="Ajax轮询"><a href="#Ajax轮询" class="headerlink" title="Ajax轮询"></a>Ajax轮询</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>实现简单，利用XHR,通过setInterval定时向后端发送请求。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>会造成数据在一小段时间内不同步和大量无效的请求，增加后端处理压力.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'https://www.baidu.com/'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//success code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="Ajax长轮询-comet"><a href="#Ajax长轮询-comet" class="headerlink" title="Ajax长轮询(comet)"></a>Ajax长轮询(comet)</h2><p>在Ajax轮询的基础上做的一点改进，在后端数据没有更新的时候不再返回空响应，而且后端一直保存连接，直到后端有数据变化，则相应请求并且关闭连接，前端收到数据，马上再次向后端发起请求，并处理刚刚收到的数据。</p><p>通常的做法是，在服务器的程序中加入一个死循环，在循环中监测数据的变动。当发现新数据时，立即将其输出给浏览器并断开连接，浏览器在收到数据后，再次发起请求以进入下一个周期。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'http://api.3g.qq.com'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">async</span>();</span><br><span class="line">            <span class="comment">//success code</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="websocket长连接"><a href="#websocket长连接" class="headerlink" title="websocket长连接"></a>websocket长连接</h2><p>WebSocket是html5出来的东西(协议)，也就是说和http协议没关系，但http是不支持长链接的，WebSocket其实是一个新协议，跟http协议基本没有关系，只是为了兼容现有浏览器的握手规范而已。</p><p>WebSocket通信协议包含两个部分，一是开放性HTTP握手连接协商连接参数，二是二进制消息分帧机制（接收消息的文本和二进制数据传输）。它是一个独立完善的协议，也可以在浏览器之外实现。</p><h3 id="HTTP升级协商"><a href="#HTTP升级协商" class="headerlink" title="HTTP升级协商"></a>HTTP升级协商</h3><p>WebSocket协议提供了很多强大的特性：基于消息的通信、自定义的二进制分帧层、子协议协商、可选的协议扩展，等等。即在交换数据之前，客户端必须与服务器协商适当的参数以建立连接。</p><p>利用HTTP完成握手有几个好处。首先，让WebSockets与现有HTTP基础设施兼容：WebSocket服务器可以运行在80和443 端口上，这通常是对客户端唯一开放的端口。其次，让我们可以重用并扩展HTTP的Upgrade流，为其添加自定义的WebSocket首部，以完成协商。</p><h3 id="请求头信息"><a href="#请求头信息" class="headerlink" title="请求头信息"></a>请求头信息</h3><p>Connection:Upgrade Sec-WebSocket-Key:eDCPPyPQZq7PiwRcx8SPog== Sec-WebSocket-Version:13 Upgrade:websocket </p><h3 id="响应头信息"><a href="#响应头信息" class="headerlink" title="响应头信息"></a>响应头信息</h3><p>HTTP/1.1 101 Switching Protocols Connection:Upgrade Sec-WebSocket-Accept:/ZVAP3n6XuqDUoDp416PYUO+ZJc= Upgrade:websocket</p><p>最后，前述握手完成后，如果握手成功，该连接就可以用作双向通信信道交换WebSocket消息。到此，客户端与服务器之间不会再发生HTTP通信，一切由WebSocket 协议接管。</p><h3 id="具体使用方法，本文采用node-js中的Socket-IO来进行说明："><a href="#具体使用方法，本文采用node-js中的Socket-IO来进行说明：" class="headerlink" title="具体使用方法，本文采用node.js中的Socket.IO来进行说明："></a>具体使用方法，本文采用node.js中的Socket.IO来进行说明：</h3><ol><li>服务端创建socket.io的实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)(); </span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app); </span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);<span class="comment">//创建实例 </span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123; res.sendfile(<span class="string">'index.html'</span>); &#125;);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a user connected'</span>); </span><br><span class="line">&#125;);<span class="comment">// 监听前端连接 </span></span><br><span class="line"></span><br><span class="line">http.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'listening on *:3000'</span>); &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>数据传输</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端客户端向后端发送数据：</span></span><br><span class="line">socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端接收数据：</span></span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123; socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'message: '</span> + msg); &#125;); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端向前端发送数据：</span></span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123; socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123; </span><br><span class="line">    io.emit(<span class="string">'chat message'</span>, msg); &#125;); &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端接收数据：</span></span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123; <span class="built_in">console</span>.log(msg); &#125;);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://mydearest.cn/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E6%8A%80%E6%9C%AF.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>函数的防抖和节流</title>
      <link>http://mydearest.cn/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html</link>
      <guid>http://mydearest.cn/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html</guid>
      <pubDate>Tue, 03 Jul 2018 14:45:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;场景：事件频繁被触发，频繁执行DOM操作、资源加载等重复行为，导致UI停顿甚至浏览器崩溃。&lt;/p&gt;
&lt;p&gt;函数防抖和节流用于限制函数的执行。是优化高频率执行js代码的一种手段。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>场景：事件频繁被触发，频繁执行DOM操作、资源加载等重复行为，导致UI停顿甚至浏览器崩溃。</p><p>函数防抖和节流用于限制函数的执行。是优化高频率执行js代码的一种手段。</p><hr><a id="more"></a><h2 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h2><p>函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">idle,action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>,</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(last);</span><br><span class="line">    last = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      action.apply(ctx,args);</span><br><span class="line">    &#125;,idle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数连续调用时，空闲时间必须大于或等于idle，action才会执行。</span></span><br></pre></td></tr></table></figure><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timeout !== <span class="literal">null</span>) </span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">        timeout = setTimeout(fn, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 滚动事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, debounce(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><p>当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。</p><p>函数防抖适用于连续调用函数，但只在延时后调用一次。定时器存在则销毁，第一次一定会创建并调用函数。</p><h2 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h2><p>每隔某个时间去执行某函数，避免函数的过多执行。</p><p>如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是说会先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">delay,action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last ;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cur = +<span class="keyword">new</span> <span class="built_in">Date</span>();  <span class="comment">//返回毫秒数</span></span><br><span class="line">    <span class="keyword">if</span>(cur - last &gt; = delay)&#123;</span><br><span class="line">      action.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">      last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际例子-1"><a href="#实际例子-1" class="headerlink" title="实际例子"></a>实际例子</h3><p>函数节流主要有两种实现方法：时间戳和定时器。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (now - prev &gt;= delay) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            prev = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Math</span>.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttle(handle, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><p>函数节流适用于间接性调用函数。定时器不存在则创建调用函数，定时销毁。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>在去上海前的一些想法</title>
      <link>http://mydearest.cn/beforehz.html</link>
      <guid>http://mydearest.cn/beforehz.html</guid>
      <pubDate>Tue, 26 Jun 2018 13:14:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;怯懦的我终于和领导提出了离职，从8月11号入职以来，jenkins打包管理、bugatti自动化部署等等惊艳到了在上家公司还是用手动发包javac的我，学到了更正规的软件开发流程体系和产品线的迭代，KA项目的定制化。从1月开始一直用RN做相关的微应用，期间虽然也做过小程序、mui的H5、antd的中后台系统，但大多数时间还是用RN写业务应用。经过几个应用的锻炼、改造，已经封出了一些较能应付业务需求的组件。复杂的集成调用框架那边都做了，其他部分做起来没有什么技术含量了。我知道已经毕业1年的我该做出些改变了。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>怯懦的我终于和领导提出了离职，从8月11号入职以来，jenkins打包管理、bugatti自动化部署等等惊艳到了在上家公司还是用手动发包javac的我，学到了更正规的软件开发流程体系和产品线的迭代，KA项目的定制化。从1月开始一直用RN做相关的微应用，期间虽然也做过小程序、mui的H5、antd的中后台系统，但大多数时间还是用RN写业务应用。经过几个应用的锻炼、改造，已经封出了一些较能应付业务需求的组件。复杂的集成调用框架那边都做了，其他部分做起来没有什么技术含量了。我知道已经毕业1年的我该做出些改变了。</p><hr><a id="more"></a><p>面对领导们的挽留，我也只能笑着婉拒。我想在大前端的道路上迈的更远，本来就没打算活很长的时间，在短暂还算充满干劲的人生中多做点自己感到快乐的事。说来也是好笑，来了南京这么久也没出去逛过，只对公司和公寓周边熟悉一些，真是符合我的作风啊o(<em>￣︶￣</em>)o。</p><p>依稀还记得刚追被去南京发展是我的内心也是非常慌乱的，陌生的城市、环境和人不停地在劝退着我，投递的简历有了回复，我不断预演这面试的场景，竟可能多的将自己的优势展现出来。将近2个小时的长途客车旅途，我到了南京南站，摸着黑上了地铁到了软件大道。9点半又误打误撞地摸到了目的地，不好意思随便进入，随即打电话确认（有人来引下路多好）。等待的过程忐忑不安，人生第一次经历三轮面试，和技术聊真的开心啊O(∩_∩)O哈哈~面试完后立即又买了车票回了家汗~~</p><p>自从工作以来就没请过假，没迟过到。自尊心强烈的我很在意别人对我的看法。去年买了房，房贷没什么压力。房子让父母住，我在工作的地方租房住，这是我的规划。不想去相亲，不想被各种绑架。</p><p>作为熟练的api caller，高中之前的学习是多么快乐啊，是的，做题(除了语文)学习很快乐。新思维解题都是带来很多不同的思路，课堂上有选择地去学习自己喜欢的事物。虽然被老师骂的惨，但暗地里还是支持的。没压力地考上了重点高中，进城上高中了，才感觉到差距是巨大的。城里的小孩终究是不一样的，读过的书也好，培养的兴趣爱好也好，上过的兴趣班都远超过你。学的东西都是套路化的解题，枯燥乏味。渲染了xx的气氛，表达了xx什么的情感。各种烦心、倒霉的事也接踵而来，小小的幸福被扼杀。好奇心和脖子的扭，知道的越多，越觉得绝望。见过的所谓的’真实’，都是为了利益。永远不要去试探人性。现在看来都只是可笑的借口罢了，压力抑郁到自残。人与人之间最公平的就是时间了，每个人一天都是24小时，谁也不多，谁也不少。特别佩服那些活的独立、认真的人们。他们年轻、强大、充满个性，差距真的差到天差地别，是我前进的目标和憧憬的对象。我不会再迷茫了，毕竟~~~</p><blockquote class="blockquote-center"><p>不去做的话永远也做不到。</p></blockquote> <p>s(优势):互联网氛围、大牛、技术提升w(劣势):房租、10m2的地下室、消费、离家远、通勤时间、异地恋o(机会):更高的待遇天花板、未来发展t(威胁):陌生的城市、重新整理技术体系、面试</p><hr><p>s:门面做的不错、近10k（南京1年经验）、双休（有时间做自己项目学习、接外包）、雨花台区（离老婆近）w:不融资、官网low、没核心产品（说在招人明年做、说呆1年能到13-14 0^0？？？）、着急招人（目前人数较少？）、外包园、1-3年9-12k？？？常见都是10-15k。</p><p>南京这边的工资待遇真的很低，感觉像命运一样，留了最后一张简历，偏偏扇贝又在这个时候叫我去面试。面试居然还提供饮品。这边催着入职，前面的还没消息，说到底还是自己太懦弱了，如果有联系或者果断点，就不会有这样的情况出现了。不去试一试怎么会知道呢，担当起自己的responsibility。</p><p>2周前投的现在认识才提醒面试是不是太迟了；虽然很想去，技术氛围浓厚。大公司就会比较选人，不会立即给你答复。可这边的工作急着让你给答复。唉就这样形成了现在的处境。努力沉淀一点再跳槽到新公司吧！！！</p><p>半杯水，懂了么。自身的强大很重要，more experience 成年人 卧薪尝胆</p><p>办公环境、补贴、五险一金、工资、福利待遇、氛围、大公司镀金、自身的强大。选择比努力更重要，实力和机遇。看看别人的评分98，6周年dlun这种自研的能跟着一起成长。大格局，这样会越来越迷茫找不到自己的定位，半杯水的思想。真正的效率。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/beforehz.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>常见排序的JS实现</title>
      <link>http://mydearest.cn/sort.html</link>
      <guid>http://mydearest.cn/sort.html</guid>
      <pubDate>Mon, 25 Jun 2018 13:37:09 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;https-github-com-damonare-Sorts-这位大兄弟♂总结的很好，快去看看吧！&quot;&gt;&lt;a href=&quot;#https-github-com-damonare-Sorts-这位大兄弟♂总结的很好，快去看看吧！&quot; class=&quot;headerlink&quot; title=&quot;https://github.com/damonare/Sorts 这位大兄弟♂总结的很好，快去看看吧！&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/damonare/Sorts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/damonare/Sorts&lt;/a&gt; 这位大兄弟♂总结的很好，快去看看吧！&lt;/h2&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="https-github-com-damonare-Sorts-这位大兄弟♂总结的很好，快去看看吧！"><a href="#https-github-com-damonare-Sorts-这位大兄弟♂总结的很好，快去看看吧！" class="headerlink" title="https://github.com/damonare/Sorts 这位大兄弟♂总结的很好，快去看看吧！"></a><a href="https://github.com/damonare/Sorts" target="_blank" rel="noopener">https://github.com/damonare/Sorts</a> 这位大兄弟♂总结的很好，快去看看吧！</h2><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常见排序的JS实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Sort = &#123;</span><br><span class="line">    <span class="comment">//快速排序(递归)</span></span><br><span class="line">    quick: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> nLength = arr.length,</span><br><span class="line">            pivotIndex = <span class="built_in">Math</span>.floor(nLength / <span class="number">2</span>),</span><br><span class="line">            pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>],</span><br><span class="line">            left = [],</span><br><span class="line">            right = [];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nLength &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">                left.push(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(left).concat([pivot], <span class="built_in">arguments</span>.callee(right));</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//冒泡排序</span></span><br><span class="line">    bubble: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nLength = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nLength &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = nLength - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    selection: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nLength = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nLength &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nLength; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> index = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; nLength; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[index]) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i !== index) &#123;</span><br><span class="line">                <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[index];</span><br><span class="line">                arr[index] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    insertion: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nLength = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nLength &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nLength; ++i) &#123;</span><br><span class="line">            <span class="keyword">var</span> j = i,</span><br><span class="line">                value = arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; value) &#123;</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j !== i) &#123;</span><br><span class="line">                arr[j] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//希尔排序</span></span><br><span class="line">    shell: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nLength = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nLength &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> step = nLength &gt;&gt; <span class="number">1</span>; step &gt; <span class="number">0</span>; step &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; step; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> j = i + step; j &lt; nLength; j += step) &#123;</span><br><span class="line">                    <span class="keyword">var</span> k = j,</span><br><span class="line">                        value = arr[j];</span><br><span class="line">                    <span class="keyword">while</span> (k &gt;= step &amp;&amp; arr[k - step] &gt; value) &#123;</span><br><span class="line">                        arr[k] = arr[k - step];</span><br><span class="line">                        k -= step;</span><br><span class="line">                    &#125;</span><br><span class="line">                    arr[k] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://mydearest.cn/sort.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>详解 Cookie、 LocalStorage 与 SessionStorage</title>
      <link>http://mydearest.cn/storage.html</link>
      <guid>http://mydearest.cn/storage.html</guid>
      <pubDate>Sat, 23 Jun 2018 05:43:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;p&gt;Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。&lt;/p&gt;
&lt;h2 id=&quot;localStorage&quot;&gt;&lt;a href=&quot;#localStorage&quot; class=&quot;headerlink&quot; title=&quot;localStorage&quot;&gt;&lt;/a&gt;localStorage&lt;/h2&gt;&lt;p&gt;localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存储容量限制，大部分浏览器应该最多5M。&lt;/li&gt;
&lt;li&gt;仅支持字符串，如果是存对象还需要将使用JSON.stringify和JSON.parse方法互相转换，有些啰嗦。&lt;/li&gt;
&lt;li&gt;读取都是同步的。大多数情况下，还挺好使的。但如果存储数据比较大，例如一张重要图片base64格式存储了，读取可能会有可感知的延迟时间。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;sessionStorage&quot;&gt;&lt;a href=&quot;#sessionStorage&quot; class=&quot;headerlink&quot; title=&quot;sessionStorage&quot;&gt;&lt;/a&gt;sessionStorage&lt;/h2&gt;&lt;p&gt;sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。</p><p>缺点：</p><ol><li>存储容量限制，大部分浏览器应该最多5M。</li><li>仅支持字符串，如果是存对象还需要将使用JSON.stringify和JSON.parse方法互相转换，有些啰嗦。</li><li>读取都是同步的。大多数情况下，还挺好使的。但如果存储数据比较大，例如一张重要图片base64格式存储了，读取可能会有可感知的延迟时间。</li></ol><h2 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h2><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p><hr><a id="more"></a><h2 id="三者的异同"><a href="#三者的异同" class="headerlink" title="三者的异同"></a>三者的异同</h2><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">Cookie</th><th style="text-align:center">localstorage</th><th>sessionstorage</th></tr></thead><tbody><tr><td style="text-align:center">生命周期</td><td style="text-align:center">一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td><td style="text-align:center">除非被清除，否则永久保存</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr><tr><td style="text-align:center">数据大小</td><td style="text-align:center">4K</td><td style="text-align:center">5M</td><td>5M</td></tr><tr><td style="text-align:center">与服务器端通信</td><td style="text-align:center">每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td><td style="text-align:center">仅在客户端（即浏览器）中保存，不参与和服务器的通信</td><td>同上</td></tr><tr><td style="text-align:center">易用性</td><td style="text-align:center">需要自己封装，原生的Cookie接口不友好</td><td style="text-align:center">可以封装来对Object和Array有更好的支持</td><td>同上</td></tr></tbody></table><h2 id="安全性的考虑"><a href="#安全性的考虑" class="headerlink" title="安全性的考虑"></a>安全性的考虑</h2><p>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。</p><h2 id="cookie用法"><a href="#cookie用法" class="headerlink" title="cookie用法"></a>cookie用法</h2><p>JavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。document.cookie=”username=John Doe”;</p><p>您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：document.cookie=”username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT”;</p><p>您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。document.cookie=”username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/“;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">cname,cvalue,exdays</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  d.setTime(d.getTime()+(exdays*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">var</span> expires = <span class="string">"expires="</span>+d.toGMTString();</span><br><span class="line">  <span class="built_in">document</span>.cookie = cname + <span class="string">"="</span> + cvalue + <span class="string">"; "</span> + expires;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">cname</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = cname + <span class="string">"="</span>;</span><br><span class="line">  <span class="keyword">var</span> ca = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ca.length; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> c = ca[i].trim();</span><br><span class="line">    <span class="keyword">if</span> (c.indexOf(name)==<span class="number">0</span>) <span class="keyword">return</span> c.substring(name.length,c.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测cookie函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkCookie</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> username=getCookie(<span class="string">"username"</span>);</span><br><span class="line">  <span class="keyword">if</span> (username!=<span class="string">""</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    alert(<span class="string">"Welcome again "</span> + username);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">    username = prompt(<span class="string">"Please enter your name:"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (username!=<span class="string">""</span> &amp;&amp; username!=<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      setCookie(<span class="string">"username"</span>,username,<span class="number">365</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="localStorage和sessionStorage用法"><a href="#localStorage和sessionStorage用法" class="headerlink" title="localStorage和sessionStorage用法"></a>localStorage和sessionStorage用法</h2><p>localStorage和sessionStorage类似(也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> setStorage(name, data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(name, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'number'</span> || <span class="keyword">typeof</span> data === <span class="string">'string'</span> || <span class="keyword">typeof</span> data === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(name, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'该类型不能用于本地存储~'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取localstorage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> getStorage(name) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">window</span>.localStorage.getItem(name)</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除localstorage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> removeStorage(name) &#123;</span><br><span class="line">    <span class="built_in">window</span>.localStorage.removeItem(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空localstorage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> clearStorage() &#123;</span><br><span class="line">    <span class="built_in">window</span>.localStorage.clear()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="规避localStorage缺点—localforage"><a href="#规避localStorage缺点—localforage" class="headerlink" title="规避localStorage缺点—localforage"></a>规避localStorage缺点—localforage</h2><p>localforage的逻辑是这样的：优先使用IndexedDB存储数据，如果浏览器不支持，使用WebSQL，浏览器再不支持，使用localStorage。</p><p>localforage的API名称和localStorage一样，但是，在同步还是异步上却不同，localforage是异步执行的，用法示意如下。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localforage.getItem(<span class="string">'key'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果err不是null，则出错。否则value就是我们想要的值</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/storage.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试题整理归纳</title>
      <link>http://mydearest.cn/interview.html</link>
      <guid>http://mydearest.cn/interview.html</guid>
      <pubDate>Sat, 23 Jun 2018 02:58:48 GMT</pubDate>
      <description>
      
        &lt;p&gt;字符串扩展的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;includes()：返回布尔值，表示是否找到了参数字符串。数组也可以 a[1]=1 且能判断undefined&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, undefined × 1, 5] empty&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// a[3]=undefined [1, 2, 3, undefined, 5] &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.indexOf(&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.includes(&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。
str | index&lt;/li&gt;
&lt;li&gt;repeat()：返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整(不四舍五入)。参数是负数或者Infinity，会报错。0/Nan返回空字符串,参数是字符串，则会先转换成数字。&lt;/li&gt;
&lt;li&gt;padStart()：头部补全。&lt;/li&gt;
&lt;li&gt;padEnd()：尾部补全&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;x&amp;apos;.padStart(5, &amp;apos;ab&amp;apos;) // &amp;apos;ababx&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;x&amp;apos;.padStart(4, &amp;apos;ab&amp;apos;) // &amp;apos;abax&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;x&amp;apos;.padEnd(5, &amp;apos;ab&amp;apos;) // &amp;apos;xabab&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;x&amp;apos;.padEnd(4, &amp;apos;ab&amp;apos;) // &amp;apos;xaba&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。默认使用空格&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>字符串扩展的方法</p><ul><li><p>includes()：返回布尔值，表示是否找到了参数字符串。数组也可以 a[1]=1 且能判断undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">4</span>]=<span class="number">5</span> <span class="comment">// [1, 2, 3, undefined × 1, 5] empty</span></span><br><span class="line"><span class="comment">// a[3]=undefined [1, 2, 3, undefined, 5] </span></span><br><span class="line"></span><br><span class="line">a.indexOf(<span class="literal">undefined</span>) <span class="comment">// -1</span></span><br><span class="line">a.includes(<span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</p></li><li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。str | index</li><li>repeat()：返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整(不四舍五入)。参数是负数或者Infinity，会报错。0/Nan返回空字符串,参数是字符串，则会先转换成数字。</li><li>padStart()：头部补全。</li><li>padEnd()：尾部补全<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;</span><br><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line"></span><br><span class="line">&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br></pre></td></tr></table></figure></li></ul><p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。默认使用空格</p><hr><a id="more"></a><ul><li>模板字符串（template string）是增强版的字符串，用反引号`标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。`${表达式、变量}`</li><li>commonjs 服务器端 amd 浏览器端</li><li>const 必须赋值定义 let 在同一作用于无法重复命名 无法变量提升</li><li>split(字符串或者正则,设置长度) 字符串=&gt;数组</li><li>substr(开始的索引//splice可以为负数-1则为字符串最后一个字符,length字符数)方法不同的是,substring(开始索引，结束索引+1)负的参数有区别只有单参数时到字符串结尾String exd=filePath.subString(filePath.lastIndexOf(“.”)+1,filePath.length)</li></ul><ol><li>声明函数作用提升?声明变量和声明函数的提升有什么区别?</li></ol><p>(1) 变量声明提升：变量申明在进入执行上下文就完成了。只要变量在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；</p><p>(2) 函数声明提升：执行代码之前会先读取函数声明，意味着可以把函数申明放在调用它的语句后面。只要函数在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；</p><p>(3) 变量or函数声明：函数声明会覆盖变量声明，但不会覆盖变量赋值。同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。注意：如果在变量声明的同时初始化a，或是之后对a进行赋值，此时a的值变量的值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg: <span class="keyword">var</span> a; <span class="keyword">var</span> c = <span class="number">1</span>; a = <span class="number">1</span>; <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125; <span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>如何判断数据类型？typeof返回的类型都是字符串形式，可以判断function的类型；在判断除Object类型的对象时比较方便。判断已知对象类型的方法： instanceof，后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object null instanceof object // error</span></span><br></pre></td></tr></table></figure></li><li><p>异步编程？</p></li></ol><ul><li><p>方法1：回调函数，优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p></li><li><p>方法2：事件监听，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p></li><li><p>方法3：发布/订阅，性质与“事件监听”类似，但是明显优于后者。</p></li><li><p>方法4：Promises对象，是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。</p></li></ul><ol start="4"><li><p>事件流？事件捕获？事件冒泡？ 事件流：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。</p><p> IE中的事件流叫事件冒泡；事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。对于html来说，就是当一个元素产生了一个事件，它会把这个事件传递给它的父元素，父元素接收到了之后，还要继续传递给它的上一级元素，就这样一直传播到document对象（亲测现在的浏览器到window对象，只有IE8及以下不这样。</p><p> 事件捕获是不太具体的元素应该更早接受到事件，而最具体的节点应该最后接收到事件。他们的用意是在事件到达目标之前就捕获它；也就是跟冒泡的过程正好相反，以html的click事件为例，document对象（DOM级规范要求从document开始传播，但是现在的浏览器是从window对象开始的）最先接收到click事件的然后事件沿着DOM树依次向下传播，一直传播到事件的实际目标；</p></li><li><p>如何添加一个dom对象到body中?innerHTML和innerText区别? body.appendChild(dom元素)；<br> innerHTML:从对象的起始位置到终止位置的全部内容,包括Html标签。 innerText:从起始位置到终止位置的内容, 但它去除Html标签  window.clearInterval() window.clearTimeout()</p></li><li><p>简述ajax流程<br>1)客户端产生触发js的事件<br>2)创建XMLHttpRequest对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client=<span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">       client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        client = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><p>3)对XMLHttpRequest进行配置 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">client.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.readyState !== <span class="number">4</span>) &#123; <span class="comment">// client状态</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123; <span class="comment">// HTTP状态码</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success'</span>, request.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">// 指定回调函数</span></span><br><span class="line">client.responseType = <span class="string">"json"</span>;</span><br><span class="line">client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json;"</span>);</span><br><span class="line">client.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>);</span><br></pre></td></tr></table></figure></p><p>4)通过AJAX引擎发送异步请求 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.send()</span><br></pre></td></tr></table></figure></p><p>5)服务器端接收请求并且处理请求，返回html或者xml内容<br>6)XML调用一个callback()处理响应回来的内容<br>7)使用JS和DOM实现局部刷新</p><ol start="7"><li><p>自执行函数？用于什么场景？好处？<br> 1、声明一个匿名函数<br> 2、马上调用这个匿名函数。<br> 作用：创建一个独立的作用域。  </p><p> 好处：防止变量弥散到全局，以免各种js库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理。</p><p> 场景：一般用于框架、插件等场景，设计私有变量和方法，封闭私有作用域。</p></li><li><p>回调函数？（传递地址，由非实现方调用）<br>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p></li><li><p>什么是闭包?堆栈溢出有什么区别？ 内存泄漏? 那些操作会造成内存泄漏？怎么样防止内存泄漏？impression<br> 闭包：就是能够读取其他函数内部变量的函数。一般是指内层函数。(子函数在外调用，子函数所在的父函数的作用域不会被释放。) </p><p> 堆栈溢出：就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。经常会在递归中发生。</p><p> 内存泄露是指：用动态存储分配函数内存空间，在使用完毕后未释放，导致一直占据该内存单元。直到程序结束。指任何对象在您不再拥有或需要它之后仍然存在。</p><p> 造成内存泄漏： setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p><p> 防止内存泄露：<br> 1、不要动态绑定事件；<br> 2、不要在动态添加，或者会被动态移除的dom上绑事件，用事件冒泡在父容器监听事件；<br> 3、如果要违反上面的原则，必须提供destroy方法，保证移除dom后事件也被移除，这点可以参考Backbone的源代码，做的比较好；<br> 4、单例化，少创建dom，少绑事件。  </p></li><li><p>html和xhtml有什么区别?HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的标记语言。</p><p>1.XHTML 元素必须被正确地嵌套。</p><p>2.XHTML 元素必须被关闭。</p><p>3.标签名必须用小写字母。</p><p>4.空标签也必须被关闭。</p><p>5.XHTML 文档必须拥有根元素。</p></li><li><p>什么是构造函数？与普通函数有什么区别?</p><p>构造函数：是一种特殊的方法(函数、对象)、主要用来创建对象时初始化对象，总与new运算符一起使用，创建对象的语句中构造函数的函数名必须与类名完全相同。</p><p>与普通函数相比只能由new关键字调用，构造函数是类的标识。</p></li><li><p>通过new创建一个对象的时候，函数内部有哪些改变？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.friend = [];</span><br><span class="line">Person.prototype.age = <span class="number">18</span>;</span><br><span class="line"> <span class="keyword">var</span> a = <span class="keyword">new</span> Person();</span><br><span class="line"> a.friend[<span class="number">0</span>] = <span class="string">'王琦'</span>; <span class="comment">// a.friend=['123'] 指向新对象 b.friend // []</span></span><br><span class="line"> a.age = <span class="number">18</span>;</span><br><span class="line"> <span class="keyword">var</span> b = <span class="keyword">new</span> Person();</span><br><span class="line"> b.friend <span class="comment">// ['王琦'] </span></span><br><span class="line"> b.age   <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><blockquote><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p></blockquote></li></ol><p><code>new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。</code></p><ol start="13"><li>事件委托的好处都有啥？说对了都给它=3=</li></ol><ul><li><p>利用冒泡的原理，把事件加到父级上，触发执行效果  </p></li><li><p>好处：新添加的元素还会有之前的事件；提高性能。</p></li></ul><ol start="14"><li>节点类型?判断当前节点类型?</li></ol><ul><li>元素节点 </li><li>属性节点 </li><li>文本节点 </li><li>注释节点 </li><li>文档节点</li></ul><p>通过nodeObject.nodeType判断节点类型：其中，nodeObject 为DOM节点（节点对象）。该属性返回以数字表示的节点类型，例如，元素节点返回 1，属性节点返回 2 。</p><ol start="15"><li><p>数组合并的方法？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 四种方法。</span></span><br><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr1 = arr1.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1,arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">arr1.push( arr2[i] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">arr1.push(...arr2)</span><br></pre></td></tr></table></figure></li><li><p>jquery和zepto有什么区别?</p></li></ol><ul><li><p>针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。</p></li><li><p>Dom操作的区别：添加id时jQuery不会生效而Zepto会生效。</p></li><li><p>zepto主要用在移动设备上，只支持较新的浏览器，好处是代码量比较小，性能也较好。jquery主要是兼容性好，可以跑在各种pc，移动上，好处是兼容各种浏览器，缺点是代码量大，同时考虑兼容，性能也不够好。</p></li></ul><ol start="17"><li>$(function(){})和window.onload 和 $(document).ready(function(){})</li></ol><ul><li><p>window.onload:用于当页面的所有元素，包括外部引用文件，图片等都加载完毕时运行函数内的函数。load方法只能执行一次，如果在js文件里写了多个，只能执行最后一个。</p></li><li><p>$(document).ready(function(){})和$(function(){})都是用于当页面的标准DOM元素被解析成DOM树后就执行内部函数。这个函数是可以在js文件里多次编写的，对于多人共同编写的js就有很大的优势，因为所有行为函数都会执行到。而且$(document).ready()函数在HMTL结构加载完后就可以执行，不需要等大型文件加载或者不存在的连接等耗时工作完成才执行，效率高。</p></li></ul><ol start="18"><li>简述下 this 和定义属性和方法的时候有什么区别?Prototype？</li></ol><ul><li><p>this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向。</p></li><li><p>prototype本质上还是一个JavaScript对象。 并且每个函数都有一个默认的prototype属性。</p></li><li><p>在prototype上定义的属性方法为所有实例共享，所有实例皆引用到同一个对象，单一实例对原型上的属性进行修改，也会影响到所有其他实例。</p></li></ul><ol start="19"><li>ajax和jsonp的区别？</li></ol><ul><li>相同点：都是请求一个url</li><li>不同点：ajax的核心是通过XMLHttpRequest获取内容</li><li>jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</li></ul><ol start="20"><li>常见的http协议状态码？</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span>：请求成功</span><br><span class="line"><span class="number">201</span>：请求成功并且服务器创建了新的资源</span><br><span class="line"><span class="number">302</span>：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。</span><br><span class="line"><span class="number">304</span>：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</span><br><span class="line"><span class="number">400</span>：服务器不理解请求的语法。</span><br><span class="line"><span class="number">404</span>：请求的资源（网页等）不存在</span><br><span class="line"><span class="number">403</span>：该状态表示服务器理解了本次请求但是拒绝执行该任务</span><br><span class="line"><span class="number">405</span>：方法不被允许</span><br><span class="line"><span class="number">500</span>：内部服务器错误</span><br></pre></td></tr></table></figure><ol start="21"><li><p>sessionStorage和localstroage与cookie之间有什么关联, cookie最大存放多少字节？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三者共同点：都是保存在浏览器端，且同源的。</span><br><span class="line"></span><br><span class="line">区别:</span><br><span class="line"><span class="number">1</span>、cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、存储大小限制也不同，cookie数据不能超过<span class="number">4</span>k，sessionStorage和localStorage 但比cookie大得多，可以达到<span class="number">5</span>M</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面(即数据不共享)；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的( 即数据共享 )。</span><br></pre></td></tr></table></figure></li><li><p>ajax的get与post区别？</p></li></ol><ul><li>get和post都是数据提交的方式。</li><li>get的数据是通过网址问号后边拼接的字符串进行传递的。post是通过一个HTTP包体进行传递数据的。</li><li>get的传输量是有限制的，post是没有限制的。(实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度)</li><li>get的安全性可能没有post高，所以我们一般用get来获取数据，post一般用来修改数据。</li><li>get就是将货品放在车顶，post放在车内</li></ul><ol start="23"><li>GC机制？为什么闭包不会被回收变量和函数？</li></ol><ul><li>GC：垃圾回收机制;  </li><li>外部变量没释放仍然保持着引用，所以指向的大函数内的小函数也释放不了。</li></ul><ol start="24"><li><p>面向对象？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">万物皆对象，把一个对象抽象成类，具体上就是把一个对象的静态特征和动态特征抽象成属性（属性名、属性值）和方法，也就是把一类事物的算法和数据结构封装在一个类之中，程序就是多个对象和互相之间的通信组成的。</span><br><span class="line"></span><br><span class="line">面向对象具有封装性，继承性，多态性。</span><br><span class="line">封装：隐蔽了对象内部不需要暴露的细节，使得内部细节的变动跟外界脱离，只依靠接口进行通信。封装性降低了编程的复杂性。通过继承，使得新建一个类变得容易，一个类从派生类那里获得其非私有的方法和公用属性的繁琐工作交给了编译器。而继承和实现接口和运行时的类型绑定机制所产生的多态，使得不同的类所产生的对象能够对相同的消息作出不同的反应，极大地提高了代码的通用性。</span><br><span class="line"></span><br><span class="line">总之，面向对象的特性提高了大型程序的重用性和可维护性。</span><br></pre></td></tr></table></figure></li><li><p>jsonp的原理和缺点？</p></li></ol><ul><li>原理：使用script标签实现跨域访问，可在url中指定回调函数，获取JSON数据并在指定的回调函数中执行jquery实现jsop。</li><li>缺点：只支持GET方式的jsonp实现，是一种脚本注入行为存在一定的安全隐患。如果返回的数据格式有问题或者返回失败了，并不会报错。</li></ul><ol start="26"><li>call和apply两者的区别和好处？</li></ol><ul><li>call和apply都是改变this指向的方法，区别在于call可以写多个参数，而apply只能写两个参数，第二个参数是一个数组，用于存放要传的参数。</li><li>用call和apply实现更好的继承和扩展，更安全。</li></ul><ol start="27"><li>压缩合并目的？http请求的优化方式？</li></ol><ul><li><p>Web性能优化最佳实践中最重要的一条是减少HTTP请求。而减少HTTP请求的最主要的方式就是，合并并压缩JavaScript和CSS文件。 </p></li><li><p>CSS Sprites（CSS精灵）：把全站的图标都放在一个图像文件中，然后用CSS的background-image和background-position属性定位来显示其中的一小部分。 </p></li><li><p>合并脚本和样式表; 图片地图：利用image map标签定义一个客户端图像映射，（图像映射指带有可点击区域的一幅图像）具体看：<a href="http://club.topsage.com/thread-2527479-1-1.html" target="_blank" rel="noopener">http://club.topsage.com/thread-2527479-1-1.html</a> </p></li><li><p>图片js/css等静态资源放在静态服务器或CDN服时，尽量采用不用的域名，这样能防止cookie不会互相污染，减少每次请求的往返数据。 </p></li><li><p>css替代图片, 缓存一些数据 </p></li><li><p>少用location.reload()：使用location.reload() 会刷新页面，刷新页面时页面所有资源 (css，js，img等) 会重新请求服务器。建议使用location.href=”当前页url” 代替location.reload() ，使用location.href 浏览器会读取本地缓存资源。</p></li></ul><ol start="28"><li>commonjs?requirejs?AMD|CMD|UMD?</li></ol><ul><li><p>CommonJS就是为JS的表现来制定规范，NodeJS是这种规范的实现，webpack 也是以CommonJS的形式来书写。因为js没有模块的功能，所以CommonJS应运而生。但它不能在浏览器中运行。 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)} </p></li><li><p>RequireJS 是一个JavaScript模块加载器。 RequireJS有两个主要方法(method): define()和require()。这两个方法基本上拥有相同的定义(declaration) 并且它们都知道如何加载的依赖关系，然后执行一个回调函数(callback function)。与require()不同的是， define()用来存储代码作为一个已命名的模块。 因此define()的回调函数需要有一个返回值作为这个模块定义。这些类似被定义的模块叫作AMD (Asynchronous Module Definition，异步模块定义)。 </p></li><li><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出 AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。 适用AMD规范适用define方法定义模块。</p></li><li><p>CMD是SeaJS 在推广过程中对模块定义的规范化产出AMD与CMD的区别：（1）对于于依赖的模块，AMD 是提前执行(好像现在也可以延迟执行了)，CMD 是延迟执行。（2）AMD 推崇依赖前置，CMD 推崇依赖就近。（3）AMD 推崇复用接口，CMD 推崇单用接口。（4）书写规范的差异。</p></li><li><p>umd是AMD和CommonJS的糅合。AMD 浏览器第一的原则发展 异步加载模块。CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD ( Universal Module Definition ), 希望解决跨平台的解决方案。UMD先判断是否支持Node.js的模块( exports )是否存在，存在则使用Node.js模块模式。</p></li></ul><ol start="29"><li>js的几种继承方式？</li></ol><ul><li>使用对象冒充实现继承</li><li>call、apply改变函数上下文实现继承</li><li>原型链方式实现继承</li></ul><ol start="30"><li><p>js原型、原型链，有什么特点？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性[[prototype]],我们通常称之为原型.原型的值可以是一个对象,也可以是<span class="literal">null</span>.如果它的值是一个对象,则这个对象也一定有自己的原型.这样就形成了一条线性的链,我们称之为原型链. </span><br><span class="line"></span><br><span class="line">访问一个对象的原型可以使用ES5中的<span class="built_in">Object</span>.getPrototypeOf方法,或者ES6中的__proto__属性. 原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的。</span><br><span class="line"></span><br><span class="line">类的继承</span><br><span class="line">特点：基于原型链，既是父类的实例，也是子类的实例</span><br><span class="line">缺点：无法实现多继承</span><br><span class="line"></span><br><span class="line">构造继承、实例继承和拷贝继承...</span><br></pre></td></tr></table></figure></li><li><p>eval是做什么的？</p></li></ol><ul><li>将把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</li></ul><ol start="32"><li>null和undefined</li></ol><ul><li>undefined表示变量声明未初始化的，null表示对象的空值（空对象指针）。</li></ul><ol start="33"><li>json的理解？</li></ol><ul><li>JSON（轻量级的数据交换格式），基于JS的子集，数据格式简单，易于读写，占用带宽小。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse() <span class="comment">// 解析成JSON对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.strinify() <span class="comment">// 解析成JSON字符串</span></span><br></pre></td></tr></table></figure></li></ul><ol start="34"><li>js延时加载的方式？</li></ol><ul><li>defer和async</li><li>动态创建DOM</li><li>按需异步加载JS</li></ul><ol start="35"><li>ajax（异步的js和xml）</li></ol><ul><li>ajax是指一种创建交互式网页应用的网页开发技术。通过后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</li></ul><ol start="36"><li>同异步的区别？</li></ol><ul><li>同步(sync)：按顺序执行。</li><li>异步(async)：不按顺序执行，可以跳过执行下面的代码。</li></ul><ol start="37"><li>ajax的缺点？</li></ol><ul><li>不支持浏览器的back按钮(事件由浏览器内核控制)</li><li>ajax暴露了与服务器的交互</li><li>对搜索引擎的支持较弱</li><li>破坏了程序的异常机制</li><li>不容易调试</li></ul><ol start="38"><li>跨域问题？</li></ol><ul><li>协议不同</li><li>端口不同</li><li>域名不同</li><li>常用解决方案：jsonp、iframe、window.name、window.postMessage、服务器设置代理页面/header配置cors</li></ul><ol start="39"><li><p>解决异步回调地狱有哪些方案？promise、generator、async/await</p></li><li><p>图片的预加载和懒加载？</p></li></ol><ul><li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</li><li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</li></ul><p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><ol start="41"><li>mouseover和mouseenter的区别？</li></ol><ul><li><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</p></li><li><p>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</p></li></ul><ol start="42"><li>改变函数内部this指针的指向函数（bind，apply，call的区别）？</li></ol><ul><li><p>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2…这种形式。</p></li><li><p>通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。</p></li></ul><ol start="43"><li>说说前端中的事件流HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。</li></ol><p>事件捕获阶段处于目标阶段事件冒泡阶段</p><p>addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。IE只支持事件冒泡。</p><ol start="44"><li><p>如何让事件先冒泡后执行？在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p></li><li><p>什么是事件委托？简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p></li></ol><p>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p><p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p><ol start="45"><li>垂直居中</li></ol><ul><li>margin:auto法 relative -&gt; absolute -&gt; marin:0 auto</li><li>margin负值法 relative -&gt; absolute -&gt; top:50% left:50% marin-top:height的一半 margin-left:width的一半或者transform：translateX(-50%)和transform：translateY(-50%)</li><li>table-cell未脱离文档流 设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。</li><li>flex布局</li></ul><ol start="46"><li>visibility=hidden, opacity=0，display:none</li></ol><ul><li>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的</li><li>visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件。</li><li>display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</li></ul><ol start="47"><li>块元素和行内元素</li></ol><ul><li>块元素：独占一行，并且有自动填满父元素，可以设置margin和padding以及高度和宽度。</li><li>行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。    </li></ul><ol start="48"><li>深拷贝</li></ol><ul><li>深拷贝的方法 1-2适用于一般的对象和数组 4-5适用于数组 3通用let obj = {  a: 1,  arr: [1, 2]};let obj2 = deepCopy(obj);obj2.a = 2console.log(obj) // { a:1, arr: [1,2] };2.es6Object.assign()方法(深复制只有一层，之后为浅复制（除非再次使用Object.assign嵌套方式赋值）)let obj = {  a: 1,  arr: [1, 2]};let obj1 = Object.assign({}, obj);obj1.a = 2//不变console.log(obj) // { a:1, arr: [1,2] };3.immutable4.arr1=arr.slice(0) slice() 返回新数组5.arr1=arr.concat()var deepCopy= function(source) {   var result={};  for (var key in source) {<pre><code>result[key] = typeof source[key]===&apos;object&apos;? deepCoypy(source[key]): source[key];</code></pre>   }  return result; }</li></ul><ol start="49"><li>判断一个变量是否是数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []; </span><br><span class="line"><span class="comment">// 1.基于instanceof </span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; </span><br><span class="line"><span class="comment">// 2.基于constructor </span></span><br><span class="line">a.constructor === <span class="built_in">Array</span>; </span><br><span class="line"><span class="comment">// 3.基于Object.prototype.isPrototypeOf </span></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(a); </span><br><span class="line"><span class="comment">// 4.基于getPrototypeOf </span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === <span class="built_in">Array</span>.prototype; </span><br><span class="line"><span class="comment">// 5.基于Object.prototype.toString </span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.apply(a) === <span class="string">'[object Array]'</span>;</span><br><span class="line"><span class="comment">// 6.Array.isArray</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><p>以上，除了Object.prototype.toString外，其它方法都不能正确判断变量的类型。</p><ol start="49"><li>优化</li></ol><ul><li>按需加载路由</li><li>代码拆分</li><li><p>第三方库提取vendor</p></li><li><p>压缩文件图片，合并文件 减少http请求</p></li><li>网络图、字体图标</li><li>上cnd</li></ul><ol start="50"><li>行内、块级、空元素 </li></ol><ul><li>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</li><li>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</li><li>空元素：即没有内容的HTML元素，例如：br、meta、hr、link、input、img</li></ul><ol start="51"><li><p>px、em、rem的区别px和em都是长度单位,px的只是固定的,em的值是相对的继承父类元素的字体大小。浏览器的默认字体高位16px。1em=16px;rem单位基于html元素的字体大小。</p></li><li><p>路由权限管理</p></li></ol><ul><li>route render方法里进行判断 redirect or return null</li><li>组件内部判断</li><li>高阶组件</li><li>dva监听url subscription</li></ul><ol start="53"><li>node中的事件循环是什么样子的?</li></ol><ul><li>event loop其实就是一个事件队列，先加入先执行，执行完一次队列，再次循环遍历看有没有新事件加入队列．执行中的叫IO events, setImmediate是在当前队列立即执行,setTimout/setInterval是把执行定时到下一个队列，process.nextTick是在当前执行完，下次遍历前执行．所以总体顺序是: IO events &gt;&gt; setImmediate &gt;&gt; setTimeout/setInterval &gt;&gt; process.nextTick</li></ul><ol start="54"><li>清空数组</li></ol><ul><li>直接赋值空数组</li><li>splice(0,数组length)清空</li><li>设置数组length=0</li></ul><ol start="55"><li>判断数组中出现次数最多的元素<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp=[];<span class="comment">//对象数组</span></span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    temp[<span class="number">0</span>]=&#123;<span class="attr">value</span>:arr[<span class="number">0</span>],<span class="attr">index</span>:<span class="number">1</span>&#125;;<span class="comment">//保存数组元素出现的次数和值</span></span><br><span class="line">    arr.sort();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==arr[i<span class="number">-1</span>])&#123;</span><br><span class="line">            temp[temp.length<span class="number">-1</span>].index++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//不相同则新增一个对象元素</span></span><br><span class="line">            temp.push(&#123;<span class="attr">index</span>:<span class="number">1</span>,<span class="attr">value</span>:arr[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="comment">//按照出现次数从大到小排列</span></span><br><span class="line">        <span class="keyword">return</span> a.index&lt;b.index;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">var</span> max=temp[<span class="number">0</span>].index;</span><br><span class="line">    <span class="keyword">var</span> maxV=temp[<span class="number">0</span>].value;</span><br><span class="line">    <span class="keyword">var</span> second=temp[<span class="number">1</span>].index;</span><br><span class="line">    <span class="keyword">var</span> secondV=temp[<span class="number">1</span>].value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;max,maxV,second,secondV&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">100</span>,<span class="number">100</span>,,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">100</span>,<span class="number">100</span>];</span><br><span class="line"><span class="keyword">var</span> &#123;max,maxV,second,secondV&#125;=f(arr);</span><br><span class="line"><span class="built_in">console</span>.log(max,maxV,second,secondV);</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>http://mydearest.cn/interview.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>正确设置网站title、keywords、description</title>
      <link>http://mydearest.cn/seo.html</link>
      <guid>http://mydearest.cn/seo.html</guid>
      <pubDate>Fri, 22 Jun 2018 10:27:43 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><a id="more"></a><p>SEO：搜索引擎优化，提高网站浏览量</p><p>SEM：搜索引擎营销</p><p>IP：独立IP访问的用户</p><p>PV：页面浏览量或点击量</p><p>UV：独立访客数</p><h2 id="title（网站标题）"><a href="#title（网站标题）" class="headerlink" title="title（网站标题）"></a>title（网站标题）</h2><p>title，就是浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：<span class="tag">&lt;<span class="name">title</span>&gt;</span>网站标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>首页title写法，一般是“网站名称-主关键词或一句含有主关键词的描述”。在做优化时习惯把主关键词放最前面，网站名称放后面，因为搜索引擎给予标题最前面的词比后面的高。比如，做“招聘”这个词，就这样写“企业招聘-创业公司招聘技巧-xx招聘”。</p></li><li><p>栏目页title写法，一般有2种：“栏目名称-网站名称”、“栏目名称栏目关键词-网站名称”。建议用“栏目名称-网站名称”。而且栏目名称最好用关键词来确定，比如企业招聘栏目最好就用企业招聘，而不要起个让人无法识别的名字如企业来人，企业看看，或企业加上一些特殊符号，这种写法虽然很有个性，但会让你的网站在优化上占了下风。</p></li><li><p>分类列表页title写法，一般是“分类列表页名称-栏目名称-网站名称”，这个和栏目页差不多。</p></li><li><p>文章页title写法，一般有3种：“文章标题-网站名称”、“内容标题-栏目名称”、“内容标题-栏目名称-网站名称”。其中，“内容标题-栏目名称-网站名称”的写法最为规范，但也相对复杂，它能给用户很好的提示，让用户知道他在访问哪篇文章，并且是在哪个网站的哪个栏目下。</p></li></ol><h2 id="keywords（关键词）"><a href="#keywords（关键词）" class="headerlink" title="keywords（关键词）"></a>keywords（关键词）</h2><p>keywords，是用户不查看源代码看不到的。主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此keywords的每个词都要能在内容中找到相应匹配，才有利于排名。keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。为什么用英文上文已经说过。而且，尽量将重要的关键字靠前放，因为靠后的关键字排名较差，除非你站有很高的权重。</p><p>小道消息称keywords曾被百度、谷歌、雅虎等搜索引擎剔除，将不会再影响搜索引擎的排序结果，设置一下总没坏处，还是有一些搜索引擎比较重视keywords标签的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”Keywords”</span> <span class="attr">Content</span>=<span class="string">”关键词1,关键词2,关键词3,关键词4″</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>首页keywords写法，一般是“网站名称,主要栏目名,主要关键词”。</p></li><li><p>栏目页keywords写法，一般是“栏目名称,栏目关键字,栏目分类列表名称”。</p></li><li><p>分类列表页keywords写法，这个就比较简单了，只要将你这个栏目中的主要关键字写入即可。</p></li><li><p>文章页keywords写法，建议大家提取文章中的关键词，比如我的文章主要是讲SEO优化的，那么我关键词肯定是SEO优化，如果你觉得你提取关键词的能力较差，也可以选择文章中出现比较多的词来作为关键词，比如我现在写的内容是关于title、keywords、description的，那我的文章页关键词就是这3个。</p></li></ol><h2 id="description（内容摘要）"><a href="#description（内容摘要）" class="headerlink" title="description（内容摘要）"></a>description（内容摘要）</h2><p>description，和上面的keywords一样，是用户不查看源代码看不到的，而且也是对于一个网页的简要内容概况。不同的是，keywords是由几个词语的组成的，而description则是完整的一句话。description一般不超过150个字符，描述内容要和页面内容相关。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用法：<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">”Description”</span> <span class="attr">Content</span>=<span class="string">”你网页的简述”</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>首页description写法，一般是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍。</p></li><li><p>栏目页description写法，一般是将栏目的标题、关键字、分类列表名称融合到里面，写成简单的介绍。</p></li><li><p>分类列表页description，这个就比较简单了，一般只需要把分类列表的标题、关键词融合在一起，写成简单的介绍。</p></li><li><p>文章页description写法，一般有2种写法，标准写法就和前面的一样，将文章标题、文章中的重要内容和关键词融合在一起，写成简单的介绍。这是最好最标准的写法。但是这样写比较麻烦，可以在文章首段和标题中加入关键词，比如我这篇文章是讲title、keywords、description的，那么在文章首段和标题中就加入这些内容，然后直接将文章首段的内容复制到description中即可。</p></li></ol><p><strong>PS：3个标签按重要性来分：title＞description＞keywords</strong></p><h2 id="其他优化技巧"><a href="#其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h2><p>1）标签语义化 2）一个页面中的H1标签只能使用一次 3）img标签都要设置 alt 属性，在这个属性中声明当前图片的信息（spider不能收录图片，但是可以抓取到图片alt属性的值） 4）HTML的层级不要太深的层级，蜘蛛可能不会抓取和收录 5）把需要推广的关键词尽可能的在页面中曝光（最好都写在H（2~6）标签中） </p>]]></content:encoded>
      
      <comments>http://mydearest.cn/seo.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript整理总结</title>
      <link>http://mydearest.cn/jssummary.html</link>
      <guid>http://mydearest.cn/jssummary.html</guid>
      <pubDate>Thu, 21 Jun 2018 11:37:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;JS的相关知识点比较繁杂，特此开篇整理一波，方便回顾总结查阅。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>JS的相关知识点比较繁杂，特此开篇整理一波，方便回顾总结查阅。</p><hr><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JavaScript 是一门跨平台、面向对象、基于原型的轻量级动态脚本语言。</p><p>与java的对比：</p><table><thead><tr><th style="text-align:left">JavaScript</th><th style="text-align:left">Java</th></tr></thead><tbody><tr><td style="text-align:left">面向对象。不区分对象类型。通过原型机制继承，任何对象的属性和方法均可以被动态添加。</td><td style="text-align:left">基于类系统。分为类和实例，通过类层级的定义实现继承。不能动态增加对象或类的属性或方法。</td></tr><tr><td style="text-align:left">变量类型不需要提前声明(动态类型)。</td><td style="text-align:left">变量类型必须提前声明(静态类型)。</td></tr><tr><td style="text-align:left">不能直接自动写入硬盘。</td><td style="text-align:left">可以直接自动写入硬盘。</td></tr></tbody></table><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="var-存在变量提升"><a href="#var-存在变量提升" class="headerlink" title="var(存在变量提升)"></a>var(存在变量提升)</h3><p>声明一个变量，可赋一个初始化值。</p><h3 id="let-let-同一变量在同一作用域不能同时声明"><a href="#let-let-同一变量在同一作用域不能同时声明" class="headerlink" title="let(let 同一变量在同一作用域不能同时声明)"></a>let(let 同一变量在同一作用域不能同时声明)</h3><p>声明一个块作用域的局部变量，可赋一个初始化值。</p><h3 id="const-const-声明时必须赋初始值-也不可以在脚本运行时重新声明"><a href="#const-const-声明时必须赋初始值-也不可以在脚本运行时重新声明" class="headerlink" title="const(const 声明时必须赋初始值,也不可以在脚本运行时重新声明)"></a>const(const 声明时必须赋初始值,也不可以在脚本运行时重新声明)</h3><p>声明一个块作用域的只读的命名常量。const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。如const a=[1,2,3] a[1]=4; const b={} b.name=”1” 数组元素和对象属性不受保护。</p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的任何其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。全区变量是全局对象的属性，在浏览器中可以用window.xx或xx来访问。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 5 使用let声明块级则是undefined</span></span><br></pre></td></tr></table></figure></p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>JavaScript 变量的另一特别之处是，你可以引用稍后声明的变量而不会引发异常。这一概念称为变量声明提升(hoisting)；var ok ; let 和 const 则不会存在变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="string">"my value"</span>;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myvar); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> myvar = <span class="string">"local value"</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> 也可写作</span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line">x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="string">"my value"</span>;</span><br><span class="line"> </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myvar;</span><br><span class="line">  <span class="built_in">console</span>.log(myvar); <span class="comment">// undefined</span></span><br><span class="line">  myvar = <span class="string">"local value"</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><p>声明函数的两种方式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 函数声明 存在函数提升且大于变量提升</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 函数表达式 var foo=function foo1()&#123;&#125; 函数名可写</span></span><br></pre></td></tr></table></figure></p><p>此时的3种递归调用自身的方式 </p><ul><li>foo()</li><li>foo1()</li><li>arguments.callee() </li></ul><p>现在已经不推荐使用arguments.callee()；原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。</p><h2 id="数据类型-7种"><a href="#数据类型-7种" class="headerlink" title="数据类型 7种"></a>数据类型 7种</h2><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><ul><li>Boolean</li><li>null</li><li>undefined</li><li>String </li><li>Number 标识范围 -2^53~2^53-1 数字均为双精度浮点类型</li><li>Symbol(它的实例是唯一且不可改变)<h3 id="对象Object"><a href="#对象Object" class="headerlink" title="对象Object"></a>对象Object</h3>对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。</li></ul><p>只有null和undefined无法拥有方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false </span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="literal">null</span> <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">[]+[] <span class="comment">// ""</span></span><br><span class="line">[]+&#123;&#125; <span class="comment">// "[object Object]"</span></span><br><span class="line">&#123;&#125;+[] <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">!+[]+[]+![] <span class="comment">// "truefalse"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max() <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">Math</span>.min() <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure></p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>字面量是由语法表达式定义的常量</p><ul><li>数组字面量(Array literals) []</li><li>布尔字面量(Boolean literals) true/false</li><li>浮点数字面量(Floating-point literals) 3.14</li><li>整数(Intergers) 5 </li><li>对象字面量(Object literals) {}</li><li>RegExp literals 一个正则表达式是字符被斜线（译注：正斜杠“/”）围成的表达式 /a+b/ </li><li>字符串字面量(String literals) “1212” ‘1212’JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象。你也能用对字符串字面值使用类似</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.length的属性：</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"John's cat"</span>.length)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">  say:funciton()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 简写</span></span><br><span class="line">  say()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>十进制整数字面量由一串数字序列组成，且没有前缀0。八进制的整数以 0（或0O、0o）开头，只能包括数字0-7。十六进制整数以0x（或0X）开头，可以包含数字（0-9）和字母 a~f 或 A~F。二进制整数以0b（或0B）开头，只能包含数字0和1。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure><h2 id="布尔环境的假值"><a href="#布尔环境的假值" class="headerlink" title="布尔环境的假值"></a>布尔环境的假值</h2><ul><li>false</li><li>undefined</li><li>null</li><li>0</li><li>NaN</li><li>空字符串（””）</li></ul><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>如果finally块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"bogus"</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// this return statement is suspended</span></span><br><span class="line">                 <span class="comment">// until finally block has completed</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>); <span class="comment">// not reachable</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// overwrites the previous "return"</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// not reachable</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// "return false" is executed now  </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>); <span class="comment">// not reachable</span></span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// console 0, 1, 3; returns false</span></span><br></pre></td></tr></table></figure></p><h2 id="for-of-和-for-in循环"><a href="#for-of-和-for-in循环" class="headerlink" title="for of 和 for in循环"></a>for of 和 for in循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有可枚举的属性名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i); <span class="comment">// logs "3", "5", "7" // 注意这里没有 hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套函数和闭包"><a href="#嵌套函数和闭包" class="headerlink" title="嵌套函数和闭包"></a>嵌套函数和闭包</h2><p>一个闭包是一个可以自己拥有独立的环境与变量的的表达式。</p><ul><li>内部函数包含外部函数的作用域。</li><li>内部函数只可以在外部函数中访问。</li><li>内部函数可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。</li></ul><h2 id="多层嵌套函数"><a href="#多层嵌套函数" class="headerlink" title="多层嵌套函数"></a>多层嵌套函数</h2><p>函数可以被多层嵌套。例如，函数A可以包含函数B，函数B可以再包含函数C。B和C都形成了闭包，所以B可以访问A，C可以访问B和A。因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域。这个称之为作用域链。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">    &#125;</span><br><span class="line">    C(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  B(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">A(<span class="number">1</span>); <span class="comment">// logs 6 (1 + 2 + 3)</span></span><br></pre></td></tr></table></figure></p><p>在这个例子里面，C可以访问B的y和A的x。这是因为：</p><ol><li>B形成了一个包含A的闭包，B可以访问A的参数和变量</li><li>C形成了一个包含B的闭包</li><li>B包含A，所以C也包含A，C可以访问B和A的参数和变量。换言之，C用这个顺序链接了B和A的作用域</li></ol><p>反过来却不是这样。A不能访问C，因为A看不到B中的参数和变量，C是B中的一个变量，所以C是B私有的。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outside</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inside</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outside()(<span class="number">10</span>); <span class="comment">// returns 20 instead of 10</span></span><br></pre></td></tr></table></figure></p><p>命名冲突发生在return x上，inside的参数x和outside变量x发生了冲突。这里的作用链域是{inside, outside, 全局对象}。因此inside的x具有最高优先权，返回了20（inside的x）而不是10（outside的x）。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>JavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数将的生存周期比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pet = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;          <span class="comment">//外部函数定义了一个变量"name"</span></span><br><span class="line">  <span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;            </span><br><span class="line">    <span class="comment">//内部函数可以访问 外部函数定义的"name"</span></span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//返回这个内部函数，从而将其暴露在外部函数作用域</span></span><br><span class="line">  <span class="keyword">return</span> getName;               </span><br><span class="line">&#125;;</span><br><span class="line">myPet = pet(<span class="string">"Vivie"</span>);</span><br><span class="line">    </span><br><span class="line">myPet();                            <span class="comment">// 返回结果 "Vivie"</span></span><br></pre></td></tr></table></figure></p><h2 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h2><p>函数的实际参数会被保存在一个类似数组的arguments对象中。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arguments</span>[i] <span class="comment">// 访问</span></span><br></pre></td></tr></table></figure></p><p>arguments变量只是 ”类数组对象“，并不是一个数组。称其为类数组对象是说它有一个索引编号和length属性。尽管如此，它并不拥有全部的Array对象的操作方法。</p><h2 id="函数参数-默认参数、剩余参数-rest"><a href="#函数参数-默认参数、剩余参数-rest" class="headerlink" title="函数参数(默认参数、剩余参数(rest))"></a>函数参数(默认参数、剩余参数(rest))</h2><p>剩余参数语法允许将不确定数量的参数表示为数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b = <span class="number">1</span>,...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数总是匿名的引入箭头函数的原因</p><ol><li>更简洁的语法</li><li>捕捉闭包上下文的this值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.age++; <span class="comment">// |this| properly refers to the person object</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></li></ol><h2 id="扩展语句"><a href="#扩展语句" class="headerlink" title="扩展语句"></a>扩展语句</h2><p>适用于对象，数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure></p><h2 id="临时对象"><a href="#临时对象" class="headerlink" title="临时对象"></a>临时对象</h2><p>你可以在String字面值上使用String对象的任何方法—JavaScript自动把String字面值转换为一个临时的String对象, 然后调用其相应方法,最后丢弃销毁此临时对象.在String字面值上也可以使用String.length属性.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"2 + 2"</span>; <span class="comment">// Creates a string literal value</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"2 + 2"</span>); <span class="comment">// Creates a String object</span></span><br><span class="line"><span class="built_in">eval</span>(s1); <span class="comment">// Returns the number 4</span></span><br><span class="line"><span class="built_in">eval</span>(s2); <span class="comment">// Returns the string "2 + 2"</span></span><br></pre></td></tr></table></figure></p><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="concat-连接两个数组并返回一个新的数组。"><a href="#concat-连接两个数组并返回一个新的数组。" class="headerlink" title="concat() 连接两个数组并返回一个新的数组。"></a>concat() 连接两个数组并返回一个新的数组。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br><span class="line">myArray = myArray.concat(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); </span><br><span class="line"><span class="comment">// myArray is now ["1", "2", "3", "a", "b", "c"]</span></span><br></pre></td></tr></table></figure><h3 id="join-将数组的所有元素连接成一个字符串。"><a href="#join-将数组的所有元素连接成一个字符串。" class="headerlink" title="join() 将数组的所有元素连接成一个字符串。"></a>join() 将数组的所有元素连接成一个字符串。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Wind"</span>, <span class="string">"Rain"</span>, <span class="string">"Fire"</span>);</span><br><span class="line"><span class="keyword">var</span> list = myArray.join(<span class="string">" - "</span>); <span class="comment">// list is "Wind - Rain - Fire"</span></span><br></pre></td></tr></table></figure><h3 id="push-在数组末尾添加一个或多个元素，并返回数组操作后的长度。"><a href="#push-在数组末尾添加一个或多个元素，并返回数组操作后的长度。" class="headerlink" title="push() 在数组末尾添加一个或多个元素，并返回数组操作后的长度。"></a>push() 在数组末尾添加一个或多个元素，并返回数组操作后的长度。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>, <span class="string">"2"</span>);</span><br><span class="line">myArray.push(<span class="string">"3"</span>); <span class="comment">// myArray is now ["1", "2", "3"]</span></span><br></pre></td></tr></table></figure><h3 id="pop-从数组移出最后一个元素，并返回该元素。"><a href="#pop-从数组移出最后一个元素，并返回该元素。" class="headerlink" title="pop() 从数组移出最后一个元素，并返回该元素。"></a>pop() 从数组移出最后一个元素，并返回该元素。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br><span class="line"><span class="keyword">var</span> last = myArray.pop(); </span><br><span class="line"><span class="comment">// myArray is now ["1", "2"], last = "3"</span></span><br></pre></td></tr></table></figure><h3 id="shift-从数组移出第一个元素，并返回该元素。"><a href="#shift-从数组移出第一个元素，并返回该元素。" class="headerlink" title="shift() 从数组移出第一个元素，并返回该元素。"></a>shift() 从数组移出第一个元素，并返回该元素。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span> (<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br><span class="line"><span class="keyword">var</span> first = myArray.shift(); </span><br><span class="line"><span class="comment">// myArray is now ["2", "3"], first is "1"</span></span><br></pre></td></tr></table></figure><h3 id="unshift-在数组开头添加一个或多个元素，并返回数组的新长度。"><a href="#unshift-在数组开头添加一个或多个元素，并返回数组的新长度。" class="headerlink" title="unshift()在数组开头添加一个或多个元素，并返回数组的新长度。"></a>unshift()在数组开头添加一个或多个元素，并返回数组的新长度。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span> (<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br><span class="line">myArray.unshift(<span class="string">"4"</span>, <span class="string">"5"</span>); </span><br><span class="line"><span class="comment">// myArray becomes ["4", "5", "1", "2", "3"]</span></span><br></pre></td></tr></table></figure><h3 id="slice-开始索引，结束索引-从数组提取一个片段，并作为一个新数组返回。"><a href="#slice-开始索引，结束索引-从数组提取一个片段，并作为一个新数组返回。" class="headerlink" title="slice(开始索引，结束索引) 从数组提取一个片段，并作为一个新数组返回。"></a>slice(开始索引，结束索引) 从数组提取一个片段，并作为一个新数组返回。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span> (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>);</span><br><span class="line">myArray = myArray.slice(<span class="number">1</span>, <span class="number">4</span>); <span class="comment">// until index 3, returning [ "b", "c", "d"]</span></span><br></pre></td></tr></table></figure><h3 id="splice-index-count-to-remove-addElement1-addElement2-…-从数组移出一些元素，（可选）并替换它们。"><a href="#splice-index-count-to-remove-addElement1-addElement2-…-从数组移出一些元素，（可选）并替换它们。" class="headerlink" title="splice(index, count_to_remove, addElement1, addElement2, …)从数组移出一些元素，（可选）并替换它们。"></a>splice(index, count_to_remove, addElement1, addElement2, …)从数组移出一些元素，（可选）并替换它们。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span> (<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>);</span><br><span class="line">myArray.splice(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>); </span><br><span class="line"><span class="comment">// myArray is now ["1", "a", "b", "c", "d", "5"]</span></span><br></pre></td></tr></table></figure><h3 id="reverse-颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。"><a href="#reverse-颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。" class="headerlink" title="reverse() 颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。"></a>reverse() 颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = <span class="keyword">new</span> <span class="built_in">Array</span> (<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br><span class="line">myArray.reverse(); </span><br><span class="line"><span class="comment">// transposes the array so that myArray = [ "3", "2", "1" ]</span></span><br></pre></td></tr></table></figure><h3 id="sort-给数组元素排序。"><a href="#sort-给数组元素排序。" class="headerlink" title="sort() 给数组元素排序。"></a>sort() 给数组元素排序。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">arr.sort() <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><p>sort() 也可以带一个回调函数来决定怎么比较数组元素。这个回调函数比较两个值，并返回3个值中的一个：</p><ul><li>如果 a 小于 b ，返回 -1(或任何负数) 降序</li><li>如果 a 大于 b ，返回 1 (或任何正数) 升序</li><li>如果 a 和 b 相等，返回 0。</li></ul><h3 id="indexOf-searchElement-fromIndex-在数组中搜索searchElement-并返回第一个匹配的索引。"><a href="#indexOf-searchElement-fromIndex-在数组中搜索searchElement-并返回第一个匹配的索引。" class="headerlink" title="indexOf(searchElement[, fromIndex]) 在数组中搜索searchElement 并返回第一个匹配的索引。"></a>indexOf(searchElement[, fromIndex]) 在数组中搜索searchElement 并返回第一个匹配的索引。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">'b'</span>)); <span class="comment">// logs 1</span></span><br><span class="line"><span class="comment">// Now try again, starting from after the last match</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">'b'</span>, <span class="number">2</span>)); <span class="comment">// logs 3</span></span><br><span class="line"><span class="built_in">console</span>.log(a.indexOf(<span class="string">'z'</span>)); <span class="comment">// logs -1, because 'z' was not found</span></span><br></pre></td></tr></table></figure><h3 id="lastIndexOf-searchElement-fromIndex-和-indexOf-差不多，但这是从结尾开始，并且是反向搜索。"><a href="#lastIndexOf-searchElement-fromIndex-和-indexOf-差不多，但这是从结尾开始，并且是反向搜索。" class="headerlink" title="lastIndexOf(searchElement[, fromIndex]) 和 indexOf 差不多，但这是从结尾开始，并且是反向搜索。"></a>lastIndexOf(searchElement[, fromIndex]) 和 indexOf 差不多，但这是从结尾开始，并且是反向搜索。</h3><h3 id="forEach-循环数组-不定的顺序-不能用break-return-false跳出循环遍历"><a href="#forEach-循环数组-不定的顺序-不能用break-return-false跳出循环遍历" class="headerlink" title="forEach() 循环数组 不定的顺序 不能用break,return false跳出循环遍历"></a>forEach() 循环数组 不定的顺序 不能用break,return false跳出循环遍历</h3><h3 id="map-循环数组返回新数组"><a href="#map-循环数组返回新数组" class="headerlink" title="map() 循环数组返回新数组"></a>map() 循环数组返回新数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = a1.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123; <span class="keyword">return</span> item.toUpperCase(); &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// logs A,B,C</span></span><br></pre></td></tr></table></figure><h3 id="filter-循环数组返回符合条件的元素"><a href="#filter-循环数组返回符合条件的元素" class="headerlink" title="filter() 循环数组返回符合条件的元素"></a>filter() 循环数组返回符合条件的元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = [<span class="string">'a'</span>, <span class="number">10</span>, <span class="string">'b'</span>, <span class="number">20</span>, <span class="string">'c'</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = a1.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> item == <span class="string">'number'</span>; &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a2); <span class="comment">// logs 10,20,30</span></span><br></pre></td></tr></table></figure><h3 id="every-循环数组-如果全部元素满足条件则返回true-否则返回false"><a href="#every-循环数组-如果全部元素满足条件则返回true-否则返回false" class="headerlink" title="every() 循环数组 如果全部元素满足条件则返回true 否则返回false"></a>every() 循环数组 如果全部元素满足条件则返回true 否则返回false</h3><h3 id="some-循环数组-只要有一项满足条件则返回true-全部不满足返回false"><a href="#some-循环数组-只要有一项满足条件则返回true-全部不满足返回false" class="headerlink" title="some() 循环数组 只要有一项满足条件则返回true 全部不满足返回false"></a>some() 循环数组 只要有一项满足条件则返回true 全部不满足返回false</h3><h3 id="reduce-迭代-使用回调函数-callback-firstValue-secondValue-把数组列表计算成一个单一值-reduceRight-从右边开始"><a href="#reduce-迭代-使用回调函数-callback-firstValue-secondValue-把数组列表计算成一个单一值-reduceRight-从右边开始" class="headerlink" title="reduce() 迭代 使用回调函数 callback(firstValue, secondValue) 把数组列表计算成一个单一值 reduceRight() 从右边开始"></a>reduce() 迭代 使用回调函数 callback(firstValue, secondValue) 把数组列表计算成一个单一值 reduceRight() 从右边开始</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">var</span> total = a.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123; <span class="keyword">return</span> first + second; &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(total) <span class="comment">// Prints 60</span></span><br></pre></td></tr></table></figure><h2 id="Map简单的键值对集合"><a href="#Map简单的键值对集合" class="headerlink" title="Map简单的键值对集合"></a>Map简单的键值对集合</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayings = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">sayings.set(<span class="string">'dog'</span>, <span class="string">'woof'</span>);</span><br><span class="line">sayings.set(<span class="string">'cat'</span>, <span class="string">'meow'</span>);</span><br><span class="line">sayings.set(<span class="string">'elephant'</span>, <span class="string">'toot'</span>);</span><br><span class="line">sayings.size; <span class="comment">// 3</span></span><br><span class="line">sayings.get(<span class="string">'fox'</span>); <span class="comment">// undefined</span></span><br><span class="line">sayings.has(<span class="string">'bird'</span>); <span class="comment">// false</span></span><br><span class="line">sayings.delete(<span class="string">'dog'</span>);</span><br><span class="line">sayings.has(<span class="string">'dog'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> sayings) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' goes '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "cat goes meow"</span></span><br><span class="line"><span class="comment">// "elephant goes toot"</span></span><br><span class="line"></span><br><span class="line">sayings.clear();</span><br><span class="line">sayings.size; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>new Map() 参数可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p><p><strong>Object和Map的比较</strong></p><ol><li>一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。</li><li>Object的键均为Strings类型，在Map里键可以是任意类型。</li><li>必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。</li><li>Map的遍历遵循元素的插入顺序。</li><li>Object有原型，所以映射中有一些缺省的键。（可以理解为map = Object.create(null)）。</li></ol><p>如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。如果需要对个别元素进行操作，使用Object。</p><h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">mySet.add(<span class="number">1</span>);</span><br><span class="line">mySet.add(<span class="string">"some text"</span>);</span><br><span class="line">mySet.add(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">mySet.has(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">mySet.delete(<span class="string">"foo"</span>);</span><br><span class="line">mySet.size; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> mySet) <span class="built_in">console</span>.log(item);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// "some text"</span></span><br><span class="line"></span><br><span class="line">mySet2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(mySet);  <span class="comment">// [1,2,3] 常用来去重</span></span><br></pre></td></tr></table></figure><p><strong>Array和Set的比较</strong></p><ol><li>数组中用于判断元素是否存在的indexOf 函数效率低下。</li><li>Set对象允许根据值删除元素，而数组中必须使用基于下标的 splice 方法。</li><li>数组的indexOf方法无法找到NaN值。</li><li>Set对象存储不重复的值，所以不需要手动处理包含重复值的情况。</li><li>数组是特殊的对象,对象是关联数组 字符串是特殊的数组</li><li>方括弧取值为动态判定[]，数字非有效的js标识符   </li></ol><h2 id="setter和getter-get-set修饰function"><a href="#setter和getter-get-set修饰function" class="headerlink" title="setter和getter (get set修饰function)"></a>setter和getter (get set修饰function)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">7</span>,</span><br><span class="line">  get b() &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  set c(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = x / <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 8 取b值时调用</span></span><br><span class="line">o.c = <span class="number">50</span>;         <span class="comment">// 给c设置值调用</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 25</span></span><br><span class="line">-----------------------</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">7</span>,</span><br><span class="line">  b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.b()); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2 id="访问所有可枚举对象属性"><a href="#访问所有可枚举对象属性" class="headerlink" title="访问所有可枚举对象属性"></a>访问所有可枚举对象属性</h2><ol><li>for in 无序</li><li>Object.keys() 不包括原型的属性名数组</li><li>Object.getOwnPropertyNames()</li></ol><h2 id="Symbol-原始数据类型-不可枚举的-符号类型"><a href="#Symbol-原始数据类型-不可枚举的-符号类型" class="headerlink" title="Symbol(原始数据类型) 不可枚举的 符号类型"></a>Symbol(原始数据类型) 不可枚举的 符号类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  myPrivateMethod  = <span class="built_in">Symbol</span>(); <span class="comment">// 不能使用new Symbol()创建，它是一个不完整的类</span></span><br><span class="line"><span class="keyword">this</span>[myPrivateMethod] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>for in 和 Object.getOwnPropertyNames()访问不到，只能通过myPrivateMethod或者Object.getOwnPropertySymbols()来访问<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">"foo"</span>) !== <span class="built_in">Symbol</span>(<span class="string">"foo"</span>)</span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">typeof</span> foo === <span class="string">"symbol"</span></span><br><span class="line"><span class="keyword">typeof</span> bar === <span class="string">"symbol"</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj[foo] = <span class="string">"foo"</span></span><br><span class="line">obj[bar] = <span class="string">"bar"</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// [ foo, bar ]</span></span><br></pre></td></tr></table></figure></p><h2 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h2><p><code>let p= new Proxy(target,handler)</code></p><ul><li><p>target用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p></li><li><p>handler一个对象，其属性是当执行一个操作时定义代理的行为的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置缺省值</span></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : <span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b);    <span class="comment">// 1, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span> <span class="keyword">in</span> p, p.c);    <span class="comment">// false, 37</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转发代理</span></span><br><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">37</span>;   <span class="comment">// 操作转发到目标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.a);    <span class="comment">// 37. 操作已经被正确地转发</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="keyword">let</span> book  = &#123;<span class="string">"name"</span>:<span class="string">"《ES6基础系列》"</span>,<span class="string">"price"</span>:<span class="number">56</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(book,&#123;</span><br><span class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params">target,property</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(property === <span class="string">"name"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"《入门到懵逼》"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> target[property];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    set:<span class="function"><span class="keyword">function</span>(<span class="params">target,property,value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(property === <span class="string">'price'</span>)&#123;</span><br><span class="line">            target[property] = <span class="number">56</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器 generator"></a>生成器 generator</h2><p>function* 来修饰GeneratorFunction函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">idMaker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = idMaker();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p><p>对象实现迭代行为<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myIterable) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">[...myIterable]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/jssummary.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>redux状态传播</title>
      <link>http://mydearest.cn/reduxstate.html</link>
      <guid>http://mydearest.cn/reduxstate.html</guid>
      <pubDate>Thu, 21 Jun 2018 11:37:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;要有内容不然搜索会挂&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>要有内容不然搜索会挂</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/reduxstate.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>响应式网页设计</title>
      <link>http://mydearest.cn/responsive.html</link>
      <guid>http://mydearest.cn/responsive.html</guid>
      <pubDate>Tue, 19 Jun 2018 17:33:47 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;什么是响应式网站&quot;&gt;&lt;a href=&quot;#什么是响应式网站&quot; class=&quot;headerlink&quot; title=&quot;什么是响应式网站&quot;&gt;&lt;/a&gt;什么是响应式网站&lt;/h2&gt;&lt;p&gt;响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="什么是响应式网站"><a href="#什么是响应式网站" class="headerlink" title="什么是响应式网站"></a>什么是响应式网站</h2><p>响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。</p><hr><a id="more"></a><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>面对不同分辨率设备灵活性强</li><li>能够快捷解决多设备显示适应问题</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>兼容各种设备工作量大，效率低下</li><li>代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li><li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li></ul><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>谷歌教程用HTML5以及CSS3的媒体查询完成了一个响应式布局的demo，大家可以用不同的尺寸的设备，查看不同分辨率下的表现。也可以在控制台模拟各种设备，欢迎大家提出意见。</p><p>在线地址：<a href="http://dir.mydearest.cn/responsive/" target="_blank" rel="noopener">http://dir.mydearest.cn/responsive/</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/responsive.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>有趣的摧毁页面</title>
      <link>http://mydearest.cn/destory.html</link>
      <guid>http://mydearest.cn/destory.html</guid>
      <pubDate>Tue, 19 Jun 2018 17:14:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;食用方法&lt;/p&gt;
&lt;p&gt;使用【上下左右键】来控制飞行器的运动&lt;/p&gt;
&lt;p&gt;使用【空格键】来发射导弹&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;javascript:var%20KICKASSVERSION=&#39;2.0&#39;; var%20s%20=%20document.createElement(&#39;script&#39;); s.type=&#39;text/javascript&#39;; document.body.appendChild(s); s.src=&#39;//hi.kickassapp.com/kickass.js&#39;; void(0);&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 点击开始摧毁 &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>食用方法</p><p>使用【上下左右键】来控制飞行器的运动</p><p>使用【空格键】来发射导弹</p><p><a href="javascript:var%20KICKASSVERSION='2.0'; var%20s%20=%20document.createElement('script'); s.type='text/javascript'; document.body.appendChild(s); s.src='//hi.kickassapp.com/kickass.js'; void(0);" target="_blank" rel="noopener"> 点击开始摧毁 </a></p><hr><a id="more"></a><p>引入JS代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"javascript:var%20KICKASSVERSION='2.0'; </span></span><br><span class="line"><span class="string">var%20s%20=%20document.createElement('script'); </span></span><br><span class="line"><span class="string">s.type='text/javascript'; document.body.appendChild(s); </span></span><br><span class="line"><span class="string">s.src='//hi.kickassapp.com/kickass.js'; void(0);"</span>&gt; 点击开始摧毁 &lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure></p><p>页面崩溃<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="string">""</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; </span><br><span class="line">    total = total + i.toString(); </span><br><span class="line">    history.pushState(<span class="number">0</span>, <span class="number">0</span>, total); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>转动吧，风扇！！！</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/destory.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
