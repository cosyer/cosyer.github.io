[{"title":"侠之大者，为国接盘","url":"%2Fhouseprice.html","content":"\n{% centerquote %} \n炒房兴邦，实业误国\n{% endcenterquote %}\n\n近年来，房价成为了生活中重要的谈资和话题，几乎所有的聊天场合都会聊到房子，什么谁谁谁有几套房，不用工作每月靠房租过活。坐公交车上都是听到一些阿姨手里几套房，在手里在捂一会，转手卖给有刚需的年轻人，后悔没多买几套之类的话。房价的上涨，刚需不敢不买，等下去看不到希望，掏空了一家父母的过去和年轻人的未来，面对zf的货币超发引起的通货膨胀，却又无可奈何。房价再涨个3、4倍，分分钟GDP超过美国啊。现在基本的理财方式已经赶不上通货膨胀的速度了，眼看着手里的钱越来越不值钱，人人自危，都只能通过购房来保值。被zf逼的哪怕背上几十年的贷款也要坐上这趟车，给zf当几十年的免费劳动力来消化这巨大的泡沫。这个浮躁社会的高房价，让我们这些刚毕业工作几年的年轻人，要我们的青春和汗水给你们买单。现在的年轻人，怎么可能刚毕业就能积攒到买房的首付，被逼的去‘啃老’，掏空全家人的钱包，成为房奴。2017年前yz的房价大概7000/m2，恒大在年初当了一波地王2w/m2买了邗江中专那边的地后，各个楼盘开始疯长，在年底11月份购入1w/m2后，如今短短半年已经涨到了1.3w/m2。试想以100m2为例如果不早点买，就得平白无故多交20w的韭菜钱。房价降是不可能降的，这个牵扯到太多人和行业的利益，一旦崩盘了，其他行业也会受到影响，经济陷入低迷，zf不断地增发货币来救市。一线城市政府来主导市场看上去房价跌了，这也只是杯水车薪，高额的房价不断地在驱逐这所谓的低端人口，也是啊，毕竟要实现小康社会啊，让先富带动后富，实现共同小康，还是直接消灭低端人口容易些。房价的压力让现在的中国人充满着戾气、浮躁。上了车的人在嘲讽着没上车的人，一旦买了房，两者就成了对立面，高房价改变了人们的价值观。如今人们对于成功的标准定义有几辆车，几套房。现在各个城市推行的所谓吸引人才政策，不就是为了让人来接盘去库存么。房价带来了价值观的革命，中下层把买房当成了人生目标，中产把买房当成了支付手段，政府把麦蒂当作经济支柱。房价捆绑了经济、政治、户籍、教育、爱情、事业甚至社会地位，集万千宠爱于一身。随着房价越来越高，社会阶层出现固化趋势，多少年轻人的梦想倍房价无情碾压，多少家庭为了买房背上沉重的债务，多少爱情因为房价变得支离破碎，还有的夫妻为了多买套房选择离婚。而在房价面前我们崇尚的个人奋斗，不值一文。年轻人开始选择佛系，不再憧憬爱情，坚持和努力并没有什么卵用，开始相信投机的价值。金钱至上主义横行，勤劳致富成为了笑话，炒房的人成为了羡慕对象，所谓的梦想是多么的幼稚可笑。这个xx的时代，只要你买不起房救市没出息的男人。毕竟男生在婚姻当中是向下兼容，而女生是向上兼容的。抱歉，中国特色社会主义的大饼我吃不下了。从古至今，中国还是没有发生什么大的变化，权利还是集中，什么人民当家作主，到头来还不是被代表了。所谓的法律还不是为了维护阶级统治的利益。我国是领导人选举能全票通过的国家，神奇不神奇呵呵。一个个大腹便便的领导们，嘴上说着服务人民，背地里作者贪污腐败的行当。这年头都希望考公务员，公务员是什么，为人名服务。一个个都争着抢着去当人民的公仆，还不是为了铁饭碗、利益。","tags":["三观"],"categories":["杂谈"]},{"title":"JavaScript深入之执行上下文","url":"%2Fcontext.html","content":"\n## 变量/函数提升\n\n```javascript\nif(!\"a\" in window){\n    var a=1;\n}\nconsole.log(a) // undefined\n```\n\n```javascript\nfunction foo() {\n    console.log('foo1');\n}\n\nfoo();  // foo2\n\nfunction foo() {\n    console.log('foo2');\n}\n\nfoo(); // foo2\n```\n\nJavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。插槽slot\n可执行代码的类型：全局代码、函数代码、eval代码。\nJavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文\n\n--- \n<!-- more -->\n\n为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：\n\n```javascript\nECStack = [];\n```\n\n试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：\n\n```javascript\nECStack = [\n    globalContext\n];\n```\n\n现在 JavaScript 遇到下面的这段代码了：\n\n```javascript\nfunction fun3() {\n    console.log('fun3')\n}\n\nfunction fun2() {\n    fun3();\n}\n\nfunction fun1() {\n    fun2();\n}\n\nfun1();\n```\n\n当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：\n\n```javascript\n// 伪代码\n\n// fun1()\nECStack.push(<fun1> functionContext);\n\n// fun1中竟然调用了fun2，还要创建fun2的执行上下文\nECStack.push(<fun2> functionContext);\n\n// 擦，fun2还调用了fun3！\nECStack.push(<fun3> functionContext);\n\n// fun3执行完毕\nECStack.pop();\n\n// fun2执行完毕\nECStack.pop();\n\n// fun1执行完毕\nECStack.pop();\n\n// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext\n```\n\n## 三大属性\n- 变量对象\n- 作用域链\n- this\n\n## 全局对象\n{% note info %}\n\n全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。\n\n{% endnote %}\n\n{% note info %}\n\n例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。\n\n{% endnote %}\n\n```javascript\n// 在浏览器客户端 全局对象就是window对象\n// 通过this引用\nthis === window  // true\nthis.window === window // true\nthis instanceof Object // 是通过Object构造函数实例出来的对象\nMath.random() \nthis.Math.random() // 预定义了一些函数和属性\n\n// window指向自身\nvar a=1;\na // 1\nthis.a // 1\nwindow.a // 1 \nthis.window.a // 1\n```\n\n## 函数声明>变量声明\n\n```javascript\nconsole.log(foo); // 打印函数\n\nfunction foo(){\n    console.log(\"foo\");\n}\n\nvar foo = 1;\n```\n执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。","tags":["上下文"],"categories":["JS"]},{"title":"JavaScript深入之作用域","url":"%2Fscope.html","content":"\n## 作用域\n\n作用域指的是程序源代码中定义变量的区域\n\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n\nJavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。函数的作用域在函数定义的时候就决定了，函数的作用域基于函数创建的位置。\n\n---\n<!-- more -->\n\n```javascript\nvar value=1\nfunction print(){\n  console.log(value)\n}\nfunction foo(){\n  var value=2\n  print()\n}\nfoo() // value 1 如果是动态作用域则是2\n```\n我们再来看两道题：\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n```\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n```\n两道题的执行结果都是 \"local scope\"\n\nJavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。\n\n","tags":["作用域"],"categories":["JS"]},{"title":"JavaScript深入之从原型到原型链","url":"%2Fprototype.html","content":"\n## 构造函数创建对象\n\n我们先使用构造函数创建一个对象：\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nperson.name = \"cosyer\";\nconsole.log(person.name); // cosyer\n```\n\n在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。\n\n---\n\n<!-- more -->\n\n很简单吧，接下来进入正题：\n\n### prototype\n\n每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：\n\n```javascript\nfunction Person() {}\n// prototype是函数才会有的属性\nPerson.prototype.name = \"cosyer\";\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name); // cosyer\nconsole.log(person2.name); // cosyer\n```\n\n那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？\n\n其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。\n\n那什么是原型呢？你可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\n\n让我们用一张图表示构造函数和实例原型之间的关系：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype1.png)\n\n在这张图中我们用 Object.prototype 表示实例原型。\n\n那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：\n\n### **proto**\n\n为了证明这一点,我们可以在火狐或者谷歌中输入：\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n于是我们更新下关系图：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype2.png)\n\n既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？\n\n### constructor\n\n指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。\n\n为了验证这一点，我们可以尝试：\n\n```javascript\nfunction Person() {}\nconsole.log(Person === Person.prototype.constructor); // true\n```\n\n所以再更新下关系图：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype3.png)\n综上我们可以得出：\n\n```javascript\nfunction Person() {}\n\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype); // true\nconsole.log(Person.prototype.constructor == Person); // true\n// 顺便学习一个ES5的方法,可以获得对象的原型 实例原型的constructor指向构造函数,构造函数的prototype指向实例原型,实例对象的__proto__指向实例原型,实例原型也是对象,它也有原型 最后的一个环节是null。访问实例对象的constructor时,也能从实例原型上去找,从而指向到构造函数。\nconsole.log(Object.getPrototypeOf(person) === Person.prototype); // true\n```\n\n## 实例与原型\n\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n举个例子：\n\n```javascript\nfunction Person() {}\n\nPerson.prototype.name = \"cosyer\";\n\nvar person = new Person();\n\nperson.name = \"Daisy\";\nconsole.log(person.name); // Daisy\n\ndelete person.name;\nconsole.log(person.name); // cosyer\n```\n\n在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。\n\n但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.\\_\\_proto\\_\\_ ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 cosyer。\n\n但是万一还没有找到呢？原型的原型又是什么呢？\n\n## 原型的原型\n\n在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```javascript\nvar obj = new Object();\nobj.name = \"cosyer\";\nconsole.log(obj.name); // cosyer\n```\n\n其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 **proto** 指向构造函数的 prototype ，所以我们再更新下关系图：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype4.png)\n\n## 原型链\n\n那 Object.prototype 的原型呢？\n\nnull，我们可以打印：\n\n```javascript\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n然而 null 究竟代表了什么呢？\n\n引用阮一峰老师的 《undefined 与 null 的区别》 就是：\n\nnull 表示“没有对象”，即该处不应该有值。\n\n所以 Object.prototype.**proto** 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n\n最后一张关系图也可以更新为：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype5.png)\n\n图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。\n\n## 补充\n\n### constructor\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nconsole.log(person.constructor === Person); // true\n```\n\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\n\n```javascript\nperson.constructor === Person.prototype.constructor;\n```\n\n### **proto**\n\n其次是 **proto** ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.**proto** 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n\n### 继承\n\n最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n\n- class 的引入只是语法糖本身还是基于原型的\n- 几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。\n\n```javascript\nvar p = Object.create(o);\n// p是一个继承自 o 的对象\n对象的原型链\no===>Object.prototype===>null\n数组的原型链\na===>Array.prototype===>Object.prototype===>null\n函数的原型链\nf===>Function.prototype===>Object.prototype===>null\n```\n\n### new 操作符具体干了什么\n1.创建空对象，并且this变量引用该对象同时继承该函数的原型\n2.属性和方法加入到this引用的对象中\n3.新创建的对象用this引用，并且隐式地返回this\n\n- es5使用Object.create()来创建对象 new {}\n使用Object.create()是将对象继承到__proto__属性上，\nObject.create(null)没有继承任何原型方法，也就是说它的原型链没有上一层。\n- es6使用class关键字\n\n- 构造器就是普通的函数,new来作用称为构造方法(构造函数)\n\n- 访问原型链会损耗性能,不存在的属性会遍历原型链直到最后一层\n\n- hasOwnProperty 是 JavaScript 中唯一处理属性并且不会遍历原型链的方法。","tags":["原型链"],"categories":["JS"]},{"title":"你所不知道的前端冷门小知识(长期更新)","url":"%2Fsmallknowledge.html","content":"\n## void \nvoid其实是javascript中的一个函数，接受一个参数，返回值永远是undefined\n```javascript\nvoid 0  \nvoid (0)  \nvoid \"hello\"  \nvoid (new Date())  \n// all will return undefined  \ncontext == void 666\n```\n\n---\n<!-- more -->\n\n## Element.scrollIntoViewIfNeeded\n Element.scrollIntoViewIfNeeded（）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。\n ```javascript\nelement.scrollIntoViewIfNeeded(); // 等同于element.scrollIntoViewIfNeeded(true) \nelement.scrollIntoViewIfNeeded(true); \nelement.scrollIntoViewIfNeeded(false);\n ```\n- 当元素已经在可视区域时，调用 Element.scrollIntoView()，无论设置什么参数，均发生滚动。\n- 当元素已经在可视区域时，调用 Element.scrollIntoViewIfNeeded()，无论设置什么参数，均不发生滚动。\n\n## JS取整\n```javascript\n~~2.5 // 2 按位取反 -2^31~2^31-1 -2147483648~2147483647\n0|3.123;// 3 或运算\n4.3|0; // 4\n4.3<<0; // 4\n```\n\n与Math.floor()的对比\n\n|区别|Math.floor|~~|\n|:---|:---:|---:|\n|NaN|NaN|0|\n|+0|+0|0|\n|-0|-0|0|\n|+Infinity|+Infinity|0|\n|-Infinity|-Infinity|0|\n|1.2|1.2|1.2|\n|-1.2|-1|-1|\n\n1. 位运算：~ 的结果是 int32 的有符号整数，所以肯定不可能是 NaN 和无穷，因此 1、4、5 两者不同。x|0  x<<0\n\n3. Math.floor 向 +∞ 取整。\n\n3. parseInt(string, radix);\n\nparseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。\n\nparseInt 解析字符串 '-0' 会得到 -0。如果参数是数字 -0，会得到 0。\n\n```javascript\nparseInt(0.0000000003) // 3\n\nparseInt('2017-07-04') // 2017\n```\n## 全等判断\njavascript 中 +0 完全等于 -0，那么怎么分区两者呢？\n```javascript\n1/0 === 1/-0 // false \n+0 === -0 // true\nObject.is(+0,-0) // false\n```\n区分NaN\n```javascript\nNaN !== NaN // true\nNaN === NaN // false \nObject.is(NaN,NaN) // true\n```\n\n## try-catch跳出forEach循环\nforEach遍历不能保证遍历的顺序，以及不能break;一般for循环的性能是forEach的20倍\n```javascript \ntry {\n    [1, 2, 3].forEach(v => {\n        if (v === 2) {\n            throw new Error('my err')\n        }\n    })\n} catch (e) {\n    if (e.message === 'my err') {\n        console.log('breaked') \n    } else {\n        throw e\n    }\n}\n```\n用some也可以做到\n[1,2,3].some((item)=>{\n  return item === 2 // 如果item等于2就跳出循环\n})\n\n## fetch模拟post进行api测试\n```javascript\nfetch(apiUrl, {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({q: 1})\n}).then(async res => console.log(await res.json()))\n```\n\n## 实现var a = add(2)(3)(4)\njs中console.log一个对象时，会对这个对象进行toString()操作，还有些情况会对对象进行valueOf()操作\nvauleOf优先于toString()被调用\n```javascript\nfunction add(num){\n    var _add = function(args){\n        num+=args;\n        return arguments.callee; //  return add(num+args);\n    }\n    _add.toString = _add.valueOf = function(){\n        return num;\n    }\n    return _add;\n}\nadd(2)(3)(4);// function 9\n```\n\n## Date相关\n\n### Date构造函数\n```javascript\nDate.now() === new Date().getTime()\nDate.parse(\"2018-06-13\") === new Date(\"2018-06-13\").getTime()\n// 浏览器之间解析时间不同 safari 解析横杠 - 会出错所以尽量用斜杠 /\n```\n### 当前时间\n```javascript\nlet d = new Date()\nlet year=d.getFullYear();\nlet month=d.getMonth()+1; // 月份索引从0开始\nlet day=d.getDate(); // getDay()用于获取星期\nlet hour=d.getHours();\nlet minute=d.getMinutes();\nlet second=d.getSeconds();\nconsole.log(`${year}-${month}-${day} ${hour}:${minute}:${second}`) // 2018-6-13 21:20:48\n// 不足2位数补0\nconsole.log([year, month, day].map((item)=>{\n        item = item.toString();\n    return item[1] ? item : \"0\" + item;\n}).join(\"-\") +\" \" +[hour, minute, second].map((item)=>{\n        item = item.toString();\n    return item[1] ? item : \"0\" + item;\n}).join(\":\"))  // 2018-06-13 21:20:48\n```\n### Date计时\n以博客存活时间为例\n```javascript\nvar time = new Date(); \nvar t = \"博客存活了\"+Math.floor((+new Date - 1527868800000) / (1000 * 60 * 60 * 24)) + \"天\" + time.getHours() + \"小时\" \n+ time.getMinutes() + \"分\" + time.getSeconds() + \"秒\"; \n// 博客存活了11天 21小时28分51秒 1527868800000当时的时间转的时间戳\n```\n\n### Date原型扩展方法\n```javascript\nDate.prototype.format = function (format) {\n\t\t\tvar o = {\n\t\t\t\t\t\"M+\": this.getMonth() + 1,\n\t\t\t\t\t\"d+\": this.getDate(),\n\t\t\t\t\t\"h+\": this.getHours(),\n\t\t\t\t\t\"m+\": this.getMinutes(),\n\t\t\t\t\t\"s+\": this.getSeconds(),\n\t\t\t\t\t\"q+\": Math.floor((this.getMonth() + 3) / 3),\n\t\t\t\t\t\"S\": this.getMilliseconds()\n\t\t\t};\n\t\t\tif (/(y+)/.test(format)) {\n\t\t\t\t\tformat = format.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n\t\t\t}\n\t\t\tfor (var k in o) {\n\t\t\t\t\tif (new RegExp(\"(\" + k + \")\").test(format)) {\n\t\t\t\t\t\t\tformat = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn format;\n\t};\n\n\tDate.prototype.addDays = function (d) {\n\t\t\tthis.setDate(this.getDate() + d);\n\t};\n\n\tDate.prototype.addWeeks = function (w) {\n\t\t\tthis.addDays(w * 7);\n\t};\n\n\tDate.prototype.addMonths = function (m) {\n\t\t\tvar d = this.getDate();\n\t\t\tthis.setMonth(this.getMonth() + m);\n\t\t\t//if (this.getDate() < d)\n\t\t\t//  this.setDate(0);\n\t};\n```\n\n## 页面加载时间\n```javascript\nwindow.onload = function () {\n  var loadTime = window.performance.timing.domContentLoadedEventEnd-window.performance.timing.navigationStart; \n  console.log('Page load time is '+ loadTime);\n}\n```\nonload和onready的区别：\n1. 执行时间\n\n　　window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 \n\n　　$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。\n\n2. 编写个数不同\n\n　　window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。\n\n　　$(document).ready()可以同时编写多个，并且都可以得到执行。\n\n3. 简化写法\n\n　　window.onload没有简化写法。\n\n　　$(document).ready(function(){})可以简写成$(function(){});\n\n## 常用标签\n```javascript\n<meta charset=\"utf-8\">\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\">\n<link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" />\n// seo三连\n<meta name=\"author\" name=\"cosyer\">\n<meta name=\"keywords\" name=\"cosyer\">\n<meta name=\"description\" name=\"cosyer\">\n<link rel=\"stylesheet\" href=\"\">\n<script src=\"\"></script>\n```\n\n## 获取url参数\n```javascript\nlet reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\")\nlet r = window.location.search.substr(1).match(reg)\nif (r != null) return decodeURIComponent(r[2]) // encodeURIComponent()\nreturn null\n```\n\n## String原型方法扩展\n```javascript\n// 连字符转驼峰\nString.prototype.hyphenToHump = function () {\n\t\treturn this.replace(/-(\\w)/g, function () {\n\t\t\t\treturn arguments[1].toUpperCase()\n\t\t})\n}\n\n// 驼峰转连字符\nString.prototype.humpToHyphen = function () {\n\t\treturn this.replace(/([A-Z])/g, \"-$1\").toLowerCase()\n}\n```\n\n## 拦截控制台、右键和F12\n```javascript\n\tdocument.onkeydown = function () {\n\t\t\tvar e = window.event || arguments[0];\n\t\t\t//屏蔽F12\n\t\t\tif (e.keyCode == 123) {\n\t\t\t\t\treturn false;\n\t\t\t\t\t//屏蔽Ctrl+Shift+I\n\t\t\t} else if ((e.ctrlKey) && (e.shiftKey) && (e.keyCode == 73)) {\n\t\t\t\t\treturn false;\n\t\t\t\t\t//屏蔽Shift+F10\n\t\t\t} else if ((e.shiftKey) && (e.keyCode == 121)) {\n\t\t\t\t\treturn false;\n\t\t\t}\n\t};\n\t//屏蔽右键单击\n\tdocument.oncontextmenu = function () {\n\t\t\treturn false;\n\t};\n```\n\n## 崩溃欺骗\n```javascript\nvar OriginTitle = document.title;\nvar titleTime;\ndocument.addEventListener('visibilitychange', function () {\n    if (document.hidden) {\n        $('[rel=\"icon\"]').attr('href', \"/img/TEP.ico\");\n        document.title = '╭(°A°`)╮ 页面崩溃啦 ~';\n        clearTimeout(titleTime);\n    }\n    else {\n        $('[rel=\"icon\"]').attr('href', \"/favicon.ico\");\n        document.title = '(ฅ>ω<*ฅ) 噫又好了~' + OriginTitle;\n        titleTime = setTimeout(function () {\n            document.title = OriginTitle;\n        }, 2000);\n    }\n});\n```\n\n## a标签\n```javascript\n    // 邮件\n\t<a href={'mailto:'+props.email}></a>\n\t// 下载只有 Firefox 和 Chrome 支持 download 属性。\n\t<a href=\"/images/myw3schoolimage.jpg\" download=\"w3logo\"></a>\n    // QQ\n\t<a href=\"tencent://message/?uin=535509852&Site=-&Menu=yes\" target=\"_blank\">QQ:535509852</a>\n```\n\n## 两数组去重合并\n```javascript\nfunction filter(a,b){\n\tfor(let m in a){ \n\tlet isExist=false;\n\tfor(let n in b ){\n\tif(b[n]==a[m]){\n\tisExist=true;\n\tbreak;\n\t}\n\t}\nif(!isExist){\n\tb.push(a[m]);\n}\n\t}\n\treturn b;\n}\n// filter([1,2,3,4],[2,3])\n// [2, 3, 1, 4]\n```\n\n## css选择器\n","tags":["知识"],"categories":["知识"]},{"title":"快速了解React 16新特性","url":"%2Freact16.html","content":"\n## Error Boundary\n\nError Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）\n\n---\n<!-- more -->\n\n```javascript\n//最佳实践：将ErrorBoundary抽象为一个公用的组件类\n \nimport React, { Component } from 'react'\n \nexport default class ErrorBoundary extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  componentDidCatch(err, info) {\n    this.setState({ hasError: true })\n    //sendErrorReport(err,info)\n  }\n  render(){\n    if(this.state.hasError){\n      return <div>Something went wrong!</div>\n    }\n    return this.props.children\n  }\n}\n```\n\n```javascript\n// 使用方式 包裹容易出错的组件\nrender(){\n  return (\n    <div>\n      <ErrorBoundary>\n        <Profile user={this.state.user} />\n      </ErrorBoundary>\n      <button onClick={this.onClick}>Update</button>\n    </div>\n  )\n}\n```\n## render方法新增返回类型\n在React 16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。\n\n```javascript\n//string\nrender(){\n  return 'hello,world'\n}\n \n//number\nrender(){\n  return 12345\n}\n \n//boolean\nrender(){\n  return isTrue?true:false\n}\n \n//null\nrender(){\n  return null\n}\n \n//fragments，未加key标识符，控制台会出现warning\nrender(){\n  return [\n    <div>hello</div>,\n    <span>world</span>,\n    <p>oh</p>\n  ]\n}\n```\n以上各种类型现在均可以直接在render中返回，不需要再在外层包裹一层容器元素，不过在返回的数组类型中，需要在每个元素上加一个唯一且不变的key值，否则控制台会报一个warning。\n\n## 使用createPortal将组件渲染到当前组件树之外\n\n## 支持自定义DOM属性\n在之前的版本中，React会忽略无法识别的HTML和SVG属性，自定义属性只能通过data-*形式添加，现在它会把这些属性直接传递给DOM（这个改动让React可以去掉属性白名单，从而减少了文件大小）。\n\n## setState传入null时不会再触发更新\n\n## 更好的服务器端渲染\nReact 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。\n\n## 新的打包策略\n新的打包策略中去掉了process.env检查。\nReact 16的体积比上个版本减小了32%（30% post-gzip），文件尺寸的减小一部分要归功于打包方法的改变。\n\n## React 16采用了新的核心架构React Fiber。官方解释是“React Fiber是对核心算法的一次重新实现”","tags":["react"],"categories":["JS"]},{"title":"React 16新特性context api","url":"%2Fcontextapi.html","content":"\nReact 16.3带来了正式版的context API。让我们来看看有哪些改变，在那些地方可以取代redux吧！\n\n--- \n<!-- more -->\n\n我当前依赖的版本\n```javascript\n\"dependencies\": {\n    \"react\": \"^16.4.0\",\n    \"react-dom\": \"^16.4.0\"\n}\n```\n## 创建context实例\n```javascript\n// 创建context实例\nconst ThemeContext = React.createContext({\n  background: 'red',\n  color: 'white'\n});\n\nconst {Provider,Consumer} = ThemeContext\n```\n\n## Provider 组件 \n**Provider组件用于将context数据传给该组件树下的所有组件 value属性是context的内容。**\n```javascript\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider value={{ text: 'hello react!' }}>\n        <Comp1 />\n        <Comp2 />\n      </Provider>\n    );\n  }\n}\n```\n## Consumer 组件\n**Consumer消费Provider传递的数据**\n```javascript\n// 函数式\nconst Comp1 = () => (\n  <Consumer>\n    {context => <p>{context.text}</p>}\n  </Consumer>\n);\n// 类\nclass Comp2 extends React.Component {\n  render() {\n    return (\n      <Consumer>\n        {context => <p>{context.text}</p>}\n      </Consumer>\n    );\n  }\n}\n```\n如果你没有将Consumer作为Provider的子组件，那么Consumer将使用创建context时的参数作为context。","tags":["context api"],"categories":["JS"]},{"title":"如何理解JS闭包","url":"%2Fclosure.html","content":"\n{% centerquote %} \nJavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。\n{% endcenterquote %} \n\n在JS中函数作为普通对象进行传递\n\n--- \n<!-- more -->\n## 什么是闭包?\n简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。(函数和声明该函数的词法环境的组合)\n\n## 为什么需要闭包？\n使用闭包主要是为了设计私有的变量和方法。闭包的优点可以避免全局变量的污染，缺点是会常驻内存，增大内存的使用\n量，使用不当会造成内存泄漏。\n\n## 特点\n1. 定义外层函数，封装被保护的局部变量。 \n2. 定义内层函数，执行对外部函数变量的操作。 \n3. 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。\n\n## 特性\n1. 函数嵌套函数，内存函数被返回。\n2. 函数内部可以引用外部的参数和变量。\n3. 参数和变量不会被垃圾回收机制回收。\n\n## 实例\n```javascript\nvar add = (function () {\n    var counter = 0;\n    return function () {return counter += 1;}\n})();\nadd();\nadd();\nadd();\n// add()调用过后应当销毁其变量，但其内层函数被返回了，并且还保留着对变量的引用，所以没有销毁还保留在内存当中。\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(arr[i])\n},i*1000)\n}\n// 打印3次3 执行setTimeout时for循环已经结束此时的i的值为3\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\n// 匿名闭包\n(function(index){\n  setTimeout(function(){\n  console.log(arr[index])\n},index*1000)\n})(i)\n}\n```\n\n避免使用过多的闭包，可以用let关键词，每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。\n```javascript\nvar arr=['one','two','three']\nfor(let i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(arr[i])\n},i*1000)\n}\n```\n","tags":["闭包"],"categories":["JS"]},{"title":"使用 Async/Await 让你的代码更简洁","url":"%2Fes7async.html","content":"\nAsync/Await是一种允许我们像构建没有回调函数的普通函数一样构建Promise的新语法。以往的异步方法无外乎回调函数和`Promise`。但是Async/Await建立于[Promise](https://mydearest.cn/createPromise.html)之上。\n\n---\n<!-- more -->\n\n## Async/Await语法\n### async关键字(放置在一个函数前面)。\n\n```javascript\nasync function f() {\n    return 1\n    // return Promise.resolve(1)\n}\nf().then(value) // 1\n```\n\nasync修饰过的函数总是返回一个promise，如果代码中有return <非promise>语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。\n### await关键字(只能在async函数内部使用)\n关键词await可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行。\n\n```javascript\nfunction timeout(ms) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n### 错误处理(使用try-catch捕获)\n```javascript\nasync function f() {\n    try {\n        let response = await fetch('http://no-such-url')\n    } catch (err) {\n        alet(err) // TypeError: failed to fetch 也能捕获多行语句 类似链式Promise最后的单个catch函数\n    }\n}\nf()\n```\n\n如果我们不使用try-catch，然后async函数f()的调用产生的promise变成reject状态的话，我们可以添加.catch去处理它：\n```javascript\nasync function f() {\n    let response = await fetch('http://no-such-url')\n}\n// f()变成了一个rejected的promise\nf().catch(alert) // TypeError: failed to fetch\n```\n\n### 结合Promise.all\nasync/await能够与Promise.all友好的协作，当我们需要等待多个promise时，我们可以将他们包装在Promise.all中然后使用await：\n\n```javascript\n\n// 直到数组全部返回结果\nlet results = await Promise.all([\n   fetch(url1),\n   fetch(url2),\n   ...\n])\n```\n## 总结\n\n随着单页JavaScript web程序的兴起和对NodeJS的广泛采用，如何优雅的处理并发对于JavaScript开发人员来说比任何以往的时候都显得更为重要。Async/Await缓解了许多因为控制流问题而导致bug遍地的这个困扰着JavaScript代码库数十年的问题，并且几乎可以保证让任何异步代码块变的更精炼，更简单，更自信。","tags":["Async/Await"],"categories":["JS"]},{"title":"从 for 循环入手优化性能","url":"%2Fforloop.html","content":"\n今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？\n\n---\n<!-- more -->\n\n从最简单的遍历数组说起。\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet i = 0;\nlet arr = [];\nwhile (i < 50) {\n    arr.push(i);\n    i++;\n}\n```\n\n如果我们想从数组 arr 中取出数据，就必须要进行遍历，普遍的做法是：\n```javascript\nfor (let i = 0; i < arr.length; i++) {\n    // arr[i]\n}\n```\n\n但其实这样的写法遍历是最慢的，他要经过两次迭代，第一次是 i 的迭代，每次都要判断 i 是否小于 arr.length，第二次是 arr 的迭代，每次循环 arr 都会调用底层的迭代器，对长度进行计算，这样循环的效率非常低，时间空间复杂度为 O[n^2]。\n\n下面进行优化，看看两者到底有什么区别：\n```javascript\nfor (let i = 0, len = arr.length; i < len; i++) {\n    // arr[i]\n}\n```\n\n区别就是，整个循环当中，我们预存了 len 来保存数组的长度，这样不需要每次循环都调用底层迭代器，调用一次即可，这样的时间空间复杂度为 O[n+1]。\n\n但是这并不是最完美的，因为会多了一次迭代操作，那么该如何进行优化呢？\n```javascript\nfor (let i = 0, item; item = arr[i++];) {\n    // item\n}\n```\n这次迭代的时间空间复杂度为 O[n] ，完美做到了每次一迭代没有通过长度进行判断，而是直接通过下标进行取值的方式映射到了循环体内部。\n\n最后用5万条数据进行测试各种方式的循环时间：\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet index = 0;\nlet arr = [];\nwhile (index < 50000) {\n    arr.push(index);\n    index++;\n}\n\nconsole.time('one');\nfor (let i = 0; i < arr.length; i++) {\n\n}\nconsole.timeEnd('one');\n\nconsole.time('two');\nfor (let i = 0, len = arr.length; i < len; i++) {\n\n}\nconsole.timeEnd('two');\n\nconsole.time('three');\nfor (let i = 0, item; item = arr[i++];) {\n\n}\nconsole.timeEnd('three');\n\n// es6的数组遍历\nconsole.time('four');\nfor (let i of arr) {\n\n}\nconsole.timeEnd('four');\n// 会访问可枚举属性和原型的遍历，数组不推荐使用\nconsole.time('five');\nfor (let i in arr) {\n\n}\nconsole.timeEnd('five');\n// one: 0.711ms\n// two: 4.508ms\n// three: 0.006ms\n// four: 3.255ms\n// five: 11.144ms\n```\n在数据量大的情况下，第三种循环方式效果显而易见。\n\n","tags":["性能优化"],"categories":["JS"]},{"title":"es6函数新特性","url":"%2Fes6function.html","content":"\n1. 设置函数默认值 \n2. 结合解构赋值默认值使用\n3. 利用rest(...变量名)传入任意参数\n\n---\n<!-- more -->\n\n## ...rest和扩展运算符\nrest参数（…变量名），用于获取函数的多余参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入其中。\n```javascript\nfunction foo(...y){\n    console.log(y)  // [1,2,3,4]\n}\nfoo(1,2,3,4)\n```\n## 利用扩展运算符（…数组）替代数组的apply方法\n在es5中，需要用apply将数组转化为函数参数，在es6中就不需要这种方式了，可以使用…来代替\n```javascript\nfunction f(x, y, z) {\n    console.log(x + ' ' + y + ' ' + z);\n}\nvar args = [1, 2, 3];\n// f.apply(null, args)\nf(...args)\n```\n\n数组push的例子：\n```javascript\nvar arr1 = [0, 1, 2]\nvar arr2 = [3, 4, 5]\nvar arr3 = arr1.concat(arr2)\nconsole.log(arr3) //[ 0, 1, 2, 3, 4, 5 ]\n\nvar arr4 = arr1.push(arr2)\nconsole.log(arr1) //[ 0, 1, 2, [ 3, 4, 5 ] ]\n```\n\n如果想使用arr1.push方法的话，就需要用apply传arr2了\n```javascript\nvar arr4 = Array.prototype.push.apply(arr1, arr2) //[ 0, 1, 2, 3, 4, 5 ]\n```\n\n如果使用扩展运算符的话，就简单一些了\n```javascript\nvar arr4 = arr1.push(...arr2)\n```\n\n## name属性\n函数的name属性可以返回函数名\n```javasctrpt\nfunction abc(){\n    console.log(abc.name)\n}\nabc() // 'abc'\n```","tags":["es6"],"categories":["JS"]},{"title":"JavaScript 中 this 的详解","url":"%2Fjsthis.html","content":"\n## this 的指向\n\n`this` 是 js 中定义的关键字， 它的指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。在实际应用中，`this`的指向大致可以分为以下四种情况。\n\n---\n<!-- more -->\n### 作为普通函数调用(直接调用)：函数名()\n当函数作为一个普通函数被调用，`this`指向全局对象。在浏览器里，全局对象就是 window。\n```javascript\nwindow.name = 'cosyer';\nfunction getName(){\n    console.log(this.name);\n}\ngetName();                   // cosyer\n```\n可以看出，此时`this`指向了全局对象 window。(NodeJS的全部对象是global)\n在ECMAScript5的严格模式下，这种情况`this`已经被规定不会指向全局对象了，而是undefined。\n```javascript\n'use strict';\nfunction fun(){\n    console.log(this);\n}\nfun();                      // undefined\n```\n### 作为对象的方法调用\n当函数作为一个对象里的方法被调用，`this`指向该对象\n```javascript\nvar obj = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\n\nobj.getName();              // cosyer\n```\n如果把对象的方法赋值给一个变量，再调用这个变量：\n```javascript\nvar obj = {\n    fun1 : function(){\n        console.log(this);\n    }\n}\nvar fun2 = obj.fun1;\nfun2();                     // window\n```\n此时调用 fun2 方法 输出了 window 对象，说明此时`this`指向了全局对象。给 fun2 赋值，其实是相当于：\n```javascript\nvar fun2 = function(){\n    console.log(this);\n}\n```\n可以看出，此时的`this`已经跟 obj 没有任何关系了。这时 fun2 是作为普通函数调用。\n\n### 作为构造函数调用\njs中没有类，但是可以从构造器中创建对象，并提供了`new`运算符来进行调用该构造器。构造器的外表跟普通函数一样，大部分的函数都可以当做构造器使用。当构造函数被调用时，`this`指向了该构造函数实例化出来的对象。\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n}\nvar obj = new Person();\nconsole.log(obj.name);      // cosyer\n```\n如果构造函数显式的返回一个对象，那么`this`则会指向该对象。\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n    return {\n        name : 'chenyu'\n    }\n}\nvar obj = new Person();\nconsole.log(obj.name);      // chenyu\n```\n如果该函数不用`new`调用，当作普通函数执行，那么`this`依然指向全局对象。\n\n### call() 或 apply() 调用 Function.prototype.bind()将当前函数绑定到指定对象绑定返回新函数之后再进行调用\n通过调用函数的 call() 或 apply() 方法可动态的改变`this`的指向。\n```javascript\nvar obj1 = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\nvar obj2 = {\n    name : 'chenyu'\n}\n\nobj1.getName();             // cosyer\nobj1.getName.call(obj2);    // chenyu\nobj1.getName.apply(obj2);   // chenyu\n```\n**简单的实现bind方法**\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 自定义的函数，模拟 bind() 对 this 的影响\nfunction myBind(func, target) {\n    return function() {\n        return func.apply(target, arguments); // 第一个参数为函数运行的this指向\n    };\n}\n\nconst testObj = myBind(test, obj);\ntest();     // false\ntestObj();  // true\n```\n从上面的示例可以看到，首先，通过闭包，保持了 target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this。\n\n不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 绑定到一个新对象，而不是 obj\nconst testObj = test.bind({});\ntest.apply(obj);    // true\n\n// 期望 this 是 obj，即输出 true\n// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\ntestObj.apply(obj); // false\n```\n\n## 箭头函数 \n{% note info %}\n箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对`this`的词法解析。\n在箭头函数出现之前，每个新定义的函数都有其自己的`this`值（例如，构造函数的`this`指向了一个新的对象；严格模式下的函数的`this`值为 undefined；如果函数是作为对象的方法被调用的，则其`this`指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。\n{% endnote %}\n\n### ES6 的箭头函数 ()=>，指向与一般function定义的函数不同，比较容易绕晕，箭头函数`this`的定义：箭头函数中的`this`是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的`this`，它的`this`是派生而来的。箭头函数会捕获其所在上下文的`this`值，作为自己的`this`值，即指向所在上下文的执行环境(直接外层函数)。\n\n### 基础语法\n```javascript\n// 等价于: => { return expression; } \n(param1, param2, …, paramN) => { statements }\n(param1, param2, …, paramN) => expression\n\n// 如果只有一个参数，圆括号是可选的:\n(singleParam) => { statements }\nsingleParam => { statements }\n\n// 无参数或者多参数的箭头函数需要使用圆括号或者下划线:\n() => { statements } _ => { statements }\n```\n### 高级语法\n```javascript\n// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:\nparams => ({foo: bar})\n\n// 支持 Rest parameters 和 default parameters:\n(param1, param2, ...rest) => { statements }\n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }\n\n// 支持参数列表中的解构赋值\nvar f = ([a, b] = [1, 2], = ) => a + b + c;\nf(); // 6\n```\n\n### 箭头函数不可以使用arguments对象，\narguments对象在函数体内不存在，如果要用的话，可以用rest参数代替\n\n### 箭头函数没有原型\n```javascript\nvar Foo = () => {};\n\nconsole.log(Foo.prototype); // undefined\n```\n### 箭头函数无法构造函数\n```javascript\nvar Foo = () => {};\n\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n### 箭头函数无法使用yield\nyield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。\n\n### 箭头函数或者组件上绑定事件的时候this.xxx.bind(this)，这样会生成新函数，推荐constructor里bind() garbage collection(垃圾回收机制)\n","tags":["this指向"],"categories":["JS"]},{"title":"react面试题记录","url":"%2FreactInterview.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/reactInterview.jpeg , reactInterview, React%}\n---\n<!-- more -->\n\n## React面试问题\n下面是一个常用的关于 React 的面试问题列表：\n\n* [React 的工作原理](#react-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)?\n* [使用 React 有何优点](#%E4%BD%BF%E7%94%A8-react-%E6%9C%89%E4%BD%95%E4%BC%98%E7%82%B9)？\n* [展示组件(Presentational component)和容器组件(Container component)之间有何不同](#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6presentational-component%E5%92%8C%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6container-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [类组件(Class component)和函数式组件(Functional component)之间有何不同](#%E7%B1%BB%E7%BB%84%E4%BB%B6class-component%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6functional-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [(组件的)状态(state)和属性(props)之间有何不同](#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81state%E5%92%8C%E5%B1%9E%E6%80%A7props%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [指出(组件)生命周期方法的不同](#%E6%8C%87%E5%87%BA%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C)？\n* [应该在 React 组件的何处发起 Ajax 请求](#%E5%BA%94%E8%AF%A5%E5%9C%A8-react-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%95%E5%A4%84%E5%8F%91%E8%B5%B7-ajax-%E8%AF%B7%E6%B1%82)？\n* [何为受控组件(controlled component)](#%E4%BD%95%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6controlled-component)？\n* [在 React 中，refs 的作用是什么](#%E5%9C%A8-react-%E4%B8%ADrefs-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为高阶组件(higher order component)](#%E4%BD%95%E4%B8%BA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6higher-order-component)？\n* [使用箭头函数(arrow functions)的优点是什么](#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0arrow-functions%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [为什么建议传递给 setState 的参数是一个 callback 而不是一个对象](#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BC%A0%E9%80%92%E7%BB%99-setstate-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA-callback-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1)？\n* [除了在构造函数中绑定 `this`，还有其它方式吗](#%E9%99%A4%E4%BA%86%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%91%E5%AE%9A-this%E8%BF%98%E6%9C%89%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E5%90%97)？\n* [怎么阻止组件的渲染](#%E6%80%8E%E4%B9%88%E9%98%BB%E6%AD%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93)？\n* [当渲染一个列表时，何为 key？设置 key 的目的是什么](#%E5%BD%93%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E6%97%B6%E4%BD%95%E4%B8%BA-key%E8%AE%BE%E7%BD%AE-key-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [(在构造函数中)调用 super(props) 的目的是什么](#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-superprops-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为 JSX](#%E4%BD%95%E4%B8%BA-jsx)？\n* [怎么用 React.createElement 重写下面的代码](#%E6%80%8E%E4%B9%88%E7%94%A8%20React.createElement%20%E9%87%8D%E5%86%99%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81)？\n* [何为 `Children`](#%E4%BD%95%E4%B8%BA-children)？\n* [在 React 中，何为 state](#%E5%9C%A8-react-%E4%B8%AD%E4%BD%95%E4%B8%BA-state)？\n* [你为何排斥 create-react-app](#%E4%BD%A0%E4%B8%BA%E4%BD%95%E6%8E%92%E6%96%A5-create-react-app)？\n* [何为 redux](#%E4%BD%95%E4%B8%BA-redux)？\n* [在 Redux 中，何为 store](#%E5%9C%A8-redux-%E4%B8%AD%E4%BD%95%E4%B8%BA-store)？\n* [何为 action](#%E4%BD%95%E4%B8%BA-action)？\n* [何为 reducer](#%E4%BD%95%E4%B8%BA-reducer)？\n* [Redux Thunk 的作用是什么](#redux-thunk-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为纯函数(pure function)](#%E4%BD%95%E4%B8%BA%E7%BA%AF%E5%87%BD%E6%95%B0pure-function)？\n* [你喜欢 React 的哪些方面](#%E4%BD%A0%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2)？\n* [你不喜欢 React 的哪些方面](#%E4%BD%A0%E4%B8%8D%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2)？\n* [示例项目](#%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE)\n\n#### React 的工作原理\nReact 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diff\" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。\n\n#### 使用 React 有何优点\n* 只需查看 `render` 函数就会很容易知道一个组件是如何被渲染的\n* JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的\n* 支持服务端渲染，这可以改进 SEO 和性能\n* 易于测试\n* React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用\n\n#### 展示组件(Presentational component)和容器组件(Container component)之间有何不同\n展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\n\n容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 `Flux actions`，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。\n\n#### 类组件(Class component)和函数式组件(Functional component)之间有何不同\n* 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 `store` 并维持状态\n* 当组件仅是接收 `props`，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n\n#### (组件的)状态(state)和属性(props)之间有何不同\n`State` 是一种数据结构，用于组件挂载时所需数据的默认值。`State` 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\n\n`Props`(properties 的简写)则是组件的配置。`props` 由父组件传递给子组件，并且就子组件而言，`props` 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\n\n#### 指出(组件)生命周期方法的不同\n* `componentWillMount` -- 多用于根组件中的应用程序配置\n* `componentDidMount` -- 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成\n* `componentWillReceiveProps` -- 这个周期函数作用于特定的 prop 改变导致的 state 转换\n* `shouldComponentUpdate` -- 如果你担心组件过度渲染，`shouldComponentUpdate` 是一个改善性能的地方，因为如果组件接收了新的 `prop`， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染\n* `componentWillUpdate` -- 很少使用。它可以用于代替组件的 `componentWillReceiveProps` 和 `shouldComponentUpdate`(但不能访问之前的 props)\n* `componentDidUpdate` -- 常用于更新 DOM，响应 prop 或 state 的改变\n* `componentWillUnmount` -- 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器\n\n#### 应该在 React 组件的何处发起 Ajax 请求\n在 React 组件中，应该在 `componentDidMount` 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 `componentDidMount` 中发起网络请求将保证这有一个组件可以更新了。\n\n#### 何为受控组件(controlled component)\n在 HTML 中，类似 `<input>`, `<textarea>` 和 `<select>` 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 `onChange` 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。\n\n#### 在 React 中，refs 的作用是什么\nRefs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。\n\n#### 何为高阶组件(higher order component)\n高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 `connect` 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\n装饰器@decoration\n练习\n\n<hr />\n\n* 写一个反转其输入的 HOC\n* 写一个从 API 提供数据给传入的组件的 HOC\n* 写一个实现 shouldComponentUpdate 来避免 reconciliation 的 HOC\n* 写一个通过 `React.Children.toArray` 对传入组件的子组件进行排序的 HOC\n\n#### 使用箭头函数(arrow functions)的优点是什么\n* 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 `this` 值(在构造函数中是新对象；在严格模式下，函数调用中的 `this` 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 `this` 值。\n* 简单：箭头函数易于阅读和书写\n* 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 `this` 的值\n\n#### 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象\n因为 `this.props` 和 `this.state` 的更新可能是异步的，不能依赖它们的值去计算下一个 state。\n\n#### 除了在构造函数中绑定 `this`，还有其它方式吗\n你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\n\n#### 怎么阻止组件的渲染\n在组件的 `render` 方法中返回 `null` 并不会影响触发组件的生命周期方法\n\n#### 当渲染一个列表时，何为 key？设置 key 的目的是什么\nKeys 会有助于 React 识别哪些 `items` 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 `items` 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 `items` 可以重新排序，就会导致 `re-render` 变慢。\n\n#### (在构造函数中)调用 super(props) 的目的是什么\n在 `super()` 被调用之前，子类是不能使用 `this` 的，在 ES2015 中，子类必须在 `constructor` 中调用 `super()`。传递 `props` 给 `super()` 的原因则是便于(在子类中)能在 `constructor` 访问 `this.props`。\n\n#### 何为 JSX\nJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就编程了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。\n\n#### 怎么用 React.createElement 重写下面的代码\n\nQuestion：\n\n```js\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n\nAnswer：\n\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n#### 何为 `Children`\n在JSX表达式中，一个开始标签(比如`<a>`)和一个关闭标签(比如`</a>`)之间的内容会作为一个特殊的属性`props.children`被自动传递给包含着它的组件。\n\n这个属性有许多可用的方法，包括 `React.Children.map`，`React.Children.forEach`， `React.Children.count`， `React.Children.only`，`React.Children.toArray`。\n\n#### 在 React 中，何为 state\nState 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。\n\n#### 你为何排斥 create-react-app\n在你排斥之前，你并不能去配置 webpack 或 babel presets。\n\n#### 何为 redux\nRedux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。\n\n#### 在 Redux 中，何为 store\nStore 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：\n\n* 允许通过 `getState()` 访问 state\n* 运行通过 `dispatch(action)` 改变 state\n* 通过 `subscribe(listener)` 注册 listeners\n* 通过 `subscribe(listener)` 返回的函数处理 listeners 的注销\n\n#### 何为 action\nActions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。\n\n#### 何为 reducer\n一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。\n\n#### Redux Thunk 的作用是什么\nRedux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。\n\n#### 何为纯函数(pure function)\n一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。\n\n#### 你喜欢 React 的哪些方面\n...\n\n#### 你不喜欢 React 的哪些方面\n...\n\n#### 示例项目\n* [React Spotify](https://github.com/Pau1fitz/react-spotify)\n* [React Soundcloud](https://github.com/andrewngu/sound-redux)\n\n#### 虚拟dom 普通的js对象\n插入新组件有了key可以帮助react找到映射\n\n#### 事件委托\n每个setState重新渲染整个子树。 如果要压缩性能，请尽可能调用 setState，并使用shouldComponentUpdate 来防止重新渲染大型子树。","tags":["面试"],"categories":["JS"]},{"title":"搭建VPS科学上网","url":"%2FscienceInternet.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/shadowsocks.jpg, Shadowsocks, Shadowsocks %}\n---\n<!-- more -->\n\n{% note info %}\n\n快速搭建Shadowsocks\n\n{% endnote %}\n\n## [购买Vultr服务器](https://www.vultr.com/)\n\n### Vultr服务器价格\n\nVultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题。\n\n最低价格的服务器是512M的内存，每个月500G的流量，只能说99%的情况下完全够用了！\n\n![introduce](http://p33v4b0bc.bkt.clouddn.com/vultr.png)\n\n## 买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令\n\n```javascript\n\nwget --no-check-certificate -O shadowsocks.sh\nhttps://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n \nchmod +x shadowsocks.sh\n \n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n\n```\n\n接着按照提示输入密码，端口和加密方式，如下图：\n\n![ss1](http://p33v4b0bc.bkt.clouddn.com/ss1.png)\n\n![ss2](http://p33v4b0bc.bkt.clouddn.com/ss1.png)\n\n然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息。\n\n## 安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。\n\nWindows客户端(代理端口默认1080)\nhttps://github.com/shadowsocks/shadowsocks-windows/releases\n\nUbuntu \nsudo add-apt-repository ppa:hzwhuang/ss-qt5 \nsudo apt-get update \nsudo apt-get install shadowsocks-qt5\n\nMac客户端(代理端口默认1086)\n\nhttps://github.com/shadowsocks/ShadowsocksX-NG/releases\n\nAndroid客户端\n\nhttps://github.com/shadowsocks/shadowsocks-android/releases","tags":["vultr"],"categories":["工具"]},{"title":"Promise诞生记","url":"%2FcreatePromise.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/promise.png, Promise, Promise %}\n\n前端近年的兴起，有大部分是因为 `NodeJS` 的诞生，而 `NodeJS` 是个适用于 **异步IO** 密集型的语言，一些基于 `NodeJS` 的框架，比喻 *KOA2、Adonis* 就有大量的 `async` 和 `await` 语法，`async`的函数的返回值就是 `Promise` 对象，我们可以用 `async` 和 `await` 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。\n\n## Promise 概念\n`Promise`是一种对异步操作的封装，主流的规范是Promise/A+。\n`Promise`可以使得异步代码层次清晰，便于理解，且更加容易维护。\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n生成实例时回执信作为参数的函数；<Br/> \n`resolve`函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n`reject`函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n---\n<!-- more -->\n\n```javascript\n// 执行顺序\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise'); // 新建后立即执行\n  resolve();\n});\npromise.then(function() {\n  console.log('resolved.'); // 同步任务执行完成后才会执行\n});\nconsole.log('Hi!');\n// Promise\n// Hi!\n// resolved\n```\n接下来我们就用`Promise`结合ajax来使用\n```\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send(params);\n  });\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n这里我们会渐进式的来创建一个 `Promise` 的实现，如果，你还不了解 `Promise` ，赶快移步 [Promise](http://es6.ruanyifeng.com/#docs/promise) 了解学习，当然这个实现会符合 [Promise/A+](https://promisesaplus.com) 规范，`JavaScript` 中有很多第三方的 `Promise` 库，[bluebird](http://bluebirdjs.com/docs/getting-started.html) 就是一个第三方 `Promise` 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。\n\n---\n\n废话不多说，直接开干。。。 😠\n\n## 定义 Promise 类型\n\n一个简单 `Promise` 语法，如下\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... doSomething\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure 第二个函数可选\n});\n```\n\n### 实现 resolve 和 then\n\n首先我们以上 👆 的语法，自己定义一个 `Promise` 实例\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    callback(value);\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n一个简单的实例写好了，然后，来用一下，看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n\n```\n{% note info %}\n\n执行结果是：`callback is not a function`\n\n{% endnote %}\n\n### 改进1：延时resolve，修改 callback 为异步\n\n**这里就遇到一个问题： **  \n\n** 目前的Promise有一个bug，假如fn中所包含的是同步代码，则resolve会立即执行，`callback` 还是 `null` ，我们的代码是同步的，而不是异步的。</br> 如是，想办法解决掉这个问题，就是利用 `setTimeout` , 把 `callback` 加入异步队列** \n\n代码如下 👇\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    // 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法\n    setTimeout(function(){\n      callback(value);\n    },0)\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n\n### 改进2：注册多个回调函数，并实现then的链式调用\n\n```javascript\nfunction Promise(fn) {\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    callbackList.push(cb);\n    // 实现链式调用\n    return this\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       // 遍历callbackList数组依次执行\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n### 改进3：引入状态\n\n```javascript\nfunction Promise(fn) {\n  let state='pending'\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    if(state=='pending'){\n      // pending加入队列\n      callbackList.push(cb);\n      return this\n    }\n    if(state=='fulfilled'){\n      // fulfilled立即执行\n      cb(value)\n      return this\n    }\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n\n**手动实现一个Promise：**\n```javascript\nclass Promise(){\n  construtor(fn){\n       // 执行队列\n       this._wathcList=[]\n       // 成功\n       this._success_res=null\n       // 失败\n       this._error_res=null\n       this._status=\"success\"\n       fn((...args))=>{\n          // 保存成功数据\n          this._success_res=args\n          this._status='success'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn1(...args);\n          });\n       },(...args)=>{\n          // 保存失败数据\n          this._error_res=args\n          this._status='error'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn2(...args);\n          });\n       }\n  }\n  // then 函数\n  then(fn1, fn2) {\n      if (this._status === \"success\") {\n          fn1(...this._success_res);\n      } else if (this._status === \"error\") {\n          fn2(...this._error_res);\n      } else {\n          this._watchList.push({\n              fn1,\n              fn2\n          })\n      }\n  }\n}\n```\n**实现Promise.all**\n```javascript\nPromise1.all = function(arr) {\n    // 存放结果集\n    let result = [];\n    return Promise1(function(resolve, reject) {\n        let i = 0;\n        // 进行迭代执行\n        function next() {\n            arr[i].then(function(res) {\n                // 存放每个方法的返回值\n                result.push(res);\n                i++;\n                // 若全部执行完\n                if (i === result.length) {\n                    // 执行then回调\n                    resolve(result);\n                } else {\n                    // 继续迭代\n                    next();\n                }\n            }, reject)\n        }\n    })\n}\n```\n\n## Promise使用注意点\n1. 一般来说，调用`resolve`或`reject`以后，`Promise`的使命就完成了，后继操作应该放到`then`方法里面，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。\n\n2. `Promise`实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为`Promise`实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即then方法后面再调用另一个`then`方法。\n\n3. `Promise.prototype.catch`方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。`getJSON`方法返回一个`Promise`对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n4. 一般来说，不要在then方法里面定义`reject`状态的回调函数（即then的第二个参数），总是使用`catch`方法。\n\n5. 跟传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应，`Promise`会吃掉错误。\n","tags":["Promise"],"categories":["JS"]},{"title":"如何使用 markdown 语法写博客","url":"%2FmarkdownGrammar.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/markdown.png, Markdown, Markdown %}\n\n# 标题1\n## 标题2\n*斜体*\n**粗体**\n***粗斜体***<br/>\n~~删除线~~\n<u>下划线文本</u>\n\n1. I\n2. Love \n3. You\n\n- 点\n\n+ Foo\n+ Bar\n---\n<!-- more -->\n\n分隔线\n***\n--- \n___\n\n* * *\n>一级引用\n>>二级引用\n\n`#include<iostream>`\n```\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n```\n~~~\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n~~~\n|标题|标题|标题|\n|:---|:---:|---:|\n|居左测试文本|居中测试文本|居右测试文本|\n|居左测试文本1|居中测试文本2|居右测试文本3|\n|居左测试文本11|居中测试文本22|居右测试文本33|\n|居左测试文本111|居中测试文本222|居右测试文本333|\n\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n### 反斜杠\n\n`Markdown` 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n```\n\\*literal asterisks\\*\n```\n效果如下：\n\n\\*literal asterisks\\*\n\n`Markdown` 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```\n  \\   反斜线\n  `   反引号\n  *   星号\n  _   底线\n  {}  花括号\n  []  方括号\n  ()  括弧\n  #   井字号\n  +   加号\n  -   减号\n  .   英文句点\n  !   惊叹号\n```\n登录[百度](http://www.baidu.com)\n![Teddy Bear](http://img2.everychina.com/img/d7/f7/1b580dfa9315111397ef93fd24ea-250x250c1-77f7/love_valentine_plush_teddy_bear.jpg)\n","tags":["markdown"],"categories":["工具"]},{"title":"Hello World - 热爱编程的普通人，顺便以此为生。","url":"%2Fhello-world.html","content":"\n之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n---\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["杂谈"],"categories":["杂谈"]}]