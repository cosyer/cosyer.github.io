[{"title":"react面试题记录","url":"%2FreactInterview.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/reactInterview.jpeg , reactInterview, React%}\n\n<!-- more -->\n\n## React面试问题\n下面是一个常用的关于 React 的面试问题列表：\n\n* [React 的工作原理](#react-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)?\n* [使用 React 有何优点](#%E4%BD%BF%E7%94%A8-react-%E6%9C%89%E4%BD%95%E4%BC%98%E7%82%B9)？\n* [展示组件(Presentational component)和容器组件(Container component)之间有何不同](#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6presentational-component%E5%92%8C%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6container-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [类组件(Class component)和函数式组件(Functional component)之间有何不同](#%E7%B1%BB%E7%BB%84%E4%BB%B6class-component%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6functional-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [(组件的)状态(state)和属性(props)之间有何不同](#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81state%E5%92%8C%E5%B1%9E%E6%80%A7props%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [指出(组件)生命周期方法的不同](#%E6%8C%87%E5%87%BA%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C)？\n* [应该在 React 组件的何处发起 Ajax 请求](#%E5%BA%94%E8%AF%A5%E5%9C%A8-react-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%95%E5%A4%84%E5%8F%91%E8%B5%B7-ajax-%E8%AF%B7%E6%B1%82)？\n* [何为受控组件(controlled component)](#%E4%BD%95%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6controlled-component)？\n* [在 React 中，refs 的作用是什么](#%E5%9C%A8-react-%E4%B8%ADrefs-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为高阶组件(higher order component)](#%E4%BD%95%E4%B8%BA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6higher-order-component)？\n* [使用箭头函数(arrow functions)的优点是什么](#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0arrow-functions%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [为什么建议传递给 setState 的参数是一个 callback 而不是一个对象](#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BC%A0%E9%80%92%E7%BB%99-setstate-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA-callback-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1)？\n* [除了在构造函数中绑定 `this`，还有其它方式吗](#%E9%99%A4%E4%BA%86%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%91%E5%AE%9A-this%E8%BF%98%E6%9C%89%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E5%90%97)？\n* [怎么阻止组件的渲染](#%E6%80%8E%E4%B9%88%E9%98%BB%E6%AD%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93)？\n* [当渲染一个列表时，何为 key？设置 key 的目的是什么](#%E5%BD%93%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E6%97%B6%E4%BD%95%E4%B8%BA-key%E8%AE%BE%E7%BD%AE-key-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [(在构造函数中)调用 super(props) 的目的是什么](#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-superprops-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为 JSX](#%E4%BD%95%E4%B8%BA-jsx)？\n* [怎么用 React.createElement 重写下面的代码](#%E6%80%8E%E4%B9%88%E7%94%A8%20React.createElement%20%E9%87%8D%E5%86%99%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81)？\n* [何为 `Children`](#%E4%BD%95%E4%B8%BA-children)？\n* [在 React 中，何为 state](#%E5%9C%A8-react-%E4%B8%AD%E4%BD%95%E4%B8%BA-state)？\n* [你为何排斥 create-react-app](#%E4%BD%A0%E4%B8%BA%E4%BD%95%E6%8E%92%E6%96%A5-create-react-app)？\n* [何为 redux](#%E4%BD%95%E4%B8%BA-redux)？\n* [在 Redux 中，何为 store](#%E5%9C%A8-redux-%E4%B8%AD%E4%BD%95%E4%B8%BA-store)？\n* [何为 action](#%E4%BD%95%E4%B8%BA-action)？\n* [何为 reducer](#%E4%BD%95%E4%B8%BA-reducer)？\n* [Redux Thunk 的作用是什么](#redux-thunk-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为纯函数(pure function)](#%E4%BD%95%E4%B8%BA%E7%BA%AF%E5%87%BD%E6%95%B0pure-function)？\n* [你喜欢 React 的哪些方面](#%E4%BD%A0%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2)？\n* [你不喜欢 React 的哪些方面](#%E4%BD%A0%E4%B8%8D%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2)？\n* [示例项目](#%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE)\n\n#### React 的工作原理\nReact 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diff\" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。\n\n#### 使用 React 有何优点\n* 只需查看 `render` 函数就会很容易知道一个组件是如何被渲染的\n* JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的\n* 支持服务端渲染，这可以改进 SEO 和性能\n* 易于测试\n* React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用\n\n#### 展示组件(Presentational component)和容器组件(Container component)之间有何不同\n展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\n\n容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 `Flux actions`，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。\n\n#### 类组件(Class component)和函数式组件(Functional component)之间有何不同\n* 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 `store` 并维持状态\n* 当组件仅是接收 `props`，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n\n#### (组件的)状态(state)和属性(props)之间有何不同\n`State` 是一种数据结构，用于组件挂载时所需数据的默认值。`State` 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\n\n`Props`(properties 的简写)则是组件的配置。`props` 由父组件传递给子组件，并且就子组件而言，`props` 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\n\n#### 指出(组件)生命周期方法的不同\n* `componentWillMount` -- 多用于根组件中的应用程序配置\n* `componentDidMount` -- 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成\n* `componentWillReceiveProps` -- 这个周期函数作用于特定的 prop 改变导致的 state 转换\n* `shouldComponentUpdate` -- 如果你担心组件过度渲染，`shouldComponentUpdate` 是一个改善性能的地方，因为如果组件接收了新的 `prop`， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染\n* `componentWillUpdate` -- 很少使用。它可以用于代替组件的 `componentWillReceiveProps` 和 `shouldComponentUpdate`(但不能访问之前的 props)\n* `componentDidUpdate` -- 常用于更新 DOM，响应 prop 或 state 的改变\n* `componentWillUnmount` -- 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器\n\n#### 应该在 React 组件的何处发起 Ajax 请求\n在 React 组件中，应该在 `componentDidMount` 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 `componentDidMount` 中发起网络请求将保证这有一个组件可以更新了。\n\n#### 何为受控组件(controlled component)\n在 HTML 中，类似 `<input>`, `<textarea>` 和 `<select>` 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 `onChange` 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。\n\n#### 在 React 中，refs 的作用是什么\nRefs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。\n\n#### 何为高阶组件(higher order component)\n高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 `connect` 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\n装饰器@decoration\n练习\n\n<hr />\n\n* 写一个反转其输入的 HOC\n* 写一个从 API 提供数据给传入的组件的 HOC\n* 写一个实现 shouldComponentUpdate 来避免 reconciliation 的 HOC\n* 写一个通过 `React.Children.toArray` 对传入组件的子组件进行排序的 HOC\n\n#### 使用箭头函数(arrow functions)的优点是什么\n* 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 `this` 值(在构造函数中是新对象；在严格模式下，函数调用中的 `this` 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 `this` 值。\n* 简单：箭头函数易于阅读和书写\n* 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 `this` 的值\n\n#### 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象\n因为 `this.props` 和 `this.state` 的更新可能是异步的，不能依赖它们的值去计算下一个 state。\n\n#### 除了在构造函数中绑定 `this`，还有其它方式吗\n你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\n\n#### 怎么阻止组件的渲染\n在组件的 `render` 方法中返回 `null` 并不会影响触发组件的生命周期方法\n\n#### 当渲染一个列表时，何为 key？设置 key 的目的是什么\nKeys 会有助于 React 识别哪些 `items` 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 `items` 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 `items` 可以重新排序，就会导致 `re-render` 变慢。\n\n#### (在构造函数中)调用 super(props) 的目的是什么\n在 `super()` 被调用之前，子类是不能使用 `this` 的，在 ES2015 中，子类必须在 `constructor` 中调用 `super()`。传递 `props` 给 `super()` 的原因则是便于(在子类中)能在 `constructor` 访问 `this.props`。\n\n#### 何为 JSX\nJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就编程了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。\n\n#### 怎么用 React.createElement 重写下面的代码\n\nQuestion：\n\n```js\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n\nAnswer：\n\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n#### 何为 `Children`\n在JSX表达式中，一个开始标签(比如`<a>`)和一个关闭标签(比如`</a>`)之间的内容会作为一个特殊的属性`props.children`被自动传递给包含着它的组件。\n\n这个属性有许多可用的方法，包括 `React.Children.map`，`React.Children.forEach`， `React.Children.count`， `React.Children.only`，`React.Children.toArray`。\n\n#### 在 React 中，何为 state\nState 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。\n\n#### 你为何排斥 create-react-app\n在你排斥之前，你并不能去配置 webpack 或 babel presets。\n\n#### 何为 redux\nRedux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。\n\n#### 在 Redux 中，何为 store\nStore 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：\n\n* 允许通过 `getState()` 访问 state\n* 运行通过 `dispatch(action)` 改变 state\n* 通过 `subscribe(listener)` 注册 listeners\n* 通过 `subscribe(listener)` 返回的函数处理 listeners 的注销\n\n#### 何为 action\nActions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。\n\n#### 何为 reducer\n一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。\n\n#### Redux Thunk 的作用是什么\nRedux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。\n\n#### 何为纯函数(pure function)\n一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。\n\n#### 你喜欢 React 的哪些方面\n...\n\n#### 你不喜欢 React 的哪些方面\n...\n\n#### 示例项目\n* [React Spotify](https://github.com/Pau1fitz/react-spotify)\n* [React Soundcloud](https://github.com/andrewngu/sound-redux)\n\n#### 虚拟dom 普通的js对象\n插入新组件有了key可以帮助react找到映射\n\n#### 事件委托\n每个setState重新渲染整个子树。 如果要压缩性能，请尽可能调用 setState，并使用shouldComponentUpdate 来防止重新渲染大型子树。","tags":["面试"],"categories":["JS"]},{"title":"搭建VPS科学上网","url":"%2FscienceInternet.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/shadowsocks.jpg, Shadowsocks, Shadowsocks %}\n\n<!-- more -->\n\n{% note info %}\n\n快速搭建Shadowsocks\n\n{% endnote %}\n\n## [购买Vultr服务器](https://www.vultr.com/)\n\n### Vultr服务器价格\n\nVultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题。\n\n最低价格的服务器是512M的内存，每个月500G的流量，只能说99%的情况下完全够用了！\n\n![introduce](http://p33v4b0bc.bkt.clouddn.com/vultr.png)\n\n## 买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令\n\n```javascript\n\nwget --no-check-certificate -O shadowsocks.sh\nhttps://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n \nchmod +x shadowsocks.sh\n \n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n\n```\n\n接着按照提示输入密码，端口和加密方式，如下图：\n\n![ss1](http://p33v4b0bc.bkt.clouddn.com/ss1.png)\n\n![ss2](http://p33v4b0bc.bkt.clouddn.com/ss1.png)\n\n然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息。\n\n## 安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。\n\nWindows客户端(代理端口默认1080)\nhttps://github.com/shadowsocks/shadowsocks-windows/releases\n\nUbuntu \nsudo add-apt-repository ppa:hzwhuang/ss-qt5 \nsudo apt-get update \nsudo apt-get install shadowsocks-qt5\n\nMac客户端(代理端口默认1086)\n\nhttps://github.com/shadowsocks/ShadowsocksX-NG/releases\n\nAndroid客户端\n\nhttps://github.com/shadowsocks/shadowsocks-android/releases","tags":["vultr"],"categories":["工具"]},{"title":"Promise诞生记","url":"%2FcreatePromise.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/promise.png, Promise, Promise %}\n\n前端近年的兴起，有大部分是因为 `NodeJS` 的诞生，而 `NodeJS` 是个适用于 **异步IO** 密集型的语言，一些基于 `NodeJS` 的框架，比喻 *KOA2、Adonis* 就有大量的 `async` 和 `await` 语法，`async`的函数的返回值就是 `Promise` 对象，我们可以用 `async` 和 `await` 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。\n\n## Promise 概念\n\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n生成实例时回执信作为参数的函数；<Br/> \n`resolve`函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n`reject`函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n---\n<!-- more -->\n\n```javascript\n// 执行顺序\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise'); // 新建后立即执行\n  resolve();\n});\npromise.then(function() {\n  console.log('resolved.'); // 同步任务执行完成后才会执行\n});\nconsole.log('Hi!');\n// Promise\n// Hi!\n// resolved\n```\n接下来我们就用`Promise`结合ajax来使用\n```\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send(params);\n  });\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n这里我们会渐进式的来创建一个 `Promise` 的实现，如果，你还不了解 `Promise` ，赶快移步 [Promise](http://es6.ruanyifeng.com/#docs/promise) 了解学习，当然这个实现会符合 [Promise/A+](https://promisesaplus.com) 规范，`JavaScript` 中有很多第三方的 `Promise` 库，[bluebird](http://bluebirdjs.com/docs/getting-started.html) 就是一个第三方 `Promise` 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。\n\n---\n\n废话不多说，直接开干。。。 😠\n\n## 定义 Promise 类型\n\n一个简单 `Promise` 语法，如下\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... doSomething\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure 第二个函数可选\n});\n```\n\n### 实现 resolve 和 then\n\n首先我们以上 👆 的语法，自己定义一个 `Promise` 实例\n\n```javascript\nfunction Promise(fn) {\n  var callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    callback(value);\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n一个简单的实例写好了，然后，来用一下，看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n\n```\n{% note info %}\n\n执行结果是：`callback is not a function`\n\n{% endnote %}\n\n### 修改 callback 为异步\n\n**这里就遇到一个问题： **  \n\n** 发现 `resolve()` 在 `then()` 之前调用，在 `resolve()` 被调用的时候， `callback` 还是 `null` ，我们的代码是同步的，而不是异步的。</br> 如是，想办法解决掉这个问题，就是利用 `setTimeout` , 把 `callback` 加入异步队列** \n\n代码如下 👇\n\n```javascript\nfunction Promise(fn) {\n  var callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    // 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法\n    setTimeout(function(){\n      callback(value);\n    },1)\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n\n然后，再来用一下,看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n```\n\n{% note info %}\n\n执行结果是：`66`\n\n{% endnote %}\n\n## Promise使用注意点\n1. 一般来说，调用`resolve`或`reject`以后，`Promise`的使命就完成了，后继操作应该放到`then`方法里面，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。\n\n2. `Promise`实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为`Promise`实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即then方法后面再调用另一个`then`方法。\n\n3. `Promise.prototype.catch`方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。`getJSON`方法返回一个`Promise`对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n4. 一般来说，不要在then方法里面定义`reject`状态的回调函数（即then的第二个参数），总是使用`catch`方法。\n\n5. 跟传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应，`Promise`会吃掉错误。\n","tags":["Promise"],"categories":["JS"]},{"title":"如何使用 markdown 语法写博客","url":"%2FmarkdownGrammar.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/markdown.png, Markdown, Markdown %}\n\n# 标题1\n## 标题2\n*斜体*\n**粗体**\n***粗斜体***<br/>\n~~删除线~~\n<u>下划线文本</u>\n\n1. I\n2. Love \n3. You\n\n- 点\n\n+ Foo\n+ Bar\n---\n<!-- more -->\n\n分隔线\n***\n--- \n___\n\n* * *\n>一级引用\n>>二级引用\n\n`#include<iostream>`\n```\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n```\n~~~\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n~~~\n|标题|标题|标题|\n|:---|:---:|---:|\n|居左测试文本|居中测试文本|居右测试文本|\n|居左测试文本1|居中测试文本2|居右测试文本3|\n|居左测试文本11|居中测试文本22|居右测试文本33|\n|居左测试文本111|居中测试文本222|居右测试文本333|\n\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n### 反斜杠\n\n`Markdown` 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n```\n\\*literal asterisks\\*\n```\n效果如下：\n\n\\*literal asterisks\\*\n\n`Markdown` 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```\n  \\   反斜线\n  `   反引号\n  *   星号\n  _   底线\n  {}  花括号\n  []  方括号\n  ()  括弧\n  #   井字号\n  +   加号\n  -   减号\n  .   英文句点\n  !   惊叹号\n```\n登录[百度](http://www.baidu.com)\n![Teddy Bear](http://img2.everychina.com/img/d7/f7/1b580dfa9315111397ef93fd24ea-250x250c1-77f7/love_valentine_plush_teddy_bear.jpg)\n","tags":["markdown"],"categories":["工具"]},{"title":"Hello World - 热爱编程的普通人，顺便以此为生。","url":"%2Fhello-world.html","content":"\n之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n---\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["杂谈"],"categories":["杂谈"]}]