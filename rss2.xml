<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>cosyer&#39;s Blog</title>
    <link>http://mydearest.cn/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>陈宇的博客</description>
    <pubDate>Wed, 22 Apr 2020 17:07:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>算法题练习</title>
      <link>http://mydearest.cn/2020/%E7%AE%97%E6%B3%95%E9%A2%98%E7%BB%83%E4%B9%A0.html</link>
      <guid>http://mydearest.cn/2020/%E7%AE%97%E6%B3%95%E9%A2%98%E7%BB%83%E4%B9%A0.html</guid>
      <pubDate>Wed, 22 Apr 2020 17:03:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;写出一个方法输出1-100内的所有素数&quot;&gt;&lt;a href=&quot;#写出一个方法输出1-100内的所有素数&quot; class=&quot;headerlink&quot; title=&quot;写出一个方法输出1-100内的所有素数&quot;&gt;&lt;/a&gt;写出一个方法输出1-100内的所有素数&lt;/h2&gt;&lt;p&gt;解析
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="写出一个方法输出1-100内的所有素数"><a href="#写出一个方法输出1-100内的所有素数" class="headerlink" title="写出一个方法输出1-100内的所有素数"></a>写出一个方法输出1-100内的所有素数</h2><p>解析：由素数（质数）定义可知：</p><ul><li>① 0、1都不是质数，那么最小的质数就是2。</li><li>② 除了1和它自身，不能被其他数整除，那么代码表达式表示为：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i % j === <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>代码实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> bl = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === j) <span class="keyword">continue</span></span><br><span class="line">      i % j === <span class="number">0</span> &amp;&amp; (bl = <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    !bl &amp;&amp; arr.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn())</span><br></pre></td></tr></table></figure><h2 id="给定一个整数数组，实现快速排序算法进行升序排列。如-2-5-8-9-3-gt-2-3-5-8-9"><a href="#给定一个整数数组，实现快速排序算法进行升序排列。如-2-5-8-9-3-gt-2-3-5-8-9" class="headerlink" title="给定一个整数数组，实现快速排序算法进行升序排列。如[2, 5, 8, 9, 3] =&gt;[2, 3, 5, 8, 9]"></a>给定一个整数数组，实现快速排序算法进行升序排列。如[2, 5, 8, 9, 3] =&gt;[2, 3, 5, 8, 9]</h2><p>解析：（分治法）将一个列表分割为左右两块，然后再将字列表再进行分割为左右两块，如何反复，知道子元素长度为1时，结束！</p><ul><li>代码实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">const</span> midVal = arr.splice(index, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> left = [],</span><br><span class="line">    right = []</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item &lt; midVal) left.push(item)</span><br><span class="line">    <span class="keyword">else</span> right.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> [...qSort(left), midVal, ...qSort(right)]</span><br><span class="line">&#125;</span><br><span class="line">qSort([<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/%E7%AE%97%E6%B3%95%E9%A2%98%E7%BB%83%E4%B9%A0.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>vue面试题记录</title>
      <link>http://mydearest.cn/2020/vueInterview.html</link>
      <guid>http://mydearest.cn/2020/vueInterview.html</guid>
      <pubDate>Wed, 22 Apr 2020 16:10:18 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Vue面试问题&quot;&gt;&lt;a href=&quot;#Vue面试问题&quot; class=&quot;headerlink&quot; title=&quot;Vue面试问题&quot;&gt;&lt;/a&gt;Vue面试问题&lt;/h2&gt;&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Vue面试问题"><a href="#Vue面试问题" class="headerlink" title="Vue面试问题"></a>Vue面试问题</h2><hr><a id="more"></a><h3 id="v-show和v-if有什么区别"><a href="#v-show和v-if有什么区别" class="headerlink" title="v-show和v-if有什么区别"></a>v-show和v-if有什么区别</h3><ul><li><p>v-ifv-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染条件为假时，则什么也不做——直到条件第一次变为真时才开始渲染条件块。</p></li><li><p>v-showv-show就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于css的display进行切换。</p></li></ul><p>所以，v-if适用于切换不频繁的场景，v-show适用于切换频繁的场景。</p><h3 id="class和style如何动态绑定"><a href="#class和style如何动态绑定" class="headerlink" title="class和style如何动态绑定"></a>class和style如何动态绑定</h3><p>class可以通过对象语法和数组语法进行动态绑定：</p><ul><li><p>对象语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;active: isActive, 'text-danger': hasError &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">data: &#123;</span><br><span class="line">    isActive: <span class="literal">true</span>,</span><br><span class="line">    hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">data: &#123;</span><br><span class="line">    activeClass: <span class="string">'active'</span>,</span><br><span class="line">    errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>style也可以通过对象语法和数组语法进行动态绑定</p><h3 id="理解vue里的单向数据流"><a href="#理解vue里的单向数据流" class="headerlink" title="理解vue里的单向数据流"></a>理解vue里的单向数据流</h3><p>所有的prop都使得其父子prop之间形成一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来不行，这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流难以解释.</p><p>额外地，每次父级组件发生更新时，子组件中的所有prop都会刷新为最新的值，这意味着你不应该在一个子组件内部改变prop，如果你这样做了，vue会在浏览器的控制台发出警告，子组件想修改时，只能通过$emit派发一个自定义事件，父组件接收到后，由父组件修改.</p><h3 id="computed和watch的区别和运用场景"><a href="#computed和watch的区别和运用场景" class="headerlink" title="computed和watch的区别和运用场景"></a>computed和watch的区别和运用场景</h3><ul><li><p>computed：是计算属性，依赖其他属性值，并且computed的值有缓存，只有他依赖的属性值发生改变时下一次获取computed的值时候才会重新计算computed的值。</p></li><li><p>watch：更多的是观察作用，类似于某些数据的监听回调，每当监听的数据发生变化时都会执行回调进行后续操作。</p></li></ul><p>运用场景：</p><ul><li><p>当我们需要进行数值计算，并依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时都要重新计算。</p></li><li><p>但我们需要在数据变化时执行异步或开销较大的操作时应该使用watch，使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的。</p></li></ul><h3 id="直接给一个数组项赋值，vue能检测到吗"><a href="#直接给一个数组项赋值，vue能检测到吗" class="headerlink" title="直接给一个数组项赋值，vue能检测到吗"></a>直接给一个数组项赋值，vue能检测到吗</h3><p>由于js的限制，vue不能检测到以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如vm.item[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如vm.items.length = newLength</li></ul><p>为了解决第一个问题，vue提供了以下操作方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">Vue.$set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">Vue.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure></p><p>为了解决第二个问题，vue提供了以下操作方法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure></p><h3 id="vue生命周期的理解"><a href="#vue生命周期的理解" class="headerlink" title="vue生命周期的理解"></a>vue生命周期的理解</h3><ul><li><p>生命周期是什么vue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载dom-&gt;渲染更新-&gt;渲染卸载等一些过程，我们称这是vue的生命周期</p></li><li><p>各个生命周期的作用</p><ul><li>beforeCreate：组件被创建之初，组件的属性生效之前</li><li>created：组件实例已经完全创建，属性也绑定，但是真实的dom还没有生成，$el还不能用</li><li>beforeMount：在挂载开始之前被调用，相关的render函数首次被调用</li><li>mounted：el被新创建的vm.$el替换，并挂载到实例上去后调用该钩子</li><li>beforeUpdate：组件数据更新之前调用，发生在虚拟dom打补丁之前 </li><li>updated：组件数据更新之后</li><li>activited：keep-alive专属，组件被激活时调用</li><li>deactivated：keep-alive专属，组件被销毁时调用</li><li>beforeDestroy：组件被销毁前 destroyed：组件被销毁后调用</li></ul></li></ul><h3 id="vue父子组件生命周期钩子函数的执行顺序"><a href="#vue父子组件生命周期钩子函数的执行顺序" class="headerlink" title="vue父子组件生命周期钩子函数的执行顺序"></a>vue父子组件生命周期钩子函数的执行顺序</h3><ul><li><p>加载渲染过程父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p></li><li><p>子组件更新过程父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p></li><li><p>父组件更新过程父beforeUpdate-&gt;父updated</p></li><li><p>销毁过程父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroy</p></li></ul><h3 id="在哪个生命周期内调用异步请求"><a href="#在哪个生命周期内调用异步请求" class="headerlink" title="在哪个生命周期内调用异步请求"></a>在哪个生命周期内调用异步请求</h3><p>可以在函数created，beforeMount，mounted中进行调用，因为在这三个钩子函数中data已经可以创建，可以将服务端返回的数据进行赋值，但是比较推荐在created钩子函数中调用异步请求，因为：</p><ul><li>能更快的获取到服务端数据，减少页面loading时间</li><li>ssr不支持beforeMount，mounted钩子函数，所以放在created中有助于一致性</li></ul><h3 id="在什么阶段才能访问操作DOM"><a href="#在什么阶段才能访问操作DOM" class="headerlink" title="在什么阶段才能访问操作DOM"></a>在什么阶段才能访问操作DOM</h3><p>在钩子函数mounted被调用之前，vue已经把编译好的模板挂载到页面上，所以在mounted中可以访问操作dom，vue具体的生命周期。</p><h3 id="父组件可以监听到子组件的生命周期吗"><a href="#父组件可以监听到子组件的生命周期吗" class="headerlink" title="父组件可以监听到子组件的生命周期吗"></a>父组件可以监听到子组件的生命周期吗</h3><ul><li><p>手动设置$emit来发布监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line">&lt;Child @mounted=<span class="string">"fn"</span> /&gt;</span><br><span class="line"><span class="comment">// child</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">"mounted"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@hook</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line">&lt;Child @hook:mounted=<span class="string">"fn"</span> /&gt;</span><br><span class="line">fn() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// child</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'emit'</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="谈谈你对keep-alive的了解"><a href="#谈谈你对keep-alive的了解" class="headerlink" title="谈谈你对keep-alive的了解"></a>谈谈你对keep-alive的了解</h3><p>keep-alive是vue内置的一个组件，可以使被包含的组件保留状态，避免重复渲染，其有以下特性：</p><ul><li>一般结合路由和动态组件使用，用于缓存组件</li><li>提供include和exclude属性，两者都支持字符串或正则表达式，include表示只有名字匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高</li><li>对应两个钩子函数actived和deactivated</li></ul><h3 id="组件中的data为什么是个函数"><a href="#组件中的data为什么是个函数" class="headerlink" title="组件中的data为什么是个函数"></a>组件中的data为什么是个函数</h3><p>因为组件是拿来复用的，且js里的对象是引用关系，如果组件中的data是一个对象，那么这样作用域没有隔离，子组件中的data属性值会相互影响，如果组件中的data是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性值不会互相影响，而new Vue的实例是不会被复用的，因此不存在引用对象的问题。</p><h3 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h3><p>我们在vue项目中主要使用v-model指令在表单input，textarea，select等元素上创建双向绑定，我们知道v-model本质上不过是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text和textarea元素使用value属性和input事件</li><li>checkbox和radio使用checked和change</li><li>select字段将value作为prop并将change作为事件</li></ul><h3 id="vue组件间通信有哪几种方式"><a href="#vue组件间通信有哪几种方式" class="headerlink" title="vue组件间通信有哪几种方式"></a>vue组件间通信有哪几种方式</h3><ul><li><p>props和$emit适用父子组件通信</p></li><li><p>ref和$parent $childrenref：如果在普通dom上使用，引用指向的就是dom元素，如果用在子组件上，引用就指向组件实例 $parent/$children：访问父子实例</p></li><li><p>EventBus（$emit/$on）这种方法通过一个空的vue实例作为中央事件总线（事件中心），用他来触发事件和监听事件，从而实现任何组件间的通信，包括父子，隔代，兄弟组件</p></li><li><p>$attrs/$listeners$attrs：包含了父作用域里不被prop所识别（且获取）的特性绑定（class和style除外）。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定（class和style除外），并且可以通过v-bind=”$attrs”传入内部组件。通常配合inheritAttrs选项一起使用</p></li></ul><p>$listeners：包含了父作用域中的v-on事件监听器，它可以通过v-on=”$listeners”传入内部组件</p><ul><li><p>provide、inject祖先组件通过provider来提供变量，然后在子孙组件中通过inject来注入变量，provide / inject API主要解决了跨级组件间的通信问题，不过他的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立一种主动提供和依赖注入的关系</p></li><li><p>vuexvuex是一个专为vue应用程序开发的状态管理模式，每一个vuex应用的核心就是store，store基本上就是一仓库，它包含着你的应用中大部分的状态</p></li></ul><p>vuex的状态存储是响应式的，当vue从store中读取状态时候，若store中的状态发生变化，那么相应的组件也会相应的得到高效更新</p><p>改变store中的状态的唯一的途径就是显式地提交mutation，这样使我们可以方便地跟踪每一个状态的变化</p><h3 id="你使用过vuex吗"><a href="#你使用过vuex吗" class="headerlink" title="你使用过vuex吗"></a>你使用过vuex吗</h3><p>vuex是一个专门为vue应用程序开发的状态管理模式，每一个vuex应用的核心是store，store基本上就是一个容器，它包含着你的应用中大部分的状态（state）</p><p>主要包括以下几个模块：</p><ul><li>state：定义了应用状态的数据结构，可以在这里设置默认的初始状态</li><li>Getter：允许组件从State中获取数据，mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性</li><li>Mutation：是唯一更改store中状态的方法，且必须是同步函数</li><li>Action：用于提交mutation，而不是直接更改状态，可以包含任意的异步操作</li><li>Module：允许将单一的Store拆分成多个store且同时保存在单一的状态树里</li></ul><h3 id="vue-SSR"><a href="#vue-SSR" class="headerlink" title="vue SSR"></a>vue SSR</h3><p>vue是构建客户端应用程序的框架，默认情况下，可以在浏览器中输出vue组件，进行生成dom和操作dom，然而，也可以将同一个组件渲染为服务端的html字符串，将他们直接发送到客户端，然后将这些静态标记激活为客户端上可以交互的应用程序。</p><p>即ssr的意思就是vue在服务端完成将标签渲染成整个html片段的工作，然后将片段直接返回给客户端使用</p><ul><li><p>ssr优点：</p><ul><li><p>更好的seo：因为spa页面的内容是通过ajax获取，而搜索引擎爬取工具并不会等待ajax一步完成后再抓取页面内容，所以在spa中是抓取不到页面通过ajax获取到的内容；而ssr是直接由服务器返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取到渲染好的页面</p></li><li><p>更快的内容到达时间（首屏加载快）：spa会等待所有vue编译后的js文件都下载完成后，才开始进行也免得渲染，文件下载需要一定的时间等，所以首屏加载需要时间，而ssr直接由服务器渲染好页面返回显示，无需等待js文件再去渲染，所以ssr有更快的内容到达时间</p></li></ul></li><li><p>ssr缺点：</p><ul><li><p>更多的开发条件限制：例如服务端渲染只支持beforeCreate和created两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序spa不同，服务端渲染应用程序，需要处于nodejs server中才能运行</p></li><li><p>更多的服务器负载</p></li></ul></li></ul>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/vueInterview.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Immer中文文档</title>
      <link>http://mydearest.cn/2020/Immer%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3.html</link>
      <guid>http://mydearest.cn/2020/Immer%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3.html</guid>
      <pubDate>Wed, 15 Apr 2020 14:51:45 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Immer-中文文档&quot;&gt;&lt;a href=&quot;#Immer-中文文档&quot; class=&quot;headerlink&quot; title=&quot;Immer 中文文档&quot;&gt;&lt;/a&gt;Immer 中文文档&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/mweststrate/immer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Immer&lt;/a&gt; 是 mobx 的作者写的一个 immutable 库，核心实现是利用 ES6 的 proxy，几乎以最小的成本实现了 js 的不可变数据结构，简单易用、体量小巧、设计巧妙，满足了我们对JS不可变数据结构的需求。&lt;br&gt;无奈网络上完善的文档实在太少，所以自己写了一份，本篇文章以贴近实战的思路和流程，对 Immer 进行了全面的讲解。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#数据处理存在的问题&quot;&gt;数据处理存在的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#解决引用类型对象被修改的办法&quot;&gt;解决引用类型对象被修改的办法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#immer功能介绍&quot;&gt;immer功能介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#安装immer&quot;&gt;安装immer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#immer如何fix掉那些不爽的问题&quot;&gt;immer如何fix掉那些不爽的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#概念说明&quot;&gt;概念说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#常用api介绍&quot;&gt;常用api介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#用immer优化react项目的探索&quot;&gt;用immer优化react项目的探索&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#抛出需求&quot;&gt;抛出需求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#优化setState方法&quot;&gt;优化setState方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#优化reducer&quot;&gt;优化reducer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#参考文档&quot;&gt;参考文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Immer-中文文档"><a href="#Immer-中文文档" class="headerlink" title="Immer 中文文档"></a>Immer 中文文档</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">Immer</a> 是 mobx 的作者写的一个 immutable 库，核心实现是利用 ES6 的 proxy，几乎以最小的成本实现了 js 的不可变数据结构，简单易用、体量小巧、设计巧妙，满足了我们对JS不可变数据结构的需求。<br>无奈网络上完善的文档实在太少，所以自己写了一份，本篇文章以贴近实战的思路和流程，对 Immer 进行了全面的讲解。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#数据处理存在的问题">数据处理存在的问题</a></li><li><a href="#解决引用类型对象被修改的办法">解决引用类型对象被修改的办法</a></li><li><a href="#immer功能介绍">immer功能介绍</a><ul><li><a href="#安装immer">安装immer</a></li><li><a href="#immer如何fix掉那些不爽的问题">immer如何fix掉那些不爽的问题</a></li><li><a href="#概念说明">概念说明</a></li><li><a href="#常用api介绍">常用api介绍</a></li></ul></li><li><a href="#用immer优化react项目的探索">用immer优化react项目的探索</a><ul><li><a href="#抛出需求">抛出需求</a></li><li><a href="#优化setState方法">优化setState方法</a></li><li><a href="#优化reducer">优化reducer</a></li></ul></li><li><a href="#参考文档">参考文档</a></li></ul><hr><a id="more"></a><h2 id="数据处理存在的问题"><a href="#数据处理存在的问题" class="headerlink" title="数据处理存在的问题"></a>数据处理存在的问题</h2><p>先定义一个初始对象，供后面例子使用：首先定义一个<code>currentState</code>对象，后面的例子使用到变量<code>currentState</code>时，如无特殊声明，都是指这个<code>currentState</code>对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentState = &#123;</span><br><span class="line">  p: &#123;</span><br><span class="line">    x: [<span class="number">2</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>哪些情况会一不小心修改原始对象？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Q1</span></span><br><span class="line"><span class="keyword">let</span> o1 = currentState;</span><br><span class="line">o1.p = <span class="number">1</span>; <span class="comment">// currentState 被修改了</span></span><br><span class="line">o1.p.x = <span class="number">1</span>; <span class="comment">// currentState 被修改了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Q2</span></span><br><span class="line">fn(currentState); <span class="comment">// currentState 被修改了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.p1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Q3</span></span><br><span class="line"><span class="keyword">let</span> o3 = &#123;</span><br><span class="line">  ...currentState</span><br><span class="line">&#125;;</span><br><span class="line">o3.p.x = <span class="number">1</span>; <span class="comment">// currentState 被修改了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Q4</span></span><br><span class="line"><span class="keyword">let</span> o4 = currentState;</span><br><span class="line">o4.p.x.push(<span class="number">1</span>); <span class="comment">// currentState 被修改了</span></span><br></pre></td></tr></table></figure><h2 id="解决引用类型对象被修改的办法"><a href="#解决引用类型对象被修改的办法" class="headerlink" title="解决引用类型对象被修改的办法"></a>解决引用类型对象被修改的办法</h2><ol><li>深度拷贝，但是深拷贝的成本较高，会影响性能；</li><li><a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">ImmutableJS</a>，非常棒的一个不可变数据结构的库，可以解决上面的问题，But，跟 Immer 比起来，ImmutableJS 有两个较大的不足：  <ul><li>需要使用者学习它的数据结构操作方式，没有 Immer 提供的使用原生对象的操作方式简单、易用；</li><li>它的操作结果需要通过<code>toJS</code>方法才能得到原生对象，这使得在操作一个对象的时候，时刻要主要操作的是原生对象还是 ImmutableJS 的返回结果，稍不注意，就会产生意想不到的 bug。</li></ul></li></ol><p>看来目前已知的解决方案，我们都不甚满意，那么 Immer 又有什么高明之处呢？</p><h2 id="immer功能介绍"><a href="#immer功能介绍" class="headerlink" title="immer功能介绍"></a>immer功能介绍</h2><h3 id="安装immer"><a href="#安装immer" class="headerlink" title="安装immer"></a>安装immer</h3><p>欲善其事必先利其器，安装 Immer 是当前第一要务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save immer</span><br></pre></td></tr></table></figure><h3 id="immer如何fix掉那些不爽的问题"><a href="#immer如何fix掉那些不爽的问题" class="headerlink" title="immer如何fix掉那些不爽的问题"></a>immer如何fix掉那些不爽的问题</h3><p>Fix Q1、Q3<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">'immer'</span>;</span><br><span class="line"><span class="keyword">let</span> o1 = produce(currentState, draft =&gt; &#123;</span><br><span class="line">  draft.p.x = <span class="number">1</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Fix Q2<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">'immer'</span>;</span><br><span class="line">fn(currentState); <span class="comment">// currentState 被修改了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> produce(o, draft =&gt; &#123;</span><br><span class="line">    draft.p1 = <span class="number">1</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Fix Q4<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">'immer'</span>;</span><br><span class="line"><span class="keyword">let</span> o4 = produce(currentState, draft =&gt; &#123;</span><br><span class="line">  draft.p.x.push(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>是不是使用非常简单，通过小试牛刀，我们简单的了解了 Immer ，下面将对 Immer 的常用 api 分别进行介绍。</p><h3 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h3><p>Immer 涉及概念不多，在此将涉及到的概念先行罗列出来，阅读本文章过程中遇到不明白的概念，可以随时来此处查阅。</p><ul><li><p>currentState<br>被操作对象的最初状态</p></li><li><p>draftState<br>根据 currentState 生成的草稿状态，它是 currentState 的代理，对 draftState 所做的任何修改都将被记录并用于生成 nextState 。在此过程中，currentState 将不受影响</p></li><li><p>nextState<br>根据 draftState 生成的最终状态</p></li><li><p>produce 生产<br>用来生成 nextState 或 producer 的函数</p></li><li><p>producer 生产者<br>通过 produce 生成，用来生产 nextState ，每次执行相同的操作</p></li><li><p>recipe 生产机器<br>用来操作 draftState 的函数</p></li></ul><h3 id="常用api介绍"><a href="#常用api介绍" class="headerlink" title="常用api介绍"></a>常用api介绍</h3><p>使用 Immer 前，请确认将<code>immer</code>包引入到模块中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> produce <span class="keyword">from</span> <span class="string">'immer'</span></span><br></pre></td></tr></table></figure><p>or<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; produce &#125; <span class="keyword">from</span> <span class="string">'immer'</span></span><br></pre></td></tr></table></figure></p><p>这两种引用方式，produce 是完全相同的</p><h4 id="produce"><a href="#produce" class="headerlink" title="produce"></a>produce</h4><p><em>备注：出现<code>PatchListener</code>先行跳过，后面章节会做介绍</em></p><h5 id="第1种使用方式："><a href="#第1种使用方式：" class="headerlink" title="第1种使用方式："></a>第1种使用方式：</h5><p>语法：<br><code>produce(currentState, recipe: (draftState) =&gt; void | draftState, ?PatchListener): nextState</code></p><p>例子1：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextState = produce(currentState, (draft) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">currentState === nextState; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>例子2：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> currentState = &#123;</span><br><span class="line">  a: [],</span><br><span class="line">  p: &#123;</span><br><span class="line">    x: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextState = produce(currentState, (draft) =&gt; &#123;</span><br><span class="line">  draft.a.push(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">currentState.a === nextState.a; <span class="comment">// false</span></span><br><span class="line">currentState.p === nextState.p; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>由此可见，对 draftState 的修改都会反应到 nextState 上，而 Immer 使用的结构是共享的，nextState 在结构上又与 currentState 共享未修改的部分，共享效果如图：</p><p><img src="http://cdn.mydearest.cn/blog/images/change-tree.gif" alt="change-tree"></p><h5 id="自动冻结功能"><a href="#自动冻结功能" class="headerlink" title="自动冻结功能"></a>自动冻结功能</h5><p>Immer 还在内部做了一件很巧妙的事情，那就是通过 produce 生成的 nextState 是被冻结（freeze）的，（Immer 内部使用<code>Object.freeze</code>方法，只冻结 nextState 跟 currentState 相比修改的部分），这样，当直接修改 nextState 时，将会报错。这使得 nextState 成为了真正的不可变数据。</p><p>例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextState = produce(currentState, (draft) =&gt; &#123;</span><br><span class="line">  draft.p.x.push(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">currentState === nextState; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h5 id="第2种使用方式"><a href="#第2种使用方式" class="headerlink" title="第2种使用方式"></a>第2种使用方式</h5><p>利用高阶函数的特点，提前生成一个生产者 producer</p><p>语法：<br><code>produce(recipe: (draftState) =&gt; void | draftState, ?PatchListener)(currentState): nextState</code></p><p>例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> producer = produce(<span class="function">(<span class="params">draft</span>) =&gt;</span> &#123;</span><br><span class="line">  draft.x = <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> nextState = producer(currentState);</span><br></pre></td></tr></table></figure></p><h5 id="recipe的返回值"><a href="#recipe的返回值" class="headerlink" title="recipe的返回值"></a>recipe的返回值</h5><p>recipe 是否有返回值，nextState 的生成过程是不同的：<br>recipe 没有返回值时：nextState 是根据 recipe 函数内的 draftState 生成的；<br>recipe 有返回值时：nextState 是根据 recipe 函数的返回值生成的；  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextState = produce(</span><br><span class="line">  currentState, </span><br><span class="line">  (draftState) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      x: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>此时，nextState 不再是通过 draftState 生成的了，而是通过 recipe 的返回值生成的。</p><h5 id="recipe中的this"><a href="#recipe中的this" class="headerlink" title="recipe中的this"></a>recipe中的this</h5><p> recipe 函数内部的<code>this</code>指向 draftState ，也就是修改<code>this</code>与修改 recipe 的参数 draftState ，效果是一样的。<br><strong>注意：此处的 recipe 函数不能是箭头函数，如果是箭头函数，<code>this</code>就无法指向 draftState 了</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">produce(currentState, <span class="function"><span class="keyword">function</span>(<span class="params">draft</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 此处，this 指向 draftState</span></span><br><span class="line">  draft === <span class="keyword">this</span>; <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="patch补丁功能"><a href="#patch补丁功能" class="headerlink" title="patch补丁功能"></a>patch补丁功能</h4><p>通过此功能，可以方便进行详细的代码调试和跟踪，可以知道 recipe 内的做的每次修改，还可以实现时间旅行。</p><p>Immer 中，一个 patch 对象是这样的:<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Patch &#123;</span><br><span class="line">  op: <span class="string">"replace"</span> | <span class="string">"remove"</span> | <span class="string">"add"</span> <span class="comment">// 一次更改的动作类型</span></span><br><span class="line">  path: (<span class="built_in">string</span> | <span class="built_in">number</span>)[] <span class="comment">// 此属性指从树根到被更改树杈的路径</span></span><br><span class="line">  value?: <span class="built_in">any</span> <span class="comment">// op为 replace、add 时，才有此属性，表示新的赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>语法：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">produce(</span><br><span class="line">  currentState, </span><br><span class="line">  recipe,</span><br><span class="line">  <span class="comment">// 通过 patchListener 函数，暴露正向和反向的补丁数组</span></span><br><span class="line">  patchListener: <span class="function">(<span class="params">patches: Patch[], inversePatches: Patch[]</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">applyPatches(currentState, changes: (patches | inversePatches)[]): nextState</span><br></pre></td></tr></table></figure></p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> produce, &#123; applyPatches &#125; <span class="keyword">from</span> <span class="string">"immer"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> state = &#123;</span><br><span class="line">  x: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> replaces = [];</span><br><span class="line"><span class="keyword">let</span> inverseReplaces = [];</span><br><span class="line"></span><br><span class="line">state = produce(</span><br><span class="line">  state,</span><br><span class="line">  draft =&gt; &#123;</span><br><span class="line">    draft.x = <span class="number">2</span>;</span><br><span class="line">    draft.y = <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  (patches, inversePatches) =&gt; &#123;</span><br><span class="line">    replaces = patches.filter(<span class="function"><span class="params">patch</span> =&gt;</span> patch.op === <span class="string">'replace'</span>);</span><br><span class="line">    inverseReplaces = inversePatches.filter(<span class="function"><span class="params">patch</span> =&gt;</span> patch.op === <span class="string">'replace'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">state = produce(state, draft =&gt; &#123;</span><br><span class="line">  draft.x = <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'state1'</span>, state); <span class="comment">// &#123; x: 3, y: 2 &#125;</span></span><br><span class="line"></span><br><span class="line">state = applyPatches(state, replaces);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'state2'</span>, state); <span class="comment">// &#123; x: 2, y: 2 &#125;</span></span><br><span class="line"></span><br><span class="line">state = produce(state, draft =&gt; &#123;</span><br><span class="line">  draft.x = <span class="number">4</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'state3'</span>, state); <span class="comment">// &#123; x: 4, y: 2 &#125;</span></span><br><span class="line"></span><br><span class="line">state = applyPatches(state, inverseReplaces);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'state4'</span>, state); <span class="comment">// &#123; x: 1, y: 2 &#125;</span></span><br></pre></td></tr></table></figure><p><code>state.x</code>的值4次打印结果分别是：<code>3、2、4、1</code>，实现了时间旅行，可以分别打印<code>patches</code>和<code>inversePatches</code>看下，</p><p><code>patches</code>数据如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    op: <span class="string">"replace"</span>,</span><br><span class="line">    path: [<span class="string">"x"</span>],</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    op: <span class="string">"add"</span>,</span><br><span class="line">    path: [<span class="string">"y"</span>],</span><br><span class="line">    value: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><code>inversePatches</code>数据如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    op: <span class="string">"replace"</span>,</span><br><span class="line">    path: [<span class="string">"x"</span>],</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    op: <span class="string">"remove"</span>,</span><br><span class="line">    path: [<span class="string">"y"</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>可见，<code>patchListener</code>内部对数据操作做了记录，并分别存储为正向操作记录和反向操作记录，供我们使用。</p><p>至此，Immer 的常用功能和 api 我们就介绍完了。</p><p>接下来，我们看如何用 Immer ，提高 React 、Redux 项目的开发效率。</p><h2 id="用immer优化react项目的探索"><a href="#用immer优化react项目的探索" class="headerlink" title="用immer优化react项目的探索"></a>用immer优化react项目的探索</h2><p>首先定义一个<code>state</code>对象，后面的例子使用到变量<code>state</code>或访问<code>this.state</code>时，如无特殊声明，都是指这个<code>state</code>对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'ronffy'</span>,</span><br><span class="line">      age: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="抛出需求"><a href="#抛出需求" class="headerlink" title="抛出需求"></a>抛出需求</h3><p>就上面定义的<code>state</code>，我们先抛一个需求出来，好让后面的讲解有的放矢：<br><strong>members 成员中的第1个成员，年龄增加1岁</strong></p><h3 id="优化setState方法"><a href="#优化setState方法" class="headerlink" title="优化setState方法"></a>优化setState方法</h3><h4 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.members[<span class="number">0</span>].age++;</span><br></pre></td></tr></table></figure><p>只所以有的新手同学会犯这样的错误，很大原因是这样操作实在是太方便了，以至于忘记了操作 State 的规则。</p><p>下面看下正确的实现方法</p><h4 id="setState的第1种实现方法"><a href="#setState的第1种实现方法" class="headerlink" title="setState的第1种实现方法"></a>setState的第1种实现方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; members &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  members: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...members[<span class="number">0</span>],</span><br><span class="line">      age: members[<span class="number">0</span>].age + <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...members.slice(<span class="number">1</span>),</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="setState的第2种实现方法"><a href="#setState的第2种实现方法" class="headerlink" title="setState的第2种实现方法"></a>setState的第2种实现方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; members &#125; = state;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    members: [</span><br><span class="line">      &#123;</span><br><span class="line">        ...members[<span class="number">0</span>],</span><br><span class="line">        age: members[<span class="number">0</span>].age + <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      ...members.slice(<span class="number">1</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上2种实现方式，就是<code>setState</code>的两种使用方法，相比大家都不陌生了，所以就不过多说明了，接下来看下，如果用 Immer 解决，会有怎样的烟火？</p><h4 id="用immer更新state"><a href="#用immer更新state" class="headerlink" title="用immer更新state"></a>用immer更新state</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(produce(<span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line">  draft.members[<span class="number">0</span>].age++;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>是不是瞬间代码量就少了很多，阅读起来舒服了很多，而且更易于阅读了。</p><h3 id="优化reducer"><a href="#优化reducer" class="headerlink" title="优化reducer"></a>优化reducer</h3><h4 id="immer的produce的拓展用法"><a href="#immer的produce的拓展用法" class="headerlink" title="immer的produce的拓展用法"></a>immer的produce的拓展用法</h4><p>在开始正式探索之前，我们先来看下 produce <a href="#第2种使用方式">第2种使用方式</a>的拓展用法:</p><p>例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> producer = produce(<span class="function">(<span class="params">draft, arg</span>) =&gt;</span> &#123;</span><br><span class="line">  obj === arg; <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> nextState = producer(currentState, obj);</span><br></pre></td></tr></table></figure></p><p>相比 produce 第2种使用方式的例子，多定义了一个<code>obj</code>对象，并将其作为 producer 方法的第2个参数传了进去；可以看到， produce 内的 recipe 回调函数的第2个参数与<code>obj</code>对象是指向同一块内存。<br>ok，我们在知道了 produce 的这种拓展用法后，看看能够在 Redux 中发挥什么功效?</p><h4 id="普通reducer怎样解决上面抛出的需求"><a href="#普通reducer怎样解决上面抛出的需求" class="headerlink" title="普通reducer怎样解决上面抛出的需求"></a>普通reducer怎样解决上面抛出的需求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_AGE'</span>:</span><br><span class="line">      <span class="keyword">const</span> &#123; members &#125; = state;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        members: [</span><br><span class="line">          &#123;</span><br><span class="line">            ...members[<span class="number">0</span>],</span><br><span class="line">            age: members[<span class="number">0</span>].age + <span class="number">1</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          ...members.slice(<span class="number">1</span>),</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合immer-reducer可以怎样写"><a href="#集合immer-reducer可以怎样写" class="headerlink" title="集合immer,reducer可以怎样写"></a>集合immer,reducer可以怎样写</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> produce(state, draft =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_AGE'</span>:</span><br><span class="line">      draft.members[<span class="number">0</span>].age++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，通过 produce ，我们的代码量已经精简了很多；<br>不过仔细观察不难发现，利用 produce 能够先制造出 producer 的特点，代码还能更优雅：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = produce(<span class="function">(<span class="params">draft, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'ADD_AGE'</span>:</span><br><span class="line">      draft.members[<span class="number">0</span>].age++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>好了，至此，Immer 优化 reducer 的方法也讲解完毕。</p><p>Immer 的使用非常灵活，多多思考，相信你还可以发现 Immer 更多其他的妙用！</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://hackernoon.com/introducing-immer-immutability-the-easy-way-9d73d8f71cb3" target="_blank" rel="noopener">Introducing Immer: Immutability the easy way</a></li></ul>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/Immer%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>鼠标点击爱心和富强特效</title>
      <link>http://mydearest.cn/2020/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%B1%E5%BF%83%E5%92%8C%E5%AF%8C%E5%BC%BA%E7%89%B9%E6%95%88.html</link>
      <guid>http://mydearest.cn/2020/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%B1%E5%BF%83%E5%92%8C%E5%AF%8C%E5%BC%BA%E7%89%B9%E6%95%88.html</guid>
      <pubDate>Tue, 07 Apr 2020 15:55:33 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;爱心&quot;&gt;&lt;a href=&quot;#爱心&quot; class=&quot;headerlink&quot; title=&quot;爱心&quot;&gt;&lt;/a&gt;爱心&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;e, t, a&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;r&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; e = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; e &amp;lt; s.length; e++) s[e].alpha &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ? (t.body.removeChild(s[e].el), s.splice(e, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) : (s[e].y--, s[e].scale += &lt;span class=&quot;number&quot;&gt;.004&lt;/span&gt;, s[e].alpha -= &lt;span class=&quot;number&quot;&gt;.013&lt;/span&gt;, s[e].el.style.cssText = &lt;span class=&quot;string&quot;&gt;&quot;left:&quot;&lt;/span&gt; + s[e].x + &lt;span class=&quot;string&quot;&gt;&quot;px;top:&quot;&lt;/span&gt; + s[e].y + &lt;span class=&quot;string&quot;&gt;&quot;px;opacity:&quot;&lt;/span&gt; + s[e].alpha + &lt;span class=&quot;string&quot;&gt;&quot;;transform:scale(&quot;&lt;/span&gt; + s[e].scale + &lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt; + s[e].scale + &lt;span class=&quot;string&quot;&gt;&quot;) rotate(45deg);background:&quot;&lt;/span&gt; + s[e].color + &lt;span class=&quot;string&quot;&gt;&quot;;z-index:99999&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        requestAnimationFrame(r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;n&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; t = &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt; == &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; e.onclick &amp;amp;&amp;amp; e.onclick;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        e.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            t &amp;amp;&amp;amp; t(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            o(e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;o&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = t.createElement(&lt;span class=&quot;string&quot;&gt;&quot;div&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a.className = &lt;span class=&quot;string&quot;&gt;&quot;heart&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s.push(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            el: a,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            x: e.clientX - &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            y: e.clientY - &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            scale: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alpha: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            color: c()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t.body.appendChild(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;i&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = t.createElement(&lt;span class=&quot;string&quot;&gt;&quot;style&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a.type = &lt;span class=&quot;string&quot;&gt;&quot;text/css&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            a.appendChild(t.createTextNode(e))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(t) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            a.styleSheet.cssText = e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t.getElementsByTagName(&lt;span class=&quot;string&quot;&gt;&quot;head&quot;&lt;/span&gt;)[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].appendChild(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;c&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;rgb(&quot;&lt;/span&gt; + ~~ (&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random()) + &lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt; + ~~ (&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random()) + &lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt; + ~~ (&lt;span class=&quot;number&quot;&gt;255&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random()) + &lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        setTimeout(e, &lt;span class=&quot;number&quot;&gt;1e3&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    i(&lt;span class=&quot;string&quot;&gt;&quot;.heart&amp;#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&amp;#125;.heart:after,.heart:before&amp;#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&amp;#125;.heart:after&amp;#123;top: -5px;&amp;#125;.heart:before&amp;#123;left: -5px;&amp;#125;&quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; (&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="爱心"><a href="#爱心" class="headerlink" title="爱心"></a>爱心</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e, t, a</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="number">0</span>; e &lt; s.length; e++) s[e].alpha &lt;= <span class="number">0</span> ? (t.body.removeChild(s[e].el), s.splice(e, <span class="number">1</span>)) : (s[e].y--, s[e].scale += <span class="number">.004</span>, s[e].alpha -= <span class="number">.013</span>, s[e].el.style.cssText = <span class="string">"left:"</span> + s[e].x + <span class="string">"px;top:"</span> + s[e].y + <span class="string">"px;opacity:"</span> + s[e].alpha + <span class="string">";transform:scale("</span> + s[e].scale + <span class="string">","</span> + s[e].scale + <span class="string">") rotate(45deg);background:"</span> + s[e].color + <span class="string">";z-index:99999"</span>);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t = <span class="string">"function"</span> == <span class="keyword">typeof</span> e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            t &amp;&amp; t(),</span><br><span class="line">            o(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = t.createElement(<span class="string">"div"</span>);</span><br><span class="line">        a.className = <span class="string">"heart"</span>,</span><br><span class="line">        s.push(&#123;</span><br><span class="line">            el: a,</span><br><span class="line">            x: e.clientX - <span class="number">5</span>,</span><br><span class="line">            y: e.clientY - <span class="number">5</span>,</span><br><span class="line">            scale: <span class="number">1</span>,</span><br><span class="line">            alpha: <span class="number">1</span>,</span><br><span class="line">            color: c()</span><br><span class="line">        &#125;),</span><br><span class="line">        t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = t.createElement(<span class="string">"style"</span>);</span><br><span class="line">        a.type = <span class="string">"text/css"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; <span class="keyword">catch</span>(t) &#123;</span><br><span class="line">            a.styleSheet.cssText = e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"rgb("</span> + ~~ (<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">","</span> + ~~ (<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">","</span> + ~~ (<span class="number">255</span> * <span class="built_in">Math</span>.random()) + <span class="string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s = [];</span><br><span class="line">    e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        setTimeout(e, <span class="number">1e3</span> / <span class="number">60</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    i(<span class="string">".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"</span>),</span><br><span class="line">    n(),</span><br><span class="line">    r()</span><br><span class="line">&#125; (<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="富强"><a href="#富强" class="headerlink" title="富强"></a>富强</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义获取词语下标</span></span><br><span class="line"><span class="keyword">var</span> a_idx = <span class="number">0</span>;</span><br><span class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//点击body时触发事件</span></span><br><span class="line">    $(<span class="string">"body"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//需要显示的词语</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"富强"</span>,<span class="string">"民主"</span>, <span class="string">"文明"</span>, <span class="string">"和谐"</span>,<span class="string">"自由"</span>, <span class="string">"平等"</span>, <span class="string">"公正"</span>,<span class="string">"法治"</span>, <span class="string">"爱国"</span>, <span class="string">"敬业"</span>,<span class="string">"诚信"</span>, <span class="string">"友善"</span>);</span><br><span class="line">    <span class="comment">//设置词语给span标签</span></span><br><span class="line">    <span class="keyword">var</span> $i = $(<span class="string">"&lt;span/&gt;"</span>).text(a[a_idx]);</span><br><span class="line">    <span class="comment">//下标等于原来下标+1  余 词语总数</span></span><br><span class="line">    a_idx = (a_idx + <span class="number">1</span>)% a.length;</span><br><span class="line">    <span class="comment">//获取鼠标指针的位置，分别相对于文档的左和右边缘。</span></span><br><span class="line">    <span class="comment">//获取x和y的指针坐标</span></span><br><span class="line">    <span class="keyword">var</span> x = e.pageX, y = e.pageY;</span><br><span class="line">    <span class="comment">//在鼠标的指针的位置给$i定义的span标签添加css样式</span></span><br><span class="line">    $i.css(&#123;<span class="string">"z-index"</span> : <span class="number">999999999999999999999999999999999999999999999999999999999999999999999</span>,</span><br><span class="line">        <span class="string">"top"</span> : y - <span class="number">20</span>,</span><br><span class="line">        <span class="string">"left"</span> : x,</span><br><span class="line">        <span class="string">"position"</span> : <span class="string">"absolute"</span>,</span><br><span class="line">        <span class="string">"font-weight"</span> : <span class="string">"bold"</span>,</span><br><span class="line">        <span class="string">"color"</span> : <span class="string">"#ff6651"</span></span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">//在body添加这个标签</span></span><br><span class="line">    $(<span class="string">"body"</span>).append($i);</span><br><span class="line">        <span class="comment">//animate() 方法执行 CSS 属性集的自定义动画。</span></span><br><span class="line">        <span class="comment">//该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。</span></span><br><span class="line">        <span class="comment">//详情请看http://www.w3school.com.cn/jquery/effect_animate.asp</span></span><br><span class="line">        $i.animate(&#123;</span><br><span class="line">        <span class="comment">//将原来的位置向上移动180</span></span><br><span class="line">            <span class="string">"top"</span> : y - <span class="number">180</span>,</span><br><span class="line">                <span class="string">"opacity"</span> : <span class="number">0</span></span><br><span class="line">         <span class="comment">//1500动画的速度</span></span><br><span class="line">        &#125;, <span class="number">1500</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//时间到了自动删除</span></span><br><span class="line">            $i.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="加入收藏"><a href="#加入收藏" class="headerlink" title="加入收藏"></a>加入收藏</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;a href="javascript:void(0)" onclick="shoucang(document.title,window.location)"&gt;加入收藏&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shoucang</span>(<span class="params">sTitle, sURL</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.external.addFavorite(sURL, sTitle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">window</span>.sidebar.addPanel(sTitle, sURL, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            alert(<span class="string">"加入收藏失败，请使用Ctrl+D进行添加"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设为首页"><a href="#设为首页" class="headerlink" title="设为首页"></a>设为首页</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;a href="javascript:void(0)" onclick="SetHome(this,window.location)"&gt;设为首页&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SetHome</span>(<span class="params">obj, vrl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        obj.style.behavior = <span class="string">'url(#default#homepage)'</span>; obj.setHomePage(vrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.netscape) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                netscape.security.PrivilegeManager.enablePrivilege(<span class="string">"UniversalXPConnect"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                alert(<span class="string">"此操作被浏览器拒绝！\n请在浏览器地址栏输入“about:config”并回车\n然后将 [signed.applets.codebase_principal_support]的值设置为'true',双击即可。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> prefs = Components.classes[<span class="string">'@mozilla.org/preferences-service;1'</span>].getService(Components.interfaces.nsIPrefBranch);</span><br><span class="line">            prefs.setCharPref(<span class="string">'browser.startup.homepage'</span>, vrl);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">"您的浏览器不支持，请按照下面步骤操作：1.打开浏览器设置。2.点击设置网页。3.输入："</span> + vrl + <span class="string">"点击确定。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片不存在显示默认图片"><a href="#图片不存在显示默认图片" class="headerlink" title="图片不存在显示默认图片"></a>图片不存在显示默认图片</h2><ul><li><p>分析：特别注意 onerror，当图片不存在时，将触发 onerror，而 onerror 中为 img 指定一个默认图片。也就是说图片存在则显示 pic.gif，图片不存在将显示默认图片。</p></li><li><p>存在的问题：如果默认图片也不存在，则继续触发 onerror，导致循环，故出现错误。如果图片存在，但网络很不通畅，也可能触发 onerror。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"abc.jpg"</span> οnerrοr=<span class="string">"nofind()"</span> /&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nofind</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img=event.srcElement;</span><br><span class="line">  img.src=<span class="string">"def"</span>; <span class="comment">//替换的图片</span></span><br><span class="line">  img.οnerrοr=<span class="literal">null</span>; <span class="comment">//控制不要一直触发错误</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%B1%E5%BF%83%E5%92%8C%E5%AF%8C%E5%BC%BA%E7%89%B9%E6%95%88.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>实现compose</title>
      <link>http://mydearest.cn/2020/%E5%AE%9E%E7%8E%B0compose.html</link>
      <guid>http://mydearest.cn/2020/%E5%AE%9E%E7%8E%B0compose.html</guid>
      <pubDate>Thu, 02 Apr 2020 15:54:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;实现compose函数的五种思路&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向过程&lt;/li&gt;
&lt;li&gt;函数组合（reduce）&lt;/li&gt;
&lt;li&gt;函数交织（AOP编程）&lt;/li&gt;
&lt;li&gt;Promise（sequence）&lt;/li&gt;
&lt;li&gt;Generator（yield）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>实现compose函数的五种思路</p><ul><li>面向过程</li><li>函数组合（reduce）</li><li>函数交织（AOP编程）</li><li>Promise（sequence）</li><li>Generator（yield）</li></ul><hr><a id="more"></a><h2 id="什么是compose"><a href="#什么是compose" class="headerlink" title="什么是compose"></a>什么是compose</h2><p>compose就是执行一系列的任务（函数），比如有以下任务队列：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tasks = [step1, step2, step3, step4]</span><br></pre></td></tr></table></figure></p><p>每一个step都是一个步骤，按照步骤一步一步的执行到结尾，这就是一个compose。</p><ul><li>第一个函数是多元的（接受多个参数），后面的函数都是单元的（接受一个参数）</li><li>执行顺序的自右向左的</li><li>所有函数的执行都是同步的（异步的后面文章会讲到）</li></ul><p>举个例子:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> init = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(<span class="function">(<span class="params">ele1, ele2</span>) =&gt;</span> ele1 + ele2, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> step2 = <span class="function">(<span class="params">val</span>) =&gt;</span> val + <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> step3 = <span class="function">(<span class="params">val</span>) =&gt;</span> val + <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> step4 = <span class="function">(<span class="params">val</span>) =&gt;</span> val + <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组成任务队列</span></span><br><span class="line">steps = [step4, step3, step2, init]</span><br><span class="line"><span class="comment">// 使用compose组合这个队列并执行</span></span><br><span class="line"><span class="keyword">let</span> composeFunc = compose(...steps)</span><br><span class="line"><span class="built_in">console</span>.log(composeFunc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></p><p>执行过程</p><blockquote><p>6 -&gt; 6 + 2 = 8 -&gt; 8 + 3 = 11 -&gt; 11 + 4 = 15</p></blockquote><p>所以流程就是从init自右到左依次执行，下一个任务的参数是上一个任务的返回结果，并且任务都是同步的，这样就能保证任务可以按照有序的方向和有序的时间执行。</p><h2 id="实现compose的五种思路"><a href="#实现compose的五种思路" class="headerlink" title="实现compose的五种思路"></a>实现compose的五种思路</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>这个思路就是使用递归的过程思想，不断的检测队列中是否还有任务，如果有任务就执行，并把执行结果往后传递，这里是一个局部的思维，无法预知任务何时结束。直观上最容易结束和理解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = args.length</span><br><span class="line">  <span class="keyword">let</span> count = length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params">...arg1</span>) </span>&#123;</span><br><span class="line">    result = args[count].apply(<span class="keyword">this</span>, arg1)</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      count = length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    count--</span><br><span class="line">    <span class="keyword">return</span> f1.call(<span class="literal">null</span>, result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h3><p>这个思路是一种函数组合的思想，将函数两两组合，不断的生成新的函数，生成的新函数挟裹了函数执行的逻辑信息，然后再两两组合，不断的传递下去，这种思路可以提前遍历所有任务，将任务组合成一个可以展开的组合结构，最后执行的时候就像推导多米诺骨牌一样。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合过程</span></span><br><span class="line">f1 = <span class="function">(<span class="params">...arg</span>) =&gt;</span> step2.call(<span class="literal">null</span>, init.apply(<span class="literal">null</span>, arg))</span><br><span class="line">f2 = <span class="function">(<span class="params">...arg</span>) =&gt;</span> step3.call(<span class="literal">null</span>, f1.apply(<span class="literal">null</span>, arg))</span><br><span class="line">f3 = <span class="function">(<span class="params">...arg</span>) =&gt;</span> step4.call(<span class="literal">null</span>, f2.apply(<span class="literal">null</span>, arg))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">const</span> _pipe = <span class="function">(<span class="params">f, g</span>) =&gt;</span> (...arg) =&gt; g.call(<span class="literal">null</span>, f.apply(<span class="literal">null</span>, arg))</span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reverse().reduce(_pipe, args.shift())</span><br></pre></td></tr></table></figure></p><h3 id="函数交织（AOP）"><a href="#函数交织（AOP）" class="headerlink" title="函数交织（AOP）"></a>函数交织（AOP）</h3><p>这个实现的灵感来自javascript设计模式中的高阶函数，因为compose的任务在本质上就是函数执行，再加上顺序，所以可以把实现顺序执行放到函数本身，对函数的原型进行方法的绑定。方法的作用对象是函数，面向对象封装的数据，面向函数封装的是函数的行为。</p><p>需要对函数绑定两个行为 before 和 after，before执行函数多元部分（启动），after执行函数单元部分。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = fn.apply(<span class="literal">null</span>, args)</span><br><span class="line">    <span class="keyword">return</span> self.call(<span class="literal">null</span>, result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = self.apply(<span class="literal">null</span>, args)</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="literal">null</span>, result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里对函数进行方法的绑定，返回的是带着函数执行的规则的另外一个函数，在这里是次序的排列规则，对返回的函数依然可以进行链式调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compose实现</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> before = args.pop()</span><br><span class="line">  <span class="keyword">let</span> start = args.pop()</span><br><span class="line">  <span class="keyword">if</span> (args.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">f1, f2</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f1.after(f2)</span><br><span class="line">    &#125;, start.before(before))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start.before(before)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行过程</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> before = args.pop()</span><br><span class="line">  <span class="keyword">let</span> start = args.pop()</span><br><span class="line">  <span class="keyword">if</span> (args.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">f1, f2</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> f1.after(f2)</span><br><span class="line">    &#125;, start.before(before))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> start.before(before)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>ES6引入了Promise，Promise可以指定一个sequence，来规定一个执行then的过程，then函数会等到执行完成后，再执行下一个then的处理。启动sequence可以使用Promise.resolve()这个函数。构建sequence可以使用reduce。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> init = args.pop()</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> args.reverse().reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sequence, func</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.call(<span class="literal">null</span>, result)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve(init.apply(<span class="literal">null</span>, arg)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator主要使用yield来构建协程，采用中断，处理，再中断的流程。可以事先规定好协程的执行顺序，然后再下次处理的时候进行参数（结果）交接，有一点要注意的是，由于执行的第一个next是不能传递参数的，所以第一个函数的执行需要手动调用，再空耗一个next，后面的就可以同步执行了。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterateSteps</span>(<span class="params">steps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; steps.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n) &#123;</span><br><span class="line">      n = <span class="keyword">yield</span> steps[i].call(<span class="literal">null</span>, n)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      n = <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现compose</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">...steps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> g = iterateSteps(steps)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> val = steps.pop().apply(<span class="literal">null</span>, args)</span><br><span class="line">    <span class="comment">// 这里是第一个值</span></span><br><span class="line">    <span class="built_in">console</span>.log(val)</span><br><span class="line">    <span class="comment">// 因为无法传参数 所以无所谓执行 就是空耗一个yield</span></span><br><span class="line">    g.next()</span><br><span class="line">    <span class="keyword">return</span> steps.reverse.reduce(<span class="function">(<span class="params">val, val1</span>) =&gt;</span> g.next(val).value, val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/%E5%AE%9E%E7%8E%B0compose.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>面试经验分享</title>
      <link>http://mydearest.cn/2020/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB.html</link>
      <guid>http://mydearest.cn/2020/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB.html</guid>
      <pubDate>Sun, 29 Mar 2020 18:21:33 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;面试流程&quot;&gt;&lt;a href=&quot;#面试流程&quot; class=&quot;headerlink&quot; title=&quot;面试流程&quot;&gt;&lt;/a&gt;面试流程&lt;/h2&gt;&lt;p&gt;大公司面试无论是实习还是校招，普遍存在面试轮次多，面试周期长的特点，就拿腾讯来说，如果你想成为暑期实习生，大概需要四到五轮面试，3-4 轮技术面+一轮 HR 面试，每次面试时间大概在 0.5-1 小时之间，推荐对自己能力没有把握或者缺少工作经验的同学尽可能在大三下学期找找实习，去自己想去的公司实习，因为大三的暑期实习既可以丰富你的履历，并且实习期间好好表现都是可以相对容易地通过转正，拿到校招 offer。&lt;/p&gt;
&lt;p&gt;在申请实习或者校招 offer 的时候，尽可能多找人帮忙内推，因为大公司部门比较多，你如果直接从官网上网申的话，简历不容易被人查看，找认识的师兄师姐帮忙内推的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;能够更有效增加你的简历的曝光，让部门主管能够直接查阅到你的简历&lt;/li&gt;
&lt;li&gt;加快面试进度，联系师兄师姐提前知道面试结果&lt;/li&gt;
&lt;li&gt;内推或者网申(可能有笔试)完之后，就等待面试官打电话给你，一般他们会跟你通过电话或者短信确认现在是否方便或者约个时间进行面试，面试的方式也分为电话面试，视频面试，现场面试等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="面试流程"><a href="#面试流程" class="headerlink" title="面试流程"></a>面试流程</h2><p>大公司面试无论是实习还是校招，普遍存在面试轮次多，面试周期长的特点，就拿腾讯来说，如果你想成为暑期实习生，大概需要四到五轮面试，3-4 轮技术面+一轮 HR 面试，每次面试时间大概在 0.5-1 小时之间，推荐对自己能力没有把握或者缺少工作经验的同学尽可能在大三下学期找找实习，去自己想去的公司实习，因为大三的暑期实习既可以丰富你的履历，并且实习期间好好表现都是可以相对容易地通过转正，拿到校招 offer。</p><p>在申请实习或者校招 offer 的时候，尽可能多找人帮忙内推，因为大公司部门比较多，你如果直接从官网上网申的话，简历不容易被人查看，找认识的师兄师姐帮忙内推的优势在于：</p><ol><li>能够更有效增加你的简历的曝光，让部门主管能够直接查阅到你的简历</li><li>加快面试进度，联系师兄师姐提前知道面试结果</li><li>内推或者网申(可能有笔试)完之后，就等待面试官打电话给你，一般他们会跟你通过电话或者短信确认现在是否方便或者约个时间进行面试，面试的方式也分为电话面试，视频面试，现场面试等等。</li></ol><hr><a id="more"></a><p>无论是哪种类型的面试，内容大致上都是一致的(除了现场面试可能要求你手写代码外)，我将专业技能面试分为以下几个部分：</p><ol><li>自我介绍</li><li>计算机基础知识</li><li>前端知识</li><li>面试者提问环节</li></ol><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>首先是自我介绍，面试前最好能够准备一段不少于 30 秒的自我介绍并对着镜子反复练习，可以介绍介绍你的名字，学校，专业，对你投递岗位的理解等等，在面试过程中尽可能流利地叙述，而不是介绍时磕磕碰碰，给面试官留下不好的印象。</p><h3 id="计算机基础知识"><a href="#计算机基础知识" class="headerlink" title="计算机基础知识"></a>计算机基础知识</h3><p>第二部分是计算机基础知识，对于应届生来说，面试官无非喜欢考察计算机网络，操作系统，数据结构与算法这三大类。当然根据你应聘的岗位有所不同，如果你是应聘一名前端工程师，考察网络的知识相对较多，对于操作系统、数据结构和算法的考察会相对较少，如果你是应聘一个后端工程师的话，那么涉及到操作系统的知识肯定会相对更多。同理算法工程师就会涉及到更多数据结构和算法的知识。</p><p>面试网络知识的话，可以多准备 HTTP/TCP 相关的知识，比如我就常被问到：</p><blockquote><p>HTTP 状态码，从浏览器打开一个网址背后都经历了什么TCP 与 UDP 的区别，为什么 TCP 需要三次握手，四次挥手等等</p></blockquote><h3 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h3><p>第三大块也就是你应聘的岗位相关的知识内容了，比如拿前端来说，一般前端知识可以分为三大块：语言基础，框架以及实践。</p><p>语言基础一般会考察你对 JS 语言本身的理解，比如说：闭包，继承，作用域，this 用法，ES6 语法等等，也会问你关于 HTML/CSS 的基础知识。</p><p>框架的话不仅仅是局限于考察对框架的用法，一般是结合你的简历内容来进行提问，比如你在简历上写你熟悉 React，面试官可能就会问你 virtual-dom 是怎么实现的，Redux 设计思想等等，如果你简历上写熟悉 Vue，那可能就会问你数据双向绑定是怎么实现的等等。</p><p>还有就是你的实践部分，这部分面试官会结合你的简历提到的一些经历，比如你有什么实习经历阿，或者在学校做过什么项目来进行提问。可能会像这样问你：</p><blockquote><p>你在这个项目中（或者实习经历）遇到最大的挑战(难题)是什么，你怎么解决的你在项目开发的过程中运用了什么技术，为什么会使用到这些技术等等</p></blockquote><h3 id="面试者提问环节"><a href="#面试者提问环节" class="headerlink" title="面试者提问环节"></a>面试者提问环节</h3><p>一般面试结束后面试官都会问你，还有什么问题想问我，这时候你可以就你感兴趣的内容进行提问，比如我一般就会问下面类型的问题：</p><ol><li>如果我有幸被录用了，我会从事什么样的工作内容</li><li>团队组织结构是怎么样的，主要负责什么样的产品</li><li>工作平时加班多吗，一般几点下班</li><li>就刚才的面试来看，你觉得我有什么不足之处这就是标准的面试过程，面试结束后如果你通过面试的话，一般一周内会给答复或者进行下一轮面试。</li></ol><p>最后需要强调的是，公司面试周期一般都会比较长，可能你从二月底开始面试，到了四月份你才会收到 offer，所以你应该多投投几家公司，不要在一棵树上吊死，不要抱着非 xxx 公司不去的心态，因为面试这种东西其实是很玄学的，七分实力，三分运气，可能你觉得良好，但是面试官却把你 pass 掉了，所以放平常心，多试试几家公司，说不定会有意外的收获。</p><h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><p>前面介绍了面试流程中的一些注意事项，下面就来说说如何去做面试前的准备。我将面试准备分为三个部分：</p><ol><li>准备简历</li><li>专业知识梳理</li><li>面试结束后</li></ol><h3 id="准备简历"><a href="#准备简历" class="headerlink" title="准备简历"></a>准备简历</h3><p>我看很多人写的简历，发现他们写的都很啰嗦，让人一眼看过去抓不住重点，我建议最好把简历精简一下，控制在 1-2 页，写的经历和项目跟你应聘的岗位有强相关，无关的经历就不要写了，写了反而显得啰嗦。</p><p>另外还有三点需要注意：</p><ol><li>描述经历或者项目的时候尽可能描述跟自己负责的模块，无关的内容就不要写了，不然被问到了可能会问惨你</li><li>写完简历的时候最好以 pdf 的格式进行存储，这样保证面试官打开的时候排版不会乱掉</li><li>简历名称最好写成像 姓名-应聘岗位-xx大学-xx专业-手机号，这样方便 HR 保留存储你的简历，不要直接取名为简历就直接发给 HR</li></ol><p>简历是你获得面试的第一步，简历的好坏需要自己用心准备，希望同学们提前认真地准备好一份觉得让自己满意的简历，以免到时候太仓促。</p><h3 id="专业知识梳理"><a href="#专业知识梳理" class="headerlink" title="专业知识梳理"></a>专业知识梳理</h3><p>这部分内容肯定是需要通过自己的不断积累的，不可能说你看了两天 JS 语法就跑来面试，学了两天 Java 就来面试后端工程师。</p><p>我们经常会通过网上文章学习内容，我的建议：善于使用浏览器的书签帮助你自己整体知识。</p><ol><li>比如说你今天看到一篇文章，但是没时间看完消化，你可以把它放到一个书签(do it later)以免之后找不到，等自己有时间了再回过头来继续看</li><li>将自己看过的，觉得不错的文章进行分类整理放在书签中，方便以后面试前可以复习</li></ol><p>网路上学习技术的途径也很多：</p><ol><li>如果想看别人写的文章，可以多逛逛掘金、知乎专栏等等</li><li>如果像通过看视频来学习的话，可以通过慕课网平台，上面有不少高质量视频可以学习</li><li>遇到问题善用搜索引擎，基本上你遇到的问题都可以通过谷歌/Stackoverflow 上得到答案</li></ol><p>每个岗位都有自己不同的知识体系，在其它领域我也不是专业的，就不班门弄斧了，我就拿前端工程师角度来看，作为一名前端工程师，至少要对整体知识体系有自己的理解.</p><h3 id="面试结束后"><a href="#面试结束后" class="headerlink" title="面试结束后"></a>面试结束后</h3><p>面试其实很多情况下都是很类似的，有的时候一面和二面的面试官都会问到相同的问题，所以在面试结束可以总结总结刚才面试中遇到的问题，为什么答不上来，如果是之前没准备的知识，可以去复习复习，这样下次再碰到类似的题目，你就可以对答如流了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>祝各位同学能够找到自己满意的offer！</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>观察者模式VS发布订阅模式</title>
      <link>http://mydearest.cn/2020/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8FVS%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</link>
      <guid>http://mydearest.cn/2020/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8FVS%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</guid>
      <pubDate>Fri, 27 Mar 2020 16:08:14 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://cdn.mydearest.cn/subscribe.png&quot; alt=&quot;subscribe&quot;&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;观察者与目标（被观察者）是直接进行交互的，包括订阅和触发。&lt;/li&gt;
&lt;li&gt;发布订阅模式是透过一个中间者当调度中心，相关的订阅与发布都由调度中心来进行协调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者的优缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;观察者模式：优点就是一一对应，比较直观明了，占用内存资源容易进行回收。缺点就是两者耦合。&lt;/li&gt;
&lt;li&gt;发布订阅模式：优点就是一方面实现了发布者与订阅者之间的解耦，中间者可在两者操作之间进行更细粒度的控制。如：条件过滤发布，权限控制等等。缺点就是整一个中间调度会越来越庞大，需要手动清除里面的发布回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;观察者模式：彩票中心里，管理员充当目标对象（被观察者），彩民充当观察者，当管理员说公布一等奖号码时，即给各个观察者发布了消息，然后彩民（观察者）就收到发布消息，进行自己的后续操作（兑奖）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发布订阅模式：每家每户向牛奶订购中心订购了牛奶，但是各家的牛奶品牌不一样，有燕塘、蒙牛等等。当燕塘牛奶来货了，订阅中心就给订购燕塘的各家各户派发燕塘牛奶。同理，当蒙牛到货时，订阅中心发布蒙牛的牛奶。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://cdn.mydearest.cn/subscribe.png" alt="subscribe"></p><p>从图中可以看出：</p><ul><li>观察者与目标（被观察者）是直接进行交互的，包括订阅和触发。</li><li>发布订阅模式是透过一个中间者当调度中心，相关的订阅与发布都由调度中心来进行协调。</li></ul><p>两者的优缺点：</p><ul><li>观察者模式：优点就是一一对应，比较直观明了，占用内存资源容易进行回收。缺点就是两者耦合。</li><li>发布订阅模式：优点就是一方面实现了发布者与订阅者之间的解耦，中间者可在两者操作之间进行更细粒度的控制。如：条件过滤发布，权限控制等等。缺点就是整一个中间调度会越来越庞大，需要手动清除里面的发布回调。</li></ul><p>举个栗子：</p><ul><li><p>观察者模式：彩票中心里，管理员充当目标对象（被观察者），彩民充当观察者，当管理员说公布一等奖号码时，即给各个观察者发布了消息，然后彩民（观察者）就收到发布消息，进行自己的后续操作（兑奖）。</p></li><li><p>发布订阅模式：每家每户向牛奶订购中心订购了牛奶，但是各家的牛奶品牌不一样，有燕塘、蒙牛等等。当燕塘牛奶来货了，订阅中心就给订购燕塘的各家各户派发燕塘牛奶。同理，当蒙牛到货时，订阅中心发布蒙牛的牛奶。</p></li></ul><hr><a id="more"></a><h2 id="观察者模式实现"><a href="#观察者模式实现" class="headerlink" title="观察者模式实现"></a>观察者模式实现</h2><p><img src="http://cdn.mydearest.cn/blog/images/observer.jpeg" alt="observer"></p><p>首先目标对象（被观察者）称为<code>Subject</code>，有若干个观察者<code>Observer</code>进行观察。当<code>Subject</code>被某些对应事件驱动了，则通知相对应的观察者，调用其回调操作。</p><p>代码实现如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">this</span>.obs = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加观察者</span></span><br><span class="line">    addObserver (ob) &#123;</span><br><span class="line">        <span class="keyword">this</span>.obs.push(ob);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">this</span>.obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> &#123;</span><br><span class="line">            ob.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  update()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'update'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">let</span> ob = <span class="keyword">new</span> Observer();</span><br><span class="line"><span class="comment">// 目标添加观察者了</span></span><br><span class="line">subject.addObserver(ob);</span><br><span class="line"><span class="comment">// 目标发布消息调用观察者的更新方法了</span></span><br><span class="line">subject.notify();   <span class="comment">//update</span></span><br></pre></td></tr></table></figure></p><h2 id="发布订阅模式实现"><a href="#发布订阅模式实现" class="headerlink" title="发布订阅模式实现"></a>发布订阅模式实现</h2><p>首先要构造一个总线控制中心，负责中间操作，实现以下三个功能：</p><ul><li>订阅xxx消息</li><li>发布xxx消息</li><li>取消订阅xxx消息</li></ul><p>代码实现如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventProxy = &#123;</span><br><span class="line">  onList: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅</span></span><br><span class="line">  on: <span class="function"><span class="keyword">function</span> (<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.onList[key]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onList[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.onList[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  off: <span class="function"><span class="keyword">function</span>(<span class="params">key, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.onList[key]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fnIndex = <span class="keyword">this</span>.onList[key].indexOf(fn)</span><br><span class="line">    <span class="keyword">if</span> (fnIndex === <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.onList[key].splice(fnIndex, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 发布</span></span><br><span class="line">  emit: <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!args.length) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有任何订阅则返回  </span></span><br><span class="line">    <span class="keyword">const</span> key = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.onList[key] || !<span class="keyword">this</span>.onList[key].length) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布对应的订阅事件</span></span><br><span class="line">    <span class="keyword">const</span> subscriber = <span class="keyword">this</span>.onList[key]</span><br><span class="line">    <span class="keyword">const</span> newArgs = args.slice(<span class="number">1</span>)</span><br><span class="line">    subscriber.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">      cb.apply(<span class="literal">null</span>, newArgs)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8FVS%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Shell入门教程</title>
      <link>http://mydearest.cn/2020/Shell%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html</link>
      <guid>http://mydearest.cn/2020/Shell%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html</guid>
      <pubDate>Sun, 22 Mar 2020 17:51:18 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;脚本运行&quot;&gt;&lt;a href=&quot;#脚本运行&quot; class=&quot;headerlink&quot; title=&quot;脚本运行&quot;&gt;&lt;/a&gt;脚本运行&lt;/h2&gt;&lt;p&gt;建立一个文本文件demo，以.sh结尾的或者不需要后缀都可以。
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NUM=10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;printf &quot;输出数字$NUM\n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo $NUM&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过sh或者bash命令运行脚本，sh scriptname 运行一个Bash脚本将会禁止所有Bash的扩展特性。
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 你能够运行它用命令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sh demo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 另外也也可以用bash来执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bash demo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;脚本以”#!”行开头，行将会命令解释器(sh或是bash)。&lt;code&gt;#!/bin/rm&lt;/code&gt; 当你运行这个脚本时，除了这个脚本消失了之外，你不会发现更多其他的东西。&lt;/p&gt;
&lt;h2 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h2&gt;&lt;p&gt;以#开头的行就是注释，会被解释器忽略。注释行前面也可以有空白字符。
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 这是一个注释&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;命令分隔符&quot;&gt;&lt;a href=&quot;#命令分隔符&quot; class=&quot;headerlink&quot; title=&quot;命令分隔符&quot;&gt;&lt;/a&gt;命令分隔符&lt;/h2&gt;&lt;p&gt;分号;命令分割符，分割符允许在同一行里有两个或更多的命令。
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo hello; echo there         # 输出 hello 和 there&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;filename=&#39;cosyer&#39;               # 变量文件名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if [ -x &quot;$filename&quot; ]; then    # 注意：&quot;if&quot; and &quot;then&quot;需要分隔符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &quot;File $filename exists.&quot;; cp $filename $filename.bak&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  echo &quot;File $filename not found.&quot;; touch $filename&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi; echo &quot;File test complete.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;结束符&quot;&gt;&lt;a href=&quot;#结束符&quot; class=&quot;headerlink&quot; title=&quot;结束符&quot;&gt;&lt;/a&gt;结束符&lt;/h2&gt;&lt;p&gt;双分号;;，case语句分支的结束符。
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;read Keypress&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case &quot;$Keypress&quot; in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[:lower:]]   ) echo &quot;Lowercase letter&quot;;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[:upper:]]   ) echo &quot;Uppercase letter&quot;;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [0-9]         ) echo &quot;Digit&quot;;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *             ) echo &quot;Punctuation, whitespace, or other&quot;;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;esac      #  允许字符串的范围出现在[]中,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          #+ 或者POSIX风格的[[中.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exit 0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h2><p>建立一个文本文件demo，以.sh结尾的或者不需要后缀都可以。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">NUM=10</span><br><span class="line">printf "输出数字$NUM\n"</span><br><span class="line">echo $NUM</span><br></pre></td></tr></table></figure></p><p>通过sh或者bash命令运行脚本，sh scriptname 运行一个Bash脚本将会禁止所有Bash的扩展特性。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 你能够运行它用命令</span></span><br><span class="line">sh demo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 另外也也可以用bash来执行</span></span><br><span class="line">bash demo</span><br></pre></td></tr></table></figure></p><p>脚本以”#!”行开头，行将会命令解释器(sh或是bash)。<code>#!/bin/rm</code> 当你运行这个脚本时，除了这个脚本消失了之外，你不会发现更多其他的东西。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>以#开头的行就是注释，会被解释器忽略。注释行前面也可以有空白字符。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这是一个注释</span></span><br></pre></td></tr></table></figure></p><h2 id="命令分隔符"><a href="#命令分隔符" class="headerlink" title="命令分隔符"></a>命令分隔符</h2><p>分号;命令分割符，分割符允许在同一行里有两个或更多的命令。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo hello; echo there         # 输出 hello 和 there</span><br><span class="line">filename='cosyer'               # 变量文件名</span><br><span class="line">if [ -x "$filename" ]; then    # 注意："if" and "then"需要分隔符</span><br><span class="line">  echo "File $filename exists."; cp $filename $filename.bak</span><br><span class="line">else</span><br><span class="line">  echo "File $filename not found."; touch $filename</span><br><span class="line">fi; echo "File test complete.</span><br></pre></td></tr></table></figure></p><h2 id="结束符"><a href="#结束符" class="headerlink" title="结束符"></a>结束符</h2><p>双分号;;，case语句分支的结束符。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">read Keypress</span><br><span class="line">case "$Keypress" in</span><br><span class="line">  [[:lower:]]   ) echo "Lowercase letter";;</span><br><span class="line">  [[:upper:]]   ) echo "Uppercase letter";;</span><br><span class="line">  [0-9]         ) echo "Digit";;</span><br><span class="line">  *             ) echo "Punctuation, whitespace, or other";;</span><br><span class="line">esac      #  允许字符串的范围出现在[]中,</span><br><span class="line">          #+ 或者POSIX风格的[[中.</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></p><hr><a id="more"></a><h2 id="句号-圆点"><a href="#句号-圆点" class="headerlink" title="句号/圆点"></a>句号/圆点</h2><p>作为一个文件名的组成部分.，当点.以一个文件名为前缀时，起作用使该文件变成了隐藏文件。这种隐藏文件ls一般是不会显示出来的。</p><p>作为目录名时，单个点（.）表示当前目录，两个点(..)表示上一级目录（或称为父目录）。</p><p>点(.)字符匹配。作为正则表达式的一部分,匹配字符时，单点（.）表示匹配任意一个字符。</p><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>引号一个很重要的作用是保护命令行上的一个参数不被shell解释，而把此参数传递给要执行的程序来处理它。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "$(ls -al)"</span><br></pre></td></tr></table></figure></p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str='this is a string'</span><br></pre></td></tr></table></figure><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</p><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your_name='cosyer'</span><br><span class="line">str="Hello, I know your are \"$your_name\"! \n"</span><br></pre></td></tr></table></figure><p>双引号里可以有变量，双引号里可以出现转义字符。</p><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>命令替换”`”，将会重新分配一个命令甚至是多个命令的输出；它会将命令的输出如实地添加到另一个上下文中。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">script_name=`basename $0`</span><br><span class="line">echo "The name of this script is $script_name."</span><br><span class="line"></span><br><span class="line">textfile_listing=`ls *`</span><br><span class="line"><span class="meta">#</span><span class="bash"> 变量中包含了当前工作目录下所有的*文件</span></span><br><span class="line">echo $textfile_listing</span><br></pre></td></tr></table></figure></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>变量赋值，初始化或改变一个变量的值，通用的变量赋值操作符，可以用于数值和字符串的赋值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var=27</span><br><span class="line">category=minerals  # "="字符后面不能加空白字符.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> = 用于测试操作符</span></span><br><span class="line">if [ "$string1" = "$string2" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span> [ <span class="string">"X<span class="variable">$string1</span>"</span> = <span class="string">"X<span class="variable">$string2</span>"</span> ] 会更安全,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 它为了防止其中有一个字符串为空时产生错误信息.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (增加的<span class="string">"X"</span>字符可以互相抵消.) </span></span><br><span class="line">then</span><br><span class="line">   command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h3 id="计算操作符"><a href="#计算操作符" class="headerlink" title="计算操作符"></a>计算操作符</h3><table><thead><tr><th>操作符</th><th>描述</th><th>操作符</th><th>描述</th><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code></td><td>加</td><td><code>/</code></td><td>除</td><td><code>**</code></td><td>求幂</td></tr><tr><td><code>-</code></td><td>减</td><td><code>*</code></td><td>乘</td><td><code>%</code></td><td>求模</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Bash在版本2.02引入了<span class="string">"**"</span>求幂操作符.</span></span><br><span class="line">let "z=5**3"</span><br><span class="line">echo "z = $z"   # z = 125</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 求模（它返回整数整除一个数后的余数）</span></span><br><span class="line">let "y=5 % 3"</span><br><span class="line">echo "y = $y"   # y = 2</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>+=</code></td><td>加等(plus-equal) 把原变量值增加一个常量并重新赋值给变量</td></tr><tr><td><code>-=</code></td><td>减等(minus-equal) 把原变量值减少一个常量并重新赋值给变量</td></tr><tr><td><code>*=</code></td><td>乘等(times-equal) 把原变量值乘上一个常量并重新赋值给变量</td></tr><tr><td><code>/=</code></td><td>除等(slash-equal) 把原变量值除以一个常量并重新赋值给变量</td></tr><tr><td><code>%=</code></td><td>模等(mod-equal) 把原变量值除以一个常量整除（即取模）并重新赋余数的值给变量</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let "var += 5" # 会使变量var值加了5并把值赋给var.</span><br><span class="line">let "var *= 4" # 使变量var的值乘上4并把值赋给var.</span><br></pre></td></tr></table></figure><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>位操作符很少在脚本中使用。他们主要用于操作和测试从端口或sockets中读到的数据。“位运算”更多地用于编译型的语言，比如说C和C++，它们运行起来快地像飞。</p><table><thead><tr><th>操作符</th><th>描述</th><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;&lt;</code></td><td>位左移（每移一位相当乘以2）</td><td>`</td><td>`</td><td>位或</td></tr><tr><td><code>&lt;&lt;=</code></td><td>位左移赋值</td><td>`</td><td>=`</td><td>位或赋值</td></tr><tr><td><code>&gt;&gt;</code></td><td>位右移（每移一位相当除以2）</td><td><code>~</code></td><td>位反</td></tr><tr><td><code>&gt;&gt;=</code></td><td>“位右移赋值”（和&lt;&lt;=相反）</td><td><code>!</code></td><td>位非</td></tr><tr><td><code>&amp;</code></td><td>位与</td><td><code>^</code></td><td>位或</td></tr><tr><td><code>&amp;=</code></td><td>位于赋值</td><td><code>^=</code></td><td>位或赋值</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &lt;&lt;=</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">"位左移赋值"</span></span></span><br><span class="line">let "var &lt;&lt;= 2" 结果使var的二进制值左移了二位（相当于乘以4）</span><br></pre></td></tr></table></figure><h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>逻辑与<code>&amp;&amp;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ $condition1 ] &amp;&amp; [ $condition2 ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于:  <span class="keyword">if</span> [ <span class="variable">$condition1</span> -a <span class="variable">$condition2</span> ]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果condition1和condition2都为真则返回真...</span></span><br><span class="line">fi;</span><br><span class="line"></span><br><span class="line">if [[ $condition1 &amp;&amp; $condition2 ]]    # Also works.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意&amp;&amp;操作不能在[ ... ]结构中使用.</span></span><br><span class="line">fi;</span><br></pre></td></tr></table></figure><p>逻辑或<code>||</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ $condition1 ] || [ $condition2 ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于:  <span class="keyword">if</span> [ <span class="variable">$condition1</span> -o <span class="variable">$condition2</span> ]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果condition1和condition2有一个为真则返回真...</span></span><br><span class="line">fi;</span><br><span class="line">if [[ $condition1 || $condition2 ]]    # Also works.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意||操作不能在[ ... ]结构中使用.</span></span><br><span class="line">fi;</span><br></pre></td></tr></table></figure><p>使用&amp;&amp;和||进行混合条件测试。在算术计算的环境中，&amp;&amp;和||操作符也可以使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $(( 1 &amp;&amp; 2 )) $((3 &amp;&amp; 0)) $((4 || 0)) $((0 || 0))</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 0 1 0</span></span><br></pre></td></tr></table></figure><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><p>逗号<code>,</code>操作符连接两个或更多的算术操作。所有的操作都被求值(可能会有副作用)，但只返回最后一个操作的结构。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let "t1 = ((5 + 3, 7 - 1, 15 - 4))"</span><br><span class="line">echo "t1 = $t1"               # t1 = 11</span><br><span class="line"></span><br><span class="line">let "t2 = ((a = 9, 15 / 3))"  # 初始化"a"并求"t2"的值.</span><br><span class="line">echo "t2 = $t2    a = $a"     # t2 = 5    a = 9</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量，是脚本编程中的如何进行数据表现的办法。它们可以在算术计算中作为操作数，在一个字符串表达式中作为符号表达抽象的意义或是其他的其它意义。变量是表示计算机内存中保存一种数据需要占的一个位置或一组的位置的标识。</p><h3 id="变量值"><a href="#变量值" class="headerlink" title="变量值"></a>变量值</h3><p>如果variable1是一个变量的名字，那么$variable1就是引用这个变量的值――即这个变量它包含的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1=12</span><br><span class="line">echo $t1</span><br></pre></td></tr></table></figure><p>一个未初始化的变量有一个”null”值――表示从没有被赋值过（注意null值不等于零）。在一个变量从未赋值之前就使用它通常会引起问题。然而，仍然有可能在执行算术计算时使用一个未初始化的变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo "$uninitialized"      # (blank line)</span><br><span class="line">let "uninitialized += 5"   # Add 5 to it.</span><br><span class="line">echo "$uninitialized"      # 5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  结论:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  一个未初始化的变量没有值，</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  但是似乎它在算术计算中的值是零。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  这个无法证实（也可能是不可移植）的行为。</span></span><br></pre></td></tr></table></figure><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 变量名不加美元符号</span></span><br><span class="line">your_var="elaine"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新定义</span></span><br><span class="line">your_var="newname"</span><br></pre></td></tr></table></figure><p><strong>注意⚠️</strong></p><ol><li>首个字符必须为字母（a-z，A-Z）。</li><li>中间不能有空格，可以使用下划线（_），等号左右也不能有空格。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ol><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">github="https://jaywcjlove.github.io"</span><br><span class="line">readonly github</span><br><span class="line">github="https://www.github.com"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行脚本，结果如下：</span></span><br><span class="line">/bin/sh: NAME: This variable is read only.</span><br></pre></td></tr></table></figure><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_var="github"</span><br><span class="line">echo $your_var</span><br><span class="line">echo $&#123;your_var&#125;</span><br><span class="line">echo "your name is $&#123;your_var&#125;-l"</span><br></pre></td></tr></table></figure><h3 id="删除变量unset"><a href="#删除变量unset" class="headerlink" title="删除变量unset"></a>删除变量unset</h3><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myUrl="https://jaywcjlove.github.io"</span><br><span class="line">unset myUrl</span><br><span class="line">echo $myUrl</span><br></pre></td></tr></table></figure><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>不同与许多其他的编程语言，Bash不以”类型”来区分变量。本质上来说，Bash变量是字符串，但是根据环境的不同，Bash允许变量有整数计算和比较。其中的决定因素是变量的值是不是只含有数字。</p><ol><li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ol><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><table><thead><tr><th>内部变量</th><th>说明</th></tr></thead><tbody><tr><td>$BASH</td><td>Bash二进制程序文件的路径</td></tr><tr><td>$BASH_ENV</td><td>该环境变量保存一个Bash启动文件路径，当启动一个脚本程序时会去读该环境变量指定的文件。</td></tr><tr><td>$BASH_SUBSHELL</td><td>一个指示子shell(subshell)等级的变量。它是Bash版本3新加入的。</td></tr><tr><td>$BASH_VERSINFO[n]</td><td>这个数组含有6个元素，指示了安装的Bash版本的信息。它和$BASH_VERSION相似，但它们还是有一些小小的不同。</td></tr><tr><td>$BASH_VERSION</td><td>安装在系统里的Bash版本。</td></tr><tr><td>$DIRSTACK</td><td>在目录堆栈里面最顶端的值(它受pushd和popd的控制)</td></tr><tr><td>$EDITOR</td><td>由脚本调用的默认的编辑器，一般是vi或是emacs。</td></tr><tr><td>$EUID</td><td>有效用户ID</td></tr><tr><td>$FUNCNAME</td><td>当前函数的名字</td></tr><tr><td>$GLOBIGNORE</td><td>由通配符(globbing)扩展的一列文件名模式。</td></tr><tr><td>$GROUPS</td><td>目前用户所属的组</td></tr><tr><td>$HOME</td><td>用户的家目录，通常是/home/username</td></tr><tr><td>$HOSTNAME</td><td>在系统启动时由一个初始化脚本中用hostname命令给系统指派一个名字。然而，gethostname()函数能设置Bash内部变量E$HOSTNAME。</td></tr><tr><td>$HOSTTYPE</td><td>机器类型，像$MACHTYPE一样标识系统硬件。</td></tr><tr><td>$IFS</td><td>内部字段分隔符</td></tr><tr><td>$IGNOREEOF</td><td>忽略EOF：在退出控制台前有多少文件结尾标识（end-of-files,control-D）会被shell忽略。</td></tr><tr><td>$LC_COLLATE</td><td>它常常在.bashrc或/etc/profile文件里被设置，它控制文件名扩展和模式匹配的展开顺序。</td></tr><tr><td>$LINENO</td><td>这个变量表示在本shell脚本中该变量出现时所在的行数。它只在脚本中它出现时有意义，它一般可用于调试。</td></tr><tr><td>$MACHTYPE</td><td>机器类型，识别系统的硬件类型。</td></tr><tr><td>$OLDPWD</td><td>上一次工作的目录(“OLD-print-working-directory”,你上一次进入工作的目录)</td></tr><tr><td>$TZ</td><td>时区</td></tr><tr><td>$MAILCHECK</td><td>每隔多少秒检查是否有新的信件</td></tr><tr><td>$OSTYPE</td><td>操作系统类型</td></tr><tr><td>$MANPATH man</td><td>指令的搜寻路径</td></tr><tr><td>$PATH</td><td>可执行程序文件的搜索路径。一般有/usr/bin/, /usr/X11R6/bin/, /usr/local/bin,等等。</td></tr><tr><td>$PIPESTATUS</td><td>此数组变量保存了最后执行的前台管道的退出状态。相当有趣的是，它不一定和最后执行的命令的退出状态一样。</td></tr><tr><td>$PPID</td><td>一个进程的$PPID变量保存它的父进程的进程ID(pid)。用这个变量和pidof命令比较。</td></tr><tr><td>$PROMPT_COMMAND</td><td>这个变量在主提示符前($PS1显示之前)执行它的值里保存的命令。</td></tr><tr><td>$PS1</td><td>这是主提示符（第一提示符），它能在命令行上看见。</td></tr><tr><td>$PS2</td><td>副提示符（第二提示符），它在期望有附加的输入时能看见。它显示像”&gt;”的提示。</td></tr><tr><td>$PS3</td><td>第三提示符。它在一个select循环里显示 (参考例子 10-29)。</td></tr><tr><td>$PS4</td><td>第四提示符，它在用-x选项调用一个脚本时的输出的每一行开头显示。它通常显示像”+”的提示。</td></tr><tr><td>$PWD</td><td>工作目录(即你现在所处的目录) ，它类似于内建命令pwd。</td></tr><tr><td>$REPLY</td><td>没有变量提供给read命令时的默认变量．这也适用于select命令的目录，但只是提供被选择的变量项目编号而不是变量本身的值。</td></tr><tr><td>$SECONDS</td><td>脚本已运行的秒数。</td></tr><tr><td>$SHELLOPTS</td><td>已经激活的shell选项列表，它是一个只读变量。</td></tr><tr><td>$SHLVL</td><td>SHELL的嵌套级别．指示了Bash被嵌套了多深．在命令行里，$SHLVL是1，因此在一个脚本里，它是2</td></tr><tr><td>$TMOUT</td><td>如果$TMOUT环境变量被设为非零值时间值time，那么经过time这么长的时间后，shell提示符会超时．这将使此shell退出登录</td></tr><tr><td>$UID</td><td>用户ID号，这是当前用户的用户标识号，它在/etc/passwd文件中记录。</td></tr></tbody></table><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>传递到脚本的参数个数</td></tr><tr><td><code>$*</code></td><td>以一个单字符串显示所有向脚本传递的参数。如”∗”用「”」括起来的情况、以”1 2…n”的形式输出所有参数。</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程ID号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的ID号</td></tr><tr><td><code>$@</code></td><td>与∗相同，但是使用时加引号，并在引号中返回每个参数。如”@”用「”」括起来的情况、以”1””2” … “$n” 的形式输出所有参数。</td></tr><tr><td><code>$-</code></td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td><code>$?</code></td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h3 id="字串移动"><a href="#字串移动" class="headerlink" title="字串移动"></a>字串移动</h3><p><code>${string#substring}</code>从$string左边开始，剥去最短匹配$substring子串。<br><code>${string##substring}</code>从$string左边开始，剥去最长匹配$substring子串。<br><code>${string%substring}</code> 从$string结尾开始，剥去最短匹配$substring子串。<br><code>${string%%substring}</code>从$string结尾开始，剥去最长匹配$substring子串。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String=abcABC123ABCabc</span><br><span class="line"><span class="meta">#</span><span class="bash">       ├----┘     ┆</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       └----------┘</span></span><br><span class="line"></span><br><span class="line">echo $&#123;String#a*C&#125;      # 123ABCabc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 剥去匹配<span class="string">'a'</span>到<span class="string">'C'</span>之间最短的字符串.</span></span><br><span class="line"></span><br><span class="line">echo $&#123;String##a*C&#125;     # abc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 剥去匹配<span class="string">'a'</span>到<span class="string">'C'</span>之间最长的字符串.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String=abcABC123ABCabc</span><br><span class="line"><span class="meta">#</span><span class="bash">       ┆           ||</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       └------------┘</span></span><br><span class="line"></span><br><span class="line">echo $&#123;String%b*c&#125;      # abcABC123ABCa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从<span class="variable">$String</span>后面尾部开始，剥去匹配<span class="string">'a'</span>到<span class="string">'C'</span>之间最短的字符串.</span></span><br><span class="line"></span><br><span class="line">echo $&#123;String%%b*c&#125;     # a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从<span class="variable">$String</span>后面尾部开始，剥去匹配<span class="string">'a'</span>到<span class="string">'C'</span>之间最长的字符串.</span></span><br></pre></td></tr></table></figure><h3 id="用awk处理字符串"><a href="#用awk处理字符串" class="headerlink" title="用awk处理字符串"></a>用awk处理字符串</h3><p>Bash脚本可以调用awk的字符串操作功能来代替它自己内建的字符串操作符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String=23skidoo1</span><br><span class="line"><span class="meta">#</span><span class="bash">      012345678    Bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      123456789    awk</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意上面两个程序对索引的不同处理:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Bash把字符串的第一个字符的标号称为<span class="string">'0'</span>。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Awk把字符串的第一个字符的标号称为<span class="string">'1'</span>。</span></span><br><span class="line"></span><br><span class="line">echo $&#123;String:2:4&#125; # position 3 (0-1-2), 4 characters long</span><br><span class="line">                                         # skid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在awk中与Bash的<span class="variable">$&#123;string:pos:length&#125;</span>等同的是substr(string,pos,length)。</span></span><br><span class="line">echo | awk '&#123; </span><br><span class="line">  print substr("'"$&#123;String&#125;"'",3,4)      # skid</span><br><span class="line">&#125;'</span><br><span class="line"><span class="meta">#</span><span class="bash">  用一个空的<span class="string">"echo"</span>由管道传一个空的输入给awk,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">+ 这样就不必提供一个文件名给awk。</span></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h2 id="for-while"><a href="#for-while" class="headerlink" title="for/while"></a>for/while</h2><p>重复一些命令的代码块,如果条件不满足就退出循环。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>在循环的每次执行中，arg将顺序的存取list中列出的变量，下面是一个基本的循环结构。</p><blockquote><p>for arg in [list]<br>do<br>   command(s)…<br>done  </p></blockquote><p>每个<code>[list]</code>中的元素都可能包含多个参数，在处理参数组时，这是非常有用的，使用set命令来强制解析每个<code>[list]</code>中的元素。并且分配每个解析出来的部分到一个位置参数中。</p><p>循环的一个简单例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto</span><br><span class="line">do</span><br><span class="line">  echo $planet  # 每个行星被单独打印在一行上.</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>一个while循环可以有多个判断条件，但是只有最后一个才能决定是否退出循环。然而这需要一种有点不同的循环语法。</p><blockquote><p>while [condition]<br>do<br>  command…<br>done  </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> --------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 简单的<span class="keyword">while</span>循环</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------</span></span><br><span class="line">var0=0</span><br><span class="line">LIMIT=10</span><br><span class="line"></span><br><span class="line">while [ "$var0" -lt "$LIMIT" ]</span><br><span class="line">do</span><br><span class="line">  echo -n "$var0 "        # -n 将会阻止产生新行。</span><br><span class="line"><span class="meta">  #</span><span class="bash">             ^           空格,数字之间的分隔。</span></span><br><span class="line">  var0=`expr $var0 + 1`   # var0=$(($var0+1))  也可以。</span><br><span class="line">                          # var0=$((var0 + 1)) 也可以。</span><br><span class="line">                          # let "var0 += 1"    也可以。</span><br><span class="line">done                      # 使用其他的方法也行。</span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多条件的<span class="keyword">while</span>循环</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------</span></span><br><span class="line">var1=unset</span><br><span class="line">previous=$var1</span><br><span class="line"></span><br><span class="line">while echo "previous-variable = $previous"</span><br><span class="line">      echo</span><br><span class="line">      previous=$var1</span><br><span class="line">      [ "$var1" != end ] # 记录之前的$var1.</span><br><span class="line">      # 这个"while"循环中有4个条件, 但是只有最后一个能控制循环.</span><br><span class="line">      # 退出状态由第4个条件决定.</span><br><span class="line">do</span><br><span class="line">echo "Input variable #1 (end to exit) "</span><br><span class="line">  read var1</span><br><span class="line">  echo "variable #1 = $var1"</span><br><span class="line">done </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><p>这个结构在循环的顶部判断条件，并且如果条件一直为false那就一直循环下去。(与while相反)。</p><blockquote><p>until [condition-is-true]<br>do<br>  command…<br>done  </p></blockquote><p><strong>注意⚠️</strong></p><ol><li>until循环的判断在循环的顶部，这与某些编程语言是不同的。</li><li>与for循环一样，如果想把do和条件放在一行里，就使用”;”。</li></ol><blockquote><p>until [condition-is-true] ; do</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">END_CONDITION=end</span><br><span class="line">until [ "$var1" = "$END_CONDITION" ]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在循环的顶部判断条件.</span></span><br><span class="line">do</span><br><span class="line">  echo "Input variable #1 "</span><br><span class="line">  echo "($END_CONDITION to exit)"</span><br><span class="line">  read var1</span><br><span class="line">  echo "variable #1 = $var1"</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>嵌套循环就是在一个循环中还有一个循环，内部循环在外部循环体中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">outer=1             # 设置外部循环计数.</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始外部循环.</span></span><br><span class="line">for a in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">  echo "Pass $outer in outer loop."</span><br><span class="line">  echo "---------------------"</span><br><span class="line">  inner=1           # 重设内部循环的计数.</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> ===============================================</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 开始内部循环.</span></span><br><span class="line">  for b in 1 2 3 4 5</span><br><span class="line">  do</span><br><span class="line">    echo "Pass $inner in inner loop."</span><br><span class="line">    let "inner+=1"  # 增加内部循环计数.</span><br><span class="line">  done</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 内部循环结束.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> ===============================================</span></span><br><span class="line"></span><br><span class="line">  let "outer+=1"    # 增加外部循环的计数.</span><br><span class="line">  echo              # 每次外部循环之间的间隔.</span><br><span class="line">done               </span><br><span class="line"><span class="meta">#</span><span class="bash"> 外部循环结束.</span></span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p>影响循环行为的命令 <code>break</code>， <code>continue</code>， break命令将会跳出循环，continue命令将会跳过本次循环下边的语句，直接进入下次循环。</p><p><strong>continue：</strong> continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LIMIT=19  # 上限</span><br><span class="line"></span><br><span class="line">echo "Printing Numbers 1 through 20 (but not 3 and 11)."</span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line"></span><br><span class="line">while [ $a -le "$LIMIT" ]</span><br><span class="line">do</span><br><span class="line">  a=$(($a+1))</span><br><span class="line">  if [ "$a" -eq 3 ] || [ "$a" -eq 11 ]  # Excludes 3 and 11.</span><br><span class="line">  then</span><br><span class="line">    continue      # 跳过本次循环剩下的语句.</span><br><span class="line">  fi</span><br><span class="line">  echo -n "$a "   # 在$a等于3和11的时候,这句将不会执行.</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>break：</strong> break命令允许跳出所有循环（终止执行后面的所有循环）。</p><p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，就要使用break命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n "Input a number between 1 to 5: "</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo "Your number is $aNum!"</span><br><span class="line">        ;;</span><br><span class="line">        *) echo "You do not select a number between 1 to 5, game is over!"</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>⚠️ 在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break n #表示跳出第 n 层循环。</span><br></pre></td></tr></table></figure><h2 id="case-select"><a href="#case-select" class="headerlink" title="case/select"></a>case/select</h2><p>case/select依靠在代码块的顶部或底部的条件判断来决定程序的分支。</p><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>case它允许通过判断来选择代码块中多条路径中的一条。它的作用和多个if/then/else语句相同，是它们的简化结构，特别适用于创建目录。</p><blockquote><p>case “$variable” in<br>  ?”$condition1” )<br>  ?command…<br>  ?;;<br>  ?”$condition2” )<br>  ?command…<br>  ?;;<br>esac  </p></blockquote><ul><li>对变量使用<code>&quot;&quot;</code>并不是强制的，因为不会发生单词分离。</li><li>每句测试行，都以右小括号<code>)</code>结尾。</li><li>每个条件块都以两个分号结尾<code>;;</code>。</li><li>case块的结束以esac(case的反向拼写)结尾。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">clear # 清屏.</span><br><span class="line"></span><br><span class="line">echo "          我的简历"</span><br><span class="line">echo "          ------- "</span><br><span class="line">echo "下面通过shell脚本输出我的简历" </span><br><span class="line">echo</span><br><span class="line">echo "[B]asicinfo, 基本信息"</span><br><span class="line">echo "[E]ducation, 教育经历"</span><br><span class="line">echo "[I]tskill, IT 技能"</span><br><span class="line">echo</span><br><span class="line">read person</span><br><span class="line">case "$person" in</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意,变量是被引用的.</span></span><br><span class="line">  "B" | "b" )</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 接受大写或小写输入.</span></span><br><span class="line">  echo</span><br><span class="line">  echo "小弟调调"</span><br><span class="line">  echo "手  机 : 136*****13"</span><br><span class="line">  echo "E-mail :wowohoo@qq.com"</span><br><span class="line">  echo "首  页 : http://JSLite.io"</span><br><span class="line">  ;;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 注意,在每个选项后边都需要以;;结尾.</span></span><br><span class="line"></span><br><span class="line">  "E" | "e" )</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 接受大写或小写输入.</span></span><br><span class="line">  echo "■ 2003年9月 到 2006年8月"</span><br><span class="line">  echo "----------------------------"</span><br><span class="line">  echo "› 学校 : 野鸟高中"</span><br><span class="line">  echo "› 专业 : 艺术类"</span><br><span class="line">  echo "› 学历 : 高中"</span><br><span class="line">  ;;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 后边的[I]tskill的信息在这里就省略了.</span></span><br><span class="line">          * )</span><br><span class="line"><span class="meta">   #</span><span class="bash"> 默认选项.</span></span><br><span class="line"><span class="meta">   #</span><span class="bash"> 空输入(敲RETURN).</span></span><br><span class="line">   echo</span><br><span class="line">   echo "没有数据！"</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select结构是建立菜单的另一种工具，这种结构是从ksh中引入的。</p><blockquote><p>select variable [in list]<br>do<br>  ?command…<br>  ?break<br>done  </p></blockquote><p>用select来创建菜单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS3='选择你喜欢的蔬菜: ' # 设置提示符字串.</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">select vegetable in "豆" "胡萝卜" "土豆" "洋葱" "芜菁甘蓝"</span><br><span class="line">do</span><br><span class="line">  echo</span><br><span class="line">  echo "你最喜欢的蔬菜是 $vegetable 。"</span><br><span class="line">  echo "讨厌!"</span><br><span class="line">  echo</span><br><span class="line">  break  # 如果这里没有'break'会发生什么?</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>如果忽略了in list列表,那么select命令将使用传递到脚本的命令行参数($@),或者是函数参数(当select是在函数中时）与忽略in list时的for语句相比较：<strong>for variable [in list]</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PS3='选择你喜欢的蔬菜:  '</span><br><span class="line">echo</span><br><span class="line">choice_of()&#123;</span><br><span class="line">  select vegetable</span><br><span class="line"><span class="meta">  #</span><span class="bash"> [<span class="keyword">in</span> list] 被忽略, 所以<span class="string">'select'</span>用传递给函数的参数.</span></span><br><span class="line">  do</span><br><span class="line">    echo</span><br><span class="line">    echo "你最喜欢的蔬菜是  $vegetable。"</span><br><span class="line">    echo "讨厌!"</span><br><span class="line">    echo</span><br><span class="line">    break</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">choice_of "豆" "米饭" "胡萝卜" "土豆" "洋葱" "芜菁甘蓝"</span><br><span class="line"><span class="meta">#</span><span class="bash">         <span class="variable">$1</span>   <span class="variable">$2</span>     <span class="variable">$3</span>      <span class="variable">$4</span>    <span class="variable">$5</span>     <span class="variable">$6</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">         传递给choice_of() 函数的参数</span></span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>和”真正的”编程语言一样，Bash也有函数，虽然在某些实现方面稍有些限制。 一个函数是一个子程序，用于实现一串操作的代码块(code block)，它是完成特定任务的”黑盒子”。 当有重复代码，当一个任务只需要很少的修改就被重复几次执行时, 这时你应考虑使用函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function function_name &#123; </span><br><span class="line">  command... </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">function_name () &#123; </span><br><span class="line">  command... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个函数内嵌套另一个函数也是可以的，但是不常用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f1 ()&#123;</span><br><span class="line">  f2 ()&#123; # nested</span><br><span class="line">    echo "Function \"f2\", inside \"f1\"."</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line">f2  #  引起错误.</span><br><span class="line">    #  就是你先"declare -f f2"了也没用.</span><br><span class="line"></span><br><span class="line">f1  #  什么也不做,因为调用"f1"不会自动调用"f2".</span><br><span class="line">f2  #  现在,可以正确的调用"f2"了,</span><br><span class="line">    #+ 因为之前调用"f1"使"f2"在脚本中变得可见了.</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>如果变量用local来声明，那么它只能在该变量声明的代码块(block of code)中可见，这个代码块就是局部”范围”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在函数内部的全局和局部变量.</span></span><br><span class="line">func ()</span><br><span class="line">&#123;</span><br><span class="line">  local loc_var=23       # 声明为局部变量.</span><br><span class="line">  echo                   # 使用内建的'local'关键字.</span><br><span class="line">  echo "\"loc_var\" in function = $loc_var"</span><br><span class="line">  global_var=999         # 没有声明为局部变量.</span><br><span class="line">                         # 默认为全局变量. </span><br><span class="line">  echo "\"global_var\" in function = $global_var"</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">func</span><br><span class="line"><span class="meta">#</span><span class="bash"> 现在，来看看是否局部变量<span class="string">"loc_var"</span>能否在函数外面可见.</span></span><br><span class="line">echo "\"loc_var\" outside function = $loc_var"</span><br><span class="line">                                   # $loc_var outside function = </span><br><span class="line">                                   # 不, $loc_var不是全局可访问的.</span><br><span class="line">echo "\"global_var\" outside function = $global_var"</span><br><span class="line">                                      # $global_var outside function = 999</span><br><span class="line">                                      # $global_var 是全局可访问的.</span><br><span class="line">exit 0</span><br><span class="line"><span class="meta">#</span><span class="bash">  与In contrast to C相比, 在函数内声明的Bash变量只有在</span></span><br><span class="line"><span class="meta">#</span><span class="bash">+ 它被明确声明成局部的变量时才是局部的</span></span><br></pre></td></tr></table></figure><p>⚠️ ：在函数调用之前，所有在函数内声明且没有明确声明为local的变量都可在函数体外可见</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func ()&#123;</span><br><span class="line">  global_var=37    #  在函数还没有被调用前</span><br><span class="line">                   #+ 变量只在函数内可见. </span><br><span class="line">&#125;                  #  函数结束</span><br><span class="line">echo "global_var = $global_var"  # global_var =</span><br><span class="line">                                 #  函数"func"还没有被调用,</span><br><span class="line">                                 #+ 所以变量$global_var还不能被访问.</span><br><span class="line">func</span><br><span class="line">echo "global_var = $global_var"  # global_var = 37</span><br><span class="line">                                 # 已经在函数调用时设置了值.</span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funWithParam()&#123;</span><br><span class="line">    echo "第一个参数为 $1 !"</span><br><span class="line">    echo "第二个参数为 $2 !"</span><br><span class="line">    echo "第十个参数为 $10 !"</span><br><span class="line">    echo "第十个参数为 $&#123;10&#125; !"</span><br><span class="line">    echo "第十一个参数为 $&#123;11&#125; !"</span><br><span class="line">    echo "参数总数有 $# 个!"</span><br><span class="line">    echo "作为一个字符串输出所有参数 $* !"</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>定义一个带有return语句的函数。函数返回值在调用该函数后通过 <code>$?</code> 来获得。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo "这个函数会对输入的两个数字进行相加运算..."</span><br><span class="line">    echo "输入第一个数字: "</span><br><span class="line">    read aNum</span><br><span class="line">    echo "输入第二个数字: "</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo "两个数字分别为 $aNum 和 $anotherNum !"</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo "输入的两个数字之和为 $? !"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个函数会对输入的两个数字进行相加运算...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入第一个数字: </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入第二个数字: </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 两个数字分别为 1 和 2 !</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入的两个数字之和为 3 !</span></span><br></pre></td></tr></table></figure><p>⚠️ <code>$10</code> 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</p><p><strong>特殊字符用来处理参数：</strong></p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试结构"><a href="#测试结构" class="headerlink" title="测试结构"></a>测试结构</h3><p>一个if/then结构能包含嵌套的比较和测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo "Testing \"false\""</span><br><span class="line">if [ "false" ]              #  "false"是一个字符串.</span><br><span class="line">then</span><br><span class="line">  echo "\"false\" is true." #+ 它被测试为真.</span><br><span class="line">else</span><br><span class="line">  echo "\"false\" is false."</span><br><span class="line">fi            # "false"为真.</span><br></pre></td></tr></table></figure><p>Else if 和 elif</p><p>elif是else if的缩写。作用是在一个if/then里嵌入一个内部的if/then结构。</p><p><code>[[]]</code>结构比Bash版本的<code>[]</code>更通用。用<code>[[ ... ]]</code>测试结构比用<code>[ ... ]</code>更能防止脚本里的许多逻辑错误。比如说，<code>&amp;&amp;</code>,<code>||</code>,<code>&lt;</code>和<code>&gt;</code>操作符能在一个<code>[[]]</code>测试里通过，但在<code>[]</code>结构会发生错误。</p><p><code>(( ))</code>结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及<code>[]</code>结构的讨论刚好相反。</p><h3 id="文件测试操作符"><a href="#文件测试操作符" class="headerlink" title="文件测试操作符"></a>文件测试操作符</h3><p>如果下面的条件成立返回真。</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>-e</td><td>文件存在</td></tr><tr><td>-a</td><td>文件存在，这个和-e的作用一样. 它是不赞成使用的，所以它的用处不大。</td></tr><tr><td>-f</td><td>文件是一个普通文件(不是一个目录或是一个设备文件)</td></tr><tr><td>-s</td><td>文件大小不为零</td></tr><tr><td>-d</td><td>文件是一个目录</td></tr><tr><td>-b</td><td>文件是一个块设备(软盘，光驱，等等。)</td></tr><tr><td>-c</td><td>文件是一个字符设备(键盘，调制解调器，声卡，等等。)</td></tr><tr><td>-p</td><td>文件是一个管道</td></tr><tr><td>-h</td><td>文件是一个符号链接</td></tr><tr><td>-L</td><td>文件是一个符号链接</td></tr><tr><td>-S</td><td>文件是一个socket</td></tr><tr><td>-t</td><td>文件(描述符)与一个终端设备相关。</td></tr><tr><td>-r</td><td>文件是否可读 (指运行这个测试命令的用户的读权限)</td></tr><tr><td>-w</td><td>文件是否可写 (指运行这个测试命令的用户的读权限)</td></tr><tr><td>-x</td><td>文件是否可执行 (指运行这个测试命令的用户的读权限)</td></tr><tr><td>-g</td><td>文件或目录的设置-组-ID(sgid)标记被设置。</td></tr><tr><td>-u</td><td>文件的设置-用户-ID(suid)标志被设置</td></tr><tr><td>-k</td><td>粘住位设置</td></tr><tr><td>-N</td><td>文件最后一次读后被修改</td></tr><tr><td>f1 -nt f2</td><td>文件f1比f2新</td></tr><tr><td>f1 -ot f2</td><td>文件f1比f2旧</td></tr><tr><td>f1 -ef f2</td><td>文件f1和f2 是相同文件的硬链接</td></tr><tr><td>!</td><td>“非” – 反转上面所有测试的结果(如果没有给出条件则返回真)。</td></tr></tbody></table><p><strong>注意⚠️</strong></p><ol><li><code>-t</code> 这个测试选项可以用于检查脚本中是否标准输入 ([ -t 0 ])或标准输出([ -t 1 ])是一个终端。</li><li><code>-g</code> 如果一个目录的sgid标志被设置，在这个目录下创建的文件都属于拥有此目录的用户组，而不必是创建文件的用户所属的组。这个特性对在一个工作组里的同享目录很有用处。</li></ol><h3 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h3><p>二元比较操作符比较两个变量或是数值。注意整数和字符串比较的分别。</p><p><strong>整数比较</strong></p><table><thead><tr><th>比较操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>等于</td><td><code>if [ &quot;$a&quot; -eq &quot;$b&quot; ]</code></td></tr><tr><td><code>-ne</code></td><td>不等于</td><td><code>if [ &quot;$a&quot; -ne &quot;$b&quot; ]</code></td></tr><tr><td><code>-gt</code></td><td>大于</td><td><code>if [ &quot;$a&quot; -gt &quot;$b&quot; ]</code></td></tr><tr><td><code>-ge</code></td><td>大于等于</td><td><code>if [ &quot;$a&quot; -ge &quot;$b&quot; ]</code></td></tr><tr><td><code>-lt</code></td><td>小于</td><td><code>if [ &quot;$a&quot; -lt &quot;$b&quot; ]</code></td></tr><tr><td><code>-le</code></td><td>小于等于</td><td><code>if [ &quot;$a&quot; -le &quot;$b&quot; ]</code></td></tr><tr><td><code>&lt;</code></td><td>小于(在双括号里使用)</td><td><code>((&quot;$a&quot; &lt; &quot;$b&quot;))</code></td></tr><tr><td><code>&lt;=</code></td><td>小于等于 (在双括号里使用)</td><td><code>((&quot;$a&quot; &lt;= &quot;$b&quot;))</code></td></tr><tr><td><code>&gt;</code></td><td>大于 (在双括号里使用)</td><td><code>((&quot;$a&quot; &gt; &quot;$b&quot;))</code></td></tr><tr><td><code>&gt;=</code></td><td>大于等于(在双括号里使用)</td><td><code>((&quot;$a&quot; &gt;= &quot;$b&quot;))</code></td></tr></tbody></table><p><strong>字符串比较</strong></p><table><thead><tr><th>比较操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>=</td><td>等于</td><td><code>if [ &quot;$a&quot; = &quot;$b&quot; ]</code></td></tr><tr><td>==</td><td>等于，它和=是同义词。</td><td><code>if [ &quot;$a&quot; == &quot;$b&quot; ]</code></td></tr><tr><td>!=</td><td>不相等，操作符在[[ … ]]结构里使用模式匹配.</td><td><code>if [ &quot;$a&quot; != &quot;$b&quot; ]</code></td></tr><tr><td>&lt;</td><td>小于，依照ASCII字符排列顺序，注意”&lt;”字符在[ ] 结构里需要转义</td><td><code>if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]</code> <code>if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]</code></td></tr><tr><td>&gt;</td><td>大于，依照ASCII字符排列顺序，注意”&gt;”字符在[ ] 结构里需要转义.</td><td><code>if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]</code> <code>if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]</code></td></tr><tr><td>-z</td><td>字符串为”null”，即是指字符串长度为零。</td><td>-</td></tr><tr><td>-n</td><td>字符串不为”null”，即长度不为零。</td><td>-</td></tr></tbody></table><p><strong>混合比较</strong></p><table><thead><tr><th>比较操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>-a</td><td>逻辑与，如果exp1和exp2都为真，则exp1 -a exp2返回真。</td><td><code>if [ &quot;$exp1&quot; -a &quot;$exp2&quot; ]</code></td></tr><tr><td>-o</td><td>逻辑或，只要exp1和exp2任何一个为真，则exp1 -o exp2 返回真。</td><td><code>if [ &quot;$exp1&quot; -o &quot;$exp2&quot; ]</code></td></tr></tbody></table><p>在一个混合测试中，把一个字符串变量引号引起来可能还不够。如果$string变量是空的话，表达式<code>[ -n &quot;$string&quot; -o &quot;$a&quot; = &quot;$b&quot; ]</code>在一些Bash版本中可能会引起错误。安全的办法是附加一个外部的字符串给可能有空字符串变量比较的所有变量，<code>[ &quot;x$string&quot; != x -o &quot;x$a&quot; = &quot;x$b&quot; ]</code> (x字符可以互相抵消)</p><h2 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h2><p>Bash已经支持了令人惊讶的字符串操作的数量。不一致的命令语法和冗余的功能，导致真的学起来有困难。</p><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String=abcABC123ABCabc</span><br><span class="line"></span><br><span class="line">echo $&#123;#String&#125;                 # 15</span><br><span class="line">echo `expr length $String`      # 15</span><br><span class="line">echo `expr "$String" : '.*'`    # 15</span><br></pre></td></tr></table></figure><p>匹配字符串开头的字串的长度，下面两种方法的 $substring 是一个正则表达式。</p><p><code>expr match &quot;$string&quot; &#39;$substring&#39;</code><br><code>expr &quot;$string&quot; : &#39;$substring&#39;</code>   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String=abcABC123ABCabc</span><br><span class="line"><span class="meta">#</span><span class="bash">       └------┘</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       </span></span><br><span class="line">echo `expr match "$String" 'abc[A-Z]*.2'`   # 8</span><br><span class="line">echo `expr "$String" : 'abc[A-Z]*.2'`       # 8</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><code>expr index $string $substring</code> 在字符串$string中$substring第一次出现的数字位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String=abcABC123ABCabc</span><br><span class="line">echo `expr index "$String" C12`             # 6</span><br><span class="line">                                             # C 字符的位置.</span><br><span class="line"></span><br><span class="line">echo `expr index "$String" 1c`              # 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="string">'c'</span> (<span class="keyword">in</span> <span class="comment">#3 position) matches before '1'.</span></span></span><br></pre></td></tr></table></figure><h3 id="字串提取"><a href="#字串提取" class="headerlink" title="字串提取"></a>字串提取</h3><p><code>${string:position}</code> 把$string中从第$postion个字符开始字符串提取出来。如果$string是”*”或”@”，则表示从位置参数中提取第$postion后面的字符串。<br><code>${string:position:length}</code> 把$string中$postion个字符后面的长度为$length的字符串提取出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 字串提取</span></span><br><span class="line">String=abcABC123ABCabc</span><br><span class="line"><span class="meta">#</span><span class="bash">       0123456789.....</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       以0开始计算.</span></span><br><span class="line"></span><br><span class="line">echo $&#123;String:0&#125;                            # abcABC123ABCabc</span><br><span class="line">echo $&#123;String:1&#125;                            # bcABC123ABCabc</span><br><span class="line">echo $&#123;String:7&#125;                            # 23ABCabc</span><br><span class="line">echo $&#123;String:7:3&#125;                          # 23A</span><br><span class="line">                                            # 提取的字串长为3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有没有可能从字符串的右边结尾处提取?</span></span><br><span class="line">    </span><br><span class="line">echo $&#123;String:-4&#125;                           # abcABC123ABCabc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认是整个字符串，就相当于<span class="variable">$&#123;parameter:-default&#125;</span>.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然而. . .</span></span><br><span class="line"></span><br><span class="line">echo $&#123;String:(-4)&#125;                         # Cabc </span><br><span class="line">echo $&#123;String: -4&#125;                          # Cabc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样,它可以工作了.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 圆括号或附加的空白字符可以转义<span class="variable">$position</span>参数.</span></span><br></pre></td></tr></table></figure><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>在单个字符前面的转义符<code>\</code>告诉shell不必特殊解释这个字符，只把它当成字面上的意思。但在一些命令和软件包里，比如说echo和sed,转义一个字符可能会引起一个相反的效果－－因为它们可能触发那个字符的特殊意思。</p><p><code>\r</code> 回车<br><code>\n</code> 换行<br><code>\c</code> 不换行<br><code>\t</code> 水平制表符<br><code>\v</code> 垂直制表符<br><code>\a</code> 表示“警告”（蜂鸣或是闪动）<br><code>\\</code> 反斜杠字符<br><code>\0ddd</code> 将自负表示成1到3的八进制数值  </p><h2 id="退出-退出状态"><a href="#退出-退出状态" class="headerlink" title="退出/退出状态"></a>退出/退出状态</h2><p><code>$?</code> 变量用于测试脚本中的命令执行结果非常的有用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo hello</span><br><span class="line">echo $?    # 因为上一条命令执行成功，打印0。</span><br><span class="line"></span><br><span class="line">lskdf      # 无效命令。</span><br><span class="line">echo $?    # 因为上面的无效命令执行失败，打印一个非零的值。</span><br><span class="line"></span><br><span class="line">exit 113   # 返回113状态码给shell。</span><br><span class="line">           # 可以运行脚本结束后立即执行命令"echo $?" 检验。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  依照惯例,命令<span class="string">'exit 0'</span>表示执行成功,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  当产生一个非零退出值时表示一个错误或是反常的条件。</span></span><br></pre></td></tr></table></figure><h3 id="变量间接引用"><a href="#变量间接引用" class="headerlink" title="变量间接引用"></a>变量间接引用</h3><p>假设一个变量的值是第二个变量的名字。这样要如何才能从第一个变量处重新获得第二个变量的值？例如，<code>a=letter_of_alphabet</code>和<code>letter_of_alphabet=z</code>，是否能由a引用得到z ? 这确实可以办到，这种技术被称为间接引用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=letter_of_alphabet   # 变量"a"保存着另外一个变量的名字.</span><br><span class="line">letter_of_alphabet=z</span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接引用.</span></span><br><span class="line">echo "a = $a"          # a = letter_of_alphabet</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间接引用.</span></span><br><span class="line">eval a=\$$a</span><br><span class="line">echo "Now a = $a"      # 现在 a = z</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="双括号结构"><a href="#双括号结构" class="headerlink" title="双括号结构"></a>双括号结构</h3><p>用<code>((...))</code>结构来使用C风格操作符来处理变量。<a href="./example/demo26">demo26</a></p><p><code>`</code>shell(( a = 23 ))  # 以C风格来设置一个值，在”=”两边可以有空格.echo “a (initial value) = $a”</p><p>(( a++ ))     # C风格的计算后自增.echo “a (after a++) = $a”</p><p>(( a– ))     # C风格的计算后自减.echo “a (after a–) = $a”</p><p>(( ++a ))     # C风格的计算前自增.echo “a (after ++a) = $a”</p><p>(( –a ))     # C风格的计算前自减.echo </p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/Shell%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Angular组件通讯</title>
      <link>http://mydearest.cn/2020/Angular%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html</link>
      <guid>http://mydearest.cn/2020/Angular%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html</guid>
      <pubDate>Sun, 15 Mar 2020 14:54:18 GMT</pubDate>
      <description>
      
        &lt;p&gt;组件通讯，意在不同的指令和组件之间共享信息。&lt;/p&gt;
&lt;h2 id=&quot;父-gt-子-input&quot;&gt;&lt;a href=&quot;#父-gt-子-input&quot; class=&quot;headerlink&quot; title=&quot;父-&amp;gt;子 input&quot;&gt;&lt;/a&gt;父-&amp;gt;子 input&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// parent.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;child [content]=&amp;quot;i&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// child.ts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Input() content:string;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;子-gt-父-output&quot;&gt;&lt;a href=&quot;#子-gt-父-output&quot; class=&quot;headerlink&quot; title=&quot;子-&amp;gt;父 output&quot;&gt;&lt;/a&gt;子-&amp;gt;父 output&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// parent.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;child (changeNumber)=&amp;quot;changeNumber($event)&amp;quot;&amp;gt;&amp;lt;/child&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// child.ts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Output() changeNumber: EventEmitter&amp;lt;number&amp;gt; = new EventEmitter();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;this.changeNumber(1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>组件通讯，意在不同的指令和组件之间共享信息。</p><h2 id="父-gt-子-input"><a href="#父-gt-子-input" class="headerlink" title="父-&gt;子 input"></a>父-&gt;子 input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// parent.html</span><br><span class="line">&lt;child [content]=&quot;i&quot;&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line">// child.ts</span><br><span class="line">@Input() content:string;</span><br></pre></td></tr></table></figure><h2 id="子-gt-父-output"><a href="#子-gt-父-output" class="headerlink" title="子-&gt;父 output"></a>子-&gt;父 output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// parent.html</span><br><span class="line">&lt;child (changeNumber)=&quot;changeNumber($event)&quot;&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line">// child.ts</span><br><span class="line">@Output() changeNumber: EventEmitter&lt;number&gt; = new EventEmitter();</span><br><span class="line"></span><br><span class="line">this.changeNumber(1);</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h2 id="子获取父实例"><a href="#子获取父实例" class="headerlink" title="子获取父实例"></a>子获取父实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// child.ts</span><br><span class="line">import &#123; Component, Input, EventEmitter, Output,Host,Inject,forwardRef &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">constructor( @Host() @Inject(forwardRef(() =&gt; ParentPage)) app: ParentPage) &#123;</span><br><span class="line">    app.content // 获取父实例的参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父获取子实例"><a href="#父获取子实例" class="headerlink" title="父获取子实例"></a>父获取子实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ViewChild(ChildPage) child:ChildPage;</span><br><span class="line"></span><br><span class="line">this.child.content //获取子实例的参数</span><br></pre></td></tr></table></figure><h2 id="service-公共的"><a href="#service-公共的" class="headerlink" title="service 公共的"></a>service 公共的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// parent.ts</span><br><span class="line">import&#123;myService&#125;from &apos;../child/myService&apos;</span><br><span class="line"></span><br><span class="line">实例化 service.i++;</span><br><span class="line"></span><br><span class="line">// child.ts</span><br><span class="line">service.i</span><br></pre></td></tr></table></figure><p>记得在app.module.ts 加上providers</p><h2 id="EventEmitter-eventbus"><a href="#EventEmitter-eventbus" class="headerlink" title="EventEmitter(eventbus)"></a>EventEmitter(eventbus)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// eventbus.service.ts</span><br><span class="line">import &#123;Component,Injectable,EventEmitter&#125; from &apos;@angular/core&apos;;</span><br><span class="line">@Injectable()</span><br><span class="line">export class myService &#123;</span><br><span class="line">    change: EventEmitter&lt;number&gt;;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.change = new EventEmitter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// parent.ts</span><br><span class="line">service.change.emit(&apos;123&apos;);</span><br><span class="line"></span><br><span class="line">// child.ts</span><br><span class="line">service.change.subscribe((value:string)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// service</span><br><span class="line">import &#123; Injectable &#125; from &apos;@angular/core&apos;;</span><br><span class="line">import &#123; Subject &#125; from &apos;rxjs/Subject&apos;;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line">export class myService &#123;</span><br><span class="line"></span><br><span class="line">    private Source = new Subject&lt;any&gt;();</span><br><span class="line">    Status$ = this.Source.asObservable();</span><br><span class="line">    StatusMission(message: any) &#123;</span><br><span class="line">        this.Source.next(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// parent.ts</span><br><span class="line">this.service.StatusMission(&apos;123&apos;);</span><br><span class="line"></span><br><span class="line">// child.ts</span><br><span class="line">this.subscription = service.Status$.subscribe(message =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">ngOnDestroy() &#123;</span><br><span class="line">    this.subscription.unsubscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上七种组件与组件的通讯方式，可以选择应用于适合的场景。</p><p>顺带介绍下重载当前路由，在Angular中，当点击当前路由的链接时，默认是忽略的。</p><h2 id="糟糕的解决方案"><a href="#糟糕的解决方案" class="headerlink" title="糟糕的解决方案"></a>糟糕的解决方案</h2><ol><li>跳出去，再跳回来。</li><li>让浏览器刷新整个页面。然而目前我们可以通过 <code>onSameUrlNavigation</code> 来解决这个问题。</li></ol><p><code>onSameUrlNavigation</code> 有两个值’reload’和’ignore’。默认为’ignore’。</p><ul><li><p>定义当路由器收到一个导航到当前 URL 的请求时应该怎么做。 默认情况下，路由器将会忽略这次导航。但这样会阻止类似于 “刷新” 按钮的特性。 使用该选项可以配置导航到当前 URL 时的行为。</p></li><li><p>路由启动配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.routing.module.ts</span></span><br><span class="line">imports: [RouterModule.forRoot(routes, &#123;<span class="attr">onSameUrlNavigation</span>: <span class="string">'reload'</span>&#125;)]</span><br></pre></td></tr></table></figure></li></ul><p><code>reload</code>并不会真正的执行加载工作，它只是重新触发了路由上的events事件循环。也可以动态配置reload<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.router.onSameUrlNavigation = <span class="string">'reload'</span>;</span><br><span class="line"><span class="keyword">this</span>.router.navigateByUrl(<span class="keyword">this</span>.router.url).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.router.onSameUrlNavigation = <span class="string">'ignore'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li>Route配置一系列的路由事件在何种情况下应该被触发，此时我们需要配置 runGuardsAndResolvers 选项，它有3个可选值。</li></ul><ol><li><p>paramsChange 只有当参数变化时才重新启动，例如 ‘article/:id’，参数指的就是这里的id。</p></li><li><p>paramsOrQueryParamsChange 当参数或查询参数变化时重新启动。例如：’article/:category?limit=10，参数指 ‘category’，查询参数指’limit’；</p></li><li><p>always 无论何种情况都重新启动</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> routes: Routes = [</span><br><span class="line">   &#123;</span><br><span class="line">       path: <span class="string">'article/:id'</span>,</span><br><span class="line">       component: ArticleComponent,</span><br><span class="line">       runGuardsAndResolvers: <span class="string">'paramsChange'</span>,</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>组件中处理路由事件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleComponent</span> <span class="title">implement</span> <span class="title">OnInit</span>, <span class="title">OnDestroy</span> </span>&#123;</span><br><span class="line">   subscription: Subscription;</span><br><span class="line">   <span class="keyword">constructor</span>(private router: Router) &#123; &#125;</span><br><span class="line">   ngOnInit() &#123;</span><br><span class="line">       <span class="keyword">this</span>.subscription = <span class="keyword">this</span>.router.events.pipe(</span><br><span class="line">           filter(<span class="function"><span class="params">event</span> =&gt;</span> event instanceOf NavigationEnd)</span><br><span class="line">       ).subscribe(<span class="function"><span class="params">_</span> =&gt;</span> &#123;...&#125;) <span class="comment">// 执行业务操作</span></span><br><span class="line">   &#125;</span><br><span class="line">   ngOnDestroy() &#123;</span><br><span class="line">       <span class="keyword">this</span>.subscription.unsubscribe(); <span class="comment">// 不要忘记处理手动订阅</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      <comments>http://mydearest.cn/2020/Angular%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>javascript设计模式</title>
      <link>http://mydearest.cn/2019/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</link>
      <guid>http://mydearest.cn/2019/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</guid>
      <pubDate>Tue, 17 Dec 2019 17:15:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;如果从作用上来划分，JavaScript设计模式大概分为五种设计类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;创建型设计模式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;结构型设计模式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;行为型设计模式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;技巧型设计模式&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;架构型设计模式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;简单工厂模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;外观模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;模板方法模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;链模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;同步模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;工厂方法模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;适配器模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;观察者模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;委托模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;异步模块模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;抽象工厂模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;代理模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;状态模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;数据访问对象模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Widget模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;建造者模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;装饰者模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;策略模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;节流模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;MVC模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;原型模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;桥接模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;职责连模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;简单模板模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;MVP模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;单例模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;组合模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;命令模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;惰性模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;MVVM模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;享元模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;访问者模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;参与者模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;中介者模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;等待者模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;备忘录模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;迭代器模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;解释器模式&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>如果从作用上来划分，JavaScript设计模式大概分为五种设计类型：</p><table><thead><tr><th style="text-align:left">创建型设计模式</th><th style="text-align:left">结构型设计模式</th><th style="text-align:left">行为型设计模式</th><th style="text-align:left">技巧型设计模式</th><th style="text-align:left">架构型设计模式</th></tr></thead><tbody><tr><td style="text-align:left">简单工厂模式</td><td style="text-align:left">外观模式</td><td style="text-align:left">模板方法模式</td><td style="text-align:left">链模式</td><td style="text-align:left">同步模块</td></tr><tr><td style="text-align:left">工厂方法模式</td><td style="text-align:left">适配器模式</td><td style="text-align:left">观察者模式</td><td style="text-align:left">委托模式</td><td style="text-align:left">异步模块模式</td></tr><tr><td style="text-align:left">抽象工厂模式</td><td style="text-align:left">代理模式</td><td style="text-align:left">状态模式</td><td style="text-align:left">数据访问对象模式</td><td style="text-align:left">Widget模式</td></tr><tr><td style="text-align:left">建造者模式</td><td style="text-align:left">装饰者模式</td><td style="text-align:left">策略模式</td><td style="text-align:left">节流模式</td><td style="text-align:left">MVC模式</td></tr><tr><td style="text-align:left">原型模式</td><td style="text-align:left">桥接模式</td><td style="text-align:left">职责连模式</td><td style="text-align:left">简单模板模式</td><td style="text-align:left">MVP模式</td></tr><tr><td style="text-align:left">单例模式</td><td style="text-align:left">组合模式</td><td style="text-align:left">命令模式</td><td style="text-align:left">惰性模式</td><td style="text-align:left">MVVM模式</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">享元模式</td><td style="text-align:left">访问者模式</td><td style="text-align:left">参与者模式</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">中介者模式</td><td style="text-align:left">等待者模式</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">备忘录模式</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">迭代器模式</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">解释器模式</td><td style="text-align:left"></td></tr></tbody></table><hr><a id="more"></a><h2 id="第-33-章-异国战场-参与者模式"><a href="#第-33-章-异国战场-参与者模式" class="headerlink" title="第 33 章 异国战场-参与者模式"></a>第 33 章 异国战场-参与者模式</h2><ul><li>参与者模式：在特定的作用域中执行给定的函数,并将参数原封不动地传递。</li></ul><h3 id="事件绑定方法"><a href="#事件绑定方法" class="headerlink" title="事件绑定方法"></a>事件绑定方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = &#123;</span><br><span class="line">    event: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 事件模块（事件绑定方法）</span></span><br><span class="line">A.event.on = <span class="function"><span class="keyword">function</span> (<span class="params">dom, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定 w3c 标准事件</span></span><br><span class="line">    <span class="keyword">if</span> (dom.addEventListener) &#123;</span><br><span class="line">        dom.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 绑定 ie 标准事件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dom.attachEvent) &#123;</span><br><span class="line">        dom.attachEvent(<span class="string">'on'</span> + type, fn);</span><br><span class="line">    <span class="comment">// 绑定 dom 事件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dom[<span class="string">'on'</span> + type] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*上面存在的问题， addEventListener 没有办法在回调函数中传递参数， 做如下的修改*/</span></span><br><span class="line">A.event.on2 = <span class="function"><span class="keyword">function</span> (<span class="params">dom, tyoe, fn, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dom.addEventListener) &#123;</span><br><span class="line">        dom.addEventListener(type, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 在dom环境中调用fn,并传递事件对象以及参数</span></span><br><span class="line">            fn.call(dom, e, data)</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .............</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 call 和 apply 方法使我们在特定作用域中执行某个函数并传入参数。</p><h3 id="实现-bind-方法"><a href="#实现-bind-方法" class="headerlink" title="实现 bind 方法"></a>实现 bind 方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 上面的方法确实是解决了参数传递的问题， 但是引发了一个新的问题</span></span><br><span class="line"><span class="comment">* 新的问题就是添加的是匿名函数导致事件回调函数不能移除了</span></span><br><span class="line"><span class="comment">* 为了解决这个问题， 就引入了bind 闭包</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">let</span> bind = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 闭包返回新函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对 fn 装饰并返回</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于bind 方法的测试</span></span><br><span class="line"><span class="keyword">let</span> demoObj = &#123;</span><br><span class="line">    title: <span class="string">'这是一个例子'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> demoFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.title)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bindFn = bind(demoFn, demoObj);</span><br><span class="line">demoFn();               <span class="comment">// undefined</span></span><br><span class="line">bindFn();               <span class="comment">// '这是一个例子'</span></span><br></pre></td></tr></table></figure><p>bindFn返回了结果，因为 bindFn 在执行时 demoObj 参与了进来并提供了作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 实际应用</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 输出参数和 this 对象</span></span><br><span class="line"><span class="keyword">let</span> demoFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有传入参与对象式 浏览器下 this 指向 Window</span></span><br><span class="line"><span class="keyword">let</span> bindFn = bind(demoFn);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, bindFn); <span class="comment">// [MouseEvent]  Window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入button this 指向了button</span></span><br><span class="line">bindFn = bind(demoFn, button); <span class="comment">// [MouseEvent] &lt;button&gt;按钮&lt;/button&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入P this 指向了P</span></span><br><span class="line">bindFn = bind(demoFn, p); <span class="comment">// [MouseEvent] &lt;p&gt;p&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line">button.removeEventListener(<span class="string">'click'</span>, bindFn)</span><br></pre></td></tr></table></figure><p>不使用实现的 bind 方法，我们也可以用原生的 bind</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bindFN = demoFn.bind()</span><br></pre></td></tr></table></figure><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 第一个需求是添加事件和移除事件已经成功了</span></span><br><span class="line"><span class="comment">* 第二个需求就是函数添加额外的自定义参数</span></span><br><span class="line"><span class="comment">* 这个时候就需要借助于函数柯里化了</span></span><br><span class="line"><span class="comment">* 函数柯里化： 根据传递的参数不同， 让一个函数存在多种状态， 处理的是函数。</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><p>函数柯里化（function currying）又称部分求值。一个函数首先会接受一些参数，接受了这些参数后，</p><p>该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包里被保存起来。待到函数真正需要求值的时候，之前传入的参数都会被一次性用于求值。</p><p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> curry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存数组的 slice 方法</span></span><br><span class="line">    <span class="keyword">let</span> Slice = [].slice;</span><br><span class="line">    <span class="comment">// 从第二个参数开始截取</span></span><br><span class="line">    <span class="keyword">let</span> args = Slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 闭包返回新函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// arguments 类数组 转化为数组</span></span><br><span class="line">        <span class="keyword">let</span> addArgs = Slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">            <span class="comment">// 拼接参数</span></span><br><span class="line">            allArgs = args.concat(addArgs);</span><br><span class="line">            <span class="comment">// 返回新函数</span></span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, allArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 柯里化的测试</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> add5 = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(<span class="number">5</span>, num)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));          <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">6</span>));           <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line">add5 = curry(add, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">6</span>));           <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">let</span> add7and8 = curry(add, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add7and8());        <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>对 add 方法的多态扩展不需要再声明函数了。</p><h3 id="通过柯里化重写-bind"><a href="#通过柯里化重写-bind" class="headerlink" title="通过柯里化重写 bind"></a>通过柯里化重写 bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过柯里化重写bind</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">let</span> bind = <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> Slice = <span class="built_in">Array</span>.prototype.slice,</span><br><span class="line">        args = Slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> addArgs = Slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">            allArgs = addArgs.concat(args);</span><br><span class="line">        <span class="keyword">return</span> fn.apply(context, allArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> demoData1 = &#123;</span><br><span class="line">    text: <span class="string">'这是第一组数据'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> demoData2 = &#123;</span><br><span class="line">    text: <span class="string">'这是第二组数据'</span></span><br><span class="line">&#125;;</span><br><span class="line">bindFn = bind(demoFn, button, demoData1); <span class="comment">// [MouseEvent, Object] &lt;button&gt;按钮&lt;/button&gt;</span></span><br><span class="line">bindFn = bind(demoFn, button, demoData1, demoData2); <span class="comment">// [MouseEvent, Object, Object] &lt;button&gt;按钮&lt;/button&gt;</span></span><br></pre></td></tr></table></figure><p>以之前的 button 为例，我们现在能在回调函数中获取传递的自定义的数据了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bindFn = demoFn.bind(button, demoData1); <span class="comment">// [Object, MouseEvent] &lt;button&gt;按钮&lt;/button&gt; 事件对象放后面的</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 为了浏览器兼容性的实现， 我们需要给未提供bind方法的浏览器添加bind方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Function</span>.prototype.bind === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> Slice = <span class="built_in">Array</span>.prototype.slice,</span><br><span class="line">            args = Slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> addArgs = Slice.call(<span class="built_in">arguments</span>),</span><br><span class="line">                allArgs = args.concat(addArgs);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.apply(context, allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于函数绑定，将函数以函数指针（函数名的方式传递），使函数在被绑定对象上的作用域中执行，可以顺利访问到对象内部的数据。缺点会消耗更多的内存执行速度会稍慢。比较常用于事件，setTimeout等异步逻辑的回调函数。</p><p>对于函数柯里化则是将接受多个参数的函数转化成接受一部分参数的新函数，余下的参数保存下来。当调用式传入的参数和保存的参数一起执行。因为要保存参数到闭包内，所以同样也会多消耗些资源。</p><h2 id="第-34-章-入场模式-等待者模式"><a href="#第-34-章-入场模式-等待者模式" class="headerlink" title="第 34 章  入场模式-等待者模式"></a>第 34 章  入场模式-等待者模式</h2><ul><li><p>等待者模式: 通过对多个异步进程进行监听，来触发未来的动作。(构建简易Promise对象，实现状态机)</p></li><li><p>场景: 不能确定先后的异步逻辑，但需要等待所有异步逻辑的完成。所有成功后执行成功回调，有一个失败就执行失败的回调函数。</p></li></ul><p>不需要实时监听所有异步逻辑是否完成，只需要监听注册的异步逻辑的状态发生改变时，对所有的异步逻辑的状态进行一次确认迭代。</p><h3 id="接口拆分"><a href="#接口拆分" class="headerlink" title="接口拆分"></a>接口拆分</h3><p>一个等待者对象内部定义了3个数组，分别存储监听对象，成功回调和失败回调；1个监控对象的类，有2个属性（成功状态和失败状态），2个方法（成功和失败方法）；私有方法_exec来处理成功或失败的回调；3个共有方法接口：when（监听异步逻辑）、done（添加成功回调）、fail（添加失败回调）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待者对象</span></span><br><span class="line"><span class="keyword">var</span> Waiter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注册了等待对象容器</span></span><br><span class="line">    <span class="keyword">var</span> dfd = [] ;</span><br><span class="line">    <span class="comment">// 成功回调方法容器</span></span><br><span class="line">    <span class="keyword">var</span> doneArr = [] ;</span><br><span class="line">    <span class="comment">// 失败回调方法容器</span></span><br><span class="line">    <span class="keyword">var</span> failArr = [] ;</span><br><span class="line">    <span class="comment">// 缓存Array方法slice</span></span><br><span class="line">    <span class="keyword">var</span> _slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line">    <span class="comment">// 保存当前等待者对象</span></span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控对象类</span></span><br><span class="line">    <span class="keyword">var</span> Primise = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 监控对象是否解决成功状态</span></span><br><span class="line">        <span class="keyword">this</span>.resolved = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 监控对象是否解决失败状态</span></span><br><span class="line">        <span class="keyword">this</span>.rejected = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监控对象类原型方法</span></span><br><span class="line">    Primise.prototype = &#123;</span><br><span class="line">        <span class="comment">// 解决成功</span></span><br><span class="line">        resolve : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        <span class="comment">// 解决失败</span></span><br><span class="line">        reject : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监控对象</span></span><br><span class="line">    that.Deferred = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Primise() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调执行方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_exec</span>(<span class="params">arr</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控异步方法 参数：监控对象</span></span><br><span class="line">    that.when = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决成功回调函数添加方法</span></span><br><span class="line">    that.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决失败回调函数添加方法</span></span><br><span class="line">    that.fail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监控对象类原型方法"><a href="#监控对象类原型方法" class="headerlink" title="监控对象类原型方法"></a>监控对象类原型方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Primise.prototype = &#123;</span><br><span class="line">    <span class="comment">// 解决成功</span></span><br><span class="line">    resolve : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置当前监控对象解决成功</span></span><br><span class="line">        <span class="keyword">this</span>.resolved = <span class="literal">true</span> ;</span><br><span class="line">        <span class="comment">// 如果没有监控对象则取消执行</span></span><br><span class="line">        <span class="keyword">if</span>(!dfd.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历所有注册了的监控对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = dfd.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果有任意一个监控对象没有被解决或者解决失败则返回</span></span><br><span class="line">            <span class="keyword">if</span>(dfd[i] &amp;&amp; !dfd[i].resolved || dfd[i].rejected) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清除监控对象 成功了就不需要再监控</span></span><br><span class="line">            dfd.splice(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行解决成功回调方法</span></span><br><span class="line">        _exec(doneArr);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 解决失败</span></span><br><span class="line">    reject : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置当前监控对象解决失败</span></span><br><span class="line">        <span class="keyword">this</span>.rejected = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果没有监控对象则取消执行</span></span><br><span class="line">        <span class="keyword">if</span>(!dfd.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除所有监控对象</span></span><br><span class="line">        dfd.splice(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 执行解决成功回调方法</span></span><br><span class="line">        _exec(failArr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调执行方法"><a href="#回调执行方法" class="headerlink" title="回调执行方法"></a>回调执行方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_exec</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="comment">// 遍历回调数组执行回调</span></span><br><span class="line">    <span class="keyword">for</span>(; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行回调函数</span></span><br><span class="line">            arr[i] &amp;&amp; arr[i]();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监控异步方法-参数：监控对象"><a href="#监控异步方法-参数：监控对象" class="headerlink" title="监控异步方法 参数：监控对象"></a>监控异步方法 参数：监控对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">that.when = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置监控对象</span></span><br><span class="line">    dfd = _slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 获取监控对象数组长度</span></span><br><span class="line">    <span class="keyword">var</span> i = dfd.length;</span><br><span class="line">    <span class="comment">// 向前遍历监控对象，最后一个监控对象的索引值为length-1</span></span><br><span class="line">    <span class="keyword">for</span>(--i; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在监控对象，或者监控对象已经解决，或者不是监控对象</span></span><br><span class="line">        <span class="keyword">if</span>(!dfd[i] || dfd[i].resolved || dfd[i].rejected || !dfd[i] <span class="keyword">instanceof</span> Primise) &#123;</span><br><span class="line">            <span class="comment">// 清理内存，清除当前监控对象</span></span><br><span class="line">            dfd.splice(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回等待者对象</span></span><br><span class="line">    <span class="keyword">return</span> that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决成功回调函数添加方法"><a href="#解决成功回调函数添加方法" class="headerlink" title="解决成功回调函数添加方法"></a>解决成功回调函数添加方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">that.done = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向成功回调函数容器中添加回调方法</span></span><br><span class="line">    doneArr = doneArr.concat(_slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="comment">// 返回等待者对象</span></span><br><span class="line">    <span class="keyword">return</span> that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决失败回调函数添加方法"><a href="#解决失败回调函数添加方法" class="headerlink" title="解决失败回调函数添加方法"></a>解决失败回调函数添加方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">that.fail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向失败回调函数容器中添加回调方法</span></span><br><span class="line">    failArr = failArr.concat(_slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="comment">// 返回等待者对象</span></span><br><span class="line">    <span class="keyword">return</span> that;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个等待者对象</span></span><br><span class="line"><span class="keyword">var</span> waiter = <span class="keyword">new</span> Waiter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个彩蛋，3秒停止</span></span><br><span class="line"><span class="keyword">var</span> first = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建监听对象</span></span><br><span class="line">    <span class="keyword">var</span> dtd = waiter.Deferred();</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'first finish'</span>);</span><br><span class="line">        <span class="comment">// 发布解决成功问题</span></span><br><span class="line">        dtd.resolve();</span><br><span class="line">        <span class="comment">// 发布解决失败问题</span></span><br><span class="line">        <span class="comment">// dtd.reject();</span></span><br><span class="line">    &#125;, <span class="number">3000</span>) ;</span><br><span class="line">    <span class="comment">// 返回监听对象</span></span><br><span class="line">    <span class="keyword">return</span> dtd;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个彩蛋，6秒后停止</span></span><br><span class="line"><span class="keyword">var</span> second = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建简体你对象</span></span><br><span class="line">    <span class="keyword">var</span> dtd = waiter.Deferred();</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'second finish'</span>);</span><br><span class="line">        <span class="comment">// 发布解决成功消息</span></span><br><span class="line">        dtd.resolve();</span><br><span class="line">        <span class="comment">// 发布解决失败问题</span></span><br><span class="line">        <span class="comment">// dtd.reject();</span></span><br><span class="line">    &#125;, <span class="number">6000</span>);</span><br><span class="line">    <span class="comment">// 返回监控对象</span></span><br><span class="line">    <span class="keyword">return</span> dtd;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听两个彩蛋的工作状态，并执行相应的成功回调函数与失败回调函数</span></span><br><span class="line">waiter</span><br><span class="line">    <span class="comment">// 监听两个彩蛋</span></span><br><span class="line">    .when(first, second)</span><br><span class="line">    <span class="comment">// 添加成功回调函数</span></span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'success again'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 添加失败回调函数</span></span><br><span class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'fail'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装get请求</span></span><br><span class="line"><span class="keyword">var</span> ajaxGet = <span class="function"><span class="keyword">function</span>(<span class="params">url, success, fail</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// 创建监测对象</span></span><br><span class="line">    <span class="keyword">var</span> dtd = waiter.Deferred();</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 请求成功</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            success &amp;&amp; success() ;</span><br><span class="line">        <span class="comment">// 请求失败 </span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dtd.reject() ;</span><br><span class="line">            fail &amp;&amp; fail() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ;</span><br><span class="line">    xhr.open(<span class="string">'get'</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 长轮询</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">getAjaxData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保存当前函数</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="built_in">arguments</span>.callee;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.get(<span class="string">'./test.php'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'轮询一次'</span>);</span><br><span class="line">            <span class="comment">// 再一次执行轮询</span></span><br><span class="line">            fn();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>等待者模式适合用于处理比较耗时的操作比如定时器操作、异步请求等。等待者模式提供了抽象非阻塞的解决方案。通过创建 Promise 对象，对应状态变化返回响应，同时监听这些响应信息，并为之提供相应的回调，根据状态执行相应的回调方法。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>事件机制</title>
      <link>http://mydearest.cn/2019/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</link>
      <guid>http://mydearest.cn/2019/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html</guid>
      <pubDate>Sun, 24 Nov 2019 14:26:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;事件机制的核心就是发布-订阅模式。维护一个对象，对象的 key 存的是事件 type，对应的 value 为触发相应 type 的回调函数，即 listeners，然后 trigger 时遍历通知，即 forEach 进行回调执行。&lt;/p&gt;
&lt;figure class=&quot;h
        
      
      </description>
      
      <content:encoded><![CDATA[<p>事件机制的核心就是发布-订阅模式。维护一个对象，对象的 key 存的是事件 type，对应的 value 为触发相应 type 的回调函数，即 listeners，然后 trigger 时遍历通知，即 forEach 进行回调执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.listener = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听事件</span></span><br><span class="line">    on(type, callback) &#123;</span><br><span class="line">        <span class="comment">// 如果是第一次监听该事件，则初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[type]) <span class="keyword">this</span>.listeners[type] = [];</span><br><span class="line">        <span class="keyword">this</span>.listeners[type].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只监听一次</span></span><br><span class="line">    once(type, callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners[type]) <span class="keyword">this</span>.listeners[type] = [];</span><br><span class="line">        <span class="comment">// once 只触发一次，触发后 off 即可 回调函数加上标识</span></span><br><span class="line">        callback._once = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.listeners[type].push(callback); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消监听</span></span><br><span class="line">    off(type, callback) &#123;</span><br><span class="line">        <span class="keyword">const</span> listeners = <span class="keyword">this</span>.listeners[type];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(listeners)) &#123;</span><br><span class="line">            <span class="comment">// filter 返回新的数组，会每次对 this.listeners[type] 分配新的空间</span></span><br><span class="line">            <span class="comment">// this.listeners[type] = listeners.filter(l =&gt; l !== callback);</span></span><br><span class="line">            <span class="comment">// 根据 type 取消对应的回调</span></span><br><span class="line">            <span class="keyword">const</span> index = listeners.indexOf(callback);</span><br><span class="line">            <span class="comment">// 用 splice 要好些，直接操作原数组</span></span><br><span class="line">            <span class="keyword">this</span>.listeners[type].splice(index, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果回调为空，删除对该事件的监听</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.listeners[type].length === <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>.listeners[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 扳机社</span></span><br><span class="line">    trigger(event) &#123;</span><br><span class="line">        <span class="comment">// type 为必传属性</span></span><br><span class="line">        <span class="keyword">const</span> &#123; type &#125; = event;</span><br><span class="line">        <span class="keyword">if</span> (!type) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'没有要触发的事件！'</span>);</span><br><span class="line">        <span class="comment">// 判断是否之前对该事件进行监听了</span></span><br><span class="line">        <span class="keyword">const</span> listeners = <span class="keyword">this</span>.listeners[type];</span><br><span class="line">        <span class="keyword">if</span> (!listeners) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`没有对象监听 <span class="subst">$&#123;type&#125;</span> 事件！`</span>);</span><br><span class="line">        <span class="keyword">if</span> (!event.target) event.target = <span class="keyword">this</span>;</span><br><span class="line">        listeners.forEach(<span class="function"><span class="params">l</span> =&gt;</span> &#123;</span><br><span class="line">            l(event);</span><br><span class="line">            <span class="comment">// 如果通过 once 监听，执行一次后取消</span></span><br><span class="line">            <span class="keyword">if</span> (l._once) <span class="keyword">this</span>.off(type, l);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">event</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`message received: <span class="subst">$&#123; event.message &#125;</span>`</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMessage2</span>(<span class="params">event</span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">`message2 received: <span class="subst">$&#123; event.message &#125;</span>`</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> EventTarget();</span><br><span class="line"></span><br><span class="line">target.on(<span class="string">'message'</span>, handleMessage);</span><br><span class="line">target.on(<span class="string">'message'</span>, handleMessage2);</span><br><span class="line">target.trigger(&#123; <span class="attr">type</span>: <span class="string">'message'</span>, <span class="attr">message</span>: <span class="string">'hello custom event'</span> &#125;); <span class="comment">// 打印 message，message2</span></span><br><span class="line"></span><br><span class="line">target.off(<span class="string">'message'</span>, handleMessage);</span><br><span class="line">target.trigger(&#123; <span class="attr">type</span>: <span class="string">'message'</span>, <span class="attr">message</span>: <span class="string">'off the event'</span> &#125;); <span class="comment">// 只打印 message2</span></span><br><span class="line"></span><br><span class="line">target.once(<span class="string">'words'</span>, handleMessage);</span><br><span class="line">target.trigger(&#123; <span class="attr">type</span>: <span class="string">'words'</span>, <span class="attr">message</span>: <span class="string">'hello2 once event'</span> &#125;); <span class="comment">// 打印 words</span></span><br><span class="line">target.trigger(&#123; <span class="attr">type</span>: <span class="string">'words'</span>, <span class="attr">message</span>: <span class="string">'hello2 once event'</span> &#125;); <span class="comment">// 报错：没有对象监听 words 事件！</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于requestAnimationFrame</title>
      <link>http://mydearest.cn/2019/%E5%85%B3%E4%BA%8ErequestAnimationFrame.html</link>
      <guid>http://mydearest.cn/2019/%E5%85%B3%E4%BA%8ErequestAnimationFrame.html</guid>
      <pubDate>Sun, 22 Sep 2019 04:24:48 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在JS中，我们可以使用 &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setIntarval&lt;/code&gt; 实现动画，但是 H5 的出现，让我们又多了两种实现动画的方式，分别是 CSS 动画（&lt;code&gt;transition&lt;/code&gt;、&lt;code&gt;an
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在JS中，我们可以使用 <code>setTimeout</code> 和 <code>setIntarval</code> 实现动画，但是 H5 的出现，让我们又多了两种实现动画的方式，分别是 CSS 动画（<code>transition</code>、<code>animation</code>）和 H5的<code>canvas</code> 实现。除此以外，H5还提供了一个专门用于请求动画的API，让 DOM 动画、canvas动画、svg动画、webGL动画等有一个专门的刷新机制。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><code>requestAnimationFrame</code> 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestAnimationFrame(callback)</span><br></pre></td></tr></table></figure><ul><li>callback：下一次重绘之前更新动画帧所调用的函数，<strong>callback仅有一个参数，为DOMHighResTimeStamp参数，表示requestAnimationFrame()开始执行回调函数的时刻。</strong></li><li>返回值：一个 long 类型整数，唯一标志元组在列表中的位置，你可以传这个值给<code>cancelAnimationFrame()</code> 以取消动画。</li></ul><p>在使用和实现上， <code>requestAnimationFrame</code> 与 <code>setTimeout</code> 类似。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> rafId = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 回调函数</span></span><br><span class="line"><span class="comment"> * @param time requestAnimationFrame 调用该函数时，自动传入的一个时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestAnimation</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(time); <span class="comment">// 打印执行requestAnimation函数的时刻</span></span><br><span class="line">  <span class="comment">// 动画没有执行完，则递归渲染</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 渲染下一帧</span></span><br><span class="line">    rafId = <span class="built_in">window</span>.requestAnimationFrame(requestAnimation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染第一帧</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(requestAnimation);</span><br></pre></td></tr></table></figure><h3 id="2-怎样执行"><a href="#2-怎样执行" class="headerlink" title="2.怎样执行"></a>2.怎样执行</h3><ul><li>首先判断 <code>document.hidden</code> 属性是否可见（true），可见状态下才能继续执行以下步骤</li><li>浏览器清空上一轮的动画函数</li><li><code>requestAnimationFrame</code> 将回调函数追加到动画帧请求回调函数列表的末尾<strong>注意：当执行 requestAnimationFrame(callback)的时候，不会立即调用 callback 回调函数，只是将其放入回调函数队列而已，同时注意，每个 callback回调函数都有一个 cancelled 标志符，初始值为 false，并对外不可见。</strong></li><li>当页面可见并且动画帧请求callback<strong>回调函数列表</strong>不为空时，浏览器会<strong>定期</strong>将这些回调函数加入到浏览器 UI 线程的队列中（<strong>由系统来决定回调函数的执行时机</strong>）。当浏览器执行这些 callback 回调函数的时候，会判断每个元组的 callback 的cancelled标志符，只有 <strong>cancelled 为 false</strong> 时，才执行callback回调函数。</li></ul><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><ol><li><code>requestAnimationFrame</code> 自带<strong>函数节流</strong>功能，采用<strong>系统时间间隔</strong>，保持最佳绘制效率，不会因为间隔时间的过短，造成过度绘制，增加页面开销，也不会因为间隔时间过长，造成动画卡顿，不流程，影响页面美观。浏览器的重绘频率一般会和显示器的刷新率保持同步。大多数采用 W3C规范，浏览器的渲染页面的标准频率也为 60 FPS（frames/per second）即每秒重绘60次，<strong>requestAnimationFrame的基本思想是 让页面重绘的频率和刷新频率保持同步</strong>，即每 1000ms / 60 = <strong>16.7ms</strong>执行一次。通过 <code>requestAnimationFrame</code> 调用回调函数引起的页面重绘或回流的时间间隔和显示器的刷新时间间隔相同。所以  <code>requestAnimationFrame</code>  不需要像 <code>setTimeout</code> 那样传递时间间隔，而是浏览器通过系统获取并使用显示器刷新频率。例如在某些高频事件（resize，scroll 等）中，使用 <code>requestAnimationFrame</code> 可以防止在一个刷新间隔内发生多次函数执行，这样保证了流程度，也节省了开销</li><li>另外，该函数的<strong>延时效果是精确的</strong>，没有<code>setTimeout</code>或<code>setInterval</code>不准的情况（JS是单线程的，<code>setTimeout</code> 任务被放进异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列的任务是否需要开始执行，造成时间延时）。<code>setTimeout</code><strong>的执行只是在内存中对图像属性进行改变，这个改变必须要等到下次浏览器重绘时才会被更新到屏幕上</strong>。如果和屏幕刷新步调不一致，就可能导致中间某些帧的操作被跨越过去，直接更新下下一帧的图像。即 <strong>掉帧</strong>使用  <code>requestAnimationFrame</code> 执行动画，最大优势是<strong>能保证回调函数在屏幕每一次刷新间隔中只被执行一次</strong>，这样就不会引起丢帧，动画也就不会卡顿</li><li><p>节省资源，节省开销在之前介绍<code>requestAnimationFrame</code>执行过程，我们知道只有当页面激活的状态下，页面刷新任务才会开始，才执行 <code>requestAnimationFrame</code>，当页面隐藏或最小化时，会被暂停，页面显示，会继续执行。<strong>节省了 CPU 开销</strong>。<strong>注意：当页面被隐藏或最小化时，定时器<code>setTimeout</code>仍在后台执行动画任务，此时刷新动画是完全没有意义的（实际上 FireFox/Chrome 浏览器对定时器做了优化：页面闲置时，如果时间间隔小于 1000ms，则停止定时器，与<code>requestAnimationFrame</code>行为类似。如果时间间隔&gt;=1000ms，定时器依然在后台执行）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器开发者工具的Console页执行下面代码。</span></span><br><span class="line"><span class="comment">// 当开始输出count后，切换浏览器tab页，再切换回来，可以发现打印的值从离开前的值继续输出</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">requestAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="built_in">console</span>.log(count);</span><br><span class="line">            requestAnimationFrame(requestAnimation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">requestAnimationFrame(requestAnimation);</span><br></pre></td></tr></table></figure></li><li><p>能够在动画流刷新之后执行，即<strong>上一个动画流会完整执行</strong></p></li></ol><h3 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h3><p>我们可以使用 <code>requestAnimationFrame</code> 实现<code>setInterval</code>及 <code>setTimeout</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setInterval实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now</span><br><span class="line">    <span class="keyword">let</span> startTime = now()</span><br><span class="line">    <span class="keyword">let</span> endTime = startTime</span><br><span class="line">    <span class="keyword">const</span> loop = () =&#123;</span><br><span class="line">        timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">        endTime = now()</span><br><span class="line">        <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">            startTime = endTime = now()</span><br><span class="line">            callback(timer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">    <span class="keyword">return</span> timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">setInterval(timer =&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a++</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="number">3</span>) <span class="built_in">window</span>.cancelAnimationFrame(timer)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setTimeout 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now</span><br><span class="line">    <span class="keyword">let</span> startTime = now()</span><br><span class="line">    <span class="keyword">let</span> endTime = startTime</span><br><span class="line">    <span class="keyword">const</span> loop = () =&#123;</span><br><span class="line">        timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">        endTime = now()</span><br><span class="line">        <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">            callback(timer)</span><br><span class="line">            <span class="built_in">window</span>.cancelAnimationFrame(timer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">    <span class="keyword">return</span> timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">setTimeout(timer =&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a++</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/%E5%85%B3%E4%BA%8ErequestAnimationFrame.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>git相关问题场景和命令</title>
      <link>http://mydearest.cn/2019/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%E5%92%8C%E5%91%BD%E4%BB%A4.html</link>
      <guid>http://mydearest.cn/2019/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%E5%92%8C%E5%91%BD%E4%BB%A4.html</guid>
      <pubDate>Fri, 20 Sep 2019 16:51:40 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;一、必备知识点&quot;&gt;&lt;a href=&quot;#一、必备知识点&quot; class=&quot;headerlink&quot; title=&quot;一、必备知识点&quot;&gt;&lt;/a&gt;一、必备知识点&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.mydearest.cn/blog/images/git.png&quot; alt=&quot;git&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="一、必备知识点"><a href="#一、必备知识点" class="headerlink" title="一、必备知识点"></a>一、必备知识点</h3><p><img src="http://cdn.mydearest.cn/blog/images/git.png" alt="git"></p><hr><a id="more"></a><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><ol><li><strong>Remote:</strong> 远程主仓库；</li><li><strong>Repository：</strong> 本地仓库；</li><li><strong>Index：</strong> Git追踪树,暂存区；</li><li><strong>workspace：</strong> 本地工作区（即你编辑器的代码）</li></ol><h3 id="二、git-add-提交到暂存区，出错怎么办"><a href="#二、git-add-提交到暂存区，出错怎么办" class="headerlink" title="二、git add 提交到暂存区，出错怎么办"></a>二、git add 提交到暂存区，出错怎么办</h3><p>一般代码提交流程为：<strong>工作区</strong> -<code>git status</code> 查看状态 -<code>git add .</code> 将所有修改加入<strong>暂存区</strong>-<code>git commit -m &quot;提交描述&quot;</code> 将代码提交到 <strong>本地仓库</strong> -<code>git push</code> 将本地仓库代码更新到 <strong>远程仓库</strong></p><h4 id="场景1：工作区"><a href="#场景1：工作区" class="headerlink" title="场景1：工作区"></a>场景1：工作区</h4><p>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 丢弃工作区的修改</span></span><br><span class="line">git checkout -- <span class="xml"><span class="tag">&lt;<span class="name">文件名</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="场景2：暂存区"><a href="#场景2：暂存区" class="headerlink" title="场景2：暂存区"></a>场景2：暂存区</h4><p>当你不但改乱了工作区某个文件的内容，还 <code>git add</code> 添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;文件名<span class="comment">// 把暂存区的修改撤销掉（unstage），重新放回工作区。</span></span><br></pre></td></tr></table></figure><h3 id="三、git-commit-提交到本地仓库，出错怎么办？"><a href="#三、git-commit-提交到本地仓库，出错怎么办？" class="headerlink" title="三、git commit 提交到本地仓库，出错怎么办？"></a>三、git commit 提交到本地仓库，出错怎么办？</h3><h4 id="1-提交信息出错"><a href="#1-提交信息出错" class="headerlink" title="1. 提交信息出错"></a>1. 提交信息出错</h4><p>更改 commit 信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend -m“新提交消息”</span><br></pre></td></tr></table></figure><h4 id="2-漏提交"><a href="#2-漏提交" class="headerlink" title="2. 漏提交"></a>2. 漏提交</h4><p>commit 时，遗漏提交部分更新，有两种解决方案：</p><ul><li>方案一：再次 commit<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m“提交消息”</span><br></pre></td></tr></table></figure></li></ul><p>  此时，git 上会出现两次 commit</p><ul><li>方案二：遗漏文件提交到之前 commit 上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add missed-file <span class="comment">// missed-file 为遗漏提交文件</span></span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure></li></ul><p>  <code>--no-edit</code> 表示提交消息不会更改，在 git 上仅为一次提交</p><h4 id="3-提交错误文件，回退到上一个-commit-版本，再-commit"><a href="#3-提交错误文件，回退到上一个-commit-版本，再-commit" class="headerlink" title="3. 提交错误文件，回退到上一个 commit 版本，再 commit"></a>3. 提交错误文件，回退到上一个 commit 版本，再 commit</h4><h5 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h5><p>删除指定的 commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改版本库，保留暂存区，保留工作区</span></span><br><span class="line"><span class="comment">// 将版本库软回退1个版本，软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。</span></span><br><span class="line">git reset --soft HEAD~<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改版本库，修改暂存区，修改工作区</span></span><br><span class="line"><span class="comment">// 将版本库回退1个版本，不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本</span></span><br><span class="line">git reset --hard HEAD~<span class="number">1</span></span><br><span class="line"><span class="comment">// git版本回退，回退到特定的commit_id版本，可以通过git log查看提交历史，以便确定要回退到哪个版本(commit 之后的即为ID);</span></span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><h5 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h5><p>撤销 某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销</p><p>作为一次最新的提交</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 撤销前一次 commit</span></span><br><span class="line">git revert HEAD</span><br><span class="line"><span class="comment">// 撤销前前一次 commit</span></span><br><span class="line">git revert HEAD^</span><br><span class="line"><span class="comment">// (比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。</span></span><br><span class="line">git revert commit</span><br></pre></td></tr></table></figure><p><code>git revert</code>是提交一个新的版本，将需要<code>revert</code>的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容</p><h5 id="git-revert-和-git-reset-的区别"><a href="#git-revert-和-git-reset-的区别" class="headerlink" title="git revert 和 git reset 的区别"></a><code>git revert</code> 和 <code>git reset</code> 的区别</h5><ul><li><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。</li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li><code>git reset</code> 是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li></ul><h3 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h3><h4 id="1-初始开发-git-操作流程"><a href="#1-初始开发-git-操作流程" class="headerlink" title="1. 初始开发 git 操作流程"></a>1. 初始开发 git 操作流程</h4><ul><li>克隆最新主分支项目代码 <code>git clone 地址</code></li><li>创建本地分支 <code>git branch 分支名</code></li><li>查看本地分支 <code>git branch</code></li><li>查看远程分支 <code>git branch -a</code></li><li>切换分支  <code>git checkout 分支名</code> (一般修改未提交则无法切换，大小写问题经常会有，可强制切换  <code>git checkout 分支名 -f</code>  非必须慎用)</li><li>将本地分支推送到远程分支 <code>git push &lt;远程仓库&lt;本地分支&gt;:&lt;远程分支&gt;</code></li></ul><h4 id="2-git-fetch"><a href="#2-git-fetch" class="headerlink" title="2. git fetch"></a>2. git fetch</h4><p>将某个远程主机的更新，全部/分支 取回本地（此时之更新了Repository）它取回的代码对你本地的开发代码没有影响，如需彻底更新需合并或使用<code>git pull</code></p><h4 id="3-git-pull"><a href="#3-git-pull" class="headerlink" title="3. git pull"></a>3. git pull</h4><p>拉取远程主机某分支的更新，再与本地的指定分支合并（相当与fetch加上了合并分支功能的操作）</p><h4 id="4-git-push"><a href="#4-git-push" class="headerlink" title="4. git push"></a>4. git push</h4><p>将本地分支的更新，推送到远程主机，其命令格式与<code>git pull</code>相似</p><h4 id="5-分支操作"><a href="#5-分支操作" class="headerlink" title="5. 分支操作"></a>5. 分支操作</h4><ul><li>使用 Git 下载指定分支命令为：<code>git clone -b 分支名仓库地址</code></li><li>拉取远程新分支 <code>git checkout -b serverfix origin/serverfix</code></li><li>合并本地分支 <code>git merge hotfix</code>：(将 hotfix 分支合并到当前分支)</li><li>合并远程分支 <code>git merge origin/serverfix</code></li><li>删除本地分支 <code>git branch -d hotfix</code>：(删除本地 hotfix 分支)</li><li>删除远程分支 <code>git push origin --delete serverfix</code></li><li>上传新命名的本地分支：<code>git push origin newName</code>;</li><li>创建新分支：<code>git branch branchName</code>：(创建名为 branchName 的本地分支)</li><li>切换到新分支：<code>git checkout branchName</code>：(切换到 branchName 分支)</li><li>创建并切换分支：<code>git checkout -b branchName</code>：(相当于以上两条命令的合并)</li><li>查看本地分支：<code>git branch</code></li><li>查看远程仓库所有分支：<code>git branch -a</code></li><li>本地分支重命名： <code>git branch -m oldName newName</code></li><li>重命名远程分支对应的本地分支：<code>git branch -m oldName newName</code></li><li>把修改后的本地分支与远程分支关联：<code>git branch --set-upstream-to origin/newName</code></li></ul><h3 id="五、优化操作"><a href="#五、优化操作" class="headerlink" title="五、优化操作"></a>五、优化操作</h3><h4 id="1-拉取代码-pull-–rebase"><a href="#1-拉取代码-pull-–rebase" class="headerlink" title="1. 拉取代码 pull –rebase"></a>1. 拉取代码 pull –rebase</h4><p>在团队协作过程中，假设你和你的同伴在本地中分别有各自的新提交，而你的同伴先于你 <code>push</code> 了代码到远程分支上，所以你必须先执行 <code>git pull</code> 来获取同伴的提交，然后才能<code>push</code> 自己的提交到远程分支。</p><p>而按照 Git 的默认策略，如果远程分支和本地分支之间的提交线图有分叉的话（即不是 fast-forwarded），Git 会执行一次 <code>merge</code> 操作，因此产生一次没意义的提交记录，从而造成了像上图那样的混乱。</p><p>其实在 pull 操作的时候，，使用 <code>git pull --rebase</code>选项即可很好地解决上述问题。 加上 <code>--rebase</code> 参数的作用是，提交线图有分叉的话，Git 会 rebase 策略来代替默认的 merge 策略。</p><p>假设提交线图在执行 pull 前是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C  remotes/origin/master</span><br><span class="line">     /</span><br><span class="line">D---E---F---G  master</span><br></pre></td></tr></table></figure><p>如果是执行 <code>git pull</code> 后，提交线图会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C remotes/origin/master</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H master</span><br></pre></td></tr></table></figure><p>结果多出了 <code>H</code> 这个没必要的提交记录。如果是执行 <code>git pull --rebase</code> 的话，提交线图就会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">            remotes/origin/master</span><br><span class="line">                |</span><br><span class="line">D---E---A---B---C---F&apos;---G&apos;  master</span><br></pre></td></tr></table></figure><p><code>F</code> <code>G</code> 两个提交通过 <code>rebase</code> 方式重新拼接在 <code>C</code> 之后，多余的分叉去掉了，目的达到。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>大多数时候，使用 <code>git pull --rebase</code>是为了使提交线图更好看，从而方便 code review。</p><p>不过，如果你对使用 git 还不是十分熟练的话，我的建议是 <code>git pull --rebase</code>多练习几次之后再使用，因为 <strong>rebase 在 git 中，算得上是『危险行为』</strong>。</p><p>另外，还需注意的是，使用 <code>git pull --rebase</code>比直接 pull 容易导致冲突的产生，如果预期冲突比较多的话，建议还是直接 pull。</p><p>注意：git pull = git fetch + git mergegit pull –rebase = git fetch + git rebase</p><h4 id="2-合代码-merge-–no-ff"><a href="#2-合代码-merge-–no-ff" class="headerlink" title="2. 合代码 merge –no-ff"></a>2. 合代码 merge –no-ff</h4><p>上述的 <code>git pull --rebase</code> 策略目的是修整提交线图，使其形成一条直线，而即将要用到的 <code>git merge --no-ff &lt;branch-name&gt;</code> 策略偏偏是反行其道，刻意地弄出提交线图分叉出来。</p><p>假设你在本地准备合并两个分支，而刚好这两个分支是 fast-forwarded 的，那么直接合并后你得到一个直线的提交线图，当然这样没什么坏处，但如果你想更清晰地告诉你同伴：<strong>这一系列的提交都是为了实现同一个目的</strong>，那么你可以刻意地将这次提交内容弄成一次提交线图分叉。</p><p>执行 <code>git merge --no-ff &lt;branch-name&gt;</code> 的结果大概会是这样的：</p><p><img src="http://cdn.mydearest.cn/blog/images/git-chain1.png" alt="git merge --no-ff"></p><p>中间的分叉线路图很清晰的显示这些提交都是为了实现 <strong>complete adjusting user domains and tags</strong></p><h5 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h5><p>往往我的习惯是，在合并分支之前（假设要在本地将 feature 分支合并到 dev 分支），会先检查 feature 分支是否『部分落后』于<strong>远程 dev 分支</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git pull # 更新 dev 分支</span><br><span class="line">git log feature..dev</span><br></pre></td></tr></table></figure><p>如果没有输出任何提交信息的话，即表示 feature 对于 dev 分支是 up-to-date 的。如果有输出的话而马上执行了 <code>git merge --no-ff</code> 的话，提交线图会变成这样：</p><p><img src="http://cdn.mydearest.cn/blog/images/git-chain2.png" alt="git-merge"></p><p>所以这时在合并前，通常我会先执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase dev</span><br></pre></td></tr></table></figure><p>这样就可以将 feature 重新拼接到更新了的 dev 之后，然后就可以合并了，最终得到一个干净舒服的提交线图。</p><p><strong>再次提醒：像之前提到的，rebase 是『危险行为』，建议你足够熟悉 git 时才这么做，否则的话是得不偿失啊。</strong></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>使用 <code>git pull --rebase</code> 和 <code>git merge --no-ff</code> 其实和直接使用 <code>git pull</code> <code>git merge</code> 得到的代码应该是一样。</p><p>使用 <code>git pull --rebase</code> 主要是为是将提交约线图平坦化，而 <code>git merge --no-ff</code> 则是刻意制造分叉。</p><h3 id="六、SSH"><a href="#六、SSH" class="headerlink" title="六、SSH"></a>六、SSH</h3><h4 id="1-查看是否生成了-SSH-公钥"><a href="#1-查看是否生成了-SSH-公钥" class="headerlink" title="1. 查看是否生成了 SSH 公钥"></a>1. 查看是否生成了 SSH 公钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">id_rsa      id_rsa.pub      known_hosts</span><br></pre></td></tr></table></figure><p>其中 id_rsa 是私钥，id_rsa.pub 是公钥。</p><h4 id="2-如果没有那就开始生成，设置全局的user-name与user-email"><a href="#2-如果没有那就开始生成，设置全局的user-name与user-email" class="headerlink" title="2. 如果没有那就开始生成，设置全局的user.name与user.email"></a>2. 如果没有那就开始生成，设置全局的user.name与user.email</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --list <span class="comment">// 查看是否设置了user.name与user.email，没有的话，去设置</span></span><br><span class="line"><span class="comment">// 设置全局的user.name与user.email</span></span><br><span class="line">git config --global user.name <span class="string">"XX"</span></span><br><span class="line">git config --global user.email <span class="string">"XX"</span></span><br></pre></td></tr></table></figure><h4 id="3-输入-ssh-keygen-即可（或ssh-keygen-t-rsa-C-quot-email-quot-）"><a href="#3-输入-ssh-keygen-即可（或ssh-keygen-t-rsa-C-quot-email-quot-）" class="headerlink" title="3. 输入 ssh-keygen 即可（或ssh-keygen -t rsa -C &quot;email&quot;）"></a>3. 输入 ssh-keygen 即可（或<code>ssh-keygen -t rsa -C &quot;email&quot;</code>）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /Users/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br></pre></td></tr></table></figure><h4 id="4-生成之后获取公钥内容，输入-cat-ssh-id-rsa-pub-即可，-复制-ssh-rsa-一直到-local这一整段内容"><a href="#4-生成之后获取公钥内容，输入-cat-ssh-id-rsa-pub-即可，-复制-ssh-rsa-一直到-local这一整段内容" class="headerlink" title="4. 生成之后获取公钥内容，输入 cat ~/.ssh/id_rsa.pub 即可， 复制 ssh-rsa 一直到 .local这一整段内容"></a>4. 生成之后获取公钥内容，输入 cat ~/.ssh/id_rsa.pub 即可， 复制 ssh-rsa 一直到 .local这一整段内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@agadorlaptop.local</span><br></pre></td></tr></table></figure><h4 id="5-打开-GitLab-或者-GitHub，点击头像，找到设置页"><a href="#5-打开-GitLab-或者-GitHub，点击头像，找到设置页" class="headerlink" title="5. 打开 GitLab 或者 GitHub，点击头像，找到设置页"></a>5. 打开 GitLab 或者 GitHub，点击头像，找到设置页</h4><h4 id="6-左侧找到-SSH-keys-按钮并点击，输入刚刚复制的公钥即可"><a href="#6-左侧找到-SSH-keys-按钮并点击，输入刚刚复制的公钥即可" class="headerlink" title="6. 左侧找到 SSH keys 按钮并点击，输入刚刚复制的公钥即可"></a>6. 左侧找到 SSH keys 按钮并点击，输入刚刚复制的公钥即可</h4><h3 id="七、暂存"><a href="#七、暂存" class="headerlink" title="七、暂存"></a>七、暂存</h3><p><code>git stash</code> 可用来暂存当前正在进行的工作，比如想 pull 最新代码又不想 commit ， 或者另为了修改一个紧急的 bug ，先 stash，使返回到自己上一个 commit,，改完 bug 之后再 stash pop , 继续原来的工作；</p><ul><li>添加缓存栈： <code>git stash</code> ;</li><li>查看缓存栈： <code>git stash list</code> ;</li><li>推出缓存栈： <code>git stash pop</code> ;</li><li>取出特定缓存内容： <code>git stash apply stash@{1}</code> ;</li></ul><h3 id="八、文件名过长错误"><a href="#八、文件名过长错误" class="headerlink" title="八、文件名过长错误"></a>八、文件名过长错误</h3><p>Filename too long warning: Clone succeeded, but checkout failed.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system core.longpaths true</span><br></pre></td></tr></table></figure><h3 id="九、邮箱和用户名"><a href="#九、邮箱和用户名" class="headerlink" title="九、邮箱和用户名"></a>九、邮箱和用户名</h3><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line"></span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure><h3 id="十、-gitignore-更新后生效："><a href="#十、-gitignore-更新后生效：" class="headerlink" title="十、.gitignore 更新后生效："></a>十、.gitignore 更新后生效：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;.gitignore is now working”</span><br></pre></td></tr></table></figure><h3 id="十一、同步Github-fork-出来的分支"><a href="#十一、同步Github-fork-出来的分支" class="headerlink" title="十一、同步Github fork 出来的分支"></a>十一、同步Github fork 出来的分支</h3><p>1、配置remote，指向原始仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://github.com/cosyer/jelly.git</span><br></pre></td></tr></table></figure><p>2、上游仓库获取到分支，及相关的提交信息，它们将被保存在本地的 upstream/master 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line"># remote: Counting objects: 75, done.</span><br><span class="line"># remote: Compressing objects: 100% (53/53), done.</span><br><span class="line"># remote: Total 62 (delta 27), reused 44 (delta 9)</span><br><span class="line"># Unpacking objects: 100% (62/62), done.</span><br><span class="line"># From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY</span><br><span class="line"># * [new branch] master -upstream/master</span><br></pre></td></tr></table></figure><p>3、切换到本地的 master 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"># Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>4、把 upstream/master 分支合并到本地的 master 分支，本地的 master 分支便跟上游仓库保持同步了，并且没有丢失本地的修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br><span class="line"># Updating a422352..5fdff0f</span><br><span class="line"># Fast-forward</span><br><span class="line"># README | 9 -------</span><br><span class="line"># README.md | 7 ++++++</span><br><span class="line"># 2 files changed, 7 insertions(+), 9 deletions(-)</span><br><span class="line"># delete mode 100644 README</span><br><span class="line"># create mode 100644 README.md</span><br></pre></td></tr></table></figure><p>5、上传到自己的远程仓库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="git合并多个commit"><a href="#git合并多个commit" class="headerlink" title="git合并多个commit"></a>git合并多个commit</h3><p>过去总是使用<code>git reset --soft</code>回退到之前的状态，再 commit 后 push orgin master -f 强推到远程库，能够覆盖掉之前的 commit 。</p><p>但在团队协作时，每次 commit 前还需要 rebase upstream，这会自动将一些其他人做的修改也自动merge到本地的源码中。如果此时希望覆盖前一次 commit ，reset 到之前的状态后，再次 commit 的内容就包含了其他人的修改，这不是我们希望看到的。因此，我们需要使用 git rebase -i 。</p><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><ul><li><ol><li>git log查看所有commit的情况，找到自己想要合并的commit之前的那个commit的ssh码；</li></ol></li><li><ol><li>git rebase -i 43jk2l3ba343，这样会弹出一个文本编辑器；git reset –soft  HEAD^ 上个commit ^^上上个commit HEAD~6；</li></ol></li><li><ol><li>修改pick为squash会将这个commit合并到前一个commit中，保存退出；</li></ol></li><li><ol><li>提示写下新的commit message，之前的message可以用#注释掉，保存退出；</li></ol></li><li><ol><li>此时再git log就会发现，两个commit被合并到一个commit中。</li></ol></li></ul><h3 id="Commit-message-前缀规范提要"><a href="#Commit-message-前缀规范提要" class="headerlink" title="Commit message 前缀规范提要"></a>Commit message 前缀规范提要</h3><table><thead><tr><th>code</th><th>info          </th></tr></thead><tbody><tr><td><strong>feat</strong>:msg</td><td>新功能 feature</td></tr><tr><td><strong>fix</strong>:msg</td><td>修复bug</td></tr><tr><td><strong>merge</strong>:msg</td><td>merge 信息</td></tr><tr><td><strong>docs</strong>:msg</td><td>文档修改</td></tr><tr><td><strong>style</strong>:msg</td><td>格式，不影响代码运行的变动</td></tr><tr><td><strong>refactor</strong>: msg</td><td>重构即不是新增功能，也不是修改bug的代码变动</td></tr><tr><td><strong>test</strong>:msg</td><td>增加测试</td></tr><tr><td><strong>chore</strong>:msg</td><td>构建过程或辅助工具的变动</td></tr><tr><td><strong>rm</strong>:msg</td><td>删除文件或代码</td></tr></tbody></table><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>本文参考了 <a href="http://hungyuhei.github.io/2012/08/07/better-git-commit-graph-using-pull---rebase-and-merge---no-ff.html" target="_blank" rel="noopener">洁癖者用 Git：pull –rebase 和 merge –no-ff</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/git%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%E5%92%8C%E5%91%BD%E4%BB%A4.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>npm总结</title>
      <link>http://mydearest.cn/2019/npm%E6%80%BB%E7%BB%93.html</link>
      <guid>http://mydearest.cn/2019/npm%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Tue, 17 Sep 2019 16:17:31 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;一-package-json-解读&quot;&gt;&lt;a href=&quot;#一-package-json-解读&quot; class=&quot;headerlink&quot; title=&quot;一. package.json 解读&quot;&gt;&lt;/a&gt;一. package.json 解读&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 项目名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;version&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;0.0.1&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 版本号：大版本.次要版本.小版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;author&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;张三&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;description&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;第一个node.js程序&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;keywords&quot;&lt;/span&gt;:[&lt;span class=&quot;string&quot;&gt;&quot;node.js&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;javascript&quot;&lt;/span&gt;], &lt;span class=&quot;comment&quot;&gt;// 关键词，有助于 npm search 发现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;repository&quot;&lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 存储库，指定代码所在位置（如果git repo在GitHub上，那么该npm docs 命令将能够找到文件位置。）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;git&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;url&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;https://path/to/url&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;license&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;MIT&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 指定包许可证，详细可见[SPDX许可证ID的完整列表](https://spdx.org/licenses/)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;engines&quot;&lt;/span&gt;: &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;node&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;0.10.x&quot;&lt;/span&gt;&amp;#125;, &lt;span class=&quot;comment&quot;&gt;// 指定该模块运行的平台，可以指定 node 版本、npm 版本等&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;bugs&quot;&lt;/span&gt;:&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;url&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;http://path/to/bug&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;email&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;bug@example.com&quot;&lt;/span&gt;&amp;#125;, &lt;span class=&quot;comment&quot;&gt;// 项目问题跟踪器的URL和应报告问题的电子邮件地址。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;contributors&quot;&lt;/span&gt;:[&amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;李四&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;email&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;lisi@example.com&quot;&lt;/span&gt;&amp;#125;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;bin&quot;&lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 指定内部命令对应的可执行文件的位置，在 scripts 中就可以简写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;string&quot;&gt;&quot;webpack&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;./bin/webpack.js&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;main&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;lib/webpack.js&quot;&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 指定加载的模块入口文件，require(&#39;moduleName&#39;)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;config&quot;&lt;/span&gt; : &amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;port&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;8080&quot;&lt;/span&gt; &amp;#125;, &lt;span class=&quot;comment&quot;&gt;// 用于添加命令行的环境变量（用户在运行 scripts 命令时，就默认在脚本文件中添加 process.env.npm_package_config_port，用户可以通过 npm config set foo:port 80 命令更改这个值）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;scripts&quot;&lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 指定运行脚本的 npm 命令行缩写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;start&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;node index.js&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;peerDependencies&quot;&lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 指定项目安装必须一起安装的模块及其版本号，（注意：从 npm 3.0 开始，peerDependencies不会再默认安装）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&lt;span class=&quot;string&quot;&gt;&quot;chai&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;1.x&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;dependencies&quot;&lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 指定项目运行所依赖的模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;express&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;latest&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;mongoose&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~3.8.3&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;handlebars-runtime&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~1.0.12&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;express3-handlebars&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~0.5.0&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;MD5&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~1.2.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&quot;devDependencies&quot;&lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 指定项目开发所需要的模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;bower&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~1.2.8&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;grunt&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~0.4.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;grunt-contrib-concat&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~0.3.0&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;grunt-contrib-jshint&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~0.7.2&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;grunt-contrib-uglify&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~0.2.7&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;grunt-contrib-clean&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~0.5.0&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;browserify&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;2.36.1&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&quot;grunt-browserify&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;~1.3.0&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;browser&quot;&lt;/span&gt;: &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 指定该模板供浏览器使用的版本&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  		&lt;span class=&quot;string&quot;&gt;&quot;tipso&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;./node_modules/tipso/src/tipso.js&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;preferGlobal&quot;&lt;/span&gt;: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;// 表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; 在 node 和 npm 环节都要使用，node 在调用 &lt;code&gt;require&lt;/code&gt; 的时候去查找模块，会按照一个次序去查找，&lt;code&gt;package.json&lt;/code&gt; 会是查找中的一个环节。npm 用的就比较多，其中的 &lt;code&gt;dependencies&lt;/code&gt; 字段就是本模块的依赖的模块清单。每次&lt;code&gt;npm update&lt;/code&gt;的时候，npm会自动的把依赖到的模块也下载下来。当&lt;code&gt;npm install&lt;/code&gt; 本模块的时候，会把这里提到的模块都一起下载下来。通过package.json,就可以管理好模块的依赖关系。&lt;/p&gt;
&lt;p&gt;关于更多规范，请看官方&lt;a href=&quot;https://docs.npmjs.com/files/package.json.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;npm-package.json&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="一-package-json-解读"><a href="#一-package-json-解读" class="headerlink" title="一. package.json 解读"></a>一. package.json 解读</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"hello world"</span>, <span class="comment">// 项目名称</span></span><br><span class="line"><span class="string">"version"</span>: <span class="string">"0.0.1"</span>, <span class="comment">// 版本号：大版本.次要版本.小版本</span></span><br><span class="line"><span class="string">"author"</span>: <span class="string">"张三"</span>,</span><br><span class="line"><span class="string">"description"</span>: <span class="string">"第一个node.js程序"</span>,</span><br><span class="line"><span class="string">"keywords"</span>:[<span class="string">"node.js"</span>,<span class="string">"javascript"</span>], <span class="comment">// 关键词，有助于 npm search 发现</span></span><br><span class="line"><span class="string">"repository"</span>: &#123; <span class="comment">// 存储库，指定代码所在位置（如果git repo在GitHub上，那么该npm docs 命令将能够找到文件位置。）</span></span><br><span class="line"><span class="string">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line"><span class="string">"url"</span>: <span class="string">"https://path/to/url"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"license"</span>:<span class="string">"MIT"</span>, <span class="comment">// 指定包许可证，详细可见[SPDX许可证ID的完整列表](https://spdx.org/licenses/)</span></span><br><span class="line"><span class="string">"engines"</span>: &#123;<span class="string">"node"</span>: <span class="string">"0.10.x"</span>&#125;, <span class="comment">// 指定该模块运行的平台，可以指定 node 版本、npm 版本等</span></span><br><span class="line"><span class="string">"bugs"</span>:&#123;<span class="string">"url"</span>:<span class="string">"http://path/to/bug"</span>,<span class="string">"email"</span>:<span class="string">"bug@example.com"</span>&#125;, <span class="comment">// 项目问题跟踪器的URL和应报告问题的电子邮件地址。</span></span><br><span class="line"><span class="string">"contributors"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"李四"</span>,<span class="string">"email"</span>:<span class="string">"lisi@example.com"</span>&#125;],</span><br><span class="line">    <span class="string">"bin"</span>: &#123; <span class="comment">// 指定内部命令对应的可执行文件的位置，在 scripts 中就可以简写</span></span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"./bin/webpack.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="string">"main"</span>: <span class="string">"lib/webpack.js"</span>, <span class="comment">// 指定加载的模块入口文件，require('moduleName')就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。</span></span><br><span class="line">    <span class="string">"config"</span> : &#123; <span class="string">"port"</span> : <span class="string">"8080"</span> &#125;, <span class="comment">// 用于添加命令行的环境变量（用户在运行 scripts 命令时，就默认在脚本文件中添加 process.env.npm_package_config_port，用户可以通过 npm config set foo:port 80 命令更改这个值）</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123; <span class="comment">// 指定运行脚本的 npm 命令行缩写</span></span><br><span class="line"><span class="string">"start"</span>: <span class="string">"node index.js"</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="string">"peerDependencies"</span>: &#123; <span class="comment">// 指定项目安装必须一起安装的模块及其版本号，（注意：从 npm 3.0 开始，peerDependencies不会再默认安装）</span></span><br><span class="line">    <span class="string">"chai"</span>: <span class="string">"1.x"</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="string">"dependencies"</span>: &#123; <span class="comment">// 指定项目运行所依赖的模块</span></span><br><span class="line"><span class="string">"express"</span>: <span class="string">"latest"</span>,</span><br><span class="line"><span class="string">"mongoose"</span>: <span class="string">"~3.8.3"</span>,</span><br><span class="line"><span class="string">"handlebars-runtime"</span>: <span class="string">"~1.0.12"</span>,</span><br><span class="line"><span class="string">"express3-handlebars"</span>: <span class="string">"~0.5.0"</span>,</span><br><span class="line"><span class="string">"MD5"</span>: <span class="string">"~1.2.0"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"devDependencies"</span>: &#123; <span class="comment">// 指定项目开发所需要的模块</span></span><br><span class="line"><span class="string">"bower"</span>: <span class="string">"~1.2.8"</span>,</span><br><span class="line"><span class="string">"grunt"</span>: <span class="string">"~0.4.1"</span>,</span><br><span class="line"><span class="string">"grunt-contrib-concat"</span>: <span class="string">"~0.3.0"</span>,</span><br><span class="line"><span class="string">"grunt-contrib-jshint"</span>: <span class="string">"~0.7.2"</span>,</span><br><span class="line"><span class="string">"grunt-contrib-uglify"</span>: <span class="string">"~0.2.7"</span>,</span><br><span class="line"><span class="string">"grunt-contrib-clean"</span>: <span class="string">"~0.5.0"</span>,</span><br><span class="line"><span class="string">"browserify"</span>: <span class="string">"2.36.1"</span>,</span><br><span class="line"><span class="string">"grunt-browserify"</span>: <span class="string">"~1.3.0"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="string">"browser"</span>: &#123; <span class="comment">// 指定该模板供浏览器使用的版本</span></span><br><span class="line">  <span class="string">"tipso"</span>: <span class="string">"./node_modules/tipso/src/tipso.js"</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="string">"preferGlobal"</span>: <span class="literal">true</span>, <span class="comment">// 表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>package.json</code> 在 node 和 npm 环节都要使用，node 在调用 <code>require</code> 的时候去查找模块，会按照一个次序去查找，<code>package.json</code> 会是查找中的一个环节。npm 用的就比较多，其中的 <code>dependencies</code> 字段就是本模块的依赖的模块清单。每次<code>npm update</code>的时候，npm会自动的把依赖到的模块也下载下来。当<code>npm install</code> 本模块的时候，会把这里提到的模块都一起下载下来。通过package.json,就可以管理好模块的依赖关系。</p><p>关于更多规范，请看官方<a href="https://docs.npmjs.com/files/package.json.html" target="_blank" rel="noopener">npm-package.json</a></p><hr><a id="more"></a><h3 id="二-版本号规范"><a href="#二-版本号规范" class="headerlink" title="二. 版本号规范"></a>二. 版本号规范</h3><ul><li><strong>指定版本</strong>：比如<code>1.2.2</code>，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</li><li><strong>波浪号（tilde）+指定版本</strong>：比如<code>~1.2.2</code>，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。</li><li><strong>插入号（caret）+指定版本</strong>：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。<strong>需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</strong></li><li><strong>latest</strong>：安装最新版本。</li></ul><h3 id="三-npm-install-与-npm-update"><a href="#三-npm-install-与-npm-update" class="headerlink" title="三. npm install 与 npm update"></a>三. npm install 与 <strong>npm update</strong></h3><ul><li>如果本地 <code>node_modules</code> 已安装，再次执行 <code>install</code> 不会更新包版本, 执行 <code>update</code> 才会更新; 而如果本地 <code>node_modules</code> 为空时，执行 <code>install/update</code> 都会直接安装更新包;</li><li><code>npm update</code> 总是会把包更新到符合 <code>package.json</code> 中指定的 semver(语义化版本) 的<strong>最新</strong>版本号——本例中符合 <code>^1.8.0</code> 的最新版本为 <code>1.15.0</code></li><li>一旦给定 <code>package.json</code>, 无论后面执行 <code>npm install</code> 还是 <code>update</code>, <code>package.json</code> 中的 webpack 版本一直顽固地保持 一开始的 <code>^1.8.0</code> 岿然不动</li></ul><h3 id="四-npm-i-与-npm-install"><a href="#四-npm-i-与-npm-install" class="headerlink" title="四. npm i 与 npm install"></a>四. npm i 与 <strong>npm install</strong></h3><p>实际使用的区别点主要如下：</p><ul><li>用<code>npm i</code>安装的模块无法用<code>npm uninstall</code>删除，用<code>npm un</code>才卸载掉</li><li><code>npm i</code>会帮助检测与当前 node 版本最匹配的 npm 包版本号，并匹配出来相互依赖的 npm 包应该提升的版本号</li><li>部分 npm 包在当前 node 版本下无法使用，必须使用建议版本</li><li>安装报错时 install 肯定会出现 <code>npm-debug.log</code>  文件，<code>npm i</code>不一定</li></ul><h3 id="五-npm-devDependencies-与-dependencies"><a href="#五-npm-devDependencies-与-dependencies" class="headerlink" title="五. npm devDependencies 与 dependencies"></a>五. npm devDependencies 与 dependencies</h3><p><code>--save-dev</code></p><p>或</p><p><code>—save</code></p><p>首先需要说明的是 Dependencies一词的中文意思是依赖和附属的意思，而dev则是 develop（开发）的简写。</p><p>所以它们的区别在 package.json 文件里面体现出来的就是，使用 <code>--save-dev</code> 安装的 插件，被写入到 devDependencies 域里面去，而使用 <code>—save</code> 安装的插件，则是被写入到 dependencies 区块里面去。</p><p>那 package.json 文件里面的 devDependencies  和 dependencies 对象有什么<strong>区别</strong>呢？</p><p><strong>devDependencies  里面的插件只用于开发环境，不用于生产环境，而 dependencies  是需要发布到生产环境的</strong>。</p><p>比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies</p><h3 id="六-全局安装与本地安装"><a href="#六-全局安装与本地安装" class="headerlink" title="六. 全局安装与本地安装"></a>六. 全局安装与本地安装</h3><p>通过 <code>-g</code> 来安装的包，将包安装成全局可用的可执行命令。</p><h4 id="1-全局安装，-将包安装成全局可用的可执行命令"><a href="#1-全局安装，-将包安装成全局可用的可执行命令" class="headerlink" title="1. 全局安装， 将包安装成全局可用的可执行命令"></a>1. 全局安装， 将包安装成全局可用的可执行命令</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局安装 babel-cli</span></span><br><span class="line">babel app.js</span><br></pre></td></tr></table></figure><h4 id="2-本地安装"><a href="#2-本地安装" class="headerlink" title="2. 本地安装"></a>2. 本地安装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地安装 babel-cli</span></span><br><span class="line">node_modules/.bin/babel app.js</span><br></pre></td></tr></table></figure><h4 id="3-修改全局安装默认路径"><a href="#3-修改全局安装默认路径" class="headerlink" title="3. 修改全局安装默认路径"></a>3. 修改全局安装默认路径</h4><ul><li><p>设置自定义的全局安装路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix <span class="string">"/usr/local/npm"</span> <span class="comment">// 自定义的全局安装路径</span></span><br><span class="line">npm config set cache <span class="string">"/usr/local/npm"</span> <span class="comment">// 自定义的全局安装路径</span></span><br></pre></td></tr></table></figure></li><li><p>设置环境变量切到  ~/.bash_profile 文件中配置路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GNPM_PATH=<span class="regexp">/usr/</span>local/npm</span><br><span class="line"><span class="keyword">export</span> GNPM_PATH</span><br><span class="line"><span class="keyword">export</span> PATH=$PATH:$GNPM_PATH/bin  <span class="comment">// 将 /usr/local/npm/bin 追加到 PATH 变量中</span></span><br><span class="line"><span class="keyword">export</span> NODE_PATH=$PATH:$GNPM_PATH/lib/node_modules <span class="comment">// 指定 NODE_PATH 变量</span></span><br></pre></td></tr></table></figure></li></ul><p>  操作系统中都会有一个<code>PATH</code>环境变量，想必大家都知道，当系统调用一个命令的时候，就会在PATH变量中注册的路径中寻找，如果注册的路径中有就调用，否则就提示命令没找到。  而 <code>NODE_PATH</code> 就是<code>NODE</code>中用来 <strong>寻找模块所提供的路径注册环境变量</strong> 。我们可以使用上面的方法指定<code>NODE_PATH</code> 环境变量。  使用 <code>npm config list</code> 查看配置</p><h3 id="七-npm-包命令"><a href="#七-npm-包命令" class="headerlink" title="七. npm 包命令"></a>七. npm 包命令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm list -g --depth <span class="number">0</span> <span class="comment">// 查看全局安装过的包 -g:全局的安装包 list：已安装的node包 –depth 0：深度0</span></span><br><span class="line">npm view &lt;packageName<span class="comment">// 查看npm服务器中包版本号 </span></span><br><span class="line">npm info &lt;packageName<span class="comment">// npm服务器更多信息，更多版本号</span></span><br><span class="line">npm ls &lt;packageName<span class="comment">// 本地包</span></span><br><span class="line">npm ls &lt;packageName-g <span class="comment">// 全局安装包</span></span><br><span class="line">npm docs <span class="comment">// 打开包git目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：npm build 与 npm start 是项目中常用的命令，注意它们有什么不同</span></span><br><span class="line">npm start [--<span class="xml"><span class="tag">&lt;<span class="name">args</span>&gt;</span>] // 在 package.json 文件中定义的 "scripts" 对象中查找 "start" 属性，执行该属性定义的命令，如果没有定义，默认执行 node server.js 命令</span></span><br><span class="line">npm build [&lt;package-folder&gt;] // 其中，&lt;package-folder为其根目录中包含一个 package.json 文件的文件夹，这是由 npm link 命令和 npm install 命令组成的管道命令，通常在安装过程中被调用。如果想要直接运行它，则运行 npm run build</span><br></pre></td></tr></table></figure><p>还有其他的 钩子命令，具体项目中我还没用到，你可以自行了解。</p><p>package.json 中 scripts 常用命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除目录</span></span><br><span class="line"><span class="string">"clean"</span>: <span class="string">"rimraf dist/*"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地搭建一个 HTTP 服务</span></span><br><span class="line"><span class="string">"serve"</span>: <span class="string">"http-server -p 9090 dist/"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开浏览器</span></span><br><span class="line"><span class="string">"open:dev"</span>: <span class="string">"opener http://localhost:9090"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时刷新</span></span><br><span class="line"> <span class="string">"livereload"</span>: <span class="string">"live-reload --port 9091 dist/"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 HTML 文件</span></span><br><span class="line"><span class="string">"build:html"</span>: <span class="string">"jade index.jade dist/index.html"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 CSS 文件有变动，就重新执行构建</span></span><br><span class="line"><span class="string">"watch:css"</span>: <span class="string">"watch 'npm run build:css' assets/styles/"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 HTML 文件有变动，就重新执行构建</span></span><br><span class="line"><span class="string">"watch:html"</span>: <span class="string">"watch 'npm run build:html' assets/html"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署到 Amazon S3</span></span><br><span class="line"><span class="string">"deploy:prod"</span>: <span class="string">"s3-cli sync ./dist/ s3://example-com/prod-site/"</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 favicon</span></span><br><span class="line"><span class="string">"build:favicon"</span>: <span class="string">"node scripts/favicon.js"</span>,</span><br></pre></td></tr></table></figure><h3 id="八-简写形式"><a href="#八-简写形式" class="headerlink" title="八. 简写形式"></a>八. 简写形式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm start   <span class="comment">// 是 npm run start 的简写</span></span><br><span class="line">npm stop    <span class="comment">// 是 npm run stop 的简写</span></span><br><span class="line">npm test    <span class="comment">// 是 npm run test 的简写</span></span><br><span class="line">npm restart <span class="comment">// 是 npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start 的简写</span></span><br></pre></td></tr></table></figure><h3 id="九-process"><a href="#九-process" class="headerlink" title="九. process"></a>九. process</h3><p>我们可以通过环境变量<code>process.env</code>对象，拿到 npm 所有的配置变量。其中 npm 脚本可以通过<code>npm_config_</code>前缀，拿到 npm 的配置变量。通过<code>npm_package_</code>前缀，拿到<code>package.json</code>里面的字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.env.npm_package_name); <span class="comment">// chejianer</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.npm_package_version); <span class="comment">// 1.0.0</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env); <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>对于 <strong>全局模式安装的包（通过 -g 来安装的包，将包安装成全局可用的可执行命令，并不意味着任何地方都可以通过 require() 来引用它）</strong>：它会通过 bin 字段配置，将实际脚本链接到 Node 可执行目录下，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">  <span class="string">"webpack"</span>: <span class="string">"./bin/webpack.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>通过全局安装的包都安装到一个统一的目录下，可以通过以下方式获得:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(process.execPath, <span class="string">".."</span>, <span class="string">".."</span>, <span class="string">"lib"</span>, <span class="string">"node_modules"</span>) </span><br><span class="line"><span class="comment">// 例如：/usr/local/lib/node_modules</span></span><br></pre></td></tr></table></figure><h3 id="一零-npm-发布包"><a href="#一零-npm-发布包" class="headerlink" title="一零. npm 发布包"></a>一零. npm 发布包</h3><ul><li><strong>创建一个空文件</strong>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/index.js</span></span><br><span class="line">exports.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello An!"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>运行：<code>npm init</code></strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package name: (<span class="built_in">module</span>) hello-an</span><br><span class="line">version: (<span class="number">1.0</span><span class="number">.0</span>) <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line">description: a hello-an package</span><br><span class="line">entry point: (hello.js) </span><br><span class="line">test command: </span><br><span class="line">git repository: </span><br><span class="line">keywords: hello an</span><br><span class="line">author: sisterAn</span><br><span class="line">license: (ISC) MIT</span><br><span class="line">About to write to /Users/lianran777/Study/node/chejianer_node/<span class="built_in">module</span>/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"hello-an"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"a hello-an package"</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"hello.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    <span class="string">"an"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">"sisterAn"</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is <span class="keyword">this</span> OK? (yes)</span><br></pre></td></tr></table></figure><ul><li><strong>注册 npm 包仓库账号</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure><ul><li><strong>上传包</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish . <span class="comment">// package.json 所在目录</span></span><br></pre></td></tr></table></figure><p>在这个过程中，npm 会将目录打包成一个存档文件，然后上传到官方源仓库中</p><ul><li><strong>管理包权限</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm owner add &lt;user[&lt;@scope&gt;/]&lt;pkg&gt;</span><br><span class="line">npm owner rm &lt;user[&lt;@scope&gt;/]&lt;pkg&gt;</span><br><span class="line">npm owner ls [&lt;@scope&gt;/]&lt;pkg&gt;</span><br></pre></td></tr></table></figure><p>在自己的项目中安装包 <code>npm install</code>，通过 <code>npm ls</code> 分析模块路径找到的所有包，并生成依赖树。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/npm%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>浏览器兼容问题总结</title>
      <link>http://mydearest.cn/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</link>
      <guid>http://mydearest.cn/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</guid>
      <pubDate>Sat, 31 Aug 2019 17:07:30 GMT</pubDate>
      <description>
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 10px;}&lt;/p&gt;
&lt;p&gt;这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 &lt;em&gt;display:inline;将其转化为行内属性。(&lt;/em&gt;这个符号只有ie6会识别)&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.bb&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;background-color&lt;/span&gt;:red;&lt;span class=&quot;comment&quot;&gt;/*所有识别*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;background-color&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;#00deff&lt;/span&gt;\&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;/*IE6、7、8识别*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    +background-color:#a200ff;/*IE6、7识别*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _&lt;span class=&quot;selector-tag&quot;&gt;background-color&lt;/span&gt;:&lt;span class=&quot;selector-id&quot;&gt;#1e0bd1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;/*IE6识别*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<ol><li><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</p></li><li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</p></li><li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p></li></ol><p>浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 10px;}</p><p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 <em>display:inline;将其转化为行内属性。(</em>这个符号只有ie6会识别)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bb</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:red;<span class="comment">/*所有识别*/</span></span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line">    +background-color:#a200ff;/*IE6、7识别*/</span><br><span class="line">    _<span class="selector-tag">background-color</span>:<span class="selector-id">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><a id="more"></a><ol><li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。</p></li><li><p>IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。</p></li><li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; </p></li><li><p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:</p></li></ol><p>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</p><ol><li>样式初始化</li></ol><ul><li><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p></li><li><p>初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p></li></ul><p>最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma, arial, \<span class="number">5</span>b8b\<span class="number">4</span>f53; &#125;</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>&#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</span><br><span class="line"><span class="selector-tag">address</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">var</span> &#123; <span class="attribute">font-style</span>:normal; &#125;</span><br><span class="line"><span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>:couriernew, courier, monospace; &#125;</span><br><span class="line"><span class="selector-tag">small</span>&#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; &#125;</span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>:none; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>:underline; &#125;</span><br><span class="line"><span class="selector-tag">sup</span> &#123; <span class="attribute">vertical-align</span>:text-top; &#125;</span><br><span class="line"><span class="selector-tag">sub</span>&#123; <span class="attribute">vertical-align</span>:text-bottom; &#125;</span><br><span class="line"><span class="selector-tag">legend</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; &#125;</span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">border</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; <span class="attribute">border-spacing</span>:<span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></p><ol><li>CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？</li></ol><p>对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.</p><ol><li><p>让页面里的字体变清晰，变细用CSS怎么做？-webkit-font-smoothing: antialiased;</p></li><li><p>display:inline-block 什么时候会显示间隙？移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p></li></ol>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>租房须知</title>
      <link>http://mydearest.cn/2019/%E7%A7%9F%E6%88%BF%E9%A1%BB%E7%9F%A5.html</link>
      <guid>http://mydearest.cn/2019/%E7%A7%9F%E6%88%BF%E9%A1%BB%E7%9F%A5.html</guid>
      <pubDate>Sun, 18 Aug 2019 14:07:31 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;文档目的&quot;&gt;&lt;a href=&quot;#文档目的&quot; class=&quot;headerlink&quot; title=&quot;文档目的&quot;&gt;&lt;/a&gt;文档目的&lt;/h2&gt;&lt;p&gt;希望这篇文档能够帮助到北上广深杭等租房漂泊的同学在找房的时候规避一些明显的问题。&lt;/p&gt;
&lt;p&gt;这里枚举了一些常见问题，适当参考文档作出一个判断，或许可以减少租客和房东都不开心的情况的出现，并节约时间。&lt;/p&gt;
&lt;p&gt;作为租客，即使在预算并不充裕，或者稍低于目标区域平均价格的时候，也可以找到靠谱的房子，只要策略得当。&lt;/p&gt;
&lt;p&gt;希望看过文档的同学可以少遇到居住不舒服的房子，至少，不要遇到居住那么不舒服的房子 :D&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="文档目的"><a href="#文档目的" class="headerlink" title="文档目的"></a>文档目的</h2><p>希望这篇文档能够帮助到北上广深杭等租房漂泊的同学在找房的时候规避一些明显的问题。</p><p>这里枚举了一些常见问题，适当参考文档作出一个判断，或许可以减少租客和房东都不开心的情况的出现，并节约时间。</p><p>作为租客，即使在预算并不充裕，或者稍低于目标区域平均价格的时候，也可以找到靠谱的房子，只要策略得当。</p><p>希望看过文档的同学可以少遇到居住不舒服的房子，至少，不要遇到居住那么不舒服的房子 :D</p><hr><a id="more"></a><h2 id="租房要点"><a href="#租房要点" class="headerlink" title="租房要点"></a>租房要点</h2><p><strong>一般原则：</strong></p><ul><li>尽量提前进行房源的寻找，不要等到房子到期、或者旺季（财年结束跳槽季、毕业季、实习季）的时候进行。</li><li>尽量寻找直租房屋，不推荐经过“转交”的房源，除非你对转手房源的人信得过。</li><li>寻找房源前，请确定清楚预算和期望居住的区域，提高找房效率，避免无意义时间浪费。</li></ul><p><strong>特殊情况下的一般推荐策略：</strong> </p><h3 id="如果租房者时间紧迫"><a href="#如果租房者时间紧迫" class="headerlink" title="如果租房者时间紧迫"></a>如果租房者时间紧迫</h3><ul><li>不太介意暂时没有独立的空间，请优先在公司群、公司或高校BBS、同学群中进行询问，看看是否有人愿意同你分享房子或者信息，相对知根知底的同事、同学比陌生人靠谱的概率大的多。</li><li>请在本地寻找当地相对最大最正规的中介连锁。</li><li>如果行李不多，部分青旅可以扛几天。（12年有同事这么经历过）</li></ul><h3 id="如果一定要和中介打交道"><a href="#如果一定要和中介打交道" class="headerlink" title="如果一定要和中介打交道"></a>如果一定要和中介打交道</h3><p>如果有可能，尽可能不要租中介的房子，尤其是市场占有率低的小中介，可能发生以下问题：</p><ol><li>代理人中途跑路或以各种各样的方式进行诈骗。</li><li>合约到期后，以各种手段侵占押金。</li><li>屋内财务不翼而飞。</li></ol><p><strong>黑名单：</strong></p><p>开来营，活跃于回龙观，霍营，龙泽地区，从2011年开始行骗至今，据不完全统计已有数百人上当受骗，其本人依靠骗来的钱财，购置了一处房产，买了一辆50多w的豪车，雇佣了保镖以及打手数人。被骗人员多次报警，起诉，均无果，任由开来营继续逍遥法外。</p><h3 id="有幸遇到房东直租"><a href="#有幸遇到房东直租" class="headerlink" title="有幸遇到房东直租"></a>有幸遇到房东直租</h3><p>“好”房东很重要，如果感觉气场不和，请不要将就，对双方都不好。</p><ul><li>因为供暖排水门锁证件等偶发的琐事产生沟通的时候，房东与你于之前的租客进行对比“之前租客都没问题”，请小心，推荐和爽快的人沟通，可以避免下面的许多问题（房子质量好同样可以大概率避免问题）。</li><li><strong>不要急于交定金/押金，多数是套路</strong>（房源确实抢手的时期，房东靠谱，交全款也没事）</li><li>去现场看房子的时候，如果房子很破，屋内东西乱丢，99%是二房东或者刚买来专门用来出租的屋子，请多留意屋子中的排水和保暖问题。</li><li>靠谱房东，在你看房子的时候，多数会主动跟你沟通和妥协：“这个灯不好，我下午给你换了”对比“这个将就一下也能用”好坏立辨，但也请判别是否是专业中介，只说不做的那种…</li></ul><h3 id="期望合租的房客"><a href="#期望合租的房客" class="headerlink" title="期望合租的房客"></a>期望合租的房客</h3><p>不论是为了节约租房成本，控制房租在个人经济支出比重，还是考虑有个互相照应、结识新朋友，来到大城市的前期，合租是个不错的选择。</p><ul><li>你单枪匹马，屋子已经有其他房客入住<ul><li>尽可能了解到对方是从事什么职业，以及是否为常住人员。避免和经常流动的人员同住，发生潜在的安全隐患以及财物损失。</li><li>尽可能了解房屋基础安全设施是否到位<ul><li>是否存在老化的煤气管道、开关，房东是否愿意修理或者更换，或者允许租客修理替换。</li><li>是否存在随处可见的烟头。</li><li>是否存在同住房客随意带陌生人留宿的现象</li></ul></li></ul></li><li>你和小伙伴组队租房<ul><li>大家觉得都OK最重要</li><li>其他参考上面的事项</li></ul></li></ul><h3 id="相对靠谱的房子来源"><a href="#相对靠谱的房子来源" class="headerlink" title="相对靠谱的房子来源"></a>相对靠谱的房子来源</h3><p>任何一个平台、渠道信息量大之后，难免出现“有效信息质量下降”，诸如赶某网、5某网、搜某网、豆某小组等网站，上面的中介&amp;伪装成中介的骗子居多，如使用该渠道，请仔细辨别：</p><ul><li>请优先使用校园论坛、朋友介绍、公司BBS、熟人IM社群等信息，但是同样需要仔细辨别信息真实程度。</li><li>除了主动或者被动（被相关信息网站标记）显示是中介的，包含以下信息大概率为二房东：<ul><li>对标题做过特别优化等内容、发布内容格式特别“规范化”，例如：五道口地铁附近三室一厅朝南房主直急租月付季付当面可谈（巴不得内容全部在标题中体现）。</li><li>房子照片可以在其他非租房信息发布的地方被搜到，多数为效果图、设计图等。推荐使用搜索引擎以图搜图来判别。<ul><li>同一手机号码发布多条不在同一地点的房源，基本是骗子类型的中介。</li><li>张贴满大街的广告并非一般房东所为，一般为二房东或者小中介。</li></ul></li><li>黑中介的特点无非是：<ul><li><strong>广泛投放性价比高出市场对信息</strong>：在各种分类信息网站或者论坛投放大量描述红红绿绿、价格远低于市场价、描述看起来很好、效果图惊艳的房子。</li><li><strong>避免直接与客户进行沟通露馅</strong>：打电话联系他们，会被对方草草挂掉，然后短信回复你，告知你一个公司的所在地，让你来公司办理入住业务。</li><li><strong>在看房之前急于促成租房合同</strong>：去公司之后，一个劲保证你想要住的地方绝对有房子，先签合同会有专人带你看房。交完佣金之后，可能会给你一套破烂到不行的房子。</li><li><strong>电话里沟通过的房子在带看的时候进行更换</strong>：电话里沟通好的房子，见面后告知刚被出租出去，恰好有另外一个惊喜的房子在等待你；在你不满意时，就带你去一个别的小区（不是你原计划居住的小区），带你去的小区往往是居住条件不好，房子多没人住的小区。同时，房东会因为找中介给佣金而提高房价。</li><li>这样你用高价住了破房子还甩给了黑中介一笔佣金。</li></ul></li></ul></li></ul><h3 id="可能被夸大描述的信息"><a href="#可能被夸大描述的信息" class="headerlink" title="可能被夸大描述的信息"></a>可能被夸大描述的信息</h3><p>在签合同入住之前，请客观对房子进行评价，对房屋信息做到眼见为实，而不是轻信描述信息。</p><ul><li>大</li><li>安静</li><li>朝向南</li><li>有某设施</li><li>低时间成本</li><li>超高的性价比</li></ul><p>展开描述一下：</p><ul><li>房子的平米数据很漂亮，但是有的二房东可以把一个70平米的房子拆成4个25平米的房子租出去。</li><li>建议在房子内多待一阵，计划长租可以白天晚上都去房子里看看，街道、邻居是否过分喧哗。</li><li>朝向这个是玄学、西南向的房子不太好住。</li><li>带阳台、带窗户。注意，“带”和“带有用的”是两回事。</li><li>离地铁 5～10 分钟，可能需要特别的大长腿，或者步幅特别快。</li></ul><p>总之，基本上除了地方可以勉强信一下，其他信息在眼见为实之前基本不要轻信。</p><ul><li>如果是中介，不要相信不要中介费，羊毛出在羊身上。</li><li>如果找中介，请找靠谱中介。所谓靠谱，就是必须至少十几家以上连锁，店面名字你听说过。不然貌似省下来的中介费，最终很有可能会从诸如说你破坏东西扣除或者赖着不给你的押金、签合同时突然增加的卫生费（丫才不给你打扫）等等方式找回来。为了省心，请选靠谱中介。</li><li>如果不确定中介是否靠谱，可以搜中介名称+骗子，然后自行鉴定。</li><li>提前至少两周开始找房子，多打电话，中介一律屏蔽（不然烦死你）。多看房，找到房东之后看房本。合同一定要签，不要犯傻。</li><li>如果和中介签合同，尤其不是靠谱中介，合同的每一个字都要看，不要相信他所说的话，合同他都有不承认的时候。</li><li>永远不要信，我是房东，我出差在外面，请转账给我老婆。</li><li><strong>签合同的小技巧</strong>合同中约定（例如必需水电的故障需要3日内修好，或者说好给你个衣柜之类）的内容房东有时会拒绝执行，在签署合同的时候，首先一切以合同为准，其次在约定中补充<em>如果不能满足允许房客随时退房，押金不得以任何理由扣留，已经交的租金按日计算返还</em>，一般会比较有效。</li></ul><h3 id="签订合同前建议获取的信息"><a href="#签订合同前建议获取的信息" class="headerlink" title="签订合同前建议获取的信息"></a>签订合同前建议获取的信息</h3><ul><li>先了解和你沟通的出租人<strong>是否有权利出租该房屋</strong>。<ul><li>必须验明房东产权证，验看出租人的身份证是否与产权证一致。</li><li>代替家人（公公／婆婆／表亲）进行房屋出租的“房东”，是否为戏精租客扮演的二房东，如果是真的亲戚代理房东进行出租，如果出了问题，她能代理和解决么。</li><li>尽量不要和房东朋友（基友／闺蜜）代理房东出租房屋产生合作，减少不必要麻烦。</li></ul></li><li>租客是否有权再次出租、转租房屋，如果是房东一般不允许出租，转租也是比较抵触的。</li><li>房东是否能提供或者办理《房屋租赁许可证》，一般建议到当地街道派出所进行办理，对房东也是一种保护，不过这个会牵扯到一些额外的费用，许多房东会回避掉。<ul><li>该许可证也可能会因为特殊原因没有，如回迁房。</li></ul></li><li>查看房屋的实际使用条件与状况<ul><li>房子的实际使用面积是否能够接受</li><li>房子的隔音效果是否能接受（邻居、街道）</li><li>房子的家具是否有严重的气味（装修、家具、环境等因素）</li><li>窗户是否严密，开关是否正常（漏风）</li><li>如果阳台没有包裹，建议不要租，会有蚊虫、灰尘，以及保暖隐患。</li><li>如果周围有工地和马路，不要租，会很喧哗，特殊情况，会喧哗到很晚。</li><li>如果是老房子，房屋下水（洗手池/马桶/地漏）有问题，不要租，轻则影响自己，重则淹了楼下。</li><li>如果是老房子，门锁有问题，房东含糊换锁或者不可以换锁的话，不要租。</li><li>附加：电梯的使用（搬家/购置东西）</li><li>如果缺少的东西，房东是否能补齐</li><li>有条件的话，最好可以试住一到两天。检查的时候看不出问题，住进去潜在问题就会出来。</li></ul></li><li>简单了解治安状况<ul><li>小区、单元是否有门禁系统、或者物业保安值守。</li><li>一般距离地铁越近的小区，流动性越大，距离地铁有十几分钟的走路时间的小区可能是不错的选择（共享单车、顺风车）。</li></ul></li><li>房子周围设施是否相对方便<ul><li>交通措施是否过度单一或者匮乏</li><li>是否有社区医疗应急（附近有大医院可忽略）</li><li>附近吃喝的地方多吗（依赖外卖、自己做饭可忽略）</li><li>便利店、超市、购物中心是否存在，如果购置东西并非全部依赖在线，需要考虑线下购物的便利性。</li><li>如果只是为了距离上班地点近，可以舍弃一些或者全部</li></ul></li><li><strong>针对在上海的同学们：</strong> 需要提前和与你签协议的人沟通，是否能办理居住证，办理居住证对于希望常驻上海的同学来说很重要，因为有些东西（买车买房小孩上学之类）是要看居住证的年限的。建议将<em>必须要办理居住证，否则随时可退房</em>作为补充条款写入。</li><li><strong>针对有小孩的同学们</strong> 提前和房东沟通可否办理租住手续（官方），现在租住同权，如果租住的是学区房小孩可以在该学区上学，但是有的时候一些自己有小孩的房东可能会拒绝。</li><li>明确公用的基础设施的使用和维修：对于群租的同学来说，<strong>卫生间（热水器，洗衣机），厨房（煤气灶、冰箱、微波炉）</strong>很可能是公用的，当公用的设施损坏以后，维修的责任需要在合同中厘清，并且规定维修时间，以防止房东或者二房东推脱责任，或者拖延不予维修。</li></ul><h3 id="明确费用"><a href="#明确费用" class="headerlink" title="明确费用"></a>明确费用</h3><p>明确以下费用由谁承担，可以注明数字时间的费用建议进行备注说明。</p><ul><li>水费<ul><li>是否分冷水/热水/清洁用水，如果区分单独确定费用。</li><li>比如北京热水涨价汹涌，问清楚价格，和充值方式（特别远的话，使用的话，多充值一点）。</li><li>热水可能以非常长的时间为缴纳周期，入住时，确保热水费用之前房东和中介是正常缴纳的。（遇到过几年没缴纳过热水费的自如房子）</li></ul></li><li>电费<ul><li>缴费方式，自己交电卡，有无电卡，还是代缴，价格。</li><li>是否为商用电（部分住宅是商用电）</li></ul></li><li>煤气费<ul><li>酒店公寓可能没有煤气，不存在煤气费一说。</li><li>如果依赖此项目，优先查看。</li><li>煤气费可能以非常长的时间为缴纳周期，入住时，确保煤气费用之前房东和中介是正常缴纳的。（遇到过几年没缴纳过煤气费的自如房子）</li></ul></li><li>电话费<ul><li>有的房子不存在此项，但是有的房子会是和房东手机绑定一起的。</li><li>如果是合租的人绑定手机，那么要查看单子缴费是月度/季度/年度。</li></ul></li><li>电视费用<ul><li>即使你不使用这个设备，这个费用也要询问的，以免账单突然多出一年费用。</li></ul></li><li>卫生费</li><li>物业费</li><li>网费</li><li>供暖费<ul><li>仅限北方，明确暖气费谁来承担，到了冬天才发现合同上未见说明。租金是承担了暖气费的标准的价格，但是却要自己交。以及暖气片存在位置会不会和合租人员产生缴费分歧。</li></ul></li><li>维修费和附带影响<ul><li>房东仓促做防水，防水坏掉了，楼下水漫金山，要维修，你可能要一半个月不能用卫生间。</li><li>年代久远的空调因漏气/坏件，还要租客你承担费用的情况，另外如果是发生在南方冬天…</li><li>灯泡这类易耗品最好也问下，一年不到，不知道是质量问题还是电压，换了4/5个，直到换了LED灯</li></ul></li><li>损坏赔偿<ul><li>如果存在某些情况，这个时候赔偿是补新，还是几倍价格，还是如何，确认清楚</li></ul></li><li>另外需要查看是否有欠费<ul><li>曾经遇到欠费600多的煤气费的业主出国，居委会三天两头上门找</li></ul></li><li>租赁期间对房屋修缮<ul><li>房屋以及附属设备出现问题或者故障，由谁维护，费用由谁承担</li></ul></li></ul><h3 id="租金支付"><a href="#租金支付" class="headerlink" title="租金支付"></a>租金支付</h3><ul><li>租金由出租人收取，是承租人使用房屋的对价;</li><li>物业管理费则由物业管理公司收取，是物业公司以自己的经营活动为所有业主、租户提供服务所收取的费用，二者不是一个法律关系，不能混为一谈。</li><li>但如双方在合同中对于此项无具体约定，则出租人无权要求承租人支付物业管理费。</li><li>签订租赁合同时要仔细阅读合同条款，对于模糊内容要详加询问，并落实于字面。<ul><li>在双方签订《房屋租赁合同》时最好将屋内所有物品详列一份清单，作为其合同附件收好。</li><li>如果可能多复印一份，我和舍友租房子，结果都找不到合同了。</li><li>合同明确租期内，房东是否可以涨价</li><li>合同明确押金以及押金退换方式（<strong>这里是深水区</strong>）</li><li>留意退房时卫生的字眼，比如“退房时房屋没有打扫干净，要扣200押金”。退房时的卫生要做到什么程度，要和房东提前明确，最好留录音和租房前的房屋照片。避免退房时被恶心房东刁难。</li></ul></li><li>如果万一不可避免地与奇葩房东发生冲突，可以参考以下维权案例<ul><li><a href="https://g.leaskh.com/2014/11/13/DIY-打官司-目录/" target="_blank" rel="noopener">DIY 打官司</a></li></ul></li></ul><h3 id="退房退租"><a href="#退房退租" class="headerlink" title="退房退租"></a>退房退租</h3><ul><li>不管出于什么原因，请尽早至少半个月，推荐一个月，和房东说明，以免耽误房东再次转租，影响自己的押金和人品。</li><li>在退房前，如果钥匙丢失，不能如数退还给房东。建议尽可能配一把钥匙。以免房东以影响安全的名义要你换锁。其实就是变相要扣押金，不要给他开口的机会。</li></ul>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/%E7%A7%9F%E6%88%BF%E9%A1%BB%E7%9F%A5.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>webpack</title>
      <link>http://mydearest.cn/2019/webpack.html</link>
      <guid>http://mydearest.cn/2019/webpack.html</guid>
      <pubDate>Sun, 18 Aug 2019 06:37:40 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;谈谈你对webpack的看法&quot;&gt;&lt;a href=&quot;#谈谈你对webpack的看法&quot; class=&quot;headerlink&quot; title=&quot;谈谈你对webpack的看法&quot;&gt;&lt;/a&gt;谈谈你对webpack的看法&lt;/h2&gt;&lt;p&gt;webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。&lt;/p&gt;
&lt;h2 id=&quot;webpack的基本功能和工作原理？&quot;&gt;&lt;a href=&quot;#webpack的基本功能和工作原理？&quot; class=&quot;headerlink&quot; title=&quot;webpack的基本功能和工作原理？&quot;&gt;&lt;/a&gt;webpack的基本功能和工作原理？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等&lt;/li&gt;
&lt;li&gt;文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等&lt;/li&gt;
&lt;li&gt;代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载&lt;/li&gt;
&lt;li&gt;模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件&lt;/li&gt;
&lt;li&gt;自动刷新：监听本地源代码的变化，自动构建，刷新浏览器&lt;/li&gt;
&lt;li&gt;代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过&lt;/li&gt;
&lt;li&gt;自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;webpack构建过程&quot;&gt;&lt;a href=&quot;#webpack构建过程&quot; class=&quot;headerlink&quot; title=&quot;webpack构建过程&quot;&gt;&lt;/a&gt;webpack构建过程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;从entry里配置的module开始递归解析entry依赖的所有module&lt;/li&gt;
&lt;li&gt;每找到一个module，就会根据配置的loader去找对应的转换规则&lt;/li&gt;
&lt;li&gt;对module进行转换后，再解析出当前module依赖的module&lt;/li&gt;
&lt;li&gt;这些模块会以entry为单位分组，一个entry和其所有依赖的module被分到一个组Chunk&lt;/li&gt;
&lt;li&gt;最后webpack会把所有Chunk转换成文件输出&lt;/li&gt;
&lt;li&gt;在整个流程中webpack会在恰当的时机执行plugin里定义的逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;webpack打包原理&quot;&gt;&lt;a href=&quot;#webpack打包原理&quot; class=&quot;headerlink&quot; title=&quot;webpack打包原理&quot;&gt;&lt;/a&gt;webpack打包原理&lt;/h2&gt;&lt;h2 id=&quot;将所有依赖打包成一个bundle-js，通过代码分割成单元片段按需加载&quot;&gt;&lt;a href=&quot;#将所有依赖打包成一个bundle-js，通过代码分割成单元片段按需加载&quot; class=&quot;headerlink&quot; title=&quot;将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载&quot;&gt;&lt;/a&gt;将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载&lt;/h2&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="谈谈你对webpack的看法"><a href="#谈谈你对webpack的看法" class="headerlink" title="谈谈你对webpack的看法"></a>谈谈你对webpack的看法</h2><p>webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。</p><h2 id="webpack的基本功能和工作原理？"><a href="#webpack的基本功能和工作原理？" class="headerlink" title="webpack的基本功能和工作原理？"></a>webpack的基本功能和工作原理？</h2><ul><li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</li><li>模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</li><li>自动刷新：监听本地源代码的变化，自动构建，刷新浏览器</li><li>代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><h2 id="webpack构建过程"><a href="#webpack构建过程" class="headerlink" title="webpack构建过程"></a>webpack构建过程</h2><ul><li>从entry里配置的module开始递归解析entry依赖的所有module</li><li>每找到一个module，就会根据配置的loader去找对应的转换规则</li><li>对module进行转换后，再解析出当前module依赖的module</li><li>这些模块会以entry为单位分组，一个entry和其所有依赖的module被分到一个组Chunk</li><li>最后webpack会把所有Chunk转换成文件输出</li><li>在整个流程中webpack会在恰当的时机执行plugin里定义的逻辑</li></ul><h2 id="webpack打包原理"><a href="#webpack打包原理" class="headerlink" title="webpack打包原理"></a>webpack打包原理</h2><h2 id="将所有依赖打包成一个bundle-js，通过代码分割成单元片段按需加载"><a href="#将所有依赖打包成一个bundle-js，通过代码分割成单元片段按需加载" class="headerlink" title="将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载"></a>将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载</h2><a id="more"></a><h2 id="什么是webpack，与gulp-grunt有什么区别"><a href="#什么是webpack，与gulp-grunt有什么区别" class="headerlink" title="什么是webpack，与gulp,grunt有什么区别"></a>什么是webpack，与gulp,grunt有什么区别</h2><ul><li>webpack是一个模块打包工具，可以递归地打包项目中的所有模块，最终生成几个打包后的文件。</li><li>区别：webpack支持代码分割，模块化（AMD,CommonJ,ES2015），全局分析</li></ul><h2 id="什么是entry-output"><a href="#什么是entry-output" class="headerlink" title="什么是entry,output?"></a>什么是entry,output?</h2><ul><li>entry 入口，告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/index.js</li><li>output 出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist</li></ul><h2 id="什么是loader，plugins"><a href="#什么是loader，plugins" class="headerlink" title="什么是loader，plugins?"></a>什么是loader，plugins?</h2><ul><li>loader是用来告诉webpack如何转换某一类型的文件，并且引入到打包出的文件中。</li><li>plugins(插件)作用更大，可以打包优化，资源管理和注入环境变量</li></ul><h2 id="什么是bundle-chunk-module"><a href="#什么是bundle-chunk-module" class="headerlink" title="什么是bundle,chunk,module?"></a>什么是bundle,chunk,module?</h2><p>bundle是webpack打包出来的文件，chunk是webpack在进行模块的依赖分析的时候，代码分割出来的代码块。module是开发中的单个模块</p><h2 id="如何自动生成webpack配置？"><a href="#如何自动生成webpack配置？" class="headerlink" title="如何自动生成webpack配置？"></a>如何自动生成webpack配置？</h2><p>可以用一些官方脚手架</p><ul><li>webpack-cli</li><li>vue-cli</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先安装</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">// 新建项目hello</span></span><br><span class="line">vue create hello</span><br></pre></td></tr></table></figure><p>nuxt-cli<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保安装了npx,npx在npm5.2.0默认安装了</span></span><br><span class="line"><span class="comment">// 新建项目hello</span></span><br><span class="line">npx create-nuxt-app hello</span><br></pre></td></tr></table></figure></p><h2 id="webpack如何配置单页面和多页面的应用程序？"><a href="#webpack如何配置单页面和多页面的应用程序？" class="headerlink" title="webpack如何配置单页面和多页面的应用程序？"></a>webpack如何配置单页面和多页面的应用程序？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个页面</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多页面应用程序</span></span><br><span class="line"><span class="built_in">module</span>.entrys = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        pageOne: <span class="string">'./src/pageOne/index.js'</span>,</span><br><span class="line">        pageTwo: <span class="string">'./src/pageTwo/index.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="几个常见的loader"><a href="#几个常见的loader" class="headerlink" title="几个常见的loader"></a>几个常见的loader</h2><ul><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li><li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>image-loader：加载并且压缩图片文件</li><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><h2 id="几个常见的plugin"><a href="#几个常见的plugin" class="headerlink" title="几个常见的plugin"></a>几个常见的plugin</h2><ul><li>define-plugin：定义环境变量</li><li>terser-webpack-plugin：通过TerserPlugin压缩ES6代码</li><li>html-webpack-plugin 为html文件中引入的外部资源，可以生成创建html入口文件</li><li>mini-css-extract-plugin：分离css文件</li><li>clean-webpack-plugin：删除打包文件</li><li>happypack：实现多线程加速编译</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">var</span> providePlugin = <span class="keyword">new</span> webpack.ProvidePlugin(&#123;<span class="attr">$</span>: <span class="string">'jquery'</span>, <span class="attr">jQuery</span>: <span class="string">'jquery'</span>, <span class="string">'window.jQuery'</span>: <span class="string">'jquery'</span>&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">'./src/js/index.js'</span>,</span><br><span class="line">        goodsInfo: <span class="string">'./src/js/goodsInfo.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/out'</span>,</span><br><span class="line">        publicPath: <span class="string">'http://localhost:8080/out'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;<span class="attr">test</span>: <span class="regexp">/.js$/</span>, <span class="attr">use</span>: [<span class="string">'babel-loader'</span>]&#125;,</span><br><span class="line">            <span class="comment">// // &#123;test: /.css$/, use: ['style-loader','css-loader']&#125;,</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     test: /.css$/,</span></span><br><span class="line">            <span class="comment">//     use: ExtractTextPlugin.extract(&#123;</span></span><br><span class="line">            <span class="comment">//       fallback: "style-loader",</span></span><br><span class="line">            <span class="comment">//       use: "css-loader"</span></span><br><span class="line">            <span class="comment">//     &#125;)</span></span><br><span class="line">            <span class="comment">// &#125;,</span></span><br><span class="line">            &#123;<span class="attr">test</span>: <span class="regexp">/.jpg|png|gif|svg$/</span>, <span class="attr">use</span>: [<span class="string">'url-loader?limit=8192&amp;name=./[name].[ext]'</span>]&#125;, </span><br><span class="line">            &#123;<span class="attr">test</span>: <span class="regexp">/.less$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> UglifyJSPlugin(),</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">            name: <span class="string">"commons"</span>,</span><br><span class="line">            filename: <span class="string">"commons.js"</span>,</span><br><span class="line">            minChunks:<span class="number">2</span>&#125;),  </span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].css"</span>), </span><br><span class="line">        providePlugin     </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/webpack.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>成为优秀程序员的建议</title>
      <link>http://mydearest.cn/2019/%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BB%BA%E8%AE%AE.html</link>
      <guid>http://mydearest.cn/2019/%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BB%BA%E8%AE%AE.html</guid>
      <pubDate>Sat, 17 Aug 2019 17:21:18 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;1-善用google⭐&quot;&gt;&lt;a href=&quot;#1-善用google⭐&quot; class=&quot;headerlink&quot; title=&quot;1. 善用google⭐&quot;&gt;&lt;/a&gt;1. 善用google⭐&lt;/h3&gt;&lt;p&gt;作为一名程序员，你要知道如何搜索问题的答案。学会有效的使用google，你将节省大量开发时间。  &lt;/p&gt;
&lt;h3 id=&quot;2-谨慎承诺超额交付⭐&quot;&gt;&lt;a href=&quot;#2-谨慎承诺超额交付⭐&quot; class=&quot;headerlink&quot; title=&quot;2. 谨慎承诺超额交付⭐&quot;&gt;&lt;/a&gt;2. 谨慎承诺超额交付⭐&lt;/h3&gt;&lt;p&gt;让你的团队知道一项任务需要三周的时间，并在两周内完成，这比让他们知道相反的情况要好。通过谨慎承诺和超额交付，你会建立信任。&lt;/p&gt;
&lt;h3 id=&quot;3-善待产品设计人员，他们是你的朋友&quot;&gt;&lt;a href=&quot;#3-善待产品设计人员，他们是你的朋友&quot; class=&quot;headerlink&quot; title=&quot;3. 善待产品设计人员，他们是你的朋友&quot;&gt;&lt;/a&gt;3. 善待产品设计人员，他们是你的朋友&lt;/h3&gt;&lt;p&gt;产品设计人员为用户的痛点提供解决方案。向他们学习，团结一致地构建有效的产品。&lt;/p&gt;
&lt;h3 id=&quot;4-找到一名导师&quot;&gt;&lt;a href=&quot;#4-找到一名导师&quot; class=&quot;headerlink&quot; title=&quot;4. 找到一名导师&quot;&gt;&lt;/a&gt;4. 找到一名导师&lt;/h3&gt;&lt;p&gt;找到一个可以学习和借鉴的人。如果你需要技术指导，&lt;a href=&quot;https://codingcoach.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coding Coach&lt;/a&gt;会是一个不错的地方。&lt;/p&gt;
&lt;h3 id=&quot;5-成为一名导师&quot;&gt;&lt;a href=&quot;#5-成为一名导师&quot; class=&quot;headerlink&quot; title=&quot;5. 成为一名导师&quot;&gt;&lt;/a&gt;5. 成为一名导师&lt;/h3&gt;&lt;p&gt;做一个别人可以学习和借鉴的人。你可以尝试在&lt;a href=&quot;https://codingcoach.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Coding Coach&lt;/a&gt;成为别人的导师。&lt;/p&gt;
&lt;h3 id=&quot;6-写些有用的评论&quot;&gt;&lt;a href=&quot;#6-写些有用的评论&quot; class=&quot;headerlink&quot; title=&quot;6. 写些有用的评论&quot;&gt;&lt;/a&gt;6. 写些有用的评论&lt;/h3&gt;&lt;p&gt;写下有用的回答而不是问为什么，mark和灌水也没什么意思。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="1-善用google⭐"><a href="#1-善用google⭐" class="headerlink" title="1. 善用google⭐"></a>1. 善用google⭐</h3><p>作为一名程序员，你要知道如何搜索问题的答案。学会有效的使用google，你将节省大量开发时间。  </p><h3 id="2-谨慎承诺超额交付⭐"><a href="#2-谨慎承诺超额交付⭐" class="headerlink" title="2. 谨慎承诺超额交付⭐"></a>2. 谨慎承诺超额交付⭐</h3><p>让你的团队知道一项任务需要三周的时间，并在两周内完成，这比让他们知道相反的情况要好。通过谨慎承诺和超额交付，你会建立信任。</p><h3 id="3-善待产品设计人员，他们是你的朋友"><a href="#3-善待产品设计人员，他们是你的朋友" class="headerlink" title="3. 善待产品设计人员，他们是你的朋友"></a>3. 善待产品设计人员，他们是你的朋友</h3><p>产品设计人员为用户的痛点提供解决方案。向他们学习，团结一致地构建有效的产品。</p><h3 id="4-找到一名导师"><a href="#4-找到一名导师" class="headerlink" title="4. 找到一名导师"></a>4. 找到一名导师</h3><p>找到一个可以学习和借鉴的人。如果你需要技术指导，<a href="https://codingcoach.io/" target="_blank" rel="noopener">Coding Coach</a>会是一个不错的地方。</p><h3 id="5-成为一名导师"><a href="#5-成为一名导师" class="headerlink" title="5. 成为一名导师"></a>5. 成为一名导师</h3><p>做一个别人可以学习和借鉴的人。你可以尝试在<a href="https://codingcoach.io/" target="_blank" rel="noopener">Coding Coach</a>成为别人的导师。</p><h3 id="6-写些有用的评论"><a href="#6-写些有用的评论" class="headerlink" title="6. 写些有用的评论"></a>6. 写些有用的评论</h3><p>写下有用的回答而不是问为什么，mark和灌水也没什么意思。</p><hr><a id="more"></a><h3 id="7-合理的命名变量和函数名"><a href="#7-合理的命名变量和函数名" class="headerlink" title="7. 合理的命名变量和函数名"></a>7. 合理的命名变量和函数名</h3><p>函数和变量应该准确地表示它们的用途，因此myCoolFunction不是一个好名字。</p><h3 id="8-给自己放个假"><a href="#8-给自己放个假" class="headerlink" title="8. 给自己放个假"></a>8. 给自己放个假</h3><p>我们都需要时间来缓解压力。去一个你一直想去的地方放个假。你的大脑和同事都会感谢你的。</p><h3 id="9-删除无用代码⭐"><a href="#9-删除无用代码⭐" class="headerlink" title="9. 删除无用代码⭐"></a>9. 删除无用代码⭐</h3><p>没有理由积累更多技术债务。</p><h3 id="10-学会阅读代码⭐"><a href="#10-学会阅读代码⭐" class="headerlink" title="10. 学会阅读代码⭐"></a>10. 学会阅读代码⭐</h3><p>阅读代码是一项非常宝贵的被低估的技能。</p><h3 id="11-找到健康工作和生活平衡点"><a href="#11-找到健康工作和生活平衡点" class="headerlink" title="11. 找到健康工作和生活平衡点"></a>11. 找到健康工作和生活平衡点</h3><p>结束一周的工作之后，周末放松一下。关闭工作通知，删除手机上的应用程序。</p><h3 id="12-只安排必要的会议"><a href="#12-只安排必要的会议" class="headerlink" title="12. 只安排必要的会议"></a>12. 只安排必要的会议</h3><p>能用邮件解决的就没必要开会，如果非要开，也应该让会议简短高效。</p><h3 id="13-结对编程"><a href="#13-结对编程" class="headerlink" title="13. 结对编程"></a>13. 结对编程</h3><p>结对编程可以让你同时扮演老师和学生的角色。</p><h3 id="14-写好邮件"><a href="#14-写好邮件" class="headerlink" title="14. 写好邮件"></a>14. 写好邮件</h3><p>邮件的内容应该简洁而清晰，抓住重点。没人会想看你的四页邮件，兄弟。</p><h3 id="15-加入社区⭐"><a href="#15-加入社区⭐" class="headerlink" title="15. 加入社区⭐"></a>15. 加入社区⭐</h3><p>和志同道合的人在一起会激励你走出低谷。</p><h3 id="16-清理你的分支⭐"><a href="#16-清理你的分支⭐" class="headerlink" title="16. 清理你的分支⭐"></a>16. 清理你的分支⭐</h3><p>清理你的版本控制分支，就像在你的岳父母来访之前清理你的房子一样。如果你不再需要，请删掉它，不删留着过年啊。</p><h3 id="17-接纳萌新"><a href="#17-接纳萌新" class="headerlink" title="17. 接纳萌新"></a>17. 接纳萌新</h3><p>包容点，不要告诉别人不够好，不能进入这个行业，每个人都是有价值。</p><h3 id="18-活到老学到老"><a href="#18-活到老学到老" class="headerlink" title="18. 活到老学到老"></a>18. 活到老学到老</h3><p>你选择了一个需要不断学习的职业，学会爱上它。</p><h3 id="19-永不言弃"><a href="#19-永不言弃" class="headerlink" title="19. 永不言弃"></a>19. 永不言弃</h3><p>这并不容易，但是我们都是从同一个地方开始，你也能做到。  </p><h3 id="20-敢于接受有挑战性的任务⭐"><a href="#20-敢于接受有挑战性的任务⭐" class="headerlink" title="20. 敢于接受有挑战性的任务⭐"></a>20. 敢于接受有挑战性的任务⭐</h3><p>如果任务没有挑战，它就不会帮助你成长。</p><h3 id="21-项目开始前明确需求⭐"><a href="#21-项目开始前明确需求⭐" class="headerlink" title="21. 项目开始前明确需求⭐"></a>21. 项目开始前明确需求⭐</h3><p>在开撸之前，你应该了解验收标准，这将为你节省时间和痛苦。</p><h3 id="22-工欲善其事，必先利其器⭐"><a href="#22-工欲善其事，必先利其器⭐" class="headerlink" title="22. 工欲善其事，必先利其器⭐"></a>22. 工欲善其事，必先利其器⭐</h3><p>拥有一套你熟悉的工具，了解哪些工具服务于哪些目的，以及项目何时可以从使用这些工具中获益。</p><h3 id="23-我们需要建设性的批评"><a href="#23-我们需要建设性的批评" class="headerlink" title="23. 我们需要建设性的批评"></a>23. 我们需要建设性的批评</h3><p>向信任的同事和朋友寻求建设性的批评，它将帮助你更优秀。 </p><h3 id="24-保持开放思维⭐"><a href="#24-保持开放思维⭐" class="headerlink" title="24. 保持开放思维⭐"></a>24. 保持开放思维⭐</h3><p>技术在变化，而且变化得很快。不要反对新技术，学习它，然后形成自己的观点。 </p><h3 id="25-保持在技术前沿，不要掉队⭐"><a href="#25-保持在技术前沿，不要掉队⭐" class="headerlink" title="25. 保持在技术前沿，不要掉队⭐"></a>25. 保持在技术前沿，不要掉队⭐</h3><p>通过关注出版物，博客，播客和科技新闻，及时了解最新的科技新闻。</p><h3 id="26-专注于解决问题⭐"><a href="#26-专注于解决问题⭐" class="headerlink" title="26. 专注于解决问题⭐"></a>26. 专注于解决问题⭐</h3><p>锻炼自己解决问题的能力，强大的解决问题的能力能够帮助你应付一切，专注于解决问题的方法。</p><h3 id="27-保持谦虚⭐"><a href="#27-保持谦虚⭐" class="headerlink" title="27. 保持谦虚⭐"></a>27. 保持谦虚⭐</h3><p>三人行必有我师，无论你什么头衔，什么公司，都要保持谦逊。</p><h3 id="28-不光要代码写的好，PPT也要讲得好"><a href="#28-不光要代码写的好，PPT也要讲得好" class="headerlink" title="28. 不光要代码写的好，PPT也要讲得好"></a>28. 不光要代码写的好，PPT也要讲得好</h3><p>学习如何吸引你的听众，并给出有效的演示。</p><h3 id="29-选型如买菜，也要货比三家⭐"><a href="#29-选型如买菜，也要货比三家⭐" class="headerlink" title="29.  选型如买菜，也要货比三家⭐"></a>29.  选型如买菜，也要货比三家⭐</h3><p>给自己更多选择，在开展工作前，调研尽可能多的解决方案。</p><h3 id="30-找到自己的定位⭐"><a href="#30-找到自己的定位⭐" class="headerlink" title="30. 找到自己的定位⭐"></a>30. 找到自己的定位⭐</h3><p>科技产业也有很多分类，找到你最感兴趣的领域，并成为一名专家。</p><h3 id="31-养成好习惯⭐"><a href="#31-养成好习惯⭐" class="headerlink" title="31. 养成好习惯⭐"></a>31. 养成好习惯⭐</h3><p>试着建立一致的、健康的习惯，比如保持专注，合理安排时间，出席会议，从最重要的任务开始。这可能需要一些时间来适应，但从长远来看是值得的。</p><h3 id="32-学会debug⭐"><a href="#32-学会debug⭐" class="headerlink" title="32. 学会debug⭐"></a>32. 学会debug⭐</h3><p>探索浏览器调试器工具。学习使用IDE调试的细节。通过学习最有效的调试问题和跟踪错误的方法，再困难的bug也能搞定。</p><h3 id="33-锻炼你现有的技能⭐"><a href="#33-锻炼你现有的技能⭐" class="headerlink" title="33. 锻炼你现有的技能⭐"></a>33. 锻炼你现有的技能⭐</h3><p>并不是说你已经掌握了一项技能就不需要再锻炼它。业精于勤荒于嬉，除非有意识地提高技能，否则技能会随着时间的推移而消失。而这个行业又发展得如此之快，坚持练习是很重要的。从“我一直都是这样做的”的心态中走出来，进入“有没有更好的方法来做这件事”的心态。  </p><p>仅仅是因为你现在拥有六块腹肌，不意味着你就可以每天吃一个🍩。</p><h3 id="34-了解原因⭐"><a href="#34-了解原因⭐" class="headerlink" title="34. 了解原因⭐"></a>34. 了解原因⭐</h3><p>有时你必须表达自己的意见，因此了解其背后的原因非常重要。为什么解决方案A比解决方案B更好？提供有效的论据，你的意见将更加可靠。</p><h3 id="35-了解自己的价值"><a href="#35-了解自己的价值" class="headerlink" title="35. 了解自己的价值"></a>35. 了解自己的价值</h3><p>技术也是商品，应该得到适当的报酬。了解你所在地区的行业平均水平。如果你赚的钱少了，是时候和你的老板谈谈，追求你应得的。</p><h3 id="36-不要害怕寻求帮助⭐"><a href="#36-不要害怕寻求帮助⭐" class="headerlink" title="36. 不要害怕寻求帮助⭐"></a>36. 不要害怕寻求帮助⭐</h3><p>如果你被困在一个问题上，花了太多时间寻找解决方案，是时候寻求帮助了。我们都是人，我们都需要帮助，寻求同事的援助并不可耻。</p><h3 id="37-学会学习⭐"><a href="#37-学会学习⭐" class="headerlink" title="37. 学会学习⭐"></a>37. 学会学习⭐</h3><p>人们学习的方式不同，有些人通过视频教程学得最好，有些人通过阅读书籍学得最好。弄清楚你的学习风格，然后努力实践。</p><h3 id="38-与人为善"><a href="#38-与人为善" class="headerlink" title="38. 与人为善"></a>38. 与人为善</h3><p>有时你会被要求向同事提供反馈，友善一点，你可以对某位同事不够积极表达看法，而不是出言不逊。</p><h3 id="39-休息一下"><a href="#39-休息一下" class="headerlink" title="39. 休息一下"></a>39. 休息一下</h3><p>连续敲8个小时代码几乎是不可能，你很快就会筋疲力尽，犯很多错误。所以设个闹钟来提醒自己停下来休息一下。去散散步，和同事一起喝杯咖啡，远离屏幕会对你的工作效率和质量产生积极的影响。</p><h3 id="40-跟踪你的学习进度"><a href="#40-跟踪你的学习进度" class="headerlink" title="40. 跟踪你的学习进度"></a>40. 跟踪你的学习进度</h3><p>学习编程需要时间，当你看不到进展时，你会感到非常沮丧。所以跟踪你的成就和实现目标的进展非常重要。在你的电脑旁边放一个小清单，每次你完成一件事，把它写下来，不管它有多小，最终将会从量变到质变。</p><h3 id="41-不要依赖库和框架⭐"><a href="#41-不要依赖库和框架⭐" class="headerlink" title="41. 不要依赖库和框架⭐"></a>41. 不要依赖库和框架⭐</h3><p>掌握一个框架和库不如深入学习这门语言，没有必要一个接一个的学习这些库和框架，但是理解框架和库如何实现可以帮助你写出更简洁强壮的代码。</p><h3 id="42-学会爱上代码审查"><a href="#42-学会爱上代码审查" class="headerlink" title="42. 学会爱上代码审查"></a>42. 学会爱上代码审查</h3><p>让别人阅读和分析你的代码可能会让你不安，但是可以提供宝贵的反馈，这会让你成为一个更好的程序员。而且你也应该提高进行良好代码评审的能力。</p><h3 id="43-多方位全面学习"><a href="#43-多方位全面学习" class="headerlink" title="43. 多方位全面学习"></a>43. 多方位全面学习</h3><p>学习其他领域的基础知识, 如设计、营销、前端开发或后端开发。它将帮助你成为一个更全面的程序员。</p><h3 id="44-不要选择熟悉的技术，而应该是正确的⭐"><a href="#44-不要选择熟悉的技术，而应该是正确的⭐" class="headerlink" title="44. 不要选择熟悉的技术，而应该是正确的⭐"></a>44. 不要选择熟悉的技术，而应该是正确的⭐</h3><p>每个项目都有不同的需求，因此我们必须为这项工作选择合适的工具。尽管选择以前使用过的技术很方便，但是如果它们不适合项目的需要，应该探索其他替代方案。</p><h3 id="45-勇于承担责任⭐"><a href="#45-勇于承担责任⭐" class="headerlink" title="45. 勇于承担责任⭐"></a>45. 勇于承担责任⭐</h3><p>所有人都会犯错，在你的职业生涯中，你会犯很多很多的错误。因此，当你犯了错误时，站出来承担责任是很重要的，它将与你的团队成员和管理层建立信任。</p><h3 id="46-检查自己的代码⭐"><a href="#46-检查自己的代码⭐" class="headerlink" title="46. 检查自己的代码⭐"></a>46. 检查自己的代码⭐</h3><p>在发起PR请求之前，检查自己的代码，如果这是同事的工作，你会发表什么评论？在请求代码审查之前首先尝试自己诊断问题或错误非常重要，就像考试交卷前应该自己检查一遍。</p><h3 id="47-从失败中吸取教训⭐"><a href="#47-从失败中吸取教训⭐" class="headerlink" title="47. 从失败中吸取教训⭐"></a>47. 从失败中吸取教训⭐</h3><p>失败只是没有达到预期的结果，并不一定是件坏事。在我们的职业生涯中，我们会面临很多失败，从失败中学习下次你能做些什么。   </p><h3 id="48-正视自己的缺点"><a href="#48-正视自己的缺点" class="headerlink" title="48. 正视自己的缺点"></a>48. 正视自己的缺点</h3><p>了解你自己，你的缺点是什么?也许你总是在推送之前忘记更新测试，或者你真的不擅长回复电子邮件。了解你的弱点，这样你就能积极地改善它们。</p><h3 id="49-保持好奇心⭐"><a href="#49-保持好奇心⭐" class="headerlink" title="49. 保持好奇心⭐"></a>49. 保持好奇心⭐</h3><p>这个行业在不断发展，所以好奇心很重要。如果你不明白什么，不管是项目需求还是一行代码，大声说出来。没有人会因为你要求说明而批评你，你会因此创造出更好的代码。   </p><h3 id="50-不要试图学习一切⭐"><a href="#50-不要试图学习一切⭐" class="headerlink" title="50. 不要试图学习一切⭐"></a>50. 不要试图学习一切⭐</h3><p>世界上有无穷无尽的知识宝库，你不可能征服它。选择几个要掌握的主题，其余的就不要管了。你可以获得其他领域的相关知识，但你不可能掌握所有内容。</p><h3 id="51-该舍弃就舍弃"><a href="#51-该舍弃就舍弃" class="headerlink" title="51.  该舍弃就舍弃"></a>51.  该舍弃就舍弃</h3><p>仅仅因为你写了一些代码并不意味着你需要对它产生感情。没有人喜欢他们所做的工作被丢弃，但是代码有一个生命周期，所以没有必要一直保留着它。</p><h3 id="52-团队支持"><a href="#52-团队支持" class="headerlink" title="52.  团队支持"></a>52.  团队支持</h3><p>优秀的团队相互支持，这为尝试新事物创造了一个安全的空间，而不用担心受到惩罚。</p><h3 id="53-在社区中寻找鼓舞"><a href="#53-在社区中寻找鼓舞" class="headerlink" title="53. 在社区中寻找鼓舞"></a>53. 在社区中寻找鼓舞</h3><p>在行业里找几个你钦佩的人。它会激励你继续你的项目或尝试新事物</p><h3 id="54-重视并且珍惜你的工作"><a href="#54-重视并且珍惜你的工作" class="headerlink" title="54. 重视并且珍惜你的工作"></a>54. 重视并且珍惜你的工作</h3><p>不管你有多少经验或者你的职位是什么，你的工作都是有价值的，给予它应有的价值。</p><h3 id="55-排除干扰"><a href="#55-排除干扰" class="headerlink" title="55. 排除干扰"></a>55. 排除干扰</h3><p>关掉闲置的通知、短信、电子邮件和社交媒体会帮助你集中精力，最大化你的工作日。晚30分钟回复你朋友的信息，他死不了，真有事就打电话了。</p><h3 id="56-乐于助人"><a href="#56-乐于助人" class="headerlink" title="56. 乐于助人"></a>56. 乐于助人</h3><p>试着支持你的团队成员，无论是参加一个重要的演讲，还是在他们遇到困难时帮助他们。</p><h3 id="57-不要吝啬你的赞美⭐"><a href="#57-不要吝啬你的赞美⭐" class="headerlink" title="57. 不要吝啬你的赞美⭐"></a>57. 不要吝啬你的赞美⭐</h3><p>如果有人做得很好，告诉他们。正面反馈是与团队成员建立信任和帮助他们事业发展的好方法。他们也更有可能帮助你</p><h3 id="58-测试你的代码⭐"><a href="#58-测试你的代码⭐" class="headerlink" title="58. 测试你的代码⭐"></a>58. 测试你的代码⭐</h3><p>测试是很重要的。单元测试、回归测试、集成测试、端到端测试。测试你的代码，你的产品将会更加稳定。</p><h3 id="59-制定应对计划"><a href="#59-制定应对计划" class="headerlink" title="59. 制定应对计划"></a>59. 制定应对计划</h3><p>当你收到一个新功能需求或bug修改时，先制定应对计划，你需要什么来解决这个问题或开发这个特性？花几分钟来做这件事，也许后面可以为你节省数小时的沮丧。</p><h3 id="60-掌握伪代码"><a href="#60-掌握伪代码" class="headerlink" title="60. 掌握伪代码"></a>60. 掌握伪代码</h3><p>伪代码是一项很好的技能，因为它允许你在不浪费时间编写代码的情况下考虑复杂的问题。将一种方法写在纸上，运行不同的测试用例，看看缺陷在哪里。</p><h3 id="61-记录你的成就"><a href="#61-记录你的成就" class="headerlink" title="61. 记录你的成就"></a>61. 记录你的成就</h3><p>如果你在工作中获得了嘉奖，把它写下来。如果你开发了一个重要的功能，把它写下来。你会拥有一些积累、沉淀，它将有助于你职业晋升亦或在某一艰难的日子鼓舞你的士气。</p><h3 id="62-学习编程基础⭐"><a href="#62-学习编程基础⭐" class="headerlink" title="62. 学习编程基础⭐"></a>62. 学习编程基础⭐</h3><p>学习一些基本的排序和搜索算法以及数据结构。它们与语言无关，可以帮助你跨语言解决问题。</p><h3 id="63-选择长期维护的技术"><a href="#63-选择长期维护的技术" class="headerlink" title="63. 选择长期维护的技术"></a>63. 选择长期维护的技术</h3><p>尽管测试最新的技术很有趣，但是选择那些在企业应用程序中易于维护的技术。你们的团队将在未来的岁月里感谢你们。</p><h3 id="64-学习设计模式⭐"><a href="#64-学习设计模式⭐" class="headerlink" title="64. 学习设计模式⭐"></a>64. 学习设计模式⭐</h3><p>设计模式是构建代码的有效工具。你可能不是每个项目都需要它们，但是对它们有一个基本的了解将有助于构建更大的应用程序。</p><h3 id="65-化繁为简⭐"><a href="#65-化繁为简⭐" class="headerlink" title="65. 化繁为简⭐"></a>65. 化繁为简⭐</h3><p>不要编写复杂的代码来展示你高超的编程技能，而要着眼于可读性和简单性。这将使你的团队成员更容易做出贡献。</p><h3 id="66-还清技术债务"><a href="#66-还清技术债务" class="headerlink" title="66. 还清技术债务"></a>66. 还清技术债务</h3><p>技术债务可能会对性能产生巨大影响，所以如果能够重构，就应该重构。（这个建议绝对是好的，但是现实中要面临诸多问题）</p><h3 id="67-优先小版本迭代"><a href="#67-优先小版本迭代" class="headerlink" title="67. 优先小版本迭代"></a>67. 优先小版本迭代</h3><p>与其每个月发布一次大规模的升级，不如更频繁地发布较小的变更。这样你不太可能会引入bug和破坏更改。</p><h3 id="68-尽早并经常提交⭐"><a href="#68-尽早并经常提交⭐" class="headerlink" title="68. 尽早并经常提交⭐"></a>68. 尽早并经常提交⭐</h3><p>尽早提交和经常提交是确保你的工作保持干净的最好方法，并且还可以减少意外地恢复重要更改的压力。</p><h3 id="69-了解何时寻求帮助"><a href="#69-了解何时寻求帮助" class="headerlink" title="69. 了解何时寻求帮助"></a>69. 了解何时寻求帮助</h3><p>你不仅不应该害怕寻求帮助，而且你应该学会什么时候寻求帮助。在寻求帮助之前，你应该试着解决问题，并记录下你尝试的事情。但是当你被一个简单的问题难住一个多小时的时候，代价大于收益，你应该向同事求助。</p><h3 id="70-问一些有效的问题⭐"><a href="#70-问一些有效的问题⭐" class="headerlink" title="70. 问一些有效的问题⭐"></a>70. 问一些有效的问题⭐</h3><p>当你问问题的时候，要尽可能的具体，（可以参考github提issue的要求）。</p><h3 id="71-工作中及时寻求反馈"><a href="#71-工作中及时寻求反馈" class="headerlink" title="71. 工作中及时寻求反馈"></a>71. 工作中及时寻求反馈</h3><p>你的工作不需要完成就能得到反馈。如果你不确定方向，请一位值得信赖的同事来检查你的解决方案的有效性。</p><h3 id="72-阅读文档⭐"><a href="#72-阅读文档⭐" class="headerlink" title="72. 阅读文档⭐"></a>72. 阅读文档⭐</h3><p>文档是关于技术的最纯粹的事实来源，因此学习阅读文档可以快速帮助你成为专家。</p><p>###　73. 尽可能做出各种尝试⭐没有什么能阻止你尝试解决问题的方法，你有什么损失呢？</p><h3 id="74-在会议上积极发言"><a href="#74-在会议上积极发言" class="headerlink" title="74. 在会议上积极发言"></a>74. 在会议上积极发言</h3><p>你的想法和意见是有价值的，所以参加会议将有助于你与你的团队和管理层建立融洽的关系。</p><h3 id="75-跨团队协作"><a href="#75-跨团队协作" class="headerlink" title="75. 跨团队协作"></a>75. 跨团队协作</h3><p>如果你有机会和公司里的其他团队一起工作，那就去争取吧。</p><h3 id="76-保持项目热情"><a href="#76-保持项目热情" class="headerlink" title="76. 保持项目热情"></a>76. 保持项目热情</h3><p>当你每周工作40个小时时，花时间做你感兴趣的项目是很重要的（72小时的话更要如此）。它们可以帮助你重新找回对编程的热爱，并尝试你在工作中可能无法接触到的新技术。</p><h3 id="77-确定你的职业目标⭐"><a href="#77-确定你的职业目标⭐" class="headerlink" title="77. 确定你的职业目标⭐"></a>77. 确定你的职业目标⭐</h3><p>对你的职业生涯有一个理想的轨迹是很重要的。如果你不这样做，你就是在没有目标的情况下射箭。</p><h3 id="78-加入到讨论中来⭐"><a href="#78-加入到讨论中来⭐" class="headerlink" title="78. 加入到讨论中来⭐"></a>78. 加入到讨论中来⭐</h3><p>在博客上发表评论，参与Twitter主题，参与社区活动，做一个积极的旁观者会比单纯的旁观学到更多东西。</p><h3 id="79-确定任务优先级"><a href="#79-确定任务优先级" class="headerlink" title="79. 确定任务优先级"></a>79. 确定任务优先级</h3><p>学会确定任务的优先顺序将有助于提高您的工作效率，建立一个日常任务和长期任务待办事项列表，并按最重要的顺序排序。</p><h3 id="80-不要忽略细节"><a href="#80-不要忽略细节" class="headerlink" title="80. 不要忽略细节"></a>80. 不要忽略细节</h3><p>细节可以在项目中产生很大的影响。</p><h3 id="81-信任你的同事"><a href="#81-信任你的同事" class="headerlink" title="81. 信任你的同事"></a>81. 信任你的同事</h3><p>你的同事因为他们的技能而被雇佣，交给他们工作，并相信他们能完成。</p><h3 id="82-学会委托"><a href="#82-学会委托" class="headerlink" title="82. 学会委托"></a>82. 学会委托</h3><p>如果你处于领导地位，学习如何有效地委派任务。它会节省你的时间，你不能做所有的事。</p><h3 id="83-不要拿自己和别人比较"><a href="#83-不要拿自己和别人比较" class="headerlink" title="83. 不要拿自己和别人比较"></a>83. 不要拿自己和别人比较</h3><p>你唯一应该比较的是昨天的自己。</p><h3 id="84-找到你的盟友"><a href="#84-找到你的盟友" class="headerlink" title="84. 找到你的盟友"></a>84. 找到你的盟友</h3><p>学习编程将是一个漫长而不怎么容易的过程，和那些帮助你成长并鼓励你坚持下去的人在一起。</p><h3 id="85-不要想一步登天⭐"><a href="#85-不要想一步登天⭐" class="headerlink" title="85. 不要想一步登天⭐"></a>85. 不要想一步登天⭐</h3><p>一开始考虑太多做一个大而全的项目会让你不堪重负。构建时要考虑可伸缩性，但在需要时才开始扩展。这样你就不会用不必要的膨胀来压倒你的团队，而是保持了成长的能力。</p><h3 id="86-衡量性能影响⭐"><a href="#86-衡量性能影响⭐" class="headerlink" title="86. 衡量性能影响⭐"></a>86. 衡量性能影响⭐</h3><p>如果你想使用一种很酷的新技术，你应该权衡这样做的性能影响。你能在不影响性能的情况下实现类似的功能吗？如果可以，你可能需要重新考虑你的方法了。</p><h3 id="87-技术歧视不可取⭐"><a href="#87-技术歧视不可取⭐" class="headerlink" title="87. 技术歧视不可取⭐"></a>87. 技术歧视不可取⭐</h3><p>不要歧视新技术或新想法，对学习新技能的可能性保持开放的心态，也不要歧视他人，我们都值得尊重。（也不要歧视旧技术，即使现在前端框架盛行，但你也不能说Jquery就没有任何可取之处。）</p><h3 id="88-申请你不能胜任的工作"><a href="#88-申请你不能胜任的工作" class="headerlink" title="88. 申请你不能胜任的工作"></a>88. 申请你不能胜任的工作</h3><p>你永远不可能满足工作的所有要求，所以抓住机会申请吧，你有什么损失呢？</p><h3 id="89-模块化你的代码"><a href="#89-模块化你的代码" class="headerlink" title="89. 模块化你的代码"></a>89. 模块化你的代码</h3><p>你可以在一个长文件中编写所有代码，但这是不可维护的。通过模块化，我们确保代码易于理解和测试。</p><h3 id="90-不要只是做代码的搬运工⭐"><a href="#90-不要只是做代码的搬运工⭐" class="headerlink" title="90. 不要只是做代码的搬运工⭐"></a>90. 不要只是做代码的搬运工⭐</h3><p>如果你要复制并粘贴<a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a>中的解决方案，你应该确切地理解它的作用，有意识地选择要引入的代码。</p><h3 id="91-创造一个舒适的工作环境⭐"><a href="#91-创造一个舒适的工作环境⭐" class="headerlink" title="91. 创造一个舒适的工作环境⭐"></a>91. 创造一个舒适的工作环境⭐</h3><p>如果你喜欢你的工作环境和技术设置，你会更有动力去工作，所以还在等什么？</p><h3 id="92-记住你来自哪里"><a href="#92-记住你来自哪里" class="headerlink" title="92. 记住你来自哪里"></a>92. 记住你来自哪里</h3><p>我们都是从同一个地方开始的，随着你的技能和职位的发展，不要忘记你来自哪里，不要膨胀。</p><h3 id="93-试着保持乐观"><a href="#93-试着保持乐观" class="headerlink" title="93. 试着保持乐观"></a>93. 试着保持乐观</h3><p>如果出了什么问题，试着乐观一点。明天是新的一天。乐观会帮助你的团队充满活力和精神健康。</p><h3 id="94-不断重新评估你的工作流程⭐"><a href="#94-不断重新评估你的工作流程⭐" class="headerlink" title="94. 不断重新评估你的工作流程⭐"></a>94. 不断重新评估你的工作流程⭐</h3><p>仅仅因为某样东西现在有效，并不意味着它永远有效。重新评估你的工作流程，并在必要时做出调整。</p><h3 id="95-学会在家办公"><a href="#95-学会在家办公" class="headerlink" title="95. 学会在家办公"></a>95. 学会在家办公</h3><p>如果你有能力在家工作，那就学会有效地在家工作。找一个独立的办公空间，远离干扰。<a href="https://dev.to/boneskull/pro-tips-for-devs-working-at-home-3b63" target="_blank" rel="noopener">Boneskull</a>写了一篇很棒的关于在家工作的文章，你应该看看。</p><h3 id="96-无障碍代码"><a href="#96-无障碍代码" class="headerlink" title="96. 无障碍代码"></a>96. 无障碍代码</h3><p>无障碍不是事后才想到的，也不一定很难，每个人都应该能够使用你的产品。</p><h3 id="97-遵守你的承诺⭐"><a href="#97-遵守你的承诺⭐" class="headerlink" title="97. 遵守你的承诺⭐"></a>97. 遵守你的承诺⭐</h3><p>如果你告诉别人你会在某一天完成某件事，要信守承诺。如果你不能在截止日期前完成任务，那就早点说出来。</p><h3 id="98-积极主动"><a href="#98-积极主动" class="headerlink" title="98. 积极主动"></a>98. 积极主动</h3><p>如果你有额外的精力，找一个任务来帮助你的团队，他们会很感激你是主动的。</p><h3 id="99-创建一个令人惊叹的作品集"><a href="#99-创建一个令人惊叹的作品集" class="headerlink" title="99. 创建一个令人惊叹的作品集"></a>99. 创建一个令人惊叹的作品集</h3><p>一个优秀的作品集让你与众不同，使用它作为展示你的编程和设计技巧的机会！</p><h3 id="100-记住你喜欢编程的原因⭐"><a href="#100-记住你喜欢编程的原因⭐" class="headerlink" title="100. 记住你喜欢编程的原因⭐"></a>100. 记住你喜欢编程的原因⭐</h3><p>你进入这个行业是因为它激发了你的兴趣，如果你感到沮丧和怨恨，休息一下，给自己空间重新点燃你对编程的激情。</p><h3 id="101-分享你的知识⭐"><a href="#101-分享你的知识⭐" class="headerlink" title="101. 分享你的知识⭐"></a>101. 分享你的知识⭐</h3><p>如果你学到了一些很酷的东西，不要吝惜分享它，参加当地的技术交流会，在午餐时间教你的同事或学员，分享你的知识可以让更多人受益同时自己也能巩固提高。</p><p>完结撒花 🎉🎉🎉</p><p>这就是我关于成为一个优秀程序员的全部建议，希望你们喜欢。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BB%BA%E8%AE%AE.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Commit Message规范</title>
      <link>http://mydearest.cn/2019/Commit%20Message%E8%A7%84%E8%8C%83.html</link>
      <guid>http://mydearest.cn/2019/Commit%20Message%E8%A7%84%E8%8C%83.html</guid>
      <pubDate>Mon, 12 Aug 2019 17:55:40 GMT</pubDate>
      <description>
      
        &lt;p&gt;在团队开发中，commit message（提交说明）就如同代码注释一样重要。良好的commit message能让团队中的其他成员对你的每次提交的目的、&lt;/p&gt;
&lt;p&gt;涉及的代码范围及作用一目了然，方便日常的查询和帮助其他成员更好的帮你Code Review，必要时还能方便的生成Change log。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在团队开发中，commit message（提交说明）就如同代码注释一样重要。良好的commit message能让团队中的其他成员对你的每次提交的目的、</p><p>涉及的代码范围及作用一目了然，方便日常的查询和帮助其他成员更好的帮你Code Review，必要时还能方便的生成Change log。</p><hr><a id="more"></a><h2 id="Commit-message格式"><a href="#Commit-message格式" class="headerlink" title="Commit message格式"></a>Commit message格式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式：&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span></span><br></pre></td></tr></table></figure><ol><li>type：<code>必填</code> 用于说明commit的类型。总共7个标识：</li></ol><ul><li>feat： 新增feature</li><li>fix: 修复bug</li><li>docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等</li><li>style: 仅仅修改了空格、格式缩进、变量名等等，不改变代码逻辑</li><li>refactor: 代码重构，没有加新功能或者修复bug</li><li>perf: 优化相关，比如提升性能、体验</li><li>test: 测试用例，包括单元测试、集成测试等</li><li>chore: 改变构建流程、或者增加依赖库、工具等</li><li>revert: 回滚到上一个版本</li></ul><ol><li><p>scope：<code>可选</code> scope用于说明 commit 影响的范围，比如数据层、控制层、视图层或者目录甚至文件等等，视项目不同而不同。</p></li><li><p>subject：<code>必填</code> subject是 commit 目的的简短描述，不超过50个字符。</p></li></ol><ul><li>约定好commit message的语言，对我们来说最好使用中文</li><li>最好以动词开头（如使用英文请使用第一人称现在时，并且第一个字母小写）</li><li><code>&lt;scope&gt;</code>之后的冒号后面留一个英文输入法的空格</li><li>结尾不加句号或其他标点符号</li><li>若此次commit是解决某个issue应该在行末尾注明并加链接，如：…(#101)</li></ul><h2 id="Commit-message检查工具"><a href="#Commit-message检查工具" class="headerlink" title="Commit message检查工具"></a>Commit message检查工具</h2><ol><li><p><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">commitizen</a>: 一个撰写合格 Commit message 的工具；</p></li><li><p><a href="https://github.com/kentcdodds/validate-commit-msg" target="_blank" rel="noopener">validate-commit-msg</a>: 用于检查 Node 项目的 Commit </p></li></ol><p>message 是否符合格式。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/Commit%20Message%E8%A7%84%E8%8C%83.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>提问的智慧</title>
      <link>http://mydearest.cn/2019/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7.html</link>
      <guid>http://mydearest.cn/2019/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7.html</guid>
      <pubDate>Mon, 12 Aug 2019 17:50:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;提问之前&quot;&gt;&lt;a href=&quot;#提问之前&quot; class=&quot;headerlink&quot; title=&quot;提问之前&quot;&gt;&lt;/a&gt;提问之前&lt;/h2&gt;&lt;p&gt;在向别人提出一个技术问题之前，请尝试从以下几个途径去寻找答案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Google&lt;/p&gt;
&lt;/l
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="提问之前"><a href="#提问之前" class="headerlink" title="提问之前"></a>提问之前</h2><p>在向别人提出一个技术问题之前，请尝试从以下几个途径去寻找答案：</p><ol><li><p>Google</p></li><li><p>Stackoverflow</p></li><li><p>相应的社区</p></li><li><p>官方文档</p></li><li><p>项目的Issue</p></li><li><p>项目源码（看个人能力）</p></li></ol><h2 id="提问之时"><a href="#提问之时" class="headerlink" title="提问之时"></a>提问之时</h2><p>以上尝试无果的情况下向别人提出问题时：</p><ol><li><p>认真做足相关功课，并整理好提问思路</p></li><li><p>礼多人不怪，一定要谦虚礼貌</p></li><li><p>清楚描述使用的环境、需求及问题的症状，语言要精简</p></li><li><p>能够提供一些问题的必要的截图、例子或者错误信息</p></li></ol><h2 id="提问结束"><a href="#提问结束" class="headerlink" title="提问结束"></a>提问结束</h2><ol><li><p>一定要表示感谢，不管问题有没有得到解决</p></li><li><p>如果问题解决，在论坛或者社区一定要 留下你的解决方案并加以必要的说明，方便后人(我深受其害)；哪怕是问的身边的人，有价值的问题也要在博客上做记录</p></li><li><p>如果以上方法都尝试了还是解决不了那就先放一放，说不定过两天就有思路了</p></li><li><p>再不行，那就换个思路或者方案来解决你的需求吧</p></li></ol><p>参考资料：</p><p><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md" target="_blank" rel="noopener">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/2019/%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
