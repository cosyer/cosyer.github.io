[{"title":"HTML中p标签中插入div标签会发生什么","url":"%2F2020%2FHTML%E4%B8%ADp%E6%A0%87%E7%AD%BE%E4%B8%AD%E6%8F%92%E5%85%A5div%E6%A0%87%E7%AD%BE%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88.html","content":"\n面试遇到了问题:`<p>中能不能插入<div>? 插入<div>会如何?`\n\n先直接实践下：\n\n![div1](http://cdn.mydearest.cn/blog/images/div1.png)\n\n> 我们可以看到,<div>把<p>分成了两段, 并且div外字段并不在<p>内。把div变成行内块级元素也不行。\n\n![div2](http://cdn.mydearest.cn/blog/images/div2.png)\n\n解答:\n可以在HTML标准(https://www.w3.org/TR/html401/struct/text.html#h-9.3.1)中看到,\n> <p>虽然是块级元素, 但是只能包含行内元素, 不能包含块级元素(包括<p>自己)\n\n![div3](http://cdn.mydearest.cn/blog/images/div3.png)\n\nover!\n","tags":["前端"],"categories":["知识"]},{"title":"Docker","url":"%2F2020%2Freact-native%E5%B0%8F%E7%BB%93.html","content":"\n## 前言\nreact-native开发使用的是JS,但是并不是纯正的JS,而是一种JSX语言，就是在JS中嵌入XML语言，因此，只要有一些JS的语法基础的原生开发者，就可以肯容易理解JSX的语法了，在RN中，推荐使用ES6的语法。\n\n## 性能\n使用react-native开发的最大的有点在于开发效率，加入APP并不复杂的话，那么完全可以使用纯JS开发，也就是Android和iOS公用一套界面和逻辑。极大的提高了开发效率。在性能上，RN的表现比原生弱一些，但\n是远好于H5。所以总体来看，其实RN的未来还是可以期待的。\n\n## 运行机制\nRN是运行JS的，Android是运行Java字节码的，所以，实际上JS代码的最终运行是通过一层封装，把JS的代码映射成原生代码，而界面上的元素最终使用的也是原生的组件，而不是自己渲染（所以在性能上，RN比H5要\n好很多）。\n\n## Component简介\n在Android中，主要交互容器是activity或Fragment,而在RN中，界面的交互容器是Component：组件。我觉得Component和原生的Fragment其实很像，都存在于activity中，都受制于activity的生命周期，都可卸\n载和装载。\n\n---\n<!--more-->\n\n## 原有架构和问题\n1. 用户编写的React代码\n2. React代码转换之后的js\n3. The Bridge\n4. Native side\n\n- 组件和 API 太过依赖 JSBridge 的初始化，而且通讯能力也局限于这一条通道。\n- JS和Native之间并不真正直接通信，它们的通信依赖于跨Bridge传输的异步JSON消息。\n\n> UI 的渲染过程分为三层：JS 业务层、shadow tree、原生 UI 层。\n\n其中 JS 和 shadow tree 是通过 JSBridge 来同步数据的，JS 层会将所有 UI node 生成一串 JSON 数据，传递到原生 shadow 层，原生 shadow 层通过传入 node 数据，新增新 UI 或者删除一些不需要的 \nUI 组件。\n\n从渲染的层次来看，React Native 是多线程运行的，最常见的是 JS 线程和原生端的线程，一旦线程间异常，JSBridge 整体将会阻塞，我们经常也能看到 JS 运行异常了，实际 JS 线程已经无响应了，但原生端\n还能响应滚动事件。\n\n##  新的架构\n\n> RN 在 0.59 版本使用 JSI 取代了先前的 JSBridge。\n分为两部分：\n- Fabric，新架构的UI manager\n- TurboModules，这个与native端交互的新一代实现\n\n现在不需要序列化成JSON并双向传递等一系列操作，实现了Native和 JS间的直接同步通讯。\n","tags":["react"],"categories":["React"]},{"title":"Vue中axios的封装","url":"%2F2020%2FVue%E4%B8%ADaxios%E7%9A%84%E5%B0%81%E8%A3%85.html","content":"\n## 聊聊 Vue 中 axios 的封装\naxios 是 Vue 官方推荐的一个 HTTP 库，用 axios 官方简介来介绍它，就是：\n\n> Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n\n作为一个优秀的 HTTP 库，axios 打败了曾经由 Vue 官方团队维护的 vue-resource，获得了 Vue 作者尤小右的大力推荐，成为了 Vue 项目中 HTTP 库的最佳选择。\n\n虽然，axios 是个优秀的 HTTP 库，但是，直接在项目中使用并不是那么方便，所以，我们需要对其进行一定程度上的配置封装，减少重复代码，方便调用。下面，我们就来聊聊 Vue 中 axios 的封装。\n\n---\n<!--more-->\n\n### 开始\n其实，网上关于 axios 封装的代码不少，但是大部分都是在入口文件（main.js）中进行 axios 全局对象属性定义的形式进行配置，类似于如下代码：\n\n```js\naxios.defaults.timeout = 10000\n```\n\n该方案有两个不足，首先，axios 封装代码耦合进入入口文件，不方便后期维护；其次，使用 axios 全局对象属性定义的方式进行配置，代码过于零散。\n\n1. 针对问题一，我使用了 Vue 源码结构中的一大核心思想——将功能拆分为文件，方便后期的维护。单独创建一个 `http.js` 或者 `http.ts` 文件，在文件中引入 axios 并对其进行封装配置，最后将其导出并挂载到 Vue 的原型上即可。此时，每次修改 axios 配置，只需要修改对应的文件即可，不会影响到不相关的功能。\n\n2. 针对问题二，采用 axios 官方推荐的，通过配置项创建 axios 实例的方式进行配置封装。\n\n代码如下：\n\n```js\n// http.js\nimport axios from 'axios'\n// 创建 axios 实例\nconst service = axios.create({\n  // 配置项\n})\n```\n\n### 根据环境设置 baseURL\nbaseURL 属性是请求地址前缀，将自动加在 url 前面，除非 url 是个绝对地址。正常情况下，在开发环境下和生产模式下有着不同的 baseURL，所以，我们需要根据不同的环境切换不同的 baseURL。\n\n在开发模式下，由于有着 devServer 的存在，需要根据固定的 url 前缀进行请求地址重写，所以，在开发环境下，将 baseURL 设为某个固定的值，比如：`/apis`。\n\n在生产模式下，根据 Java 模块的请求前缀的不同，可以设置不同的 baseURL。\n\n具体代码如下：\n\n```js\n// 根据 process.env.NODE_ENV 区分状态，切换不同的 baseURL\nconst service = axios.create({\n\tbaseURL: process.env.NODE_ENV === 'production' ? `/java` : '/apis',\n})\n```\n\n### 统一设置请求头\n在这里和大家聊一个问题，什么是封装？在我看来，封装是通过更少的调用代码覆盖更多的调用场景。\n\n由于，大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，所以，在这里，我采用的方案是，将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置。\n\n代码如下：\n\n```js\nconst service = axios.create({\n    ...\n\theaders: {\n        get: {\n          'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        },\n        post: {\n          'Content-Type': 'application/json;charset=utf-8'\n          // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来\n        }\n  },\n})\n```\n\n### 跨域、超时、响应码处理\naxios 中，提供是否允许跨域的属性——withCredentials，以及配置超时时间的属性——timeout，通过这两个属性，可以轻松处理跨域和超时的问题。\n\n下面，我们来说说响应码处理：\n\naxios 提供了 validateStatus 属性，用于定义对于给定的HTTP 响应状态码是 resolve 或 reject promise。所以，正常设置的情况下，我们会将状态码为 2 系列或者 304 的请求设为 resolve 状态，其余为 reject 状态。结果就是，我们可以在业务代码里，使用 catch 统一捕获响应错误的请求，从而进行统一处理。\n\n但是，由于我在代码里面使用了 async-await，而众所周知，async-await 捕获 catch 的方式极为麻烦，所以，在此处，我选择将所有响应都设为 resolve 状态，统一在 then 处理。\n\n此部分代码如下：\n\n```js\nconst service = axios.create({\n\t// 跨域请求时是否需要使用凭证\n\twithCredentials: true,\n    // 请求 30s 超时\n\ttimeout: 30000,\n\tvalidateStatus: function () {\n\t\t// 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常\n\t\treturn true\n\t},\n})\n```\n\n### 请求、响应处理\n在不使用 axios 的情况下，每次请求或者接受响应，都需要将请求或者响应序列化。\n\n而在 axios 中， `transformRequest` 允许在向服务器发送请求前，修改请求数据；`transformResponse` 在传递给 then/catch 前，允许修改响应数据。\n\n通过这两个钩子，可以省去大量重复的序列化代码。\n\n代码如下：\n\n```js\nconst service = axios.create({\n    // 在向服务器发送请求前，序列化请求数据\n    transformRequest: [function (data) {\n        data = JSON.stringify(data)\n        return data\n    }],\n    // 在传递给 then/catch 前，修改响应数据\n    transformResponse: [function (data) {\n        if (typeof data === 'string' && data.startsWith('{')) {\n            data = JSON.parse(data)\n        }\n        return data\n    }]\n})\n```\n\n### 拦截器\n拦截器，分为请求拦截器以及响应拦截器，分别在请求或响应被 then 或 catch 处理前拦截它们。\n\n之前提到过，由于 async-await 中 catch 难以处理的问题，所以将出错的情况也作为 resolve 状态进行处理。但这带来了一个问题，请求或响应出错的情况下，结果没有数据协议中定义的 msg 字段（消息）。所以，我们需要在出错的时候，手动生成一个符合返回格式的返回数据。\n\n由于，在业务中，没有需要在请求拦截器中做额外处理的需求，所以，请求拦截器的 resolve 状态，只需直接返回就可以了。\n\n请求拦截器代码如下：\n\n```js\n// 请求拦截器\nservice.interceptors.request.use((config) ={\n\treturn config\n}, (error) ={\n\t// 错误抛到业务代码\n    error.data = {}\n    error.data.msg = '服务器异常，请联系管理员！'\n    return Promise.resolve(error)\n})\n```\n\n再来聊聊响应拦截器，还是之前的那个问题，除了请求或响应错误，还有一种情况也会导致返回的消息体不符合协议规范，那就是状态码不为 2 系列或 304 时。此时，我们还是需要做一样的处理——手动生成一个符合返回格式的返回数据。但是，有一点不一样，我们还需要根据不同的状态码生成不同的提示信息，以方便处理上线后的问题。\n\n响应拦截器代码如下：\n\n```js\n// 根据不同的状态码，生成不同的提示信息\nconst showStatus = (status) ={\n    let message = ''\n    // 这一坨代码可以使用策略模式进行优化\n    switch (status) {\n        case 400:\n            message = '请求错误(400)'\n            break\n        case 401:\n            message = '未授权，请重新登录(401)'\n            break\n        case 403:\n            message = '拒绝访问(403)'\n            break\n        case 404:\n            message = '请求出错(404)'\n            break\n        case 408:\n            message = '请求超时(408)'\n            break\n        case 500:\n            message = '服务器错误(500)'\n            break\n        case 501:\n            message = '服务未实现(501)'\n            break\n        case 502:\n            message = '网络错误(502)'\n            break\n        case 503:\n            message = '服务不可用(503)'\n            break\n        case 504:\n            message = '网络超时(504)'\n            break\n        case 505:\n            message = 'HTTP版本不受支持(505)'\n            break\n        default:\n            message = `连接出错(${status})!`\n    }\n    return `${message}，请检查网络或联系管理员！`\n}\n\n// 响应拦截器\nservice.interceptors.response.use((response) ={\n    const status = response.status\n    let msg = ''\n    if (status < 200 || status >= 300) {\n        // 处理http错误，抛到业务代码\n        msg = showStatus(status)\n        if (typeof response.data === 'string') {\n            response.data = { msg }\n        } else {\n            response.data.msg = msg\n        }\n    }\n    return response\n}, (error) ={\n    // 错误抛到业务代码\n    error.data = {}\n    error.data.msg = '请求超时或服务器异常，请检查网络或联系管理员！'\n    return Promise.resolve(error)\n})\n```\n\n_tips：友情提示，上面那一坨 switch-case 代码，可以使用策略模式进行优化~_\n\n### 支持 TypeScript\n由于前段时间，我在部门内推了 TypeScript，为了满足自己的强迫症，将所有 js 文件改写为了 ts 文件。由于 axios 本身有 TypeScript 相关的支持，所以只需要把对应的类型导入，然后赋值即可。\n\n### 完整代码\n```ts\n// http.ts\nimport axios, { AxiosRequestConfig, AxiosResponse } from 'axios'\n\nconst showStatus = (status: number) ={\n  let message = ''\n  switch (status) {\n    case 400:\n      message = '请求错误(400)'\n      break\n    case 401:\n      message = '未授权，请重新登录(401)'\n      break\n    case 403:\n      message = '拒绝访问(403)'\n      break\n    case 404:\n      message = '请求出错(404)'\n      break\n    case 408:\n      message = '请求超时(408)'\n      break\n    case 500:\n      message = '服务器错误(500)'\n      break\n    case 501:\n      message = '服务未实现(501)'\n      break\n    case 502:\n      message = '网络错误(502)'\n      break\n    case 503:\n      message = '服务不可用(503)'\n      break\n    case 504:\n      message = '网络超时(504)'\n      break\n    case 505:\n      message = 'HTTP版本不受支持(505)'\n      break\n    default:\n      message = `连接出错(${status})!`\n  }\n  return `${message}，请检查网络或联系管理员！`\n}\n\nconst service = axios.create({\n  // 联调\n  baseURL: process.env.NODE_ENV === 'production' ? `/` : '/apis',\n  headers: {\n    get: {\n      'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8'\n    },\n    post: {\n      'Content-Type': 'application/json;charset=utf-8'\n    }\n  },\n  // 是否跨站点访问控制请求\n  withCredentials: true,\n  timeout: 30000,\n  transformRequest: [(data) ={\n    data = JSON.stringify(data)\n    return data\n  }],\n  validateStatus () {\n    // 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常\n    return true\n  },\n  transformResponse: [(data) ={\n    if (typeof data === 'string' && data.startsWith('{')) {\n      data = JSON.parse(data)\n    }\n    return data\n  }]\n})\n\n// 请求拦截器\nservice.interceptors.request.use((config: AxiosRequestConfig) ={\n    return config\n}, (error) ={\n    // 错误抛到业务代码\n    error.data = {}\n    error.data.msg = '服务器异常，请联系管理员！'\n    return Promise.resolve(error)\n})\n\n// 响应拦截器\nservice.interceptors.response.use((response: AxiosResponse) ={\n    const status = response.status\n    let msg = ''\n    if (status < 200 || status >= 300) {\n        // 处理http错误，抛到业务代码\n        msg = showStatus(status)\n        if (typeof response.data === 'string') {\n            response.data = {msg}\n        } else {\n            response.data.msg = msg\n        }\n    }\n    return response\n}, (error) ={\n    // 错误抛到业务代码\n    error.data = {}\n    error.data.msg = '请求超时或服务器异常，请检查网络或联系管理员！'\n    return Promise.resolve(error)\n})\n\nexport default service\n```\n","tags":["工具"],"categories":["JS"]},{"title":"对称加密、非对称加密、摘要、数字签名、数字证书","url":"%2F2020%2F%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E6%91%98%E8%A6%81%E3%80%81%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E3%80%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.html","content":"\n作为一个开发人员，或多或少都听说过对称加密、非对称加密、摘要、数字签名、数字证书这几个概念，它们是用来保证在互联网通信过程中数据传输安全的。有人可能会有疑惑，我给传输数\n据加个密不就安全了，为什么还要搞这么多花样出来？本文主要通过一个案例来讲解这几个概念的实际作用。\n\n在此之前，我先简单介绍一下这几个概念。\n## 对称加密\n对称加密是指用来加密和解密的是同一个秘钥。其特点是加密速度快，但是秘钥容易被黑客截获，所以安全性不高。密钥不可能一开始在发送方和接收方都全部生成好了 需要在一方生成之后传递给另一方 如果在传递过程密钥被劫持 整个加密就不安全了。常见的有AES、DES算法。\n\n## 非对称加密\n非对称加密是指用来加密和解密的是不同的秘钥，它们是成对出现的，称为公钥和私钥，知道其中一个秘钥是无法推导出另外一个秘钥的。用公钥加密的内容需要用私钥才能解密，用私钥加密\n的内容需要用公钥才能解密。非对称加密的特点是安全性高，缺点是加密速度慢。公钥对外公开 如果密文是私钥加密 那么任何人都能用公钥解密。常见的有RSA、ECC算法。\n\n## 混合加密\n在传递过程把我们的对称加密中的密钥用非对称加密的方式去传递就好了。\n![mix](http://cdn.mydearest.cn/blog/images/mix.png)\n\n## 摘要\n所谓的摘要就是一段信息或者一个文件通过某个哈希算法(也叫摘要算法)而得到的一串字符。摘要算法的特点就是不同的文件计算出的摘要是不同的(也有可能相同，但是可能性非常非常低)，\n比如一个1G的视频文件，哪怕只是改动其中一个字节，最后计算得到的摘要也是完全不同的，所以摘要算法通常是用来判断文件是否被篡改过。其还有一个特点就是通过摘要是无法推导出源文\n件的信息的。常用的摘要(散列)算法有MD5、SHA等。\n\n## 数字签名\n数字签名就是一个文件的摘要加密后的信息。数字签名是和源文件一起发送给接收方的，接收方收到后对文件用摘要算法算出一个摘要，然后和数字签名中的摘要进行比对，两者不一致的话说\n明文件被篡改了。\n\n## 数字证书\n数字证书是一个经证书授权中心生成的文件，数字证书里一般会包含公钥、公钥拥有者名称、CA的数字签名、有效期、授权中心名称、证书序列号等信息。其中CA的数字签名是验证证书是否被\n篡改的关键，它其实就是对证书里面除了CA的数字签名以外的内容进行摘要算法得到一个摘要，然后CA机构用他自己的私钥对这个摘要进行加密就生成了CA的数字签名，CA机构会公开它的公\n钥，验证证书时就是用这个公钥解密CA的数字签名，然后用来验证证书是否被篡改。\n\n---\n<!--more-->\n\n## 案例讲解\n场景：\n张三要找人装修一个房子，原则是谁的出价便宜就给谁装修，所以对于报价文件就是属于机密文件。下面我们来看下不同的方式传输报价文件都会有什么风险。\n\n### 通过对称加密有什么风险\n现在李四想接这个装修的活，他做了一份报价文件(文件名:lisi.txt，文件内容:报价50万)。然后李四用一个对称秘钥123对这个文件进行加密。最后李四将这个秘钥和加密的文件发给张三，\n张三收到后用这个秘钥解密，知道了李四的报价是50万。同时王五也想接这个装修的活，他本来是想报价55万的，但是又担心报价太高而丢掉这个活。恰巧王五是个黑客高手，于是他截获了李\n四发给张三的秘钥和加密文件，知道了李四报价是50万。最后王五将自己的报价改成了49万发给张三，结果王五接下了这个装修活。\n\n> 结论：用对称加密的话，一旦秘钥被黑客截获，加密就形同虚设，所以安全性比较低。\n\n### 如果用非对称加密会怎么样\n首先张三会生成一对秘钥，私钥是zhangsan1，公钥是zhangsan2，私钥张三自己保存，将公钥公布出去。\n\n李四将报价文件list.txt用张三公布的公钥zhangsan2进行加密后传给张三，然后张三用私钥zhangsan1进行解密得到李四的报价是50万。\n\n这个时候即使王五截获到了李四发给张三的报价文件，由于王五没有张三的私钥，所以他是无法解密文件的，也就无法知道李四的报价。最后王五因为报价55万而丢掉了这个装修的机会。\n\n所以用非对称加密是可以保证数据传输安全的。不过这里说一句题外话，既然非对称加密安全性高，那为什么不淘汰掉对称加密呢？其实关键就在于加密速度，非对称加密计算量很大，所以加\n密速度是很慢的，如果发送消息非常频繁，使用非对称加密的话就会对性能造成很大影响。所以在实际开发过程中通常是对称加密和非对称加密结合使用的。也就是对称加密的秘钥是用非对称\n加密后发送的，这样能保证对称加密的秘钥不被黑客截获，然后在发送业务数据时就用对称加密。这样既保证了安全性也保证了加密速度。\n\n> 结论：非对称加密可以防止黑客截获加密后的内容，安全性高。\n\n### 数字签名有什么用\n前面都说了非对称加密是安全的，那为什么还要数字签名呢？\n\n设想一下，王五截获了李四的报价文件，王五虽然无法知道李四的实际报价，但是他完全可以伪造一份李四的报价(文件名:lisi.txt，文件内容:报价60万)，然后将这份伪造文件用张三公布\n的公钥zhangsan2进行加密后替换原来的报价文件。张三收到后解密发现报价是60万，于是张三就以为李四报的价是60万，最后决定将装修的活给报价55万的王五来做。\n\n发生这个问题的关键就在于张三无法知道报价文件是否被篡改过。要解决这个问题就需要用到数字签名。首先李四需要自己生成一对非对称加密的秘钥，私钥lisi1自己保存，公钥lisi2发给张\n三。然后李四对自己的报价文件通过摘要算法得到一个摘要(假设摘要是aaa)，再用自己的私钥lisi1加密这个摘要就得到了报价文件的数字签名，最后将加密的报价文件和数字签名一起发给张\n三，张三收到后先用李四发过来的公钥lisi2解密数字签名得到摘要aaa，然后用自己的私钥zhangsan1解密加密的文件得到报价源文件，然后对报价源文件进行摘要算法，看计算得到的结果是\n不是aaa，如果不是aaa的话就说明报价文件被篡改了。\n\n在这种情况下，如果王五截获了李四发给张三的文件。王五是无法解密报价文件的。如果王五伪造一份报价文件的话，等张三收到后就会发现报价文件和数字签名不匹配。那王五能不能伪造报\n价文件的同时也伪造签名呢？因为王五没有李四的私钥，所以没法对伪造的报价文件的摘要进行加密，所以也就没法伪造签名。\n\n> 结论：非对称加密虽然能确保加密文件内容不被窃取，但不能保证文件不被篡改。数字签名就是用来验证文件是否被篡改过。\n\n### 数字证书有什么用\n既然非对称加密可以保证文件内容的安全性，数字签名又可以保证文件不被篡改，那还要数字证书有什么用呢？\n\n我们再来设想一下，王五自己也生成了一对用于非对称加密的秘钥，私钥是wangwu1，公钥是wangwu2。前面李四将自己的公钥lisi2发给张三的过程中被王五给截获了，王五用自己的公钥\nwangwu2替换了李四的公钥lisi2，所以张三最后收到的公钥实际上是王五的，但张三对这并不知情。后面李四发的数字签名和加密的报价文件都被王五截获，并且王五伪造了一份报价文件，同\n时用自己的私钥加密报价文件的摘要生成伪造的签名并发给张三，张三收到后进行验证发现数字签名和报价文件是匹配的，就以为这份报价文件是真实的。\n\n出现这个问题的关键就在于张三没法确认收到的公钥到底是不是李四发的，这个时候数字证书就起到作用了。李四到权威的数字证书机构申请数字证书，证书里面包含了公钥(lisi2)和公钥的\n拥有者(李四)等相关信息，然后李四将证书发给张三，张三通过证书里面的信息就可以知道公钥到底是不是李四的了。\n\n那证书在发送过程中有没有可能被王五截获并篡改呢？要知道证书里面还包含CA的数字签名，这个签名是证书机构用他们自己的私钥对证书的摘要进行加密的，而公钥是公开的。所以即便王五\n截获并篡改了证书内容，他也无法伪造证书机构的签名，张三在收到证书后通过验证签名也会发现证书被篡改了。\n","tags":["http"],"categories":["知识"]},{"title":"关于node的那些事(进阶篇)","url":"%2F2020%2F%E5%85%B3%E4%BA%8Enode%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B(%E8%BF%9B%E9%98%B6%E7%AF%87).html","content":"\n## 👨提问：注册路由时 app.get、app.use、app.all 的区别是什么？\n\n### app.use(path,callback)\n\n> app.use是express用来调用中间件的方法。中间件通常不处理请求和响应，一般只处理输入数据，并将其交给队列中的下一个处理程序，比如下面这个例子app.use\n('/user')，那么只要路径以 /user 开始即可匹配，如 /user/tree 就可以匹配。\n\n### app.all()\n\n> app.all 是路由中指代所有的请求方式，用作路由处理，匹配完整路径，在app.use之后可以理解为包含了app.get、app.post等的定义，比如app.all('/\nuser/tree'),能同时覆盖：get('/user/tree') 、 post('/user/tree')、 put('/user/tree') ,不过相对于app.use()的前缀匹配，它则是匹配具体的路\n由。\n\n`all完整匹配，use只匹配前缀`\n\n---\n<!--more-->\n\n## express response有哪些常用方法?\nexpress response对象是对Node.js原生对象ServerResponse的扩展，express response常见的有：res.end()、res.send()、res.render()、res.\nredirect()，而这几个有什么不同呢？更多请看文档[express Response](https://www.expressjs.com.cn/4x/api.html#res)\n\n### res.end()\n结束response - 如果服务端没有数据回传给客户端则可以直接用res.end返回，以此来结束响应过程。\n\n### res.send(body)\n如果服务端有数据可以使用res.send,可以忽略res.end，body参数可以是一个Buffer对象，一个String对象或一个Array。\n\n### res.render\nres.render用来渲染模板文件，也可以结合模版引擎来使用，下面看个简单的demo (express+ejs模版引擎)\n\n[node-ejs](http://cdn.mydearest.cn/blog/images/node-ejs.png)\n\n- 配置\n```js\napp.set('views', path.join(__dirname, 'views')); // views：模版文件存放的位置，默认是在项目根目录下\napp.set('view engine', 'ejs'); // view engine：使用什么模版引擎\n```\n\n其次是根据使用的模版引擎语法编写模版，最后通过res.render(view,locals, callback)导出，具体使用参数\n\n```\nview：模板的路径\nlocals：渲染模板时传进去的本地变量\ncallback：如果定义了回调函数，则当渲染工作完成时才被调用，返回渲染好的字符串（正确）或者错误信息 ❌\n```\n\n### res.redirect\n重定义到path所指定的URL，同时也可以重定向时定义好HTTP状态码（默认为302）\n```js\nres.redirect('http://baidu.com');\nres.redirect(301, 'http://baidu.com');\n```\n\n## node如何利用多核CPU以及创建集群?\n众所周知，nodejs是基于chrome浏览器的V8引擎构建的，一个nodejs进程只能使用一个CPU(一个CPU运行一个node实例)，举个例子：我们现在有一台8核的服务器，\n那么如果不利用多核CPU，是很一种浪费资源的行为，这个时候可以通过启动多个进程来利用多核CPU。\n\nNode.js给我们提供了cluster模块，用于nodejs多核处理，同时可以通过它来搭建一个用于负载均衡的node服务集群。创建多进程。\n\n> 本质还是通过 child_process.fork() 专门用于衍生新的 Node.js 进程,衍生的 Node.js 子进程独立于父进程，但两者之间建立的 IPC 通信通道除外， 每\n个进程都有自己的内存，带有自己的 V8 实例\n\n```js\nconst cluster = require('cluster')\nconst os = require('os')\nconst express = require('express')\nconst path = require('path')\nconst ejs = require('ejs')\nconst app = express()\n\nconst numCPUs = os.cpus().length\n\nif (cluster.isMaster) {\n    for (let i =0 ;i<numCPUs.length;++i) {\n        cluster.fork()\n    }\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`worker ${worker.process.pid} died`)\n    })\n} else {\n    app.listen(3000, function(){\n        console.log(`worker ${worker.process.pid} started`)\n    })\n}\n// 一个端口被多个进程监听\n```\n\n```bash\nlsof -i -P -n | grep 3000\nps -ef | grep pid\n```\n\n## 开启多个子线程\n```js\nconst {\n    Worker, isMainThread, parentPort, workerData\n} = require('worker_threads');\nconst worker = new Worker(__filename, {\n    workerData: script\n});\n```\n\n- 线程间如何传输数据: parentPort postMessage on 发送监听消息\n- 共享内存： SharedArrayBuffer 通过这个共享内存\n\n- 在服务中若需要执行 shell 命令，那么就需要开启一个进程\n```js\nvar exec = require('child_process').exec;\nexec('ls', function(error, stdout, stderr){\n    if(error) {\n        console.error('error: ' + error);\n        return;\n    }\n    console.log('stdout: ' + stdout);\n});\n```\n\n## node是怎样支持https?\nhttps实现，离不开证书，通过openssl生成公钥私钥（不做详细介绍），然后基于 express的 https模块 实现，设置options配置, options有两个选项，一个是\n证书本体，一个是密码。\n\n## node和客户端怎么解决跨域的问题？\napp.all('*',(req,res,next)=>{}) 效果相当于app.use((req,res,next)=>{}), 这也是app.all的一个比较常见的应用，就是用来处理跨域请求。\n```js\napp.all('*', function (req, res, next) {\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Headers', 'X-Requested-With');\n    res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');\n    res.header('Content-Type', 'application/json;charset=utf-8');\n    if (req.method == 'OPTIONS') {\n        res.send(200);\n    } else {\n        next();\n    }\n});\n```\n\n- cors模块\n\n## 两个node程序之间怎样交互?\n通过fork，原理是子程序用process.on来监听父程序的消息，用 process.send给父程序发消息，父程序里用child.on,child.send进行交互，来实现父进程和子\n进程互相发送消息。\n\n> child-process和process的stdin,stdout,stderror是一样的吗?概念都是一样的，输入，输出，错误，都是流．区别是在父程序眼里，子程序的stdout是输入流，stdin是输出流\n\n## 执行中间件（洋葱模型）\n我们通过 use 注册中间件，中间件函数有两个参数第一个是上下文，第二个是 next，在中间件函数执行过程中，若遇到 next() ，那么就会进入到下一个中间件中执\n行，下一个中间执行完成后，在返回上一个中间件执行 next() 后面的方法，这便是中间件的执行逻辑。\n\n## 介绍下 stream\n\n流在 nodejs 用的很广泛，但对于大部分开发者来说，更多的是使用流，比如说 HTTP 中的 request respond ，标准输入输出，文件读取\n（createReadStream）， gulp 构建工具等等。\n流，可以理解成是一个管道，比如读取一个文件，常用的方法是从硬盘读取到内存中，在从内存中读取，这种方式对于小文件没问题，但若是大文件，效率就非常低，还有\n可能内存不足，采用流的方式，就好像给大文件插上一根吸管，持续的一点点读取文件的内容，管道的另一端收到数据，就可以进行处理，了解 Linux 的朋友应该非常熟\n悉这个概念。\n\n\n- Node.js 中有四种基本的流类型：\n\n1. Writable - 可写入数据的流（例如 fs.createWriteStream()）。\n2. Readable - 可读取数据的流（例如 fs.createReadStream()）。\n3. Duplex - 可读又可写的流（例如 net.Socket）。\n4. Transform - 在读写过程中可以修改或转换数据的 Duplex 流（例如 zlib.createDeflate()）。接触比较多的还是第一二种pipe 来消费可读流\n\n```js\nconst fs = require('fs');\n// 直接读取文件\nfs.open('./xxx.js', 'r', (err, data) => {\n    if (err) {\n        console.log(err)\n    }\n    console.log(data)\n})\n// 流的方式读取、写入\nlet readStream = fs.createReadStream('./a.js');\nlet writeStream = fs.createWriteStream('./b.js')\nreadStream.pipe(writeStream).on('data', (chunk) => { // 可读流被可写流消费\n    console.log(chunk)\n    writeStream.write(chunk);\n}).on('finish', () => console.log('finish'))\n```\n\n","tags":["NodeJS"],"categories":["Node"]},{"title":"实现图片懒加载","url":"%2F2020%2F%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD.html","content":"\n## 前言\n图片懒加载在一些图片密集型的网站中运用比较多，通过图片懒加载可以让一些不可视的图片不去加载，避免一次性加载过多的图片导致请求阻塞（浏览器一般对同一域名\n下的并发请求的连接数有限制），这样就可以提高网站的加载速度，提高用户体验。 \n\n[效果预览](http://cdn.mydearest.cn/blog/images/lazyload.png)\n\n---\n<!--more-->\n## 如何做\n\n### 步骤一\n首先我们需要让我们html中需要懒加载的img标签的src设置缩略图或者不设置src，然后自定义一个属性，值为真正的图片或者原图的地址（比如下面的data-src），\n并且定义一个类名，表示该图片是需要懒加载的（比如下面例子的lazy-image），这有两个作用：\n\n1. 为以后获取需要懒加载图片的img元素 \n2. 可以给这个类名设置背景图片，作为图片未加载前的过度图片，比如显示为loading的图片。\n\n```js\n<img data-src=\"https://tb1.bdstatic.com/tb/cms/liveshow/ent_slid2.jpg\" class=\"lazy-image\"/> \n// css部分 \n.lazy-image { \n    background: url('../img/loading.gif') no-repeat center; \n}\n```\n\n### 步骤二\n页面加载完后，我们需要获取所有需要懒加载的图片的元素集合，判断是否在可视区域，如果是在可视区域的话，设置元素的src属性值为真正图片的地址。\n\n```js\ninViewShow() {     \n    let imageElements = Array.prototype.slice.call(document.querySelectorAll('.lazy-image'))    \n    let len = imageElements.length     \n    for(let i = 0; i < len; i++) {         \n        let imageElement = imageElements[i]        \n        const rect = imageElement.getBoundingClientRect() // 出现在视野的时候加载图片         \n        if(rect.top < document.documentElement.clientHeight) {             \n            imageElement.src = imageElement.dataset.src // 移除掉已经显示的             \n            imageElements.splice(i, 1)             \n            len--             \n            i--         \n        }     \n    } \n}\n```\n这里判断是否出现在可视区域内，是通过获取元素的getBoundingClientRect属性的top值和页面的clientHeight进行对比，如果top值小于clientHeight，则说\n明元素出现在可视区域了。BoundingClientRect是获取某个元素相对于视窗的位置集合，见下图，注意bottom和right和我们平时的bottom和right不一样。 \n\n[lazyload2](http://cdn.mydearest.cn/blog/images/lazyload2.png)\n\n### 步骤三\n用户滚动窗口的时候，遍历所有需要懒加载的元素，通过每个元素的BoundingClientRect属性来判断元素是否出现在可视区域内，判断方法同第二步一样。 \n\n```js\ndocument.addEventListener('scroll', inViewShow)\n```\n\n这里我们可以优化下，可以通过函数节流优化滚动事件的处理函数。\n\n\n### 补充-利用高级特性Intersection Observer来判断元素是否可见。\n上面我们利用元素的BoundingClientRect的top属性和body的clientHeight来判断元素是否可见，这种传统方式获取元素是否可见的一个缺点是我们还需要绑定\nscroll事件，scroll事件是伴随着大量计算的，会造成资源浪费，虽然我们可以通过节流函数来提高性能，但还是会有性能浪费的问题，而Intersection Observer\n可以不用监听scroll事件，做到元素一可见便调用回调，在回调里面我们来判断元素是否可见。\n\n```js\nif (\"IntersectionObserver\" in window) {        \n    let lazyImageObserver = new IntersectionObserver((entries, observer) => {          \n        entries.forEach((entry, index) => {            \n            // 如果元素可见            \n            if (entry.intersectionRatio > 0) {              \n                let lazyImage = entry.target              \n                lazyImage.src = lazyImage.dataset.src              \n                lazyImage.classList.remove(\"lazy-image\")              \n                lazyImageObserver.unobserve(lazyImage)              \n                // this.lazyImages.splice(index, 1)            \n            }          \n        })        \n    })        \n    this.lazyImages.forEach(function(lazyImage) {          \n        lazyImageObserver.observe(lazyImage);        \n    })      \n}\n```\n\n## 仓库代码\n[lazyload](https://github.com/cosyer/jelly/tree/gh-pages/lazyload)\n\n[在线预览](https://cosyer.github.io/jelly/lazyload/)\n","tags":["优化"],"categories":["工具"]},{"title":"超详细的TypeScript教程","url":"%2F2020%2F%E8%B6%85%E8%AF%A6%E7%BB%86%E7%9A%84TypeScript%E6%95%99%E7%A8%8B.html","content":"\n# typescript\n[TypeScript](https://www.typescriptlang.org/) 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。\n\n## 区别\n|TypeScript|JavaScript|\n|:---:|:---:|\n|JavaScript 的超集用于解决大型项目的代码复杂性|一种脚本语言，用于创建动态网页|\n|可以在编译期间发现并纠正错误|作为一种解释型语言，只能在运行时发现错误|\n|强类型，支持静态和动态类型|弱类型，没有静态类型选项|\n|最终被编译成 JavaScript 代码，使浏览器可以理解|可以直接在浏览器中使用|\n|支持模块、泛型和接口|不支持模块，泛型或接口|\n|支持 ES3，ES4，ES5 和 ES6 等|不支持编译其他 ES3，ES4，ES5 或 ES6 功能|\n|社区的支持仍在增长，而且还不是很大|大量的社区支持以及大量文档和解决问题的支持|\n\n### 安装\n```js\nnpm install -g typescript\n```\n\n### 编译\n```js\ntsc helloworld.ts\n// helloworld.ts => helloworld.js\n```\n\n[在线学习语法和特性](https://www.typescriptlang.org/play)\n\n---\n<!--more-->\n\n## 类型 (11种)\n### Boolean\n```js\nlet isDone: boolean = false;\n// ES5：var isDone = false;\n```\n\n### Number\n```js\nlet count: number = 10;\n// ES5：var count = 10;\n```\n\n### String\n```js\nlet name: string = \"cosyer\";\n// ES5：var name = 'cosyer';\n```\n\n### Array\n```js\nlet list: number[] = [1, 2, 3];\n// ES5：var list = [1,2,3];\n\nlet list: Array<number> = [1, 2, 3]; // Array<number>泛型语法\n// ES5：var list = [1,2,3];\n```\n\n### Enum\n使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。\n#### 数字枚举\n```js\nenum Direction {\n  NORTH,\n  SOUTH,\n  EAST,\n  WEST,\n}\n\nlet dir: Direction = Direction.NORTH;\n```\n默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction.SOUTH 的值为 1，Direction.EAST 的值为 2，Direction.WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码：\n```js\n\"use strict\";\nvar Direction;\n(function (Direction) {\n  Direction[(Direction[\"NORTH\"] = 0)] = \"NORTH\";\n  Direction[(Direction[\"SOUTH\"] = 1)] = \"SOUTH\";\n  Direction[(Direction[\"EAST\"] = 2)] = \"EAST\";\n  Direction[(Direction[\"WEST\"] = 3)] = \"WEST\";\n})(Direction || (Direction = {}));\nvar dir = Direction.NORTH;\n```\n也可以设置 NORTH 的初始值，比如：\n```js\nenum Direction {\n  NORTH = 3,\n  SOUTH,\n  EAST,\n  WEST,\n}\n```\n\n#### 字符串枚举\n```js\nenum Direction {\n  NORTH = \"NORTH\",\n  SOUTH = \"SOUTH\",\n  EAST = \"EAST\",\n  WEST = \"WEST\",\n}\n```\n编译生成：\n```js\n\"use strict\";\nvar Direction;\n(function (Direction) {\n    Direction[\"NORTH\"] = \"NORTH\";\n    Direction[\"SOUTH\"] = \"SOUTH\";\n    Direction[\"EAST\"] = \"EAST\";\n    Direction[\"WEST\"] = \"WEST\";\n})(Direction || (Direction = {}));\n```\n\n#### 异构枚举\n异构枚举的成员值是数字和字符串的混合：\n```js\nenum Enum {\n  A,\n  B,\n  C = \"C\",\n  D = \"D\",\n  E = 8,\n  F,\n}\n```\n编译生成：\n```js\n\"use strict\";\nvar Enum;\n(function (Enum) {\n    Enum[Enum[\"A\"] = 0] = \"A\";\n    Enum[Enum[\"B\"] = 1] = \"B\";\n    Enum[\"C\"] = \"C\";\n    Enum[\"D\"] = \"D\";\n    Enum[Enum[\"E\"] = 8] = \"E\";\n    Enum[Enum[\"F\"] = 9] = \"F\";\n})(Enum || (Enum = {}));\n```\n数字枚举相对字符串枚举多了 “反向映射”：\n```js\nconsole.log(Enum.A) //输出：0\nconsole.log(Enum[0]) // 输出：A\n```\n\n### Any\n在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。\n```js\nlet notSure: any = 666;\nnotSure = \"cosyer\";\nnotSure = false;\n```\nany 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查。\n```js\nlet value: any;\n\nvalue.foo.bar; // OK\nvalue.trim(); // OK\nvalue(); // OK\nnew value(); // OK\nvalue[0][1]; // OK\n```\n在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。AnyScript 2333.\n\n### Unknown\n就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。下面我们来看一下 unknown 类型的使用示例：\n```js\nlet value: unknown;\n\nvalue = true; // OK\nvalue = 42; // OK\nvalue = \"Hello World\"; // OK\nvalue = []; // OK\nvalue = {}; // OK\nvalue = Math.random; // OK\nvalue = null; // OK\nvalue = undefined; // OK\nvalue = new TypeError(); // OK\nvalue = Symbol(\"type\"); // OK\n```\n\n对 value 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 unknown 的值赋值给其他类型的变量时会发生什么？\n\n```js\nlet value: unknown;\n\nlet value1: unknown = value; // OK\nlet value2: any = value; // OK\nlet value3: boolean = value; // Error\nlet value4: number = value; // Error\nlet value5: string = value; // Error\nlet value6: object = value; // Error\nlet value7: any[] = value; // Error\nlet value8: Function = value; // Error\n```\nunknown 类型只能被赋值给 any 类型和 unknown 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 unknown 类型的值。毕竟我们不知道变量 value 中存储了什么类型的值。\n\n将 value 变量类型设置为 unknown 后，这些操作都不再被认为是类型正确的。通过将 any 类型改变为 unknown 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。\n\n### Tuple\n众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。\n\n元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子：\n```js\nlet tupleType: [string, boolean]; // 强制类型匹配\ntupleType = [\"cosyer\", true];\n```\n\n### Void\n某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n```js\n// 声明函数返回值为void\nfunction warnUser(): void {\n  console.log(\"This is my warning message\");\n}\n```\n\n需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 undefined 或 null：\n```js\nlet unusable: void = undefined;\n```\n\n### Null/Undefined\nTypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。\n```js\nlet u: undefined = undefined;\nlet n: null = null;\n```\n默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。然而，如果你指定了--strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自的类型。\n\n### Never\nnever 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。\n\n```js\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message);\n}\n\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n```\n\n在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下：\n```js\ntype Foo = string | number;\n\nfunction controlFlowAnalysisWithNever(foo: Foo) {\n  if (typeof foo === \"string\") {\n    // 这里 foo 被收窄为 string 类型\n  } else if (typeof foo === \"number\") {\n    // 这里 foo 被收窄为 number 类型\n  } else {\n    // foo 在这里是 never\n    const check: never = foo;\n  }\n}\n```\n\n注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：\ntype Foo = string | number | boolean;\n复制代码然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保\ncontrolFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论：`使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。`\n\n## 类型断言\n### 尖括号\n```js\nlet someValue: any = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n```\n\n### as\n```js\nlet someValue: any = \"this is a string\";\nlet strLength: number = (someValue as string).length;\n```\n\n## 类型守卫\n类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护：\n\n### in 关键字\n```js\ninterface Admin {\n  name: string;\n  privileges: string[];\n}\n\ninterface Employee {\n  name: string;\n  startDate: Date;\n}\n\ntype UnknownEmployee = Employee | Admin;\n\nfunction printEmployeeInformation(emp: UnknownEmployee) {\n  console.log(\"Name: \" + emp.name);\n  if (\"privileges\" in emp) {\n    console.log(\"Privileges: \" + emp.privileges);\n  }\n  if (\"startDate\" in emp) {\n    console.log(\"Start Date: \" + emp.startDate);\n  }\n}\n```\n\n### typeof 关键字\n```js\nfunction padLeft(value: string, padding: string | number) {\n  if (typeof padding === \"number\") {\n      return Array(padding + 1).join(\" \") + value;\n  }\n  if (typeof padding === \"string\") {\n      return padding + value;\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`);\n}\n```\ntypeof 类型保护只支持两种形式：typeof v === \"typename\" 和 typeof v !== typename，\"typename\" 必须是 \"number\"， \"string\"， \"boolean\" 或 \"symbol\"。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。\n\n### instanceof 关键字\n```js\ninterface Padder {\n  getPaddingString(): string;\n}\n\nclass SpaceRepeatingPadder implements Padder {\n  constructor(private numSpaces: number) {}\n  getPaddingString() {\n    return Array(this.numSpaces + 1).join(\" \");\n  }\n}\n\nclass StringPadder implements Padder {\n  constructor(private value: string) {}\n  getPaddingString() {\n    return this.value;\n  }\n}\n\nlet padder: Padder = new SpaceRepeatingPadder(6);\n\nif (padder instanceof SpaceRepeatingPadder) {\n  // padder的类型收窄为 'SpaceRepeatingPadder'\n}\n```\n\n### 自定义类型保护的类型谓词\n```js\nfunction isNumber(x: any): x is number {\n  return typeof x === \"number\";\n}\n\nfunction isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n```\n\n## 联合类型和类型别名\n### 联合类型\n联合类型通常与 null 或 undefined 一起使用：\n```js\nconst sayHello = (name: string | undefined) => {\n  /* ... */\n};\n```\n例如，这里 name 的类型是 string | undefined 意味着可以将 string 或 undefined 的值传递给sayHello 函数。\n```js\nsayHello(\"cosyer\");\nsayHello(undefined);\n```\n\n### 可辨识联合\n\nTypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。它包含 3 个要点：`可辨识、联合类型和类型守卫。`\n\n这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。`如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。`\n\n#### 可辨识\n可辨识要求联合类型中的每个元素都含有一个单例类型属性(公共属性)，比如：\n```js\nenum CarTransmission {\n  Automatic = 200,\n  Manual = 300\n}\n\ninterface Motorcycle {\n  vType: \"motorcycle\"; // discriminant\n  make: number; // year\n}\n\ninterface Car {\n  vType: \"car\"; // discriminant\n  transmission: CarTransmission\n}\n\ninterface Truck {\n  vType: \"truck\"; // discriminant\n  capacity: number; // in tons\n}\n```\n在上述代码中，我们分别定义了 Motorcycle、 Car 和 Truck 三个接口，在这些接口中都包含一个 vType 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。\n\n#### 联合类型\n基于前面定义了三个接口，我们可以创建一个 Vehicle 联合类型：\n```js\ntype Vehicle = Motorcycle | Car | Truck;\n```\n现在我们就可以开始使用 Vehicle 联合类型，对于 Vehicle 类型的变量，它可以表示不同类型的车辆。\n\n#### 类型守卫\n下面我们来定义一个 evaluatePrice 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下：\n```js\nconst EVALUATION_FACTOR = Math.PI; \nfunction evaluatePrice(vehicle: Vehicle) {\n  return vehicle.capacity * EVALUATION_FACTOR;\n}\n\nconst myTruck: Truck = { vType: \"truck\", capacity: 9.5 };\nevaluatePrice(myTruck);\n```\n对于以上代码，TypeScript 编译器将会提示以下错误信息：\n```js\nProperty 'capacity' does not exist on type 'Vehicle'.\nProperty 'capacity' does not exist on type 'Motorcycle'.\n```\n\n原因是在 Motorcycle 接口中，并不存在 capacity 属性，而对于 Car 接口来说，它也不存在 capacity 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 evaluatePrice 方法，重构后的代码如下：\n```js\nfunction evaluatePrice(vehicle: Vehicle) {\n  switch(vehicle.vType) {\n    case \"car\":\n      return vehicle.transmission * EVALUATION_FACTOR;\n    case \"truck\":\n      return vehicle.capacity * EVALUATION_FACTOR;\n    case \"motorcycle\":\n      return vehicle.make * EVALUATION_FACTOR;\n  }\n}\n```\n\n### 类型别名\n类型别名用来给一个类型起个新名字(alias)。\n```js\ntype Message = string | string[];\n\nlet greet = (message: Message) => {\n  // ...\n};\n```\n\n## 交叉类型\nTypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\n\n```js\ninterface IPerson {\n  id: string;\n  age: number;\n}\n\ninterface IWorker {\n  companyId: string;\n}\n\ntype IStaff = IPerson & IWorker;\n\nconst staff: IStaff = {\n  id: 'E1006',\n  age: 33,\n  companyId: 'EFT'\n};\n\nconsole.dir(staff)\n```\n在上面示例中，我们首先为 IPerson 和 IWorker 类型定义了不同的成员，然后通过 & 运算符定义了 IStaff 交叉类型，所以该类型同时拥有 IPerson 和 IWorker 这两种类型的成员。\n\n## 函数\n### 区别\n|TypeScript|JavaScript|\n|:---:|:---:|\n|含有类型|无类型|\n|箭头函数|箭头函数（ES2015）|\n|函数类型|无函数类型|\n|必填和可选参数|所有参数都是可选的|\n|默认参数|默认参数|\n|剩余参数|剩余参数|\n|函数重载|无函数重载|\n\n### 箭头函数\n简单看下示例，详细可见[JavaScript 中 this 的详解](https://mydearest.cn/jsthis.html)\n```js\nmyBooks.forEach(() => console.log('reading'));\n\nmyBooks.forEach(title => console.log(title));\n\nmyBooks.forEach((title, idx, arr) =>\n  console.log(idx + '-' + title);\n);\n\nmyBooks.forEach((title, idx, arr) => {\n  console.log(idx + '-' + title);\n});\n```\n\n### 参数类型和返回类型\n```js\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\n```\n\n### 函数类型\n```js\nlet IdGenerator: (chars: string, nums: number) => string;\n\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\n\nIdGenerator = createUserId;\n```\n\n### 可选参数和默认参数\n```js\n// 可选参数\nfunction createUserId(name: string, id: number, age?: number): string {\n  return name + id;\n}\n\n// 默认参数\nfunction createUserId(\n  name: string = \"cosyer\",\n  id: number,\n  age?: number\n): string {\n  return name + id;\n}\n```\n在声明函数时，可以通过 ? 号来定义可选参数，比如 age?: number 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。\n\n### 剩余参数\n```js\nfunction push(array, ...items) {\n  items.forEach(function (item) {\n    array.push(item);\n  });\n}\n\nlet a = [];\npush(a, 1, 2, 3);\n```\n\n### 函数重载\n函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。\n```js\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: string): string;\nfunction add(a: string, b: number): string;\nfunction add(a: number, b: string): string;\nfunction add(a: Combinable, b: Combinable) {\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return a.toString() + b.toString();\n  }\n  return a + b;\n}\n```\n\n方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：\n```js\nclass Calculator {\n  add(a: number, b: number): number;\n  add(a: string, b: string): string;\n  add(a: string, b: number): string;\n  add(a: number, b: string): string;\n  add(a: Combinable, b: Combinable) {\n    if (typeof a === \"string\" || typeof b === \"string\") {\n      return a.toString() + b.toString();\n    }\n    return a + b;\n  }\n}\n\nconst calculator = new Calculator();\nconst result = calculator.add(\"cosyer\", \" chenyu\");\n```\n这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，add(a: Combinable, b: Combinable){ } 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。\n\n## 数组\n### 数组解构\n```js\nlet x: number; let y: number; let z: number;\nlet five_array = [0,1,2,3,4];\n[x,y,z] = five_array; // 0 1 2\n```\n\n### 扩展运算符\n```js\nlet two_array = [0, 1];\nlet five_array = [...two_array, 2, 3, 4];\n```\n\n### 数组遍历\n```js\nlet colors: string[] = [\"red\", \"green\", \"blue\"];\nfor (let i of colors) {\n  console.log(i);\n}\n```\n\n## 对象\n### 对象解构\n```js\nlet person = {\n  name: \"cosyer\",\n  gender: \"Male\",\n};\n\nlet { name, gender } = person;\n```\n\n### 对象展开扩展\n```js\nlet person = {\n  name: \"cosyer\",\n  gender: \"Male\",\n  address: \"Nanjing\",\n};\n\n// 组装对象\nlet personWithAge = { ...person, age: 33 };\n\n// 获取除了某些项外的其它项\nlet { name, ...rest } = person;\n```\n\n## 接口\n\n在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。\n\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述\n\n### 对象的形状(描述)\n```js\ninterface Person {\n  name: string;\n  age: number;\n}\n\nlet cosyer: Person = {\n  name: \"cosyer\",\n  age: 25,\n};\n```\n\n### 可选、只读属性\n```js\ninterface Person {\n  readonly name: string;\n  age?: number;\n}\n```\n只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。\n\n```js\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n```\n\n\n## 泛型\n软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n\n> 在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。\n\n设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。\n\n泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。\n\n### 泛型接口\n```js\ninterface GenericIdentityFn<T> {\n  (arg: T): T;\n}\n```\n\n### 泛型类\n```js\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\n```\n\n### 泛型变量\n对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：\n\n- T（Type）：表示一个 TypeScript 类型\n- K（Key）：表示对象中的键类型\n- V（Value）：表示对象中的值类型\n- E（Element）：表示元素类型\n\n### 泛型工具类型(6种)\n为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。\n#### typeof\ntypeof 操作符可以用来获取一个变量声明或对象的类型。\n```js\ninterface Person {\n  name: string;\n  age: number;\n}\n\nconst cosyer: Person = { name: 'cosyer', age: 25 };\ntype Cosyer= typeof cosyer; // -> Person\n\nfunction toArray(x: number): Array<number> {\n  return [x];\n}\n\ntype Func = typeof toArray; // -> (x: number) => number[]\n```\n\n#### keyof\nkeyof 操作符可以用来一个对象中的所有 key 值：\n```js\ninterface Person {\n    name: string;\n    age: number;\n}\n\ntype K1 = keyof Person; // \"name\" | \"age\"\ntype K2 = keyof Person[]; // \"length\" | \"toString\" | \"pop\" | \"push\" | \"concat\" | \"join\" \ntype K3 = keyof { [x: string]: Person };  // string | number\n```\n\n#### in\nin 用来遍历枚举类型：\n```js\ntype Keys = \"a\" | \"b\" | \"c\"\n\ntype Obj =  {\n  [p in Keys]: any\n} // -> { a: any, b: any, c: any }\n```\n\n#### infer\n在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。\n```js\ntype ReturnType<T> = T extends (\n  ...args: any[]\n) => infer R ? R : any;\n```\n以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。\n\n#### extends\n有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。\n```js\ninterface ILengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends ILengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n```\n```js\n// error, number doesn't have a .length property\nloggingIdentity(3)\n\nloggingIdentity({length: 10, value: 3});\n```\n\n#### Partial\nPartial<T> 的作用就是将某个类型里的属性全部变为可选项 ?。\n```js\n/**\n * node_modules/typescript/lib/lib.es5.d.ts\n * Make all properties in T optional\n */\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n```js\ninterface Todo {\n  title: string;\n  description: string;\n}\n\nfunction updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n\nconst todo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\",\n};\n\nconst todo2 = updateTodo(todo1, {\n  description: \"throw out trash\",\n});\n```\n\n## 装饰器\n### 装饰器是什么\n- 它是一个表达式\n- 该表达式被执行后，返回一个函数\n- 函数的入参分别为 target、name 和 descriptor\n- 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象\n\n### 装饰器的分类\n- 类装饰器（Class decorators）\n- 属性装饰器（Property decorators）\n- 方法装饰器（Method decorators）\n- 参数装饰器（Parameter decorators）\n\n#### 类装饰器\n```js\ndeclare type ClassDecorator = <TFunction extends Function>(\n  target: TFunction\n) => TFunction | void;\n```\n类装饰器顾名思义，就是用来装饰类的。它接收一个参数：\n- target: TFunction - 被装饰的类\n```js\nfunction Greeter(target: Function): void {\n  target.prototype.greet = function (): void {\n    console.log(\"Hello cosyer!\");\n  };\n}\n\n@Greeter\nclass Greeting {\n  constructor() {\n    // 内部实现\n  }\n}\n\nlet myGreeting = new Greeting();\nmyGreeting.greet(); // console output: 'Hello cosyer!';\n```\n\n`自定义参数`\n```js\nfunction Greeter(greeting: string) {\n  return function (target: Function) {\n    target.prototype.greet = function (): void {\n      console.log(greeting);\n    };\n  };\n}\n\n@Greeter(\"Hello TS!\")\nclass Greeting {\n  constructor() {\n    // 内部实现\n  }\n}\n\nlet myGreeting = new Greeting();\nmyGreeting.greet(); // console output: 'Hello TS!';\n```\n\n#### 属性装饰器\n```js\ndeclare type PropertyDecorator = (target:Object, \n  propertyKey: string | symbol ) => void;\n```\n\n属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：\n- target: Object - 被装饰的类\n- propertyKey: string | symbol - 被装饰类的属性名\n\n```js\nfunction logProperty(target: any, key: string) {\n  delete target[key];\n\n  const backingField = \"_\" + key;\n\n  Object.defineProperty(target, backingField, {\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n\n  // property getter\n  const getter = function (this: any) {\n    const currVal = this[backingField];\n    console.log(`Get: ${key} => ${currVal}`);\n    return currVal;\n  };\n\n  // property setter\n  const setter = function (this: any, newVal: any) {\n    console.log(`Set: ${key} => ${newVal}`);\n    this[backingField] = newVal;\n  };\n\n  // Create new property with getter and setter\n  Object.defineProperty(target, key, {\n    get: getter,\n    set: setter,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nclass Person { \n  @logProperty\n  public name: string;\n\n  constructor(name : string) { \n    this.name = name;\n  }\n}\n\nconst p1 = new Person(\"cosyer\");\np1.name = \"chenyu\";\n// Set: name => cosyer\n// Set: name => chenyu\n```\n\n#### 方法装饰器\n```js\ndeclare type MethodDecorator = <T>(target:Object, propertyKey: string | symbol, \t \t\n  descriptor: TypePropertyDescript<T>) => TypedPropertyDescriptor<T> | void;\n```\n\n方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：\n- target: Object - 被装饰的类\n- propertyKey: string | symbol - 方法名\n- descriptor: TypePropertyDescript - 属性描述符\n\n```js\nfunction LogOutput(tarage: Function, key: string, descriptor: any) {\n  let originalMethod = descriptor.value;\n  let newMethod = function(...args: any[]): any {\n    let result: any = originalMethod.apply(this, args);\n    if(!this.loggedOutput) {\n      this.loggedOutput = new Array<any>();\n    }\n    this.loggedOutput.push({\n      method: key,\n      parameters: args,\n      output: result,\n      timestamp: new Date()\n    });\n    return result;\n  };\n  descriptor.value = newMethod;\n}\n\nclass Calculator {\n  @LogOutput\n  double (num: number): number {\n    return num * 2;\n  }\n}\n\nlet calc = new Calculator();\ncalc.double(11);\n// console ouput: [{method: \"double\", output: 22, ...}]\nconsole.log(calc.loggedOutput); \n```\n\n#### 参数装饰器\n```js\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, \n  parameterIndex: number ) => void\n```\n参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：\n- target: Object - 被装饰的类\n- propertyKey: string | symbol - 方法名\n- parameterIndex: number - 方法中参数的索引值\n\n```js\nfunction Log(target: Function, key: string, parameterIndex: number) {\n  let functionLogged = key || target.prototype.constructor.name;\n  console.log(`The parameter in position ${parameterIndex} at ${functionLogged} has\n\tbeen decorated`);\n}\n\nclass Greeter {\n  greeting: string;\n  constructor(@Log phrase: string) {\n\tthis.greeting = phrase; \n  }\n}\n\n// console output: The parameter in position 0 \n// at Greeter has been decorated\n```\n\n\n## 类\n### 类的属性和方法\n在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。\n```js\nclass Greeter {\n  // 静态属性\n  static cname: string = \"Greeter\";\n  // 成员属性\n  greeting: string;\n\n  // 构造函数 - 执行初始化操作\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  // 静态方法\n  static getClassName() {\n    return \"Class name is Greeter\";\n  }\n\n  // 成员方法\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n\nlet greeter = new Greeter(\"world\");\n```\n编译生成：\n```js\n\"use strict\";\nvar Greeter = /** @class */ (function () {\n    // 构造函数 - 执行初始化操作\n    function Greeter(message) {\n        this.greeting = message;\n    }\n    // 静态方法\n    Greeter.getClassName = function () {\n        return \"Class name is Greeter\";\n    };\n    // 成员方法\n    Greeter.prototype.greet = function () {\n        return \"Hello, \" + this.greeting;\n    };\n    // 静态属性\n    Greeter.cname = \"Greeter\";\n    return Greeter;\n}());\nvar greeter = new Greeter(\"world\");\n```\n\n### 访问器(getter/setter)\n在 TypeScript 中，我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。\n```js\nlet passcode = \"Hello TypeScript\";\n\nclass Employee {\n  private _fullName: string;\n\n  get fullName(): string {\n    return this._fullName;\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode == \"Hello TypeScript\") {\n      this._fullName = newName;\n    } else {\n      console.log(\"Error: Unauthorized update of employee!\");\n    }\n  }\n}\n\nlet employee = new Employee();\nemployee.fullName = \"cosyer\";\nif (employee.fullName) {\n  console.log(employee.fullName);\n}\n```\n\n### 继承\n继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加自己新功能的能力，继承是类与类或者接口与接口之间最常见的关系。\n```js\nclass Animal {\n  name: string;\n  \n  constructor(theName: string) {\n    this.name = theName;\n  }\n  \n  move(distanceInMeters: number = 0) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  \n  move(distanceInMeters = 5) {\n    console.log(\"Slithering...\");\n    super.move(distanceInMeters);\n  }\n}\n\nlet sam = new Snake(\"Sammy the Python\");\nsam.move();\n```\n\n### 私有字段\n在 TypeScript 3.8 版本就开始支持ECMAScript 私有字段\n```js\nclass Person {\n  #name: string;\n\n  constructor(name: string) {\n    this.#name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.#name}!`);\n  }\n}\n\nlet cosyer = new Person(\"cosyer\");\n\ncosyer.#name;\n// Property '#name' is not accessible outside class 'Person'\n// because it has a private identifier.\n```\n\n与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：\n\n- 私有字段以 # 字符开头，有时我们称之为私有名称；\n- 每个私有字段名称都唯一地限定于其包含的类；\n- 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；\n- 私有字段不能在包含的类之外访问，甚至不能被检测到。\n\n## 编译上下文\n### tsconfig.json 的作用\n- 用于标识 TypeScript 项目的根路径；\n- 用于配置 TypeScript 编译器；\n- 用于指定编译的文件。\n\n### tsconfig.json 重要字段\n- files - 设置要编译的文件的名称；\n- include - 设置需要进行编译的文件，支持路径模式匹配；\n- exclude - 设置无需进行编译的文件，支持路径模式匹配；\n- compilerOptions - 设置与编译流程相关的选项。\n\n### compilerOptions 选项\n```js\n{\n  \"compilerOptions\": {\n\n    /* 基本选项 */\n    \"target\": \"es5\",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'\n    \"module\": \"commonjs\",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'\n    \"lib\": [],                             // 指定要包含在编译中的库文件\n    \"allowJs\": true,                       // 允许编译 javascript 文件\n    \"checkJs\": true,                       // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'\n    \"declaration\": true,                   // 生成相应的 '.d.ts' 文件\n    \"sourceMap\": true,                     // 生成相应的 '.map' 文件\n    \"outFile\": \"./\",                       // 将输出文件合并为一个文件\n    \"outDir\": \"./\",                        // 指定输出目录\n    \"rootDir\": \"./\",                       // 用来控制输出目录结构 --outDir.\n    \"removeComments\": true,                // 删除编译后的所有的注释\n    \"noEmit\": true,                        // 不生成输出文件\n    \"importHelpers\": true,                 // 从 tslib 导入辅助工具函数\n    \"isolatedModules\": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                        // 启用所有严格类型检查选项\n    \"noImplicitAny\": true,                 // 在表达式和声明上有隐含的 any类型时报错\n    \"strictNullChecks\": true,              // 启用严格的 null 检查\n    \"noImplicitThis\": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysStrict\": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'\n\n    /* 额外的检查 */\n    \"noUnusedLocals\": true,                // 有未使用的变量时，抛出错误\n    \"noUnusedParameters\": true,            // 有未使用的参数时，抛出错误\n    \"noImplicitReturns\": true,             // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"noFallthroughCasesInSwitch\": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）\n\n    /* 模块解析选项 */\n    \"moduleResolution\": \"node\",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)\n    \"baseUrl\": \"./\",                       // 用于解析非相对模块名称的基目录\n    \"paths\": {},                           // 模块名到基于 baseUrl 的路径映射的列表\n    \"rootDirs\": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeRoots\": [],                       // 包含类型声明的文件列表\n    \"types\": [],                           // 需要包含的类型声明文件名列表\n    \"allowSyntheticDefaultImports\": true,  // 允许从没有设置默认导出的模块中默认导入。\n\n    /* Source Map Options */\n    \"sourceRoot\": \"./\",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置\n    \"mapRoot\": \"./\",                       // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlineSourceMap\": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlineSources\": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性\n\n    /* 其他选项 */\n    \"experimentalDecorators\": true,        // 启用装饰器\n    \"emitDecoratorMetadata\": true          // 为装饰器提供元数据的支持\n  }\n}\n```\n\n## 仓库代码\n[typescript-learn](https://github.com/cosyer/typescript-learn)\n\n## 相关问题\n[TypeScript 中，interface 和 type 的区别](https://mydearest.cn/2020/TypeScript%20%E4%B8%AD%EF%BC%8Cinterface%20%E5%92%8C%20type%20%E7%9A%84%E5%8C%BA%E5%88%AB.html)\n","tags":["typescript"],"categories":["JS"]},{"title":"XSS学习&实践","url":"%2F2020%2FXSS%E5%AD%A6%E4%B9%A0%26%E5%AE%9E%E8%B7%B5.html","content":"\n`web安全`一直是开发中不可忽视的一部分。而xss作为web开发中最常见的攻击手段，防范是必然的。基于web浏览器tricks，JavaScript的发展，npm等开源项目漏\n洞，web注入等会让开发者越来越防不胜防。\n\n## 插入执行标签\n- script\n- img onerror触发\n- iframe srcdoc触发\n\n## 标签等提前闭合(截断)\n- 如在富文本, input, textarea, 可编辑div等，[0x01](https://xss.haozi.me/#/0x01)，[0x02](https://xss.haozi.me/#/0x02)\n- style标签\n```js\n<style>\n</style ><script>alert(1)</script>\n</style>\n```\n- 注释提前闭合\n```js\n--!><script>alert(1)</script>\n```\n\n---\n<!--more-->\n\n- input type重写\ninput的type，在type之前可以重写为image，通过onerror注入\n\n## ES6 tag标签\n```js\n<script>alert`1`</script>\n```\n\n## 转义字符仍可执行\n- script标签可执行 base64的html代码片段\n- onerror可执行 转义为 html 10进制， 16进制的代码片段\n- url转义为 html 10进制， 16进制 仍可执行, url的定义可获取其他域下的资源文件\n```js\nscheme:[//[user:password@]host[:port]][/]path[?query][#fragment]\n```\n\n## svg不闭合也执行\n## 正则替换不靠谱\n- 正则替换\n- 正则命中\n- 追加执行，正则替换失效\n\n## 防护\n- 配置安全头\n- xss监控\n- 服务端白名单过滤\n","tags":["前端"],"categories":["工具"]},{"title":"windows安装mysql","url":"%2F2020%2Fwindows%E5%AE%89%E8%A3%85mysql.html","content":"\n## 安装包下载\n\n- 下载地址：https://dev.mysql.com/downloads/mysql/\n\n- Mysql国内镜像：http://mirrors.sohu.com/mysql/MySQL-8.0/\n\n下载完成后，选择一个磁盘内放置并解压。\n\n## 设置环境变量 \n1. 变量名：MYSQL_HOME\n2. 变量值：E:\\mysql5.7.23\n3. path里添加：%MYSQL_HOME%\\bin\n\n## 初始化设置\n### 创建data Uploads文件夹\n### my.init文件\n\n```js\n[mysqld]\nport=3306\ncharacter_set_server=utf8\nbasedir=E:\\mysql5.7.23\ndatadir=E:\\mysql5.7.23\\data\nserver-id=1\nsql_mode=NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\nlower_case_table_names=1\ninnodb_file_per_table = 1\nlog_timestamps=SYSTEM\n\nlog-error   = error.log\nslow_query_log = 1\nslow_query_log_file = slow.log\nlong_query_time = 5\nlog-bin = binlog\nbinlog_format = row\nexpire_logs_days = 15\nlog_bin_trust_function_creators = 1\nsecure-file-priv=E:\\mysql5.7.23\\Uploads\n\n[client]   \ndefault-character-set=utf8\n```\n\n---\n<!--more-->\n\n### 初始化生成data下文件(以管理员身份运行cmd)\n```js\nmysqld --initialize-insecure\n```\n\n### 安装服务\n```js\nmysqld --install mysql8\n```\n\n### 启动和停止\n```js\nnet start mysql8 \nnet stop mysql8\n```\n\n## MySQL初始化root密码\n\n- mysql默认root用户没有密码，输入mysql –u root 进入mysql\n\n1. 进入mysql数据库\n```js\nuse mysql;\n```\n\n2. 初始化root密码\n```js\nmysql>update user set password=PASSWORD('123456') where User='root';\n```\n\n`8.0+版本`\n```js\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\n```\n\n## root密码忘记解决方法（Windows环境）\n\n1. 确保MySQL服务停止\n\n2. 打开第一个cmd窗口，进入MySQL安装目录下的bin目录\n\n3. 跳过权限安全检查，MySQL服务运行起来后，不用输入密码就能进入数据库\n\n例如，D:\\mysql-5.5.35-win32\\bin>mysqld –defaults-file=”D:\\mysql-5.5.35-win32\\my.ini” –console –skip-grant-tables\n\n4. 打开第二个cmd窗口，连接MySQL\n\n- 输入命令：mysql -uroot -p\n\n- 出现 Enter password: 直接回车\n\n5. 使用命令切换到mysql数据库：\n```js\nuse mysql;\n```\n\n6. 使用命令更改root密码：\n```js\nUPDATE user SET Password=PASSWORD('123456') where USER='root';\n```\n\n7. 刷新权限：\n```js\nFLUSH PRIVILEGES;\n```\n8. 退出：\n```js\nquit;\n```\n\n9. 关闭上面打开的两个cmd窗口，重新启动MySQL服务。\n","tags":["mysql"],"categories":["工具"]},{"title":"【Mac 终端配置】iTerm2 + oh-my-zsh","url":"%2F2020%2FMac%20iTerm2%20%2B%20oh-my-zsh.html","content":"\n## 前置校验\n```bash\n# 1、默认已安装 Homebrew、iTerm2\n# 2、查看是否安装了zsh，查看是否返回 /usr/bin/zsh\ncat /etc/shells\n# 若未安装\nbrew install zsh\n\n# iTerm2 启动项配置\nchsh -s /bin/zsh      # 设置为zsh\nchsh -s /bin/bash     # 设置为bash（Mac自带默认）\n```\n\n---\n<!--more-->\n\n## 安装 ob-my-zsh\n```bash\n# 方式一：wegt安装\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n\n# 方式二：curl 安装\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n\n# 方式三：手动安装\ngit clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n\n# 卸载\nuninstall_oh_my_zsh zsh\n\n# zsh配置环境变量\n~/.zshrc\n```\n\n## 安装 Powerline\n```bash\n# 1、检测是否已经安装，若有版本信息则已安装\npip show powerline-status\n\n# 2、将 powerline-status 安装在/usr/根目录中\npip install --user powerline-status\n\n# 上一步若显示没有 pip,先安装pip\nsudo easy_install pip\n```\n\n## 设置字体\n```bash\n# 1、新建文件夹(如~/Desktop/OpenSource)，文件夹下\ncd ~/Desktop/OpenSource\ngit clone https://github.com/powerline/fonts.git --depth=1\n# 2、进入脚本目录\ncd fonts\n# 3、执行脚本\n./install.sh\n\n# 进入 iTerm2 -> Preferences -> Profiles -> Text -> Font -> Change Font\n# 选择Meslo LG S for Powerfine, 常规， 12\n```\n\n## 设置配色方案\n```bash\n# 直接下载tar.zip包(包含全部配色)\n# 进入 iTerm2 -> Preferences -> Profiles->Color \n# 选择 Color Presets->import 选择解压好的目录下schemes目录中相应配色方案导入\n```\n\n## 安装 oh-my-zsh 主题\n```bash\n# 下载安装 agnoster 主题，将主题拷贝到oh my zsh的zsh中\ncd ~/Desktop/OpenSource\ngit clone https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git\ncd oh-my-zsh-agnoster-fcamblor/\n./install\n\n# 将 ZSH_THEME 值改为 agnoster，ecs 退出，:wq 保存\nvi ~/.zshrc\n```\n\n## 安装插件\n```bash\n# ======================== 高亮插件 ========================\n# 在 ~ 目录下新建文件夹 zsh-plugins(~/.zshrc 默认目录)\ncd zsh-plugins\ngit clone git://github.com/zsh-users/zsh-syntax-highlighting.git\nvim .zshrc\n# 文末添加以下配置\nsource ~/zsh-pludins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\ncd ~/.oh-my-zsh/custom/plugins\nvim .zshrc\n# 文末添加以下配置\nplugins=(zsh-syntax-highlighting)\n\n# ======================== 自动补齐插件 ========================\ncd zsh-plugins\nhttp://mimosa-pudica.net/src/incr-0.2.zsh\n# 将文件放到 ~/zsh-pludins/inrc下\nvim .zshrc\nsource ~/.oh-my-zsh/plugins/incr/incr*.zsh\n```\n","tags":["工具"],"categories":["工具"]},{"title":"关于node的那些事(基础篇)","url":"%2F2020%2F%E5%85%B3%E4%BA%8Enode%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B(%E5%9F%BA%E7%A1%80%E7%AF%87).html","content":"\n## 👨提问：最近Deno很火，会不会替代node的替代品，学node是不是没有前途？\n> 莫慌，Node依旧是社区热捧的服务器端 JavaScript 运行环境，Deno的出现其实本质上是完善现阶段的Node（新轮子），包括原生支持TS、安全性、支持ES \nModule浏览器模块、等特征。万变不离其宗，虽然有了Deno，将来可能就不需要 Node.js，但是新事物总是需要不断推演和考验后，所以这一点而言，Node短时间内很\n难被替换，毕竟背后依附着强大社区的支撑。\n\n## node 如何获取命令行传来的参数？\n> process.argv。process是一个全局变量，它提供当前 Node.js 进程的有关信息，而process.argv 属性则返回一个数组，数组中的信息包括启动Node.js进程时的命令行参数。\n\n- process.argv[0] : 返回启动Node.js进程的可执行文件所在的绝对路径\n- process.argv[1] : 为当前执行的JavaScript文件路径\n- process.argv.splice(2) : 移除前两者后，剩余的元素为其他命令行参数(也就是我们自定义部分)\n\n```js\n\"script\": {\n    \"serve\": \"node test.js arg1 arg2 arg3\"\n}\n\n// test.js\nconst arguments = process.argv.splice(2) // [arg1, arg2, arg3]\n\n// 结合commander\ncommander.parse(process.argv)\n```\n\n---\n<!--more-->\n\n## 为什么要用node（基于v8引擎运行在服务端的JS运行环境）\n> 总结起来node有以下几个特点:简单强大，轻量可扩展．简单体现在node使用的是javascript，json来进行编码，人人都会；强大体现在非阻塞IO,可以适应分块传输数据，较慢的网络环境，尤其擅长\n高并发访问；轻量体现在node本身既是代码，又是服务器，前后端使用统一语言;可扩展体现在可以轻松应对多实例，多服务器架构，同时有海量的第三方应用组件。\n\n- 全局对象\nprocess、console、Buffer\n\n**基于事件驱动和无阻塞适合高并发的场景，统一语言**\n\n## 怎么看 nodejs 可支持高并发\nnodejs 其实并不是真正的单线程架构，因为 nodejs 还有I/O线程存在（网络I/O、磁盘I/O），这些I/O线程是由更底层的 libuv 处理，这部分线程对于开发者来\n说是透明的。 JavaScript 代码永远运行在V8上，是单线程的。异步通过一次次循环事件队列来实现的。\n\n- 单线程架构的优势和劣势：\n  - 优势：\n1. 单线程就一个线程在玩，省去了线程间切换的开销\n2. 还有线程同步的问题，线程冲突的问题的也不需要担心\n\n  - 劣势：\n\n1. 劣势也很明显，现在起步都是 4 核，单线程没法充分利用 cpu 的资源\n2. 单线程，一旦崩溃，应用就挂掉了，大家调试脚本也知道一旦执行过程报错了，本次调试就直接结束了\n3. 因为只能利用一个 cpu ，一旦 cpu 被某个计算一直占用， cpu 得不到释放，后续的请求就会一直被挂起，直接无响应了\n\n## node有哪些相关的文件路径？\n> Node 中的文件路径有 __dirname, __filename, process.cwd(), ./ 或者 ../\n\n- __dirname: 总是返回被执行的 js 所在文件夹的绝对路径\n- __filename: 总是返回被执行的 js 的绝对路径\n- process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径\n\n## node相关path API 有哪些？\n> path 模块提供了一些实用工具，用于处理文件和目录的路径，常用api有：path.dirname、path.join、path.resolve 其他的看文档 [Path API](http://nodejs.cn/api/path.html)\n\n- path.dirname()： 返回 path 的目录名\n- path.join()：所有给定的 path 片段连接到一起，然后规范化生成的路径\n- path.resolve()：方法会将路径或路径片段的序列解析为绝对路径，解析为相对于当前目录的绝对路径，相当于cd命令\n\npath.join(__dirname, '../lib/common.js')和 path.resolve(__dirname, '../lib/common.js')返回的结果相同，难道可以相互替换？\n\n1. join是把各个path片段连接在一起， resolve把/当成根目录\n```js\npath.join('/a', '/b') // '/a/b'\npath.resolve('/a', '/b') //'/b'\n```\n\n2. join是直接拼接字段，resolve是解析路径并返回\n```js\npath.join(\"a\",\"b\")  // \"a/b\"\npath.resolve(\"a\", \"b\") // \"/Users/tree/Documents/infrastructure/KSDK/src/a/b\"\n```\n\n## node的文件读取怎么做的？\n> 通过fs文件系统模块提供的API，也是node中重要的模块之一，fs模块主要用于文件的读写、移动、复制、删除、重命名等操作。\n\n```js\nfs.rename('a', 'b', (err)=>{\n    if (err) {\n        exec('rm -rf a', function(err, out) {\n\n        })\n    } else {}\n})\n```\n\n> ⏰需要注意的是，使用require('fs')载入fs模块，fs模块中所有方法都有同步和异步两种形式,刚刚我们展示的rename是异步方法的调用，因为在繁忙的进程中，应使用异步方法， 同步的版本会阻塞整个进程（停止所有的连接），当然fs.rename对应的同步方法就是fs.renameSync\n\n```js\n// 同步的例子\nlet isExists = fs.existsSync('dirname')\nif (isExists) {\n    process.exit(1);\n}\n// 无论同步异步尽量对抛出的异常做相应的处理\n```\n\n## node的url模块是用来干嘛的？\n> 用来对url的字符串解析、url组成等功能，主要包括以下几个API。url.parse()、url.format()\n\n- url.parse：可以将一个url的字符串解析并返回一个url的对象\n- url.format:将传入的url对象解析成一个url字符串并返回\n\n```js\nurl.parse(\"https://baidu.com:8080/test/h?query=js#node\")\n\nUrl {\n  protocol: 'http:',\n  slashes: true,\n  auth: null,\n  host: 'baidu.com:8080',\n  port: '8080',\n  hostname: 'baidu.com',\n  hash: '#node',\n  search: '?query=js',\n  query: 'query=js',\n  pathname: '/test/h',\n  path: '/test/h?query=js',\n  href: 'http://baidu.com:8080/test/h?query=js#node'\n}\n```\n\n## node的http模块创建服务与Express或Koa框架有何不同?\n> express是一个服务端框架，框架简单封装了node的http模块，express支持node原生的写法，express不仅封装好服务器，还封装了中间件、路由等特征，方便开发web服务器，换句话说express = http模块 + 中间件 + 路由\n\n### http\n```js\nconst http = require('http')\nconst server = http.createServer(function (req, res) {\n    res.writeHead(200, {\n       'content-type': 'text/plain'\n    })\n    res.write('hello world')\n    res.end()\n})\nserver.listen(3000)\n```\n\n### express\n```js\nconst express = require('express')\nconst app = express()\napp.user(middleware)\n\napp.get('/', function(req, res){\n    res.send('hello world')\n})\n\napp.listen(3000, function() {\n\n})\n\nfunction middleware(req, res, next) {\n    next()\n}\n```\n\n### koa\n```js\nconst Koa = require('koa')\nconst app = new Koa()\napp.user(middleware)\n\napp.listen(3000)\n\nasync function middleware(ctx, next) {\n    await next()\n}\n```\n\n##  Express和Koa框架中间件有什么不同？\n> 中间件： app.use方法就是往中间件队列中塞入新的中间件，express中间件处理方式是线性的，next过后继续寻找下一个中间件，当然如果没有调用next()的话，就不会调用下一个函数了，调用就会被终止。\n\n- express 中间件：是通过 next 的机制，即上一个中间件会通过 next 触发下一个中间件\n- koa2 中间件：是通过 async await 实现的，中间件执行顺序是“洋葱圈”模型（推荐）\n\n1. 语法区别\nexperss 异步使用 回调\nkoa1 异步使用 generator + yield\nkoa2 异步使用 await/async\n\n2. 中间件区别\nkoa采用洋葱模型，进行顺序执行，出去反向执行，支持context传递数据\nexpress本身无洋葱模型，需要引入插件，不支持context\nexpress的中间件中执行异步函数，执行顺序不会按照洋葱模型，异步的执行结果有可能被放到最后，response之前。\n\n3. 集成度区别\nexpress 内置了很多中间件，集成度高，使用省心，\nkoa 轻量简洁，容易定制\n\n## koa2和egg的区别\n- egg是在koa2上的封装\n- egg有controller、service、router\n- egg约定了文件目录结构\n\n## 什么是模版引擎？\n> 模板引擎是一个通过结合页面模板、要展示的数据生成HTML页面的工具，本质上是后端渲染（SSR）的需求，加上Node渲染页面本身是纯静态的，当我们需要页面多样化、更灵活，我们就需要使用模板引擎来强化页面，更好的凸显服务端渲染的优势。\n\n常见主流模版引擎有：\n\n- art-template [官方文档](http://aui.github.io/art-template/) ：号称效率最高的，模版引擎\n- ejs  [官方文档](https://ejs.co/)：是一个JavaScript模板库，用来从JSON数据中生成HTML字符串。\n- pug [官方文档](https://pugjs.org/api/getting-started.html)：是一款健壮、灵活、功能丰富的模板引擎，专门为 Node.js 平台开发\n\n[Node.js入门教程](https://github.com/cosyer/node-learn)\n","tags":["NodeJS"],"categories":["Node"]},{"title":"react SSR教程","url":"%2F2020%2Freact%20SSR%E6%95%99%E7%A8%8B.html","content":"\n# 前言\n\n本文是基于react ssr的入门教程，在实际项目中使用还需要做更多的配置和优化，比较适合第一次尝试react ssr的小伙伴们。技术涉及到 koa2 + react，案例使用create-react-app创建。\n\n## 客户端渲染与服务端渲染\n\n### 客户端渲染\n+ 客户端渲染，实际上就是客户端向服务端请求页面，服务端返回的是一个非常简单的 HTML 页面，在这个页面里，只有很少的一些 HTML 标签\n+ 客户端渲染时，页面中有两个比较重要的点，第一个是 script 标签，可能会有好几个 script 标签，这个标签是打包后的 js 代码，用来生成 DOM 元素，发送请求，事件绑定等。但是，生成的 DOM 元素需要有一个在页面上展示的容器，所以另外一个点就是容器，一般是一个 id 名为 root 或 app 的 div 标签，类似于这样 `<div id=\"root\"></div>` 或`<div id=\"app\"></div>`\n+ 客户端渲染的特点\n  + 客户端加载所有的 js 资源，渲染 DOM 元素\n  + 在浏览器页面上的所有资源，都由客户端主动去获取，服务端只负责静态资源的提供和 API 接口，不再负责页面的渲染，如果采用 CDN 的话，服务端仅仅需要提供 API 接口\n  + 优点: 前后端分离，责任区分，前端专注页面的开发，后端专注接口的开发\n  + 缺点: 首屏加载资源多，首屏加载时响应慢。页面上没有 DOM 元素，不利于 SEO 优化\n\n### 服务端渲染\n+ 服务端渲染，就是客户端页面上的 HTML 元素，都要由服务端负责渲染。服务端利用模板引擎，把数据填充到模板中，生成 HTML 字符串，最终把 HTML 字符串返回到浏览器，浏览器接收到 HTML 字符串，通过 HTML 引擎解析，最终生成 DOM 元素，显示在页面上\n+ 比如 Node.js 可以渲染的模板引擎有 ejs，nunjucks，pug 等。Java 最常见的是 JSP 模板引擎。Python 最常见的是 Jinja2 模板引擎。\n+ 服务端渲染的特点\n  + 优点: 页面资源大多由服务端负责处理，所以页面加载速度快，缩短首屏加载时间。有利于 SEO 优化。无需占用客户端资源\n  + 缺点: 不利于前后端分离，开发效率低。占用服务器资源\n\n### 区分与选择\n+ 客户端渲染和服务端渲染本质的区别就是，是谁负责 HTML 页面的拼接，那么就是谁渲染的页面\n+ 如果对首屏加载时间有非常高的需求，或者是需要 SEO 优化，那么就选择服务端渲染\n+ 如果对首屏加载时间没有要求，也不需要做 SEO 优化，类似于做后台管理系列的业务，那么就可以选择客户端渲染\n+ 具体选择客户端渲染还是服务端渲染，没有强制的要求，具体要根据项目的需求来区分选择\n\n---\n<!--more-->\n\n## SSR 介绍\nServer Slide Rendering，缩写为 **ssr** 即服务器端渲染，这个要从SEO说起，目前react单页应用HTML代码是下面这样的\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"shortcut icon\" href=\"favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"/>\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <title>React App</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\"></div>\n    <script src=\"/js/main.js\"></script>\n  </body>\n</html>\n```\n1. 如果main.js 加载比较慢，会出现白屏一闪的现象。\n2. 传统的搜索引擎爬虫因为不能抓取JS生成后的内容，遇到单页web项目，抓取到的内容啥也没有。在SEO上会吃很多亏，很难排搜索引擎到前面去。\nReact SSR（react服务器渲染）正好解决了这2个问题。\n\n## React SSR介绍\n\n这里通过一个例子来带大家入坑！先使用create-react-app创建一个react项目。因为要修改webpack，这里我们使用react-app-rewired启动项目。根目录创建一个server目录存放服务端代码，服务端代码我们这里使用koa2。\n\n这里先来看看react ssr是怎么工作的。\n\n![图片描述][1]\n\n这个业务流程图比较清晰了，服务端只生成HTML代码，实际上前端会生成一份main.js提供给服务端的HTML使用。这就是react ssr的工作流程。有了这个图会更好的理解，如果这个业务没理解清楚，后面的估计很难理解。\n\n> react提供的SSR方法有两个renderToString 和 renderToStaticMarkup，区别如下：\n\n- renderToString 方法渲染的时候带有 data-reactid 属性. 在浏览器访问页面的时候，main.js能识别到HTML的内容，不会执行React.createElement二次创建DOM。\n- renderToStaticMarkup 则没有 data-reactid 属性，页面看上去干净点。在浏览器访问页面的时候，main.js不能识别到HTML内容，会执行main.js里面的React.createElement方法重新创建DOM。适用于纯静态页面。\n\n## 实现流程\n\n```javascript\nimport \"./App.css\";\n\nimport React, { Component } from \"react\";\n\nimport logo from \"./logo.svg\";\n\nclass App extends Component {\n  componentDidMount() {\n    console.log('哈哈哈~ 服务器渲染成功了！');\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <img src={logo} className=\"App-logo\" alt=\"logo\" />\n          <p>\n            Edit <code>src/App.js</code> and save to reload.\n          </p>\n          <a\n            className=\"App-link\"\n            href=\"https://reactjs.org\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Learn React\n          </a>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n在项目中新建server目录，用于存放服务端代码。项目中我们用的ES6，所以还要配置下.babelrc\n\n> .babelrc 配置，因为要使用到ES6\n```json\n{\n    \"presets\": [\n        \"env\",\n        \"react\"\n    ],\n    \"plugins\": [\n        \"transform-decorators-legacy\",\n        \"transform-runtime\",\n        \"react-hot-loader/babel\",\n        \"add-module-exports\",\n        \"transform-object-rest-spread\",\n        \"transform-class-properties\",\n        [\n            \"import\",\n            {\n                \"libraryName\": \"antd\",\n                \"style\": true\n            }\n        ]\n    ]\n}\n```\n\n> index.js 项目入口做一些预处理，使用asset-require-hook过滤掉一些类似 ```import logo from \"./logo.svg\";``` 这样的资源代码。因为我们服务端只需要纯的HTML代码，不过滤掉会报错。这里的name，我们是去掉了hash值的。\n\n```javascript\nrequire(\"asset-require-hook\")({\n  extensions: [\"svg\", \"css\", \"less\", \"jpg\", \"png\", \"gif\"],\n  name: '/static/media/[name].[ext]'\n});\nrequire(\"babel-core/register\")();\nrequire(\"babel-polyfill\");\nrequire(\"./app\");\n```\n\n> public/index.html html模版代码要做个调整，```{{root}}``` 这个可以是任何可以替换的字符串，等下服务端会替换这段字符串。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"/>\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n    <title>React App</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\">{{root}}</div>\n  </body>\n</html>\n\n```\n\n> app.js 服务端渲染的主要代码，加载App.js，使用renderToString 生成html代码，去替换掉 index.html 中的 ```{{root}}``` 部分\n\n```javascript\nimport App from '../src/App';\nimport Koa from 'koa';\nimport React from 'react';\nimport Router from 'koa-router';\nimport fs from 'fs';\nimport koaStatic from 'koa-static';\nimport path from 'path';\nimport { renderToString } from 'react-dom/server';\n\n// 配置文件\nconst config = {\n  port: 3030\n};\n\n// 实例化 koa\nconst app = new Koa();\n\n// 静态资源\napp.use(\n  koaStatic(path.join(__dirname, '../build'), {\n    maxage: 365 * 24 * 60 * 1000,\n    index: 'root' \n    // 这里配置不要写成'index'就可以了，因为在访问localhost:3030时，不能让服务默认去加载index.html文件，这里很容易掉进坑。\n  })\n);\n\n// 设置路由\napp.use(\n  new Router()\n    .get('*', async (ctx, next) => {\n      ctx.response.type = 'html'; //指定content type\n      let shtml = '';\n      await new Promise((resolve, reject) => {\n        fs.readFile(path.join(__dirname, '../build/index.html'), 'utfa8', function(err, data) {\n          if (err) {\n            reject();\n            return console.log(err);\n          }\n          shtml = data;\n          resolve();\n        });\n      });\n      // 替换掉 {{root}} 为我们生成后的HTML\n      ctx.response.body = shtml.replace('{{root}}', renderToString(<App />));\n    })\n    .routes()\n);\n\napp.listen(config.port, function() {\n  console.log('服务器启动，监听 port： ' + config.port + '  running~');\n});\n\n```\n\n> config-overrides.js 因为我们用的是create-react-app，这里使用react-app-rewired去改下webpack的配置。因为执行**npm run build**的时候会自动给资源加了hash值，而这个hash值，我们在asset-require-hook的时候去掉了hash值，配置里面需要改下，不然会出现图片不显示的问题，这里也是一个坑，要注意下。\n\n```javascript\nmodule.exports = {\n  webpack: function(config, env) {\n    // ...add your webpack config\n    // console.log(JSON.stringify(config));\n    // 去掉hash值，解决asset-require-hook资源问题\n    config.module.rules.forEach(d => {\n      d.oneOf &&\n        d.oneOf.forEach(e => {\n          if (e && e.options && e.options.name) {\n            e.options.name = e.options.name.replace('[hash:8].', '');\n          }\n        });\n    });\n    return config;\n  }\n};\n\n```\n\n好了，所有的代码就这些了，是不是很简单了？我们koa2读取的静态资源是 build目录下面的。先执行**npm run build**打包项目，再执行**node ./server** 启动服务端项目。看下\nhttp://localhost:3030 页面的HTML代码检查下：\n\n![图片描述][2]\n\n没有```{{root}}```了，服务器渲染成功！\n\n> 注: 这个项目只是用来学习 react 的服务端渲染，而非安利大家一定要使用服务端渲染，因为 react 和 vue 的服务端渲染和普通的服务端渲染有很多的不一样，所以可以学习一下，提高一下自己的水平。\n\n## 代码仓库地址\n[react-koa2-ssr](https://github.com/cosyer/react-koa2-ssr)\n\n[1]: http://cdn.mydearest.cn/blog/images/react-ssr.png\n[2]: http://cdn.mydearest.cn/blog/images/react-ssr-demo.png\n","tags":["解决方案"],"categories":["React"]},{"title":"Docker","url":"%2F2020%2FDocker.html","content":"\nDocker，是一款现在最流行的 软件容器平台，提供了软件运行时所依赖的环境。\n\n## 物理机\n硬件环境，真实的 计算机实体，包含了例如物理内存，硬盘等等硬件；\n\n## 虚拟机:\n在物理机上 模拟出一套硬件环境和操作系统，应用软件可以运行于其中，并且毫无感知，是一套隔离的完整环境。本质上，它只是物理机上的一份运行文件。\n\n## 为什么需要虚拟机？\n\n### 环境配置与迁移\n在软件开发和运行中，环境依赖一直是一个很头疼的难题，比如你想运行 node 应用，那至少环境得安装 node 吧，而且不同版本，不同系统都会影响运行。解决的办法就是我们的包装包中直接包含运行环境的安装，让同一份环境可以快速复制到任意一台物理机上。\n\n### 资源利用率与隔离\n通过硬件模拟，并包含一套完整的操作系统，应用可以独立运行在虚拟机中，与外界隔离。并且可以在同一台物理机上，开启多个不同的虚拟机启动服务，即一台服务器，提供多套服务，且资源完全相互隔离，互不影响。不仅能更好提高资源利用率率，降低成本，而且也有利于服务的稳定性。\n\n### 传统虚拟机的缺点\n\n#### 资源占用大\n由于虚拟机是模拟出一套完整系统，包含众多系统级别的文件和库，运行也需要占用一部分资源，单单启动一个空的虚拟机，可能就要占用 100+MB 的内存了。\n \n#### 启动缓慢\n同样是由于完整系统，在启动过程中就需要运行各种系统应用和步骤，也就是跟我们平时启动电脑一样的耗时。\n\n#### 冗余步骤多\n系统有许多内置的系统操作，例如用户登录，系统检查等等，有些场景其实我们要的只是一个隔离的环境，其实也就是说，虚拟机对部分需求痛点来说，其实是有点过重的。\n\n## Linux 容器\nLinux 中的一项虚拟化技术，称为 Linux 容器技术(LXC)。它在进程层面模拟出一套隔离的环境配置，但并没有模拟硬件和完整的操作系统。因此它完全规避了传统虚拟机的缺点，在启动速度，资源利用上远远优于虚拟机；\n\n---\n<!--more-->\n\n## Docker\n\nDocker 就是基于 Linux 容器的一种上层封装，提供了更为简单易用的 API 用于操作 Docker，属于一种`容器解决方案`。\n基本概念: 在 Docker 中，有三个核心的概念:\n\n### 镜像 (Image):\n\n1. 从原理上说，镜像属于一种`root 文件系统`，包含了一些系统文件和环境配置等，可以将其理解成一套`最小操作系统`。为了让镜像轻量化和可移植，Docker 采用了`Union FS 的分层存储模式`。将文件系统分成一层一层的结构，逐步从底层往上层构建，每层文件都可以进行继承和定制。这里从前端的角度来理解:`镜像就类似于代码中的 class，可以通过继承与上层封装进行复用`。\n2. 从外层系统看来，一个镜像就是一个 Image`二进制文件`，可以任意迁移，删除，添加；\n\n### 容器 (Container):\n\n1. 镜像是一份静态文件系统，无法进行运行时操作，就如class，如果我们不进行实例化时，便无法进行操作和使用。因此`容器可以理解成镜像的实例`，即`new 镜像()`，这样我们便可以创建、修改、操作容器；一旦创建后，就可以简单理解成一个轻量级的操作系统，可以在内部进行各种操作，例如运行 node 应用，拉取 git 等；\n2. 基于镜像的分层结构，容器是`以镜像为基础底层`，在上面封装了一层`容器的存储层`；\n\n- 存储空间的生命周期与容器一致；\n- 该层存储层会随着容器的销毁而销毁；\n- 尽量避免往容器层写入数据；\n\n3. 容器中的数据的持久化管理主要由两种方式:\n\n- 数据卷 (Volume): 一种可以在多个容器间共享的特殊目录，其处于容器外层，并不会随着容器销毁而删除；\n- 挂载主机目录: 直接将一个主机目录挂载到容器中进行写入；\n\n### 仓库 (Repository):\n\n1. 为了便于镜像的使用，Docker 提供了类似于 git 的仓库机制，在仓库中包含着各种各样版本的镜像。官方服务是 Docker Hub；\n2. 可以快速地从仓库中拉取各种类型的镜像，也可以基于某些镜像进行自定义，甚至发布到仓库供社区使用；\n\n### 安装\n- linux\n> curl -sSL https://get.docker.com/ | sh或者wget -qO- https://get.docker.com/ | sh\n\n```bash\ncurl https://get.docker.com/ > install-docker.sh # 下载安装脚本\nsh install-docker.sh # 执行安装脚本\n```\n\n- Mac\nhttps://download.docker.com/mac/stable/Docker.dmg\n\n- windows\nhttps://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe\n\n### 第一个 docker 项目\n接下来我们搭建一个能够托管静态文件的 Nginx 服务器，容器运行程序，而容器哪来的呢？容器是镜像创建出来的。那镜像又是哪来的呢？\n\n镜像是通过一个 Dockerfile 打包来的，它非常像我们前端的package.json文件。\n\n```\nDockerfile: 类似于“package.json”\n |\n V\nImage: 类似于“Win7纯净版.rar”\n |\n V\nContainer: 一个完整操作系统\n```\n\n#### 创建文件\n```\nhello-docker\n  |____index.html\n  |____Dockerfile\n```\n- index.html\n```html\n<h1>Hello docker</h1>\n```\n\n- Dockerfile\n```\nFROM nginx\n\nCOPY ./index.html /usr/share/nginx/html/index.html\n\nEXPOSE 80\n```\n\n#### 打包镜像\n```bash\ncd hello-docker/ # 进入刚刚的目录\ndocker image build ./ -t hello-docker:1.0.0 # 打包镜像\n```\n此时遇到问题`Docker 安装后 报 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? `\n\n```bash\nsystemctl daemon-reload\nsudo service docker restart\nsudo service docker status (should see active (running))\n```\n然后重新运行 `docker image build ./ -t hello-docker:1.0.0` 命令。这条命令的意思是基于路径./（当前路径）打包一个镜像，镜像的名字是hello-docker，版本号是1.0.0。该命令会自动寻找\nDockerfile来打包出一个镜像。\n\n解读下Dockerfile的内容：\n- FROM nginx：基于哪个镜像\n- COPY ./index.html /usr/share/nginx/html/index.html：将宿主机中的./index.html文件复制进容器里的/usr/share/nginx/html/index.html\n- EXPOSE 80：容器对外暴露80端口\n\n> 注意！Docker 中的选项（Options）放的位置非常有讲究，docker --help image和docker image --help是完全不同的命令\n\n#### 配置国内镜像源\n在 Linux 环境下，我们可以通过修改 /etc/docker/daemon.json ( 如果文件不存在，你可以直接创建它 ) 这个 Docker 服务的配置文件达到效果。\n- Docker中国官方镜像加速\n```\n{\n    \"registry-mirrors\": [\n        \"https://registry.docker-cn.com\"\n    ]\n}\n```\n- 网易163镜像加速\n```\n{\n  \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]\n}\n```\n- 中科大镜像加速\n```\n{\n    \"registry-mirrors\": [\"https://docker.mirrors.ustc.edu.cn\"]     \n}\n```\n- 直接下载站点镜像\n> docker pull hub.c.163.com/library/tomcat:latest  //复制站点链接用 pull 下来\n\n然后重启 docker 让配置生效\n```bash\nsudo systemctl restart docker\n```\n\n通过 docker info 来查阅当前注册的镜像源列表，验证我们配置的镜像源是否生效\n```bash\nsudo docker info\n```\n\n#### 运行容器\n```bash\ndocker container create -p 9000:80 hello-docker:1.0.0 # 根据镜像创建容器\ndocker container start xxx # xxx 为上一条命令运行得到的结果\n```\n\n然后在浏览器打开ip:9000，就能刚刚自己写的index.html内容。\n\n在上边第一个命令中，我们使用docker container create来创建基于hello-docker:1.0.0镜像的一个容器，使用-p来指定端口绑定——将容器中的80端口绑定在宿主机的2333端口。执行完该命令，会返回一个容ID\n而第二个命令，则是启动这个容器启动后，就能通过访问本机的9000端口来达到访问容器内80端口的效果了\n\n> Tips: 你可以使用docker container ls来查看当前运行的容器\n当容器运行后，可以通过如下命令进入容器内部：\n```bash\ndocker container exec -it xxx /bin/bash # xxx 为容器ID\n```\n\n原理实际上是启动了容器内的/bin/bash，此时你就可以通过bash shell与容器内交互了。就像远程连接了SSH一样\n\n#### 退出容器\n```bash\nexit # 直接退出\n\nCtrl + p + q # 退出不停止\n```\n\n#### 制作镜像\n```bash\ndocker commit -m='message' -a='cosyer' containerId hello-docker:1.0.1\n```\n\n#### DockerFile\n- FROM：这个镜像依赖谁（基础镜像）\n- MAINTAINER：这个镜像是谁写的（维护者的信息）\n- RUN：构建镜像需要运行的命令\n- ADD：步骤：copu 文件，会自动解压\n- WORKDIR：设置当前工作目录\n- VOLUME：设置券，挂载主机目录\n- EXPOSE： 暴露端口\n- CMD：指定这个容器启动的时候要运行的命令 只有最后一个会生效，可被替代\n- ENTRYPOINT：指定这个容器启动的时候要运行的命令，可以追加命令\n- ONBUILD：当构建一个被继承 DockerFile 这个时候就会运行 ONBUILD 的命令，触发指令\n- COPY：类似 ADD 将我们的文件拷贝到镜像中\n- ENV：构建镜像的时候设置环境变量\n\n#### 发布镜像\n- docker login\n- docker tag imageId message\n- docker push imageId\n\n#### 总结\n1. 写一个 Dockerfile\n2. 使用docker image build来将Dockerfile打包成镜像\n3. 使用docker container create来根据镜像创建一个容器\n4. 使用docker container start来启动一个创建好的容器\n\n```bash\n# images\ndocker pull image\ndocker images # 查看所有镜像\ndocker rmi imageId -f # 强制删除镜像\ndocker rmi -f \\$(docker images -aq) # 小技巧删除所有镜像\n\n# container\ndocker ps # 查看运行容器\n-a 列出历史\n-n 列出最近\n-q 只显示编号\ndocker rm containerId # 删除容器\ndocker rmi -f \\$(docker ps -aq) # 小技巧删除所有容器\ndocker start id # 启动容器\ndocker restart id #重启容器\ndocker stop id # 停止当前运行的容器\ndocker kill id # 强制停止当前运行容器\ndocker inspect containerId # 查看容器基本信息\ndocker logs containerId # 查看容器日志\ndocker exec -it containerId /bin/bash # 进入容器\ndocker attach # 本机输入到容器中\ndocker cp 本机路径 容器id:文件路径 # 主机内容拷贝到容器\ndocker cp 容器id:文件路径 本机路径 # 容器拷贝内容到主机\n```\n\n![docker](http://cdn.mydearest.cn/blog/images/docker.png)\n\n```bash\niptables --list | grep DOCKER\n\niptables -t nat -nvL\n\nsysctl net.ipv4.ip_forward  \n\nfirewall-cmd --state\n\nvi /etc/sysctl.conf\n\ndocker rm -f `docker ps -a -q`\n\ndocker inspect my-nginx9|grep IPAddress\n\ndocker container run --name nginxserver -d -p 80:80 nginx\n\n172.17.0.2:80\n```\n\n- 遇到了centos7系统docker 宿主机不能访问容器问题，unbantu系统没问题\n```bash\n#停止docker\nsystemctl stop docker\n#关闭docker0\nip link set dev docker0 down\n#删除docker0网桥\nbrctl delbr docker0\n#防火墙设置,后来发现这一步不用执行可以\niptables -t nat -F POSTROUTING\n#增加docker0 网桥\nbrctl addbr docker0\n#增加网卡\nip addr add 172.16.10.1/24 dev docker0\n#启用网卡\nip link set dev docker0 up\n#重启docker服务\nsystemctl restart docker\n```\n\n#### 三种网络模式\n- bridge(桥接)\n- host(主机模式与宿主机共享网络)\n- none(不配置网络)\n```bash\n# 自定义网络\ndocker network create --driver bridge --subnet 192.168.3.0/16 --gateway 192.168.3.1 mynet\n\n# 查看网络列表\ndocker network ls\n# 删除网络\ndocker neteork rm id\n```\n\n### SPA应用静态站点迁移\n之前的步骤：\n1. 本地`npm run build`打包静态文件\n2. 手动FTP传输到服务器\n3. git push更新github\n\n自动化CI：\n1. 执行git push\n2. 自动检测到 github 有代码更新，自动打包出一个 Docker 镜像\n3. CI 编译完成后，SSH 登录 VPS，删掉现有容器，用新镜像创建一个新容器\n\n好处：\n1. 不必再手动 FTP 上传文件\n2. 当进行修改错别字这样的简单操作时，可以免测。改完直接git push，而不必本地npm run build\n\n#### travis\n免费的CI资源[travis](https://www.travis-ci.org/)，需要在[/hub.docker.com](https://hub.docker.com/)注册账号。\n使用 Github 登录 Travis CI 后，在左边点击+加号添加自己的 Github 仓库后，需要移步到 Setting 为项目添加DOCKER_USERNAME和DOCKER_PASSWORD环境变量。这样保证我们可以秘密的登录 Docker Hub 而\n不被其他人看到自己的密码。\n\n```\nlanguage: node_js\nnode_js:\n  - \"12\"\nservices:\n  - docker\n\nbefore_install:\n  - npm install\n\nscript:\n  - npm run build\n  - echo \"$DOCKER_PASSWORD\" | docker login -u \"$DOCKER_USERNAME\" --password-stdin\n  - docker build -t cosyer/hello-docker:1.0.0 .\n  - docker push cosyer/hello-docker:1.0.0\n```\n\n然后需要添加 Dockerfile 文件来描述如何打包 Docker 镜像。\n按照.travis.yml的命令次序，在打包镜像时，npm run build已经执行过了，项目产出已经有了。不必在 Docker 容器中运行npm install和npm run build之类的，直接复制文件即可：\n\n```\nFROM nginx\n\nCOPY ./dist/ /usr/share/nginx/html/\nCOPY ./vhost.nginx.conf /etc/nginx/conf.d/hello-docker.conf\n\nEXPOSE 80\n```\n将不访问文件的请求全部重定向到/index.html，处理history路由`vhost.nginx.conf`\n```\nserver {\n    listen 80;\n    server_name localhost;\n    location / {\n        root /usr/share/nginx/html;\n        index index.html index.htm;\n        proxy_set_header Host $host;\n\n        if (!-f $request_filename) {\n          rewrite ^.*$ /index.html break;\n        }\n\n    }\n\n    error_page 500 502 503 504 /50x.html;\n    location = /50x.html {\n        root /usr/share/nginx/html;\n    }\n}\n```\n\n### nginx反向代理\n宿主机`/etc/nginx/conf.d/vhost.conf`\n```\nserver {\n    listen 80;\n    server_name pea3nut.info;\n\n    location / {\n        proxy_pass http://127.0.0.1:8082;\n    }\n}\n```\n配置的意思是，监听来自 80 端口的流量，若访问域名是mydearest.cn（替换为你自己的域名），则全部转发到http://127.0.0.1:8082中\n\n### nodejs站点迁移(express)\n之前的步骤：\n1. 本地修改好 Ejs 或者其他文件\n2. 手动通过 FTP 上传到服务器\n3. 在服务器端重启 Nodejs 进程。若有 npm 包依赖改动，需要在VP S服务器上手动执行npm install\n4. git push更新 Github 源码\n\n> Tips: 你可能发现了 Dockerfile 中的ENTRYPOINT命令必须指定一个前台进程。若你的 Nodejs 应用是使用 PM2 进行保护的，你需要替换pm2 start app.js为pm2-docker app.js\n\n### docker-compose  \ndocker-compose 是 Docker 官方提供的一个 Docker 管理工具。\n\ndocker-compose 和 Docker 差不多，也是只要一份文件就能跑起来。docker-compose 主要的作用就是能够让你不必手敲那么多 Docker 命令\n\n- 安装\n```bash\ncurl -L \"https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\n```\n\n- 目录\n建立一个目录，然后在目录中建立docker-compose.yml，内容如下：\n```bash\nversion: \"3.7\" # 这个是配置文件的版本，不同的版本号声明方式会有细微的不同\nservices:\n    info:\n        container_name: hello-docker\n        image: cosyer/hello-docker:1.0.0\n        ports:\n            - \"8082:80\"\n        restart: on-failure\n```\n\n- 启动\n```bash\ndocker-compose up info\n```\ndocker-compose 会帮我们自动去拉镜像，创建容器，将容器中的80端口映射为宿主机的8082端口。restart字段还要求 docker-compose 当发现容器意外挂掉时\n重新启动容器，类似于 pm2，所以你不必再在容器内使用 pm2\n\n如果想要更新一个镜像创建新容器，只需要：\n```bash\ndocker-compose pull info\ndocker-compose stop info\ndocker-compose rm info\ndocker-compose up -d info # -d 代表后台运行\n```\n","tags":["解决方案"],"categories":["工具"]},{"title":"Nginx","url":"%2F2020%2FNginx.html","content":"\n定义：轻量级、高性能的 Web 服务器，在现今的大型应用、网站基本都离不开 Nginx，已经成为了一项必选的技术；其实可以把它理解成 入口网关。\n\n> 当你去银行办理业务时，刚走进银行，需要到入门处的机器排队取号，然后按指令到对应的柜台办理业务，或者也有可能告诉你，今天不能排号了，回家吧！\n> 这样一个场景中，取号机器就是 Nginx(入口网关)。一个个柜台就是我们的业务服务器(办理业务)；银行中的保险箱就是我们的数据库(存取数据)；🤣\n\n![nginx](http://cdn.mydearest.cn/blog/images/nginx.png)\n\n## 特点\n1. 轻量级，配置方便灵活，无侵入性；\n2. 占用内存少，启动快，性能好；\n3. 高并发，事件驱动，异步；\n4. 热部署，修改配置热生效；\n\n---\n<!--more-->\n\n## 架构模型\n- 基于 socket 与 Linux epoll (I/O 事件通知机制)，实现了高并发；\n  - 基于 socket 与 Linux epoll (I/O 事件通知机制)，实现了 高并发；\n  - 磁盘不足的情况，可能会导致阻塞；\n\n- Master-worker 进程模式\n  - Nginx 启动时会在内存中常驻一个 Master 主进程\n    - 读取配置文件\n    - 创建、绑定、关闭 socket\n    - 启动、维护、配置 worker 进程\n    - 编译脚本、打开日志\n  - master 进程会开启配置数量的 worker 进程，比如根据 CPU 核数等\n    - 利用 socket 监听连接，不会新开进程或线程，节约了创建与销毁进程的成本\n    - 检查网络、存储，把新连接加入到轮询队列中，异步处理\n    - 能有效利用 cpu 多核，并避免了线程切换和锁等待\n- 热部署模式\n  - 当我们修改配置热重启后，master 进程会以新的配置新创建 worker 进程，新连接会全部交给新进程处理\n  - 老的 worker 进程会在处理完之前的连接后被 kill 掉，逐步全替换成新配置的 worker 进程\n\n## 配置\n\n### 官网下载\n\n### 配置文件路径： /usr/local/etc/nginx/nginx.conf\n\n### 启动: 终端输入 nginx，访问 localhost:8080 就能看到 Welcome...\n\n### 停止与启动\n```bash\nnginx -s stop: # 停止服务\nnginx -s reload # 热重启服务\n```\n\n### 配置代理\n```bash\nserver {\n    listen 80;\n    location / {\n        proxy_pass http://xxx.xxx.xx.xx:3000;\n    }\n}\n```\n\n## 常用场景\n### 代理\n其实 Nginx 可以算一层 代理服务器，将客户端的请求处理一层后，再转发到业务服务器，这里可以分成两种类型，其实实质就是请求的转发，使用 Nginx 非常合适、高效；\n\n### 正向代理(VPN)\n\n- 即用户通过访问这层正向代理服务器，再由代理服务器去到原始服务器请求内容后，再返回给用户；\n- 例如我们常使用的 VPN 就是一种常见的正向代理模式。通常我们无法直接访问谷歌服务器，但是通过访问一台国外的服务器，再由这台服务器去请求谷歌返回给用户，用户即可访问谷歌；\n\n#### 特点\n1. 代理服务器属于`客户端层`，称之为正向代理；\n2. 代理服务器是`为用户服务`，对于用户是透明的，用户知道自己访问代理服务器；\n3. 对内容服务器来说是隐藏的，内容服务器并无法分清访问是来自用户或者代理；\n\n![forward-agent](http://cdn.mydearest.cn/blog/images/forward-agent.png)\n\n### 反向代理(Nginx)\n\n- 用户访问头条的反向代理网关，通过网关的一层处理和调度后，再由网关将访问转发到内部的服务器上，返回内容给用户；\n\n#### 特点\n1. 代理服务器属于`服务端层`，因此称为反向代理。通常代理服务器与内部内容服务器会隶属于同一内网或者集群；\n2. 代理服务器是`为内容服务器`服务的，对用户是隐藏的，用户不清楚自己访问的具体是哪台内部服务器；\n\n![reverse-proxy](http://cdn.mydearest.cn/blog/images/reverse-proxy.png)\n\n#### 反向代理的好处:\n\n1. 安全与权限:\n用户访问必须通过反向代理服务器，也就是便可以在做这层做统一的请求校验，过滤拦截不合法、危险的请求，从而就能更好的保证服务器的安全与稳定；\n\n2. 负载均衡: 能有效分配流量，最大化集群的稳定性，保证用户的访问质量；\n\n##### 负载均衡\n- 负载均衡是基于反向代理下实现的一种 流量分配 功能，目的是为了达到服务器资源的充分利用，以及更快的访问响应；\n\n- 其实很好理解，还是以上面银行的例子来看: 通过门口的取号器，系统就可以根据每个柜台的业务排队情况进行用户的分配，使每个柜台都保持在一个比较高效的运作状态，避免出现分配不均的情况；\n\n- 由于用户并不知道内部服务器中的队列情况，而反向代理服务器是清楚的，因此通过Nginx，便能很简单地实现流量的均衡分配；\n\n- Nginx 实现: Upstream模块，这样当用户访问 http://xxx 时，流量便会被按照一定的规则分配到upstream中的3台服务器上；\n\n```js\nhttp {\n    upstream xxx {\n        server 1.1.1.1:3001;\n        server 2.2.2.2:3001;\n        server 3.3.3.3:3001;\n    }\n    server {\n        listen 8080;\n        location / {\n            proxy_pass http://xxx;\n        }\n    }\n}\n```\n- 分配的策略\n  - 分配的权重(weight)\n  ```js\n  upstream xxx {\n    server 1.1.1.1:3001 weight=1;\n    server 2.2.2.2:3001 weight=1;\n    server 3.3.3.3:3001 weight=8;\n  }\n  ```\n  - 时间顺序(默认): 按用户的访问的顺序逐一的分配到正常运行的服务器上；\n  - 连接数优先(least_conn): 优先将访问分配到列表中连接数队列最短的服务器上；\n  - 响应时间优先(fair): 优先将访问分配到列表中访问响应时间最短的服务器上；\n  - ip_hash: 通过 ip_hash 指定，使每个 ip 用户都访问固定的服务器上，有利于用户特异性数据的缓存，例如本地 session 服务等\n  - url_hash: 通过 url_hash 指定，使每个 url 都分配到固定的服务器上，有利于缓存；\n\n## Nginx 对于前端的作用\n1. 快速配置静态服务器(当访问 localhost:80 时，就会默认访问到 /Users/files/index.html)\n```js\nserver {\n\tlisten 80;                                                         \n\tserver_name localhost;                                               \n\t\t\n\tlocation / {\n\t\troot   /Users/files;\n\t\tindex  index.html;\n\t}\n}\n```\n\n2. 访问限制(可以制定一系列的规则进行访问的控制，例如直接通过 ip 限制)\n```bash\n# 屏蔽 192.168.1.1 的访问；\n# 允许 192.168.1.2 ~ 10 的访问；\nlocation / {\n    deny  192.168.1.1;\n    allow 192.168.1.2/10;\n    deny  all;\n}\n```\n\n3. 解决跨域(其实跨域是浏览器的安全策略，这意味着只要不是通过浏览器，就可以绕开跨域的问题。所以只要通过在同域下启动一个 Nginx 服务，转发请求即可)\n```bash\nlocation ^~/api/ {\n\t# 重写请求并代理到对应域名下\n  rewrite ^/api/(.*)$ /$1 break;\n  proxy_pass https://www.cross-target.com/;\n}\n```\n\n4. 图片处理(通过 ngx_http_image_filter_module 这个模块，可以作为一层图片服务器的代理，在访问的时候 对图片进行特定的操作，例如裁剪，旋转，压缩等)\n\n5. 本地代理，绕过白名单限制\n\n- 例如我们在接入一些第三方服务时经常会有一些域名白名单的限制，如果我们在本地通过localhost进行开发，便无法完成功能。这里我们可以做一层本地代理，便可以直接通过指定域名访问本地开发环境；\n\n```js\nserver {\nlisten 80;\nserver_name www.toutiao.com;\n\n// server_name xxxx.cn xxxx.xxxx.cn;\n// rewrite ^/(.*) https://xxx.xxxx.cn permanent; #跳转到Https\n\nlocation / {\n    proxy_pass http://localhost:3000;\n  }\n}\n```\n","tags":["解决方案"],"categories":["工具"]},{"title":"Hybrid混合方案","url":"%2F2020%2FHybrid.html","content":"\n随着 Web技术 和 移动设备 的快速发展，在各家大厂中，Hybrid 技术已经成为一种最主流最不可取代的架构方案之一。一套好的 Hybrid 架构方案能让 App 既能拥有极致的体验和性能，同时也能拥有Web技术灵活的开发模式、跨平台能力以及热更新机制。因此，相关的 Hybrid 领域人才也是十分的吃香，精通Hybrid 技术和相关的实战经验，也是面试中一项大大的加分项。\n\n## 混合方案简析\nHybrid App，俗称 混合应用，即混合了 Native技术 与 Web技术 进行开发的移动应用。现在比较流行的混合方案主要有三种，主要是在UI渲染机制上的不同:\n\n### Webview UI\n\n#### 通过 JSBridge 完成 H5 与 Native 的双向通讯，并 基于 Webview 进行页面的渲染；\n##### 优势: 简单易用，架构门槛/成本较低，适用性与灵活性极强；\n##### Webview 性能局限，在复杂页面中，表现远不如原生页面；\n\n### Native UI\n\n#### 通过 JSBridge 赋予 H5 原生能力，并进一步将 JS 生成的虚拟节点树(Virtual DOM)传递至 Native 层，并使用 原生系统渲染。\n##### 优势: 用户体验基本接近原生，且能发挥 Web技术 开发灵活与易更新的特性；\n##### 上手/改造门槛较高，最好需要掌握一定程度的客户端技术。相比于常规Web开发，需要更高的开发调试、问题排查成本；\n\n\n### 小程序\n\n#### 通过更加定制化的 JSBridge，赋予了 Web 更大的权限，并使用双 WebView 双线程的模式隔离了 JS逻辑 与 UI渲染，形成了特殊的开发模式，加强了 H5 与 Native 混合程度，属于第一种方案的优化版本；\n##### 优势: 用户体验好于常规 Webview 方案，且通常依托的平台也能提供更为友好的开发调试体验以及功能；\n##### 劣势: 需要依托于特定的平台的规范限定\n\n---\n<!--more-->\n\n## Webview\nWebview 是 Native App 中内置的一款基于Webkit内核的浏览器，主要由两部分组成:\n- WebCore 排版引擎\n- JSCore 解析引擎\n\n在原生开发 SDK 中 Webview 被封装成了一个组件，用于作为 Web页面 的容器。因此作为宿主的客户端中拥有更高的权限，可以对 Webview 中的Web页面进行配置和开发。\nHybrid技术中双端的交互原理，便是基于 Webview 的一些 API 和特性。\n\n## 交互原理\nHybrid技术中最核心的点就是Native端与H5端之间的双向通讯层，其实这里也可以理解为我们需要一套跨语言通讯方案，便是我们常听到的JSBridge。\n\n### JavaScript 通知 Native\n1. API注入，Native 直接在 JS 上下文中挂载数据或者方法\n\n延迟较低，在安卓4.1以下具有安全性问题，风险较高\n\n2. WebView URL Scheme 跳转拦截\n\n兼容性好，但延迟较高，且有长度限制\n\n3. WebView 中的 prompt/console/alert拦截(通常使用 prompt)\n\n### Native 通知 Javascript\n1. IOS: stringByEvaluatingJavaScriptFromString\n```js\n// Swift\nwebview.stringByEvaluatingJavaScriptFromString(\"alert('NativeCall')\")\n```\n\n2. Android: loadUrl (4.4-)\n```js\n// 调用js中的JSBridge.trigger方法\n// 该方法的弊端是无法获取函数返回值；\nwebView.loadUrl(\"javascript:JSBridge.trigger('NativeCall')\")\n```\n\n3. Android: evaluateJavascript (4.4+)\n```js\n// 4.4+后使用该方法便可调用并获取函数返回值；\nmWebView.evaluateJavascript（\"javascript:JSBridge.trigger('NativeCall')\", new ValueCallback<String>() {\n    @Override\n    public void onReceiveValue(String value) {\n        //此处为 js 返回的结果\n    }\n});\n```\n\n## 接入方案\n整套方案需要 Web 与 Native 两部分共同来完成:\n\n- Native: 负责实现URL拦截与解析、环境信息的注入、拓展功能的映射、版本更新等功能；\n- JavaScirpt: 负责实现功能协议的拼装、协议的发送、参数的传递、回调等一系列基础功能。\n\n接入方式:\n- 在线H5: 直接将项目部署于线上服务器，并由客户端在 HTML 头部注入对应的 Bridge。\n  - 优势: 接入/开发成本低，对 App 的侵入小；\n  - 劣势: 重度依赖网络，无法离线使用，首屏加载慢；\n\n- 内置离线包: 将代码直接内置于 App 中，即本地存储中，可由 H5 或者 客户端引用 Bridge。\n  - 优势: 首屏加载快，可离线化使用；\n  - 劣势: 开发、调试成本变高，需要多端合作，且会增加 App 包体积\n\n## 5. 优化方案简述\n- Webview 预加载: Webview 的初始化其实挺耗时的。我们测试过，大概在100~200ms之间，因此如果能前置做好初始化于内存中，会大大加快渲染速度。\n- 更新机制: 使用离线包的时候，便会涉及到本地离线代码的更新问题，因此需要建立一套云端下发包的机制，由客户端下载云端最新代码包 (zip包)，并解压替换本地代码。\n  - 增量更新: 由于下发包是一个下载的过程，因此包的体积越小，下载速度越快，流量损耗越低。只打包改变的文件，客户端下载后覆盖式替换，能大大减小每次更新包的体积。   \n  - 条件分发: 云平台下发更新包时，可以配合客户端设置一系列的条件与规则，从而实现代码的条件更新:\n      - 单 地区 更新: 例如一个只有中国地区才能更新的版本；\n      - 按 语言 更新: 例如只有中文版本会更新；\n      - 按 App 版本 更新: 例如只有最新版本的 App 才会更新；\n      - 灰度 更新: 只有小比例用户会更新；\n      - AB测试: 只有命中的用户会更新；\n- 降级机制: 当用户下载或解压代码包失败时，需要有套降级方案，通常有两种做法:\n\n  - 本地内置: 随着 App 打包时内置一份线上最新完整代码包，保证本地代码文件的存在，资源加载均使用本地化路径；\n  - 域名拦截: 资源加载使用线上域名，通过拦截域名映射到本地路径。当本地不存在时，则请求线上文件，当存在时，直接加载；\n\n- 跨平台部署: Bridge层 可以做一套浏览器适配，在一些无法适配的功能，做好降级处理，从而保证代码在任何环境的可用性，一套代码可同时运行于 App内 与 普通浏览器；\n-环境系统: 与客户端进行统一配合，搭建出 正式 / 预上线 / 测试 / 开发环境，能大大提高项目稳定性与问题排查；\n- 开发模式:\n  - 能连接PC Chrome/safari 进行代码调试；\n  - 具有开发调试入口，可以使用同样的 Webview 加载开发时的本地代码；\n  - 具备日志系统，可以查看 Log 信息；\n","tags":["解决方案"],"categories":["工具"]},{"title":"如何在 create-react-app 中使用 CSS Modules","url":"%2F2020%2F%E5%A6%82%E4%BD%95%E5%9C%A8%20create-react-app%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20CSS%20Modules.html","content":"\n先简单了解下什么是 [CSS Modules](https://github.com/css-modules/css-modules)\n\n> A CSS Module is a CSS file in which all class names and animation names are scoped locally by default\n\n简单点说 CSS Module 是具有局部作用域的 css 文件。既然提到了局部作用域，那么肯定有全局作用域，在 create-react-app 中，我们引入 css 文件通常为以下形式：\n\n```css\n/* index.css */\n.color {\n  color: red;\n}\n```\n\n```js\n/* index.tsx */\nimport React, { Component } from 'react'\nimport './index.css'\n\nexport default class Index extends Component {\n  // ...\n}\n```\n\n---\n<!--more-->\n\n## 全局污染和错误覆盖\n\n这种引入方法就会出现全局污染的问题，CSS 使用全局选择器机制来设置样式，优点是方便重写样式，缺点是所有的样式都是全局生效，样式可能被错误覆盖。假定一个页面有以下两个组件：\n\n- <Header />，内容如下：\n```js\nimport React, { Component } from 'react'\nimport './header.css'\n\nexport default class Index extends Component {\n  // ...\n  render() {\n    return <div className=\"color\">Header color</div>\n  }\n}\n```\n\n- header.css\n```css\n.color {\n  color: red;\n}\n```\n\n- <Content />, 内容如下：\n```js\nimport React, { Component } from 'react'\nimport './content.css'\n\nexport default class Index extends Component {\n  // ...\n  render() {\n    return <div className=\"color\">Content color</div>\n  }\n}\n```\n\n- content.css\n```css\n.color {\n  color: green;\n}\n```\n\n我们期待在页面上 Header color 的字的颜色为 red，Content color 为 green，但实际上是两个都为 green，这就是因为我们直接引入 header.css 和 content.css 后，样式拥有全局作用域，而相同的样式又可能出现错误地覆盖，因此就出现了上面的情况。\n\n避免这种情况在 create-react-app 的方法就是使用 CSS Modules，使用方法就是将对应的 css 文件名称命名为 [name].module.css 的形式（使用 less 或者 sass 类似），以 Header 组件为例，修改如下：\n```css\n/* header.module.css */\n.color {\n  color: red;\n}\n```\n\n```js\nimport React, { Component } from 'react'\nimport headerStyle from './header.module.css'\n\nexport default class Index extends Component {\n  // ...\n  render() {\n    return <div className={headerStyle.color}>Header color</div>\n  }\n}\n```\n\n这样 Header color 的颜色就会为 red。\n\n它的实现过程就是利用 Webpack 的 css-loader 生成（基本）唯一的 class 名称，在 create-react-app 中会以 [filename]_[classname]__[hash] 的命名规则来生成 class 名称，例如 Header 组件生成后的 html 如下：\n```html\n<div class=\"header_color__2Oqjl\">Header color</div>\n```\n\n使用了 CSS Modules 后，就相当于给每个 class 名外加加了一个 :local，以此来实现样式的局部化，如果你想切换到全局模式，使用对应的 :global。:local 与 :global 的区别是 CSS Modules 只会对 :local 块的 class 样式做规则处理，:global 的样式编译后不变。\n\n```css\n.color {\n  color: red\n}\n\n/* 以上与下面等价 */\n:local(.color) {\n  color: red; \n}\n\n/* 定义全局样式 */\n:global(.global-bg) {\n  background-color: red;\n}\n```\n\n## composes处理复用\n在开发中会遇到样式的复用问题，CSS Modules 只提供了唯一的方式来处理：`composes` 组合:\n\n```css\n/* 基础样式 */\n.base {\n  font-size: 20px;\n  color: #82D7F7\n}\n\n.active {\n  composes: base;\n  /* 组合外部文件 */\n  composes: bold from './content.module.css';\n  /* active 其他样式 */\n  text-decoration: underline;\n}\n```\n\n在 active 中 composes base，编译后会 active 会变成三个 class\n```html\n<div class=\"composes-demo_active__27azZ composes-demo_base__MLJCB content_bold__vgYTg\">active</div>\n```\n\n## 总结\n在 create-react-app 中使用 CSS Modules 会频繁的输入 styles.**，可以使用 [react-css-modules](https://github.com/gajus/react-css-modules)来避免这点，它通过高阶函数的形式来避免重复输入 styles.**。\n\n栗子↓\n```js\nimport React from 'react';\nimport CSSModules from 'react-css-modules';\nimport styles from './table.css';\n\nclass Table extends React.Component {\n    render () {\n        return <div styleName='table'>\n            <div styleName='row'>\n                <div styleName='cell'>A0</div>\n                <div styleName='cell'>B0</div>\n            </div>\n        </div>;\n    }\n}\nexport default CSSModules(Table, styles);\n```\n\n有兴趣的同学可以参考模拟下`react-css-modules`的实现。\n\n总的来说在 create-react-app 中使用 CSS Modules 还是比较容易，如果还没有在项目中尝试的话非常值得去使用 CSS Modules👏👏👏。\n","tags":["性能优化"],"categories":["JS"]},{"title":"TypeScript 中，interface 和 type 的区别","url":"%2F2020%2FTypeScript%20%E4%B8%AD%EF%BC%8Cinterface%20%E5%92%8C%20type%20%E7%9A%84%E5%8C%BA%E5%88%AB.html","content":"\n在 `TypeScript` 中，`interface` 和 `type` 主要用于类型的声明，它们的相同点以及区别如下：\n\n---\n<!--more-->\n\n## 相同点\n\n### 都可以描述一个对象或者函数\n```js\n/* interface */\ninterface User {\n  name: string\n  age: number\n}\n\ninterface SetUser {\n  (name: string, age: number): string\n}\n```\n\n```js\n/* type */\ntype User = {\n  name: string\n  age: number\n}\n\ntype SetUser = {\n  (name: string, age: number): string\n}\n```\n\n### 都可以进行拓展\n```js\n/* interface */\ninterface User {\n  name: string\n  age: number\n}\n\ninterface ProUser extends User {\n  email: string\n}\n\ntype VipUserType = {\n  readonly vip: boolean\n}\n\n/* interface 和 type 拓展*/\ninterface VipUserInterfce extends VipUserType {\n  member: boolean\n}\n```\n\n```js\n/* type */\ntype User = {\n  name: string\n  age: number\n}\n\ntype ProUser = User & {\n  email: string\n}\n\ninterface VipUserInterface {\n  readonly vip: boolean\n}\n\n/* type 与 interface 拓展 */\ntype VipUserType = VipUserInterface & {\n  member: boolean\n}\n```\n\n## 区别\n\n### type 可以声明基本类型别名，联合类型，元组类型，而 interface 不可以\n```js\n/* 基本类型 */\ntype Name = string\n\n/* 联合类型 */\ninterface Dog {}\ninterface Cat {}\n\ntype Pet = Dog | Cat\n\n/* 元组类型 */\ntype PetList = [Dog, Cat]\n```\n\n### interface 可以进行类型合并，而 type 不可以\n```js\ninterface Cloner {\n  clone(animal: Animal): Animal\n}\n\ninterface Cloner {\n  clone(animal: Sheep): Sheep\n}\n\ninterface Cloner {\n  clone(animal: Dog): Dog\n  clone(animal: Cat): Cat\n}\n\n// 以上三个 interface 会被合并成一个声明\ninterface Cloner {\n  clone(animal: Dog): Dog\n  clone(animal: Cat): Cat\n  clone(animal: Sheep): Sheep\n  clone(animal: Animal): Animal\n}\n```\n\n[关于 declaration-merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html)\n","tags":["性能优化"],"categories":["JS"]},{"title":"大文件分片上传优化","url":"%2F2020%2F%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E4%BC%98%E5%8C%96.html","content":"\n> 在开发过程中，会遇到在网站上传 100 MB 以上的文件经常失败，重试也要等老半天。那么应该怎么做才能快速上传，就算失败了再次发送也能从上次中断的地方继续上传呢？\n\n## 整体思路\n第一步是结合项目背景，调研比较优化的解决方案。\n文件上传失败是老生常谈的问题，常用方案是将一个大文件切片成多个小文件，并行请求接口进行上传，所有请求得到响应后，在服务器端合并所有的分片文件。当分片上传失败，可以在重新上传时进行判断，只上传上次失败的部分，减少用户的等待时间，缓解服务器压力。这就是分片上传文件。\n\n流程图如下：\n![upload-flow](http://cdn.mydearest.cn/blog/images/upload-flow.png)\n\n---\n<!--more-->\n\n### 文件 MD5 加密\n- MD5 是文件的唯一标识，可以利用文件的 MD5 查询文件的上传状态。\n\n根据文件的修改时间、文件名称、最后修改时间等信息，通过 [spark-md5](https://www.npmjs.com/package/spark-md5) 生成文件的 MD5。需要注意的是，大规格文件需要分片读取文件，将读取的文件内容添加到 通过 [spark-md5](https://www.npmjs.com/package/spark-md5) 的 hash 计算中，直到文件读取完毕，最后返回最终的 hash 码到 callback 回调函数里面。这里可以根据需要添加文件读取的进度条。\n\n```js\nfunction md5File(file) {\n    return new Promise((resolve, reject) => {\n        var blobSlice =\n            File.prototype.slice ||\n            File.prototype.mozSlice ||\n            File.prototype.webkitSlice,\n        chunkSize = file.size / 100, // 分成100份\n        chunks = 100,\n        currentChunk = 0,\n        spark = new SparkMD5.ArrayBuffer(),\n        fileReader = new FileReader();\n\n        fileReader.onload = function (e) {\n        console.log(\"read chunk nr\", currentChunk + 1, \"of\", chunks);\n        spark.append(e.target.result); // Append array buffer\n        currentChunk++;\n\n        if (currentChunk < chunks) {\n            loadNext();\n        } else {\n            let cur = +new Date();\n            console.log(\"finished loading\");\n            // alert(spark.end() + '---' + (cur - pre)); // Compute hash\n            let result = spark.end();\n            resolve(result);\n        }\n        };\n\n        fileReader.onerror = function () {\n        console.warn(\"oops, something went wrong.\");\n        };\n\n        function loadNext() {\n        var start = currentChunk * chunkSize,\n            end =\n            start + chunkSize >= file.size ? file.size : start + chunkSize;\n\n        fileReader.readAsArrayBuffer(blobSlice.call(file, start, end));\n        $(\"#checkProcessStyle\").css({\n            width: currentChunk + 1 + \"%\",\n        });\n        $(\"#checkProcessValue\").html(currentChunk + 1 + \"%\");\n        }\n\n        loadNext();\n    });\n}\n```\n\n### 查询文件状态\n前端得到文件的 MD5 后，从后台查询是否存在名称为 MD5 的文件夹，如果存在，列出文件夹下所有文件，得到已上传的切片列表，如果不存在，则已上传的切片列表为空。\n\n```js\n// 校验文件的MD5\ncheckFileMD5 (file, fileName, fileMd5Value, onError) {\n  const fileSize = file.size\n  const { chunkSize, uploadProgress } = this\n  this.chunks = Math.ceil(fileSize / chunkSize)\n  return new Promise(async (resolve, reject) => {\n    const params = {\n      fileName: fileName,\n      fileMd5Value: fileMd5Value,\n    }\n    const { ok, data } = await services.checkFile(params)\n    if (ok) {\n      this.hasUploaded = data.chunkList.length\n      uploadProgress(file)\n      resolve(data)\n    } else {\n      reject(ok)\n      onError()\n    }\n  })\n}\n```\n\n### 文件分片\n文件上传优化的核心就是文件分片，Blob 对象中的 slice 方法可以对文件进行切割，File 对象是继承 Blob 对象的，因此 File 对象也有 slice 方法。\n定义每一个分片文件的大小变量为 chunkSize，通过文件大小 FileSize 和分片大小 chunkSize 得到分片数量 chunks，使用 for 循环和 file.slice() 方法对文件进行分片，序号为 0 - n，和已上传的切片列表做比对，得到所有未上传的分片，push 到请求列表 requestList。\n\n![chunk](http://cdn.mydearest.cn/blog/images/chunk.png)\n\n```js\nasync checkAndUploadChunk (file, fileMd5Value, chunkList) {\n  let { chunks, upload } = this\n  const requestList = []\n  for (let i = 0; i < chunks; i++) {\n    let exit = chunkList.indexOf(i + '') > -1\n    // 如果已经存在, 则不用再上传当前块\n    if (!exit) {\n      requestList.push(upload(i, fileMd5Value, file))\n    }\n  }\n  console.log({ requestList })\n  const result =\n    requestList.length > 0\n      ? await Promise.all(requestList)\n        .then(result => {\n          console.log({ result })\n          return result.every(i => i.ok)\n        })\n        .catch(err => {\n          return err\n        })\n      : true\n  console.log({ result })\n  return result === true\n}\n```\n\n### 上传分片\n调用 `Promise.all` 并发上传所有的切片，将切片序号、切片文件、文件 `MD5` 传给后台。\n后台接收到上传请求后，首先查看名称为文件 MD5 的文件夹是否存在，不存在则创建文件夹，然后通过 `fs-extra` 的 rename 方法，将切片从临时路径移动切片文件夹中，结果如下：\n\n![file-chunk](http://cdn.mydearest.cn/blog/images/file-chunk.png)\n\n当全部分片上传成功，通知服务端进行合并，当有一个分片上传失败时，提示“上传失败”。在重新上传时，通过文件 MD5 得到文件的上传状态，当服务器已经有该 MD5 对应的切片时，代表该切片已经上传过，无需再次上传，当服务器找不到该 MD5 对应的切片时，代表该切片需要上传，用户只需上传这部分切片，就可以完整上传整个文件，这就是文件的断点续传。\n\n```js\n// 上传chunk\nupload (i, fileMd5Value, file) {\n  const { uploadProgress, chunks } = this\n  return new Promise((resolve, reject) => {\n    let { chunkSize } = this\n    // 构造一个表单，FormData是HTML5新增的\n    let end =\n      (i + 1) * chunkSize >= file.size ? file.size : (i + 1) * chunkSize\n    let form = new FormData()\n    form.append('data', file.slice(i * chunkSize, end)) // file对象的slice方法用于切出文件的一部分\n    form.append('total', chunks) // 总片数\n    form.append('index', i) // 当前是第几片\n    form.append('fileMd5Value', fileMd5Value)\n    services\n      .uploadLarge(form)\n      .then(data => {\n        if (data.ok) {\n          this.hasUploaded++\n          uploadProgress(file)\n        }\n        console.log({ data })\n        resolve(data)\n      })\n      .catch(err => {\n        reject(err)\n      })\n  })\n}\n```\n### 上传进度\n虽然分片批量上传比大文件单次上传会快很多，也还是有一段加载时间，这时应该加上上传进度的提示，实时显示文件上传进度。\n原生 Javascript 的 XMLHttpRequest 有提供 progress 事件，这个事件会返回文件已上传的大小和总大小。项目使用 [axios](https://www.kancloud.cn/yunye/axios/234845) 对 ajax 进行封装，可以在 config 中增加 `onUploadProgress` 方法，监听文件上传进度。\n\n```js\nconst config = {\n  onUploadProgress: progressEvent => {\n    var complete = (progressEvent.loaded / progressEvent.total * 100 | 0) + '%'\n  }\n}\nservices.uploadChunk(form, config)\n```\n\n### 合并分片\n上传完所有文件分片后，前端主动通知服务端进行合并，服务端接受到这个请求时主动合并切片，通过文件 MD5 在服务器的文件上传路径中找到同名文件夹。从上文可知，文件分片是按照分片序号命名的，而分片上传接口是异步的，无法保证服务器接收到的切片是按照请求顺序拼接。所以应该在合并文件夹里的分片文件前，根据文件名进行排序，然后再通过 `concat-files` 合并分片文件，得到用户上传的文件。至此大文件上传就完成了。\n\n![file-merge](http://cdn.mydearest.cn/blog/images/file-merge.png)\n\n```js\n// node\n// 合并文件\nexports.merge = {\n  validate: {\n    query: {\n      fileName: Joi.string()\n        .trim()\n        .required()\n        .description('文件名称'),\n      md5: Joi.string()\n        .trim()\n        .required()\n        .description('文件md5'),\n      size: Joi.string()\n        .trim()\n        .required()\n        .description('文件大小'),\n    },\n  },\n  permission: {\n    roles: ['user'],\n  },\n  async handler (ctx) {\n    const { fileName, md5, size } = ctx.request.query\n    let { name, base: filename, ext } = path.parse(fileName)\n    const newFileName = randomFilename(name, ext)\n    await mergeFiles(path.join(uploadDir, md5), uploadDir, newFileName, size)\n      .then(async () => {\n        const file = {\n          key: newFileName,\n          name: filename,\n          mime_type: mime.getType(`${uploadDir}/${newFileName}`),\n          ext,\n          path: `${uploadDir}/${newFileName}`,\n          provider: 'oss',\n          size,\n          owner: ctx.state.user.id,\n        }\n        const key = encodeURIComponent(file.key)\n          .replace(/%/g, '')\n          .slice(-100)\n        file.url = await uploadLocalFileToOss(file.path, key)\n        file.url = getFileUrl(file)\n        const f = await File.create(omit(file, 'path'))\n        const files = []\n        files.push(f)\n        ctx.body = invokeMap(files, 'toJSON')\n      })\n      .catch(() => {\n        throw Boom.badData('大文件分片合并失败，请稍候重试~')\n      })\n  },\n}\n```\n\n\n## 仓库代码\n[nodeFileUploadDemo](https://github.com/cosyer/nodeFileUploadDemo)\n\n## 总结\n本文讲述了大规格文件上传优化的一些做法，总结为以下 4 点：\n\n1. `Blob.slice` 将文件切片，并发上传多个切片，所有切片上传后告知服务器合并，实现大文件分片上传；\n2. 原生 XMLHttpRequest 的 `onprogress` 对切片上传进度的监听，实时获取文件上传进度；\n3. `spark-md5 `根据文件内容算出文件 MD5，得到文件唯一标识，与文件上传状态绑定；\n4. 分片上传前通过文件 MD5 查询已上传切片列表，上传时只上传未上传过的切片，实现断点续传。\n","tags":["性能优化"],"categories":["Node"]},{"title":"30分钟精通React Hooks","url":"%2F2020%2F30%E5%88%86%E9%92%9F%E7%B2%BE%E9%80%9AReact%20Hooks.html","content":"\n它来了，它来了，16.8版本`hooks`成功加入(*^▽^*)\n\n你还在为该使用无状态组件（Function）还是有状态组件（Class）而烦恼吗？\n—— 拥有了hooks，你再也不需要写Class了，你的所有组件都将是Function。\n\n你还在为搞不清使用哪个生命周期钩子函数而日夜难眠吗？\n—— 拥有了Hooks，生命周期钩子函数可以先丢一边了。\n\n你在还在为组件中的this指向而晕头转向吗？\n—— 既然Class都丢掉了，哪里还有this？你的人生第一次不再需要面对this。\n\n---\n<!--more-->\n\n## React为什么要搞一个Hooks？\n***想要复用一个有状态的组件太麻烦了！***\n我们都知道react的核心思想是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用react，你会发现你的项目中实际上很多react组件冗长且难以复用。尤其是那些写成class的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。\n\n那之前，官方推荐怎么解决这个问题呢？答案是：[渲染属性（Render Props）](https://reactjs.org/docs/render-props.html)和[高阶组件（Higher-Order Components）](https://reactjs.org/docs/higher-order-components.html)。\n\n### 渲染属性\n渲染属性指的是使用一个值为函数的prop来传递需要动态渲染的nodes或组件。如下面的代码可以看到DataProvider组件包含了所有跟状态相关的代码，而Cat组件则可以是一个单纯的展示型组件，这样一来DataProvider就可以单独复用了。\n\n```js\nimport Cat from 'components/cat'\nclass DataProvider extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { target: 'Zac' };\n  }\n\n  render() {\n    return (\n      <div>\n        {this.props.render(this.state)}\n      </div>\n    )\n  }\n}\n\n<DataProvider render={data => (\n  <Cat target={data.target} />\n)}/>\n```\n虽然这个模式叫Render Props，但不是说非用一个叫render的props不可，习惯上大家更常写成下面这种：\n```js\n<DataProvider>\n  {data => (\n    <Cat target={data.target} />\n  )}\n</DataProvider>\n```\n\n#### 其他🌰\n```js\nclass GithubProfile extends React.PureComponent<IProps, IStates> {\n  state: IStates = {\n    profile: {}\n  }\n\n  componentDidMount() {\n    fetch('https://api.github.com/users/cosyer')\n      .then(response => {\n        return response.json()\n      })\n      .then(res => {\n        this.setState({\n          profile: res\n        })\n      })\n  }\n  \n  render() {\n    const { profile } = this.state\n    return (\n      <div className=\"profile\">\n        <img src={profile.avatar_url} alt=\"avatar\" width=\"200px\" />\n        <div>name: {profile.name}</div>\n        <div>company: {profile.company}</div>\n        <div>bio: {profile.bio}</div>\n      </div>\n    )\n  }\n}\n```\n如果其它页面也有相同的需求，或者数据一样，仅仅 UI 不一样，那么我们该怎么处理？其实这个问题目的很简单，那就是：如何实现代码复用。\n```js\n// Render Props\nclass Profile extends React.Component<IProps, IStates> {\n  constructor(props:IProps) {\n    super(props)\n    this.state = {\n      profile: {}\n    }\n  }\n\n  componentDidMount() {\n    fetch('https://api.github.com/users/cosyer')\n      .then(response => {\n        return response.json()\n      })\n      .then(res => {\n        this.setState({\n          profile: res\n        })\n      })\n  }\n\n  render() {\n    const { profile } = this.state\n    return <React.Fragment>{this.props.children(profile)}</React.Fragment>\n  }\n}\n```\n定义 props 渲染函数：\n```js\nclass ProfileRenderProps extends React.PureComponent {\n  render() {\n    return (\n      <Profile>\n        {(profile:any) => (\n          <div className=\"profile\">\n            <img src={profile.avatar_url} alt=\"avatar\" width=\"200px\" />\n            <div>name: {profile.name}</div>\n            <div>company: {profile.company}</div>\n            <div>bio: {profile.bio}</div>\n          </div>\n        )}\n      </Profile>\n    )\n  }\n}\n```\n#### 缺点\n- 回调地狱\n\n### 高阶组件\n说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。\n\n看个栗子\n```js\nconst withUser = WrappedComponent => {\n  const user = sessionStorage.getItem(\"user\");\n  return props => <WrappedComponent user={user} {...props} />;\n};\n\nconst UserPage = props => (\n  <div class=\"user-container\">\n    <p>My name is {props.user}!</p>\n  </div>\n);\n\nexport default withUser(UserPage);\n```\n`withUser`函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。\n但是这两种模式会增加代码的层级关系，而hooks简洁多了，没有多余的层级嵌套，把各种想要的功能写成一个一个可复用的自定义hook，当你的组件想用什么功能时，直接在组件里调用这个hook即可。\n\n```js\n// withGithubProfile\nconst withGithubProfile = (WrappedComponent:any) => {\n  return class extends React.Component<IProps, IStates> {\n    constructor(props:IProps) {\n      super(props)\n      this.state = {\n        profile: {}\n      }\n    }\n    \n    componentDidMount() {\n      fetch('https://api.github.com/users/cosyer')\n        .then(response => {\n          return response.json()\n        })\n        .then(res => {\n          this.setState({\n            profile: res\n          })\n        })\n    }\n    \n    render() {\n      const { profile } = this.state\n      return <WrappedComponent profile={profile} {...this.props} />\n    }\n  }\n}\n```\n引入高阶组件，使用其profile\n```js\nclass GithubProfileHoc extends React.Component<IProps, IStates> {\n  render() {\n    const { profile } = this.props\n    return (\n      <div className=\"profile\">\n        <img src={profile.avatar_url} alt=\"avatar\" width=\"200px\" />\n        <div>name: {profile.name}</div>\n        <div>followers: {profile.followers}</div>\n        <div>following: {profile.following}</div>\n      </div>\n    )\n  }\n}\n\nexport default WithGithubProfile(GithubProfileHoc)\n```\n#### 缺点\n- 使用多个高阶组件时，无法确定 props 来源\n- 相同的 props 会存在覆盖的情况\n- 增加调试难度\n\n***生命周期钩子函数里的逻辑太乱了吧！***\n我们通常希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情。比如我们需要在componentDidMount中发起ajax请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在componentDidUpdate做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。\n\n***class真的太让人困惑了！***\n我们用class来创建react组件时，还有一件很麻烦的事情，就是this的指向问题。为了保证this的指向正确，我们要经常写这样的代码：`this.handleClick = this.handleClick.bind(this)`，或者是这样的代码：`<button onClick={() => this.handleClick(e)}>`。一旦我们不小心忘了绑定this，各种bug就随之而来，很麻烦。\n\n还有就是无状态组件因为需求的变动需要有自己的state，又得很麻烦的改成class组件。\n\n在 React 16.8 之前 function 有两个问题：\n\n- function 组件不得不返回一些 UI 信息，即 JSX 代码\n- function 组件内部不能拥有 state\n\n- Hooks 让函数式组件拥有类组件一样的功能，state ，lifecycle 以及 context。\n- Hooks 不是 React 的新功能，可以将它理解为一个“钩子”，可以让你在不写类组件的情况下“勾住”React 的所有功能。\n\n## State Hooks\n### 状态组件\n```js\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Click me\n        </button>\n      </div>\n    );\n  }\n}\n```\n\n### hooks改造\n```js\nimport { useState } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n是不是简单多了！可以看到，Example变成了一个函数，但这个函数却有自己的状态（count），同时它还可以更新自己的状态（setCount）。\n\n除了`useState`这个hook外，还有很多别的hook，比如`useEffect`提供了类似于`componentDidMount`等生命周期钩子的功能，`useContext`提供了上下文（context）的功能等等。\n\n`useState`是react自带的一个hook函数，它的作用就是用来声明状态变量。useState这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第[0]项是当前的状态值，第[1]\n项是可以改变状态值的方法函数。\n\n当用户点击按钮时，我们调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给react了，react将会重新渲染我们的Example组件，并且使用的是更新后的新的状态，即count=1。\nExample本质上也是一个普通的函数，为什么它可以记住之前的状态？Example函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？\n\n### 组件有多个状态值\n```js\nfunction ExampleWithManyStates() {\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState('banana');\n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n}\n```\n`useState`接收的初始值没有规定一定要是`string/number/boolean`这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的`this.setState`做的是合并状态后返回一个新\n状态，而`useState`是直接替换老状态后返回新状态。最后，react也给我们提供了一个`useReducer`的hook，如果你更喜欢redux式的状态管理方案的话。\n\n从`ExampleWithManyStates`函数我们可以看到，`useState`无论调用多少次，相互之间是独立的。其实我们看hook的“形态”，有点类似之前被官方否定掉的`Mixins`这种方案，都是提供一种“插拔式的功能注入”\n的能力。而`Mixins`之所以被否定，是因为`Mixins`机制是让多个Mixins共享一个对象的数据空间，这样就很难确保不同`Mixins`依赖的状态不发生冲突。不同组件调用同一个hook也能保证各自状态的独立性，这\n就是两者的本质区别。\n\n### react是怎么保证多个useState的相互独立的？\n看上面给出的`ExampleWithManyStates`例子，我们调用了三次`useState`，每次我们传的参数只是一个值（如42，‘banana’），我们根本没有告诉react这些值对应的key是哪个，那react是怎么保证这三个useState找到它对应的state呢？\n\n```js\n//第一次渲染\nuseState(42);  //将age初始化为42\nuseState('banana');  //将fruit初始化为banana\nuseState([{ text: 'Learn Hooks' }]); //...\n\n//第二次渲染\nuseState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）\nuseState('banana');  //读取状态变量fruit的值（这时候传的参数banana直接被忽略）\nuseState([{ text: 'Learn Hooks' }]); //...\n```\n\n答案是，react是根据`useState`出现的顺序来定的。我们具体来看一下：\n```js\nlet showFruit = true;\nfunction ExampleWithManyStates() {\n  const [age, setAge] = useState(42);\n  \n  if(showFruit) {\n    const [fruit, setFruit] = useState('banana');\n    showFruit = false;\n  }\n \n  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n}\n```\n\n```js\n//第一次渲染\nuseState(42);  //将age初始化为42\nuseState('banana');  //将fruit初始化为banana\nuseState([{ text: 'Learn Hooks' }]); //...\n\n//第二次渲染\nuseState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）\n// useState('banana');  \nuseState([{ text: 'Learn Hooks' }]); //读取到的却是状态变量fruit的值，导致报错\n```\n所以react规定我们必须把hooks写在函数的最外层，不能写在ifelse等条件语句当中，来确保hooks的执行顺序一致。\n\n## Effect Hooks\n同样是上个栗子，俺们增加一个新功能：\n```js\nimport { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 类似于componentDidMount 和 componentDidUpdate:\n  useEffect(() => {\n    // 更新文档的标题\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n```\n我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起ajax请求获取数据，添加一些监听的注册和取消注册，手动修改dom等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如\n`componentDidMount`，`componentDidUpdate`和`componentWillUnmount`。而现在的useEffect就相当与这些声明周期函数钩子的集合体。它以一抵三，厉害了！\n\n同时，由于前文所说hooks可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的useEffect钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。\n\n### useEffect做了什么？\n首先，我们声明了一个状态变量count，将它的初始值设为0。然后我们告诉react，我们的这个组件有一个副作用。我们给`useEffect hook`传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我\n们的副作用是调用`browser API`来修改文档标题。当react要渲染我们的组件时，它会先记住我们用到的副作用。等react更新了DOM之后，它再依次执行我们定义的副作用函数。\n\n这里要注意：\n1. react首次渲染和之后的每次渲染都会调用一遍传给useEffect的函数。而之前我们要用两个声明周期函数来分别表示首次渲染`componentDidMount`，和之后的更新导致的重新渲染`componentDidUpdate`。\n\n2. `useEffect`中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的`componentDidMount`或`componentDidUpdate`中的代码则是同步执行的。这种安排对大多数副作\n用说都是合理的，但有的情况除外，比如我们有时候需要先根据DOM计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。\n\n### useEffect怎么解绑一些副作用？\n这种场景很常见，当我们在`componentDidMount`里添加了一个注册，我们得在`componentWillUnmount`中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。\n\n怎么清除呢？让我们传给`useEffect`的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些pubsub模式的实现中很常见。\n```js\nimport { useState, useEffect } from 'react';\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n```\n这里有一个点需要重视！这种解绑的模式跟`componentWillUnmount`不一样。`componentWillUnmount`只会在组件被销毁前执行一次而已，而useEffect里的\n函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。每次视图更新之后，并不是只有组件卸载的时候执行。所以我们一起来看一下面这个问题：\n\n### 为什么要让副作用函数每次组件更新都执行一遍？\n我们先看以前的模式：\n```js\ncomponentDidMount() {\n  ChatAPI.subscribeToFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\n\ncomponentWillUnmount() {\n  ChatAPI.unsubscribeFromFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\n```\n我们在`componentDidMount`注册，再在`componentWillUnmount`清除注册。但假如这时候props.friend.id变了怎么办？我们不得不再添加一个componentDidUpdate来处理这种情况：\n```js\ncomponentDidUpdate(prevProps) {\n  // 先把上一个friend.id解绑\n  ChatAPI.unsubscribeFromFriendStatus(\n    prevProps.friend.id,\n    this.handleStatusChange\n  );\n  // 再重新注册新但friend.id\n  ChatAPI.subscribeToFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\n```\n很繁琐，而我们但`useEffect`则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：\n```\n1.页面首次渲染\n2.替friend.id=1的朋友注册\n\n3.突然friend.id变成了2\n4.页面重新渲染\n5.清除friend.id=1的绑定\n6.替friend.id=2的朋友注册\n```\n\n### 怎么跳过一些不必要的副作用函数？\n按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改\n变时，才执行我们传的副作用函数（第一个参数）。\n\n```js\nuseEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 只有当count的值发生变化时，才会重新执行`document.title`这一句\n```\n当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是`componentDidMount`加`componentWillUnmount`的模式。不过这种用法可能带来bug，少用。\n\n## 怎么写自定义的Effect Hooks?\n为什么要自己去写一个Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。\n\n比如我们可以把上面写的FriendStatus组件中判断朋友是否在线的功能抽出来，新建一个useFriendStatus的hook专门用来判断某个id是否在线。\n```js\nimport { useState, useEffect } from 'react';\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}\n```\n这时候FriendStatus组件就可以简写为：\n```js\nfunction FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}\n```\n假如这个时候我们又有一个朋友列表也需要显示是否在线的信息也可以复用：\n```js\nfunction FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  return (\n    <li style={{ color: isOnline ? 'green' : 'black' }}>\n      {props.friend.name}\n    </li>\n  );\n}\n```\nfunky!!!\n\n比如还有\n\n### useProfile 使用 Hooks 实现 API 请求\n```js\n// useProfile\nconst useProfile = () => {\n  const [profile, setProfile] = useState({} as TProfile)\n  const [loading, setLoading] = useState(false)\n  const [isError, setIsError] = useState(false)\n\n  useEffect(() => {\n    setLoading(true)\n    fetch('https://api.github.com/users/gaearon')\n      .then(response => {\n        return response.json()\n      })\n      .then(res => {\n        setProfile(res as TProfile)\n        setIsError(false)\n        setLoading(false)\n      }).catch(()=> {\n        setIsError(true)\n        setLoading(false)\n      })\n  }, [])\n\n  return { profile, loading, isError }\n}\n```\n使用 `useProfile` Hooks：\n```js\nconst UseProfilePage = () => {\n  const { profile, loading, isError } = useProfile()\n  return (\n    <React.Fragment>\n      {isError ? (\n        <div>Network Error...</div>\n      ) : (\n        <div className=\"profile\">\n          {loading ? (\n            <div>loading profile...</div>\n          ) : (\n            <React.Fragment>\n              <img src={profile.avatar_url} alt=\"avatar\" width=\"200px\" />\n              <div>name: {profile.name}</div>\n              <div>company: {profile.company}</div>\n              <div>bio: {profile.bio}</div>\n            </React.Fragment>\n          )}\n        </div>\n      )}\n    </React.Fragment>\n  )\n}\n```\n### useInput 使用 Hooks 实现 input 输入逻辑\n```js\nconst useInput = (initialValue:string) => {\n  const [value, setValue] = useState(initialValue)\n\n  const handleChange = (e:any) => {\n    setValue(e.target.value)\n  }\n\n  return {\n    value,\n    onChange: handleChange\n  }\n}\n```\n```js\nconst useInputDemo = () => {\n  const value = useInput('cosyer')\n\n  return (\n    <div className=\"use-input\">\n      <p>current name: {value.value}</p>\n      <input {...value} />\n    </div>\n  )\n}\n```\n\n## useContext\n`useContext` 是为了在 function 组件中使用类组件的 [context](https://reactjs.org/docs/context.html) API，使用方法很简单，首先创建一个 context：\n```js\nconst local = '🇨🇳'\nconst ThemeContext = React.createContext(local)\n```\n然后在 `useContext hook` 使用 context：\n```js\nfunction UseContextDemo() {\n  const local = useContext(ThemeContext)\n  return (\n    <div>\n      <p>local: {local}</p>\n    </div>\n  )\n}\n// render: 🇨🇳\n```\n在 class 组件中，如果想要修改 context 的值，我们会使用 Provider 提供 value 值，同样，在 function 组件中也可以：\n```js\nconst ThemeContext = React.createContext('🇨🇳')\n\nfunction Context() {\n  const local = useContext(ThemeContext)\n  return <p>local: {local}</p>\n}\n\nfunction App() {\n  return (\n    <ThemeContext.Provider value={'🇺🇸'}>\n      <Context />\n    </ThemeContext.Provider>\n  )\n}\n// render: 🇺🇸\n```\n\n## useReducer\n`useReducer` 是 `useState` 的一种代替方案，用于 state 之间有依赖关系或者比较复杂的场景。`useReducer` 接收三个参数：\n\n- reducer：(state, action) => newState\n- initialArg： 初始化参数\n- Init： 惰性初始化,返回初始化数据\n\n返回当前 state 以及配套的 dispatch 方法。首先看下 `useReducer` 处理简单的 state：\n```js\nfunction UseReducerDemo() {\n  const [count, dispatch] = useReducer(state => {\n    return state + 1\n  }, 0)\n\n  return (\n    <div>\n      <p>count: {count}</p>\n      <button\n        onClick={() => {\n          dispatch()\n        }}\n      >\n        add\n      </button>\n    </div>\n  )\n}\n```\n这个例子和使用 `useState` 一样，都达到了计数的效果。 该例子中，`useReducer` 初始化了 count 值为 0，传入的 reducer 很简单，当接收到一个 dispatch 时，将 count 的值增加 1。\n\n### 处理 state 有相互依赖的场景\n```js\nconst CountApp = () => {\n  const [count, setCount] = useState(0)\n  const [frozen, setFrozen] = useState(false)\n\n  const increase = () => {\n    setCount(prevCount => {\n      if (frozen) {\n        return prevCount\n      }\n      return prevCount + 1\n    })\n  }\n\n  useEffect(() => {\n    increase()\n    setFrozen(true)\n    increase()\n  }, [])\n\n  return <p>count {count}</p>\n}\n// render 2\n```\n原因在于 function 组件的更新机制，当引入 hooks 以后，function 组件也拥有了 state 的功能，当我们 setState 时，UI 会重新渲染，但在这个过程中**function 组件中，state 以及 props 都是静态值，不存在引用，或者也可以理解为 state 和 props 是一个 capture value，每次渲染的 state 和 props 都是独立的。**\n\n在这个例子中，由于 useEffect 传入的依赖为 []，即该副作用只会在 UI 第一次渲染结束后执行一次。而在这次 render 中，count 的值为 0， frozen 值为 false，所以第二次执行 increase 时，frozen 值依然为 false， setCount 返回的 prevCount 为 1 ，然后增加 1，这也就是为什么最后 render 的结果为 2，而不是 1。\n\n对于 state 有相互依赖的情况，我们可以用 `useReducer` 来处理：\n```js\nconst INCREASE = 'INCREASE'\nconst SET_FROZEN = 'SET_FROZEN'\n\nconst initialState = {\n  count: 0,\n  frozen: false\n}\n\nconst CountApp = () => {\n  const reducer = (state: any, action: any) => {\n    switch (action.type) {\n      case INCREASE:\n        if (state.frozen) {\n          return state\n        }\n        return {\n          ...state,\n          count: state.count + 1\n        }\n\n      case SET_FROZEN:\n        return {\n          ...state,\n          frozen: action.frozen\n        }\n      default:\n        return state\n    }\n  }\n  const [state, dispath] = useReducer(reducer, initialState)\n\n  useEffect(() => {\n    dispath({ type: INCREASE })\n    dispath({ type: SET_FROZEN, frozen: true })\n    dispath({ type: INCREASE })\n  }, [])\n\n  return <p>current count: {state.count}</p>\n}\n```\n\n### 如何用useState实现useReducer\n```js\nconst CountApp = () => {\n  const [state, setState] = useState({\n    count: 0,\n    frozen: false,\n  });\n\n  const increase = () => {\n    setState(prevState => {\n      if (prevState.frozen) {\n        return prevState;\n      }\n      return {\n        ...prevState,\n        count: state.count + 1,\n      };\n    });\n  };\n\n  const setFrozen = () => {\n    setState(prevState => {\n      return {\n        ...prevState,\n        frozen: true,\n      };\n    });\n  };\n\n  useEffect(() => {\n    increase();\n    setFrozen();\n    increase();\n  }, []);\n\n  return <p>current count: {state.count}</p>;\n  // render：1\n};\n```\n`useReducer` 和 `useState` 相比，优势在于可以将使用 reducer 将一些逻辑进行抽离，进行集中化管理。\n\n## useCallback\n\n`useCallback` 可以理解为将函数进行了缓存，它接收一个回调函数和一个依赖数组，只有当依赖数组中的值发生改变时，该回调函数才会更新。\n```js\nfunction UseCallbackDemo() {\n  const [count, setCount] = useState(0)\n\n  const handleResize = useCallback(() => {\n    console.log(`the current count is: ${count}`)\n  }, [count])\n\n  useEffect(() => {\n    window.addEventListener('resize', handleResize)\n    return () => window.removeEventListener('resize', handleResize)\n  }, [handleResize])\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          setCount(count + 1)\n        }}\n      >\n        click\n      </button>\n      <p>current count: {count}</p>\n    </div>\n  )\n}\n```\n该例子中，当改变 count 后，然后改变浏览器窗口大小，可以获取到最新的 count 。如果传入的依赖为 []，handleResize 不会更新，则改变浏览器窗口时， count 的值始终为 0 。\n\n## useMemo\n`useMemo` 对值进行了缓存，与 `useCallback` 类似，接收一个创建值的函数和一个依赖数组，它仅会在某个依赖项改变时才重新计算 memoized 值，这种优化有助于避免在每次渲染时都进行高开销的计算。\n\n```js\nfunction UseMemoDemo() {\n  const [count, setCount] = useState(0)\n  const [value, setValue] = useState('')\n\n  const useMemoChild = useMemo(() => <Child count={count} />, [count])\n  return (\n    <div>\n      <p>{count}</p>\n      <button\n        onClick={() => {\n          setCount(count + 1)\n        }}\n      >\n        click\n      </button>\n      <br />\n      <input value={value} onChange={e => setValue(e.target.value)} />\n      {useMemoChild}\n    </div>\n  )\n}\n\nfunction Child({ count }: { count: number }) {\n  console.log('child render')\n  return (\n    <Fragment>\n      <p>useMemo hooks</p>\n      <p>child count: {count}</p>\n    </Fragment>\n  )\n}\n```\n该例子中，UseMemoDemo 组件引用了 Child 组件，在 UseMemoDemo 组件中，定义了 count 和 value 两个 state，如果不使用 `useMemo`，那么每当 UseMemoDemo 中 input 发生改变时，Child 组件就会重\n新渲染。但 Child 组件 UI 只和 count 有关，那么这样就会造成 Child 组件无效更新，因此就引入了 `useMemo`，将 count 作为依赖传入，这样只有当 count 值发生改变时， Child 组件才会重新渲染。\n\n## useRef\n`useRef` 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数 （initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。在 function 组件中， 使用 `useRef` 主要可以完成以\n下两件事：\n\n1. 获取 dom 结构\n2. 保存变量\n\n先看一个获取 dom 节点, 点击 button 时，input 聚焦。\n```js\nfunction UseRefDemo() {\n  const inputRef = useRef(null as any)\n\n  const handleFocusInput = () => {\n    inputRef.current.focus()\n  }\n\n  return (\n    <div>\n      <input ref={inputRef} />\n      <button onClick={handleFocusInput}>click focus</button>\n    </div>\n  )\n}\n```\n官方demo\n```js\nfunction Counter() {\n  const [count, setCount] = useState(0)\n\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(`You clicked ${count} times`)\n    }, 3000)\n  })\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  )\n}\n```\n如果我们 3s 点多次点击 button，那么控制台输出的结果会是 0,1,2,3…， 这是由于每次渲染时 count 的值都是固定的。但类似的逻辑在 class 组件中表现不一样：\n```js\ncomponentDidUpdate() {\n  setTimeout(() => {\n    console.log(`You clicked ${this.state.count} times`);\n  }, 3000);\n}\n```\n在 class 组件中，我们在 3s 内多次点击 button，最后在控制台输出的结果是最后一次 count 更新的值。\n解释说明下：\n> state 是 Immutable 的，setState 后一定会生成一个全新的 state 引用。但 Class Component 通过 this.state 方式读取 state，这导致了每次代码执行都会拿到最新的 state 引用，所以快速点击4次的结果是 4 4 4 4。\n\n\n而在 function 组件中，我们使用 `useRef` 实现这个效果 \n```js\nfunction useRefDemo() {\n  const [count, setCount] = useState(0)\n  const countRef = useRef(count)\n\n  useEffect(() => {\n    countRef.current = count\n    setTimeout(() => {\n      console.log(`You clicked ${countRef.current} times`)\n    }, 2000)\n  }, [count])\n\n  return (\n    <div>\n      <p>count: {count}</p>\n      <button\n        onClick={() => {\n          setCount(count + 1)\n        }}\n      >\n        click\n      </button>\n    </div>\n  )\n}\n```\nuseRef 返回的对象在组件的整个生命周期内保持不变，每次渲染时返回的是同一个ref对象，因此 countRef.current 始终是最新的 count 值。\n\n> 闭包带来的坑:\n因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 count，也就导致了输出了 0、1、2。如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref 在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。\n\n**但由于对 state 的读取没有通过 this. 的方式，使得每次 setTimeout 都读取了当时渲染闭包环境的数据，虽然最新的值跟着最新的渲染变了，但旧的渲染里，状态依然是旧值。**\n\n## useImperativeHandle\n`useImperativeHandle` 可以让你在使用 ref 时，自定义暴露给父组件的实例值，在大多数情况下，应当避免使用 ref 这样的命令式代码。`useImperativeHandle` 应当与 `forwardRef` 一起使用：\n```js\nfunction FancyInput(props, ref) {\n  const inputRef = useRef(null as any)\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus()\n    }\n  }))\n  return <input ref={inputRef} />\n}\n\nconst FancyInputRef = forwardRef(FancyInput)\n\nconst useImperativeHandleDemo = () => {\n  const inputRef = useRef(null as any)\n\n  useEffect(() => {\n    inputRef.current.focus()\n  })\n\n  return <FancyInputRef ref={inputRef} />\n}\n```\n\n## useLayoutEffect\n其函数签名 与 `useEffect` 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前完成。\n```js\nconst BlinkyRender = () => {\n  const [value, setValue] = useState(0);\n\n  useEffect(() => {\n    if (value === 0) {\n      setValue(10 + Math.random() * 200);\n    }\n  }, [value]);\n\n  return (\n    <div onClick={() => setValue(0)}>value: {value}</div>\n  );\n};\n```\n当我们快速点击时，value 会发生随机变化，但 `useEffect` 是 UI 已经渲染到屏幕上以后才会执行，value 会先渲染为 0，然后在渲染成随机数，因此屏幕会出现闪烁。\n```js\nuseLayoutEffect(() => {\n  if (value === 0) {\n    setValue(10 + Math.random() * 200);\n  }\n}, [value]);\n```\n相比使用 `useEffect`，当点击 div，value 更新为 0，此时页面并不会渲染，而是等待 useLayoutEffect 内部状态修改后，才会去更新页面，所以页面不会闪烁。\n\n## useDebugValue\n`useDebugValue` 可用于在 React 开发者工具中显示自定义 hook 的标签。\n```js\nfunction useFriendStatus() {\n  const [isOnline] = useState(null)\n  useDebugValue(isOnline ? 'Online' : 'Offline')\n\n  return isOnline\n}\n\nconst App = () => {\n  const isOnline = useFriendStatus()\n\n  return <div>{isOnline}</div>\n}\n```\n在某些情况下，格式化值的显示可能是一项开销很大的操作，因此，`useDebugValue` 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查（打开 React 开发者工具）时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。\n例如， 一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用:\n```js\nuseDebugValue(date, date => date.toDateString());\n```\n\n## hooks中的坑\n1. 不要在循环，条件或嵌套函数中调用Hook，必须始终在React函数的顶层使用Hook。这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子\n函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。\n\n2. 使用useState时候，使用push，pop，splice等直接更改数组对象的坑，使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面\n不会有这个问题。\n```js\nlet [num,setNums] = useState([0,1,2,3])\nconst test = () => {\n    // 这里坑是直接采用push去更新num，setNums(num)是无法更新num的，必须使用num = [...num ,1]\n    num.push(1)\n    // num = [...num ,1]\n    setNums(num)\n}\n\n// class采用同样的方式是没有问题的\nthis.state.nums.push(1)\nthis.setState({\n    nums: this.state.nums\n})\n```\n\n比对`eagerState`和`currentState`，引用类型当然是同一个引用所以当然不会重新渲染，和`pureComponent`只进行浅比较的逻辑差不多。(setNum,依赖数组)\n因为本身我们就是修改的 state 的 obj.name，因此在这次闭包中，认为传过来的新的 state 其实和之前对比是相同的（之前的 state 是我们人工修改的值），这种情况下，\n就不会出发渲染。\n\n3. useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect。useEffect使用set一定要加条件判断否则会出现死循环。\n\n4. useEffect是render结束后，callback函数执行，但是不会阻断浏览器的渲染，算是某种异步的方式吧。但是class的componentDidMount 和componentDidUpdate是同步的,在render结束后就运行,useEffect在大部分场景下都比class的方式性能更好.\n\nuseLayoutEffect里面的callback函数会在DOM更新完成后立即执行，但是会在浏览器进行任何绘制之前运行完成，阻塞了浏览器的绘制.\n\n## useEffect依赖数组深入\n```js\n// <React.Fragment></React.Fragment>\n// <></>\n```\n空数组副作用回调函数只运行一次，并不代表 useEffect 只运行一次。在每次更新中，useEffect 依然会每次都执行，只不过因为传递给它的数组依赖项是空的，导致 React \n每次检查的时候，都没有发现依赖的变化，所以不会重新执行回调。\n\n> 检查依赖，只是简单的比较了一下值或者引用是否相等。\n\n1. 什么都不传，组件每次 render 之后 useEffect 都会调用，相当于 componentDidMount 和 componentDidUpdate。\n2. 传入一个空数组 [], 只会调用一次，相当于 componentDidMount 和 componentWillUnmount。\n3. 传入一个数组，其中包括变量，只有这些变量变动时，useEffect 才会执行。\n\nReact中判断是否需要执行useEffect内代码是通过Object.is进行判断的，而这个判断方法对于对象和数组之间的判断永远返回false。\n\n## hooks实现计时器\n注意第一个计时器错误的写法，在useEffect里面重复定义setInterval，正确写法是setInterval只定义一次，它的回调函数保存状态的更新，重点是把count更新和\nsetInterval定义分开。\n```js\nimport React from 'react'\nimport { useState,useRef,useEffect } from 'react'\n\n// 错误的写法\n// const CountTimer = () => {\n//     let [count, setCount] = useState(0)\n//     let CountTimer\n//     useEffect(() => {\n//         setInterval(() => {\n//             setCount(count+1)   \n//         })\n//         return () => window.clearInterval(CountTimer)\n//     }, [count])\n//     return (\n//         <React.Fragment>\n//             <div> {count} </div>\n//         </React.Fragment>\n//     )\n// }\n\n//正确的写法\nconst CountTimer = () => {\n    let [count, setCount] = useState(0)\n    let intervalCb = useRef(null)\n    let CountTimer\n    useEffect(() => {\n        intervalCb.current = () => {\n            setCount(count+1)   \n        }\n    }, [count])\n\n    useEffect(() => {\n        function itvFn() {\n            intervalCb.current()\n        }\n        CountTimer = window.setInterval(itvFn, 1000)\n        return () => window.clearInterval(CountTimer)\n    }, [])\n\n    const handleStop = () => {\n        window.clearInterval(CountTimer)\n    }\n    return (\n        <React.Fragment>\n            <div >{count}</div>\n            <div onClick={() => {handleStop()}}>停止计时</div>\n        </React.Fragment>\n    )\n}\n\nexport default CountTimer\n```\n\n## useMemo、useCallback、useEffect的区别\nuseMemo和useEffect的执行时机是不一致的：useEffect执行的是副作用，所以一定是在渲染之后执行的，useMemo是需要有返回值的，而返回值可以直接参与渲染的，所以\nuseMemo是在渲染期间完成的，有这样一个一前一后的区别。\n\nuseMemo返回的是计算的结果值，用于缓存计算后的状态\nuseCallback返回的是函数，主要用来缓存函数，因为函数式组件中的state的变化都会导致整个组件被重新刷新（即使一些函数没有必要被刷新），此时用useCallback就会将\n函数进行缓存，减少渲染时的性能损耗​；\n\n## 仓库代码\n\n[react-hooks-demo](https://github.com/cosyer/react-hooks-demo)\n\n## 总结\n\n这篇文章将 React Hooks 语法进行了简单介绍，Hooks 功能十分强大，如果看完文章还不是很理解的话，建议把这些 demo 自己再手动实现一遍，这样收获会更多。\n如果文章内容有哪些描述错误或者不清的地方，欢迎各位纠正并一起交流。👏👏👏\n","tags":["react"],"categories":["JS"]},{"title":"面试问题集锦","url":"%2F2020%2F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.html","content":"\n## 请做一下自我介绍\n**回答提示：** 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n## 你最大的优点是什么？\n**回答提示：** 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n## 说说你最大的缺点？\n**回答提示：** 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n---\n<!--more-->\n\n## 说说你对加班的看法？\n**回答提示：** 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n**回答样本：** 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n## 说说你对薪资的要求？\n**回答提示：** 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n**回答样本：**\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n## 在五年内，你的职业规划？\n**回答提示：** 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n## 你朋友对你的评价?\n**回答提示：** 想从侧面了解一下你的性格及与人相处的问题。\n\n**回答样本：**\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n## 你还有什么问题要问吗?\n**回答提示：** 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n## 录用后发现不适合这个职位，怎么办?\n**回答提示：** 工作一段时间发现工作不适合，有两种情况：\n\n①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；\n\n②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n## 工作时跟领导意见不同怎么办?\n**回答样本：** \n\n①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。\n\n②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。\n\n③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n## 工作出现失误并造成损失，你会怎么做?\n**回答样本：** \n\n①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n## 谈谈你对跳槽的看法?\n**回答样本：** \n\n①正常的“跳槽”能够促进人才合理流动，应该支持。\n\n②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n##和同事、上司难以相处，你怎么办?\n**回答样本：** \n\n①我会服从领导的指挥，配合同事的工作。\n\n②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。\n\n③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。\n\n④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n##上级领导抢了你的功劳怎么办?\n**回答样本：** 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：\n\n①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。\n\n②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n## 同事孤立你，你怎么办?\n**回答样本：** \n\n①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。\n\n②工作中，切勿伤害别人的自尊心。\n\n③不在领导前拨弄是非。\n\n## 你最近是否参加了培训课程?\n**回答提示：** 自费参加，就是XX的培训课程（可以多谈谈自己学的技术）。\n\n## 你对于我们公司了解多少?\n**回答提示：** 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。\n\n## 你最擅长的技术方向是什么?\n**回答提示：** 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n## 请说出你选择这份工作的动机?\n**回答提示：** 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n**回答样本：** 因为我很热爱这个工作，很想从事这方面的工作。\n\n## 你能为我们公司带来什么呢?\n**回答提示：** \n\n①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过XX近两年专业的培训，立刻就可以上岗工作”。\n\n②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n## 最能概括你自己的三个词?\n**回答样本：** 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n## 作为被面试者给我打一下分?\n**回答提示：** 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n## 你怎么理解你应聘的职位?\n**回答提示：** 可以把岗位职责和任务及工作态度阐述下。\n\n## 喜欢这份工作的哪一点?\n**回答提示：** 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n## 为什么要离职?\n**回答提示：** \n\n①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。\n\n②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n## 说说你对行业、技术发展趋势的看法?\n**回答提示：** 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n## 对工作的期望与目标何在?\n**回答提示：** 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n## 谈谈你的家庭?\n**回答提示：** 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n**回答样本：** 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n## 你认为自己申请这个职位还欠缺什么?\n**回答提示：** 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n**回答样本：** 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n## 你欣赏哪种性格的人?\n**回答提示：** 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n## 你通常如何处理别人的批评?\n**回答提示：** \n\n①沉默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。\n\n②我会等大家冷静下来再讨论。\n\n## 怎样对待自己的失败?\n**回答提示：** 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n## 什么会让你有成就感?\n**回答提示：** 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n## 眼下你生活中最重要的是什么?\n**回答提示：** 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n## 你为什么愿意到我们公司来工作?\n**回答提示：** 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n**回答样本：** \n\n①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。\n\n②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n## 你和别人发生过争执吗?\n**回答提示：** 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n## 你做过的哪件事最令自己感到骄傲?\n**回答提示：** 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请聚餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n## 对这项工作，你有哪些可预见的困难?\n**回答提示：** \n\n①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。\n\n②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n## 录用后你将怎样开展工作?\n**回答提示：** \n\n①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。\n\n②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n## 你希望与什么样的上级共事?\n**回答提示：** \n\n①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。\n\n②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n## 你工作经验欠缺，如何能胜任这项工作?\n**回答提示：** \n\n①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。\n\n②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n**回答样本：** 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n## 你会怎样获得同事的帮助?\n**回答提示：** 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n## 如果你没被录用，你怎么打算?\n**回答样本：** 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n## 最令你沮丧的事情?\n**回答样本：** 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n## 想过创业吗?\n**回答提示：** 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n## 为什么我们要在众多的面试者中选择你?\n**回答提示：** 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n**回答样本：** 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、EQ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n## 除了本公司外，还应聘了哪些公司?\n**回答提示：** 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n## 你并非毕业于名牌院校?\n**回答样本：** 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了XX的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n## 怎样看待学历和能力?\n**回答样本：** 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n## 谈谈如何适应办公室工作的新环境?\n**回答样本：** \n\n①办公室里每个人都有各自的岗位与职责，不得擅离岗位。\n\n②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。\n\n③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n## 谈谈对这个职务的期许?\n**回答提示：** 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n**回答样本：** 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n## 何时可以到职?\n**回答提示：** 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。\n","tags":["面试"],"categories":["知识"]},{"title":"三栏布局总结（左右固定宽度 中间自适应）","url":"%2F2020%2F%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93.html","content":"\n圣杯布局和双飞翼布局(其实是一回事)都是实现的三栏布局。\n\n## 浮动布局(float + margin)\n```css\n<div class=\"container\">\n    <div class=\"left\">Left</div>\n     <!-- 右栏部分要写在中间内容之前 -->\n    <div class=\"right\">Right</div>\n    <div class=\"main\">Main</div>\n</div>\n\nbody,html,.container{\n    height: 100%;\n    padding:0;\n    margin: 0;\n}\n/*左边栏左浮动*/\n.left{\n    float:left;\n    height:100%;\n    width:200px;\n    background:#333;\n}\n/*中间栏自适应*/\n.main{\n    height:100%;\n    margin:0 200px;\n    background: red;\n}\n/*右边栏右浮动*/\n.right{\n    float:right;\n    height:100%;\n    width:200px;\n    background:#333;\n}\n```\n- 优点：快捷 简单 兼容性较好\n- 缺点: 有局限性 脱离文档流 需要清除浮动等\n\n---\n<!--more-->\n\n## 绝对布局(position)\n```css\n<div class=\"container\">\n    <div class=\"left\">Left</div>\n    <div class=\"main\">Main</div>\n    <div class=\"right\">Right</div>\n</div>\n\nbody,html,.container{\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    overflow: hidden;\n}\n/*左右进行绝对定位*/\n.left,.right{\n    position: absolute;\n    height:100%;\n    top: 0;\n    background: #333;\n}\n.left{\n    left: 0;\n    width: 200px;\n}\n.right{\n    right: 0;\n    width: 200px;\n}\n/*中间用margin空出左右元素所占的空间*/\n.main{\n    height:100%;\n    margin: 0 200px;\n    background: red;\n}\n/*或者中间也进行绝对定位*/\n.main{\n    position: absolute;\n    height:100%;\n    left: 200px;\n    right:200px;\n    background: red;\n}\n```\n- 优点：简单粗暴\n- 缺点: 脱离文档流 高度未知会出现问题 可用性差\n\n## 弹性盒子布局(flex)\n```css\n<div class=\"container\">\n    <div class=\"left\">Left</div>\n    <div class=\"main\">Main</div>\n    <div class=\"right\">Right</div>\n</div>\n\nbody,html{\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    overflow: hidden;\n}\n.container{\n    display: flex;\n}\n.left{\n    width:200px;\n    background: red;\n}\n.main{\n    flex: 1;\n    background: blue;\n}\n.right{\n    width:200px;\n    background: red;\n}\n```\n- 优点：比较完美 移动端首选\n- 缺点: 不兼容 ie9 及以下\n\n## 表格布局(table)\n```css\n<div class=\"container\">\n    <div class=\"left\">Left</div>\n    <div class=\"main\">Main</div>\n    <div class=\"right\">Right</div>\n</div>\n\nbody,html{\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    overflow: hidden;\n}\n.container{\n    display: table;\n    width:100%;\n}\n.container>div{\n    display: table-cell;\n}\n.left{\n    width: 200px;\n    background: red;\n}\n.main{\n    background: blue;\n}\n.right{\n    width: 200px;\n    background: red;\n}\n```\n- 优点：兼容性很好（ie8 及以上） 父元素高度会被子元素撑开（不担心高度塌陷）\n- 缺点: seo 不友好 当其中一个单元格高度超出的时候，其他的单元格也是会跟着一起变高的\n\n## 网格布局(Grid)\n```css\n<div class=\"container\">\n    <div class=\"left\">Left</div>\n    <div class=\"main\">Main</div>\n    <div class=\"right\">Right</div>\n</div>\n\nbody,html{\n    height: 100%;\n    padding: 0;\n    margin: 0;\n    overflow: hidden;\n}\n.container{\n    display: grid;\n    width: 100%;\n    grid-template-rows: 100px;  /*设置行高*/\n    grid-template-columns: 200px auto 200px;  /*设置列数属性*/\n}\n.left{\n    background: red;\n}\n.main{\n    background: blue;\n}\n.right{\n    background:red;\n}\n```\n- 优点：简单强大 解决二维布局问题\n- 缺点: 不兼容 ie9 及以下\n\n## 总结\n|布局方案|实现|优点|缺点|\n|:--|:--|:--|:--|\n|Float布局|左右中三列，左列左浮动，右列右浮动，中间列设置左右margin|比较简单，兼容性也比较好|浮动元素脱离文档流，使用的时候只需要注意一定要清除浮\n动。|\n|Position布局|左中右三列（无顺序），根据定位属性去直接设置各个子元素位置|快捷，设置很方便|元素脱离了文档流，后代元素也脱离了文档流，高度未知的时候，\n会有问题，有效性和可使用性比较差|\n|Table布局|左中右三列，父元素display: table;子元素display: table-cell;居中子元素不设宽度|使用起来方便,兼容性也不存在问题|①无法设置栏边距；②\n对seo不友好；③当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的|\n|Flex布局|左中右三列，父元素display: flex;两侧元素设宽；居中子元素flex: 1;|比较完美|存在IE上兼容性问题，只能支持到IE9以上|\n|Grid布局|左中右三列，父元素display: grid;利用网格实现|最强大和最简单|兼容性不好，IE10+上支持，而且也仅支持部分属性|\n","tags":["布局"],"categories":["CSS"]},{"title":"js二进制和位运算","url":"%2F2020%2Fjs%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97.html","content":"\n# js 二进制与位运算\n生活中，我们经常用到的是以十进制为单位，进位是满 10 进 1，而计算机是用二进制，那么就是满 2 进 1 喽，为什么采用二进制呢？简单说下，Ta的由来其实是根据电路的开关闭合，电路只有 0 和 1，具体的详情这里不多做解释了，可以自行百科^_^。javascript 采用有符号 32 位的 2 进制，可表示 4294967295 个整数(含正负)，范围是 -2147483648(2 的 32 次方) ~ 2147483647。\n\n## 带符号二进制基本规则与几个概念\n在计算机中规定最高位是符号位，0 为正，1 为负。正数表示是原码，负数是原码的补码。\n\n### 原码\n除去符号位，其他 32 位都为正。\n\n例：00000000000000000000000000001010 原码 00000000000000000000000000001010。\n\n### 反码\n所谓反码，除符号位外，其他位 0 变 1，1 变 0。\n例：1010 反码 1101\n\n### 补码\n所谓补码，就像是小学学过的 10 进制补数，举个例子就很好理解，3 的补数是多少？是 7。4 的补数是 6，补数就是 10 减去这个数。在二进制的补码就是相加等于 0，互为相反数。\n\n* 0 的补码\n  0 的原码、反码、补码均为 0\n* 正数的补码\n  原码\n* 负数的补码\n  原码除符号位外的所有位取反+1。如何推出来的，看了一篇文章，挺有意思。[点击查看](https://blog.csdn.net/wenxinwukui234/article/details/42119265)\n\n---\n<!--more-->\n\n## 位运算\n### 按位与（AND） &\n描述：a & b 对于每一个比特位，只有两个操作数相应的比特位都是 1 时，结果才为 1，否则为 0。(摘自 MDN)\n\n举例：2 & 3 = 2\n    0000 0010\n& 0000 0011\n———————\n    0000 0010\n\n#### 应用场景:\n判断奇偶\n\n```js\nconsole.log(num & 1) // 1 是奇数  0是偶数\n```\n\n__权限设置：解权限__\n\n因为奇数的最后一位永远是 1。\n举例：num 是 3\n0000 0011\n0000 0001\n—————\n0000 0001\n\n### 按位或（OR）|\n描述：对于每一个比特位，当两个操作数相应的比特位至少有一个 1 时，结果为 1，否则为 0。(摘自 MDN)\n\n举例：2 | 3 = 3\n   0000 0010\n | 0000 0011\n———————\n    0000 0011\n\n#### 应用场景：\n**小数取整**\n\n```js\nfunction fn(n) {\n  return n | 0\n}\nfn(3.2) // 3\n```\n\n**权限**\n\n假设我们读的权限是 1 写的权限是 2，如果一个用户同时拥有读和写两种权限，正常来分配就是用一个数组[1,2]，那么用或运算符如何分配呢？\n\n```js\nclass Permission {\n  constructor() {\n    this.instance = null\n    this.permissions = {\n      r: 1, // 读\n      w: 2, // 写\n      e: 4 // 执行\n    }\n  }\n  getR() { return this.permissions.r }\n  getW() { return this.permissions.w }\n  getE() { return this.permissions.e }\n  \n  getRW() { return this.permissions.r | this.permissions.w }\n  getRE() { return this.permissions.r | this.permissions.e }\n  getWE() { return this.permissions.w | this.permissions.e }\n  \n  getRWE() { return this.permissions.r | this.permissions.w | this.permissions.e }\n  getAll() { return Object.values(this.permissions).reduce((p1, p2, i) =p1 | p2) }\n  \n  isR(per) { return Boolean(per & this.permissions.r) }\n  isW(per) { return Boolean(per & this.permissions.w) }\n  isE(per) { return Boolean(per & this.permissions.e) }\n  \n  static getInstance() {\n    !this.instance && (this.instance = new Permission())\n    return this.instance\n  }\n}\nconst per = Permission.getInstance()\nper.getRW() // 读写权限：3\nper.getAll() // 所有权限：7\nper.isR(3) // true 是否有读的权限\nper.isW(5) // false 是否有写的权限\nper.isE(5) // true 是否有执行的权限\n```\n\n注：基本运算过程\n1 | 2 =>\n  0000 0001\n| 0000 0010\n————————————\n0000 0011\n=3\n\n### 按位异或（XOR）^\n描述：对于每一个比特位，当两个操作数相应的比特位有且只有一个 1 时，结果为 1，否则为 0。(摘自 MDN)\n\n举例：2 ^ 3\n   0000 0010\n^ 0000 0011\n——————\n    0000 0001\n\n#### 应用场景\n变量交换\n我们会用到两个变量的值进行交换，比如冒泡排序的两两对比，若前者比后者大就交换位置：\n\n```js\nvar a = 1,\n  b = 2\nvar temp = a\nvar a = b\nvar b = temp\n```\n\n这里是声明第三个变量来实现交换。那么，用按位异或可以这么做：\n\n```js\nvar a = 1,\n  b = 2\na ^= b\nb ^= a\na ^= b\n```\n\n分解一下上面的：\na += 1 和 a ^= b 表达式规则是一样的\n所以 a ^= b =a = a ^ b， 看下面运算过程：\n    0000 0001\n ^ 0000 0010\n——————\n    0000 0011\n此时，a 就变成了 3。\nb ^= a =b = b ^ a\n    0000 0010\n ^ 0000 0011\n——————\n    0000 0001\n此时，b 变成了 1。\n重复第一步：\n    0000 0011\n ^ 0000 0001\n——————\n    0000 0010\n此时，a 变成了 2。最终 a=2,b=1 实现了变量的交换。好处是少声明了一个临时变量，效率上，亲测结果 异或运算交换并不比第三变量的效率高(测试交换 100 次)。\n\n## 按位非（NOT）~\n描述：反转操作数的比特位，即 0 变成 1，1 变成 0。\n看到这个可能会想到上面所说的反码，这两者是有区别的，反码是**按照有符号和无符号算的**,取反是不管有没有符号全部 0 变 1,1 变 0 的\n\n### 应用场景\n**小数取整**\n还有一个特征是取反是不能用于浮点型，所以可以用来向下取整，效果和 Math.floor()一样，~~效率要高。\n\n```js\nfunction fn(n) {\n  return ~~n\n}\nfn(3.2) // 3\n```\n\n## 左移（Left shift）<<\n描述：a << b ,将 a 的二进制形式向左移 b (< 32) 比特位，右边用 0 填充。(摘自 MDN)\n举例：3 << 4\n0000 0011 向左移动 4 位 =0011 0000\n可知，左移数是越来越大的。**移动运算符运算效率较高**\n\n### 应用场景\nx 乘以 y 的 n 次方：**x << y**\n\n```js\n1 << 3 =0000 1000 化成10进制 =1 * 2的3次方 =8\n```\n\n2 进制化成 10 进制 就是 2 的 n 次方 乘以 当前位。\n\n## 有符号右移 a >b\n描述：将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位。\n该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。\n举例：\n正数右移：4 >2\n\n```js\n   0000 0000 0000 0000 0000 0000 0000 0100\n>                                      2\n——————————————————————————————————————————\n   0000 0000 0000 0000 0000 0000 0000 0001\n```\n\n正数右移，不够的位数用符号位 0 补全，可以发现规律，结果是 4 / (2 的 2 次方) =当前位/(2 的移位的位数的次方)\n\n负数右移：-3 >4\n\n```js\n   1000 0000 0000 0000 0000 0000 0000 0011 的补码是=>\n   1111 1111 1111 1111 1111 1111 1111 1101 向右移动4位，右边舍去，左侧用符号位补齐\n>                                      4\n——————————————————————————————————————————\n   1111 1111 1111 1111 1111 1111 1111 1111 补码是=>\n   1000 0000 0000 0000 0000 0000 0000 0001 所以,最终是-1\n```\n\n## 无符号右移 a >>b\n描述：将 a 的二进制表示向右移 b (< 32) 位，丢弃被移出的位，并使用 0 在左侧填充。\n正数右移：4 >>2\n\n```js\n    0000 0000 0000 0000 0000 0000 0000 0100\n>>                                      2\n———————————————————————————————————————————\n    0000 0000 0000 0000 0000 0000 0000 0001\n```\n\n可以发现 4 >>2 和 4 >2 结果都是 1，也就是说，对于非负数来说，有无符号右移结果都是相同。\n负数右移：-4 >>2\n\n```js\n    1000 0000 0000 0000 0000 0000 0000 0100 补码=>\n    1111 1111 1111 1111 1111 1111 1111 1100\n>>                                      2\n———————————————————————————————————————————\n    0011 1111 1111 1111 1111 1111 1111 1111\n    化成10进制=2^29...2^1+1 = 1073741823\n```\n\n## 总结：\n**位运算 优势：乘除，取模，运算效率高 劣势：可读性较低，对初学者有难度，工作中应当按需所取，不应为炫技滥用。** 好多源码都有用到位运算（express、koa、koa-body），现在学习了位运算，妈妈再也不担心读不懂源码了！\n","tags":["工具"],"categories":["JS"]},{"title":"HTML5中的Web Notification桌面通知","url":"%2F2020%2FHTML5%E4%B8%AD%E7%9A%84Web%20Notification%E6%A1%8C%E9%9D%A2%E9%80%9A%E7%9F%A5.html","content":"\nWeb Notifications 技术使页面可以发出通知，通知将被显示在页面之外的系统层面上。能够为用户提供更好的体验，即使用户忙于其他工作时也可以收到来自页面的消息通知，例如一个新邮件的提醒，或者一个在线聊天室收到的消息提醒等等。\n\n> PS：除了IE外，各大现代浏览器都对这个桌面推送有了基本的支持。\n\n---\n<!--more-->\n\n## 开始\n要创建一个消息通知，非常简单，直接使用 window 对象下面的Notification类即可，代码如下：\n```js\nvar n = new Notification(\"桌面推送\", {\n\ticon: 'img/icon.png',\n\tbody: '这是我的第一条桌面通知。',\n    image:'img/1.jpg'\n});\n```\n\n> PS：消息通知只有通过Web服务访问该页面时才会生效，如果直接双击打开本地文件，是没有任何效果的。也就是说你的文件需要使用服务器的形式打开，而不是直接使用浏览器打开本地文件。\n\n## 语法\n```js\nlet myNotification = new Notification(title, options);\n```\n- title：定义一个通知的标题，当它被触发时，它将显示在通知窗口的顶部。\n\n- options（可选）对象包含应用于通知的任何自定义设置选项。\n\n常用的选项有：\n\n- body: 通知的正文，将显示在标题下方。\n\n- tag: 类似每个通知的ID，以便在必要的时候对通知进行刷新、替换或移除。\n\n- icon: 显示通知的图标\n\n- image: 在通知正文中显示的图像的URL。\n\n- data: 您想要与通知相关联的任意数据。这可以是任何数据类型。\n\n- renotify: 一个 Boolean 指定在新通知替换旧通知后是否应通知用户。默认值为false，这意味着它们不会被通知。\n\n- requireInteraction: 表示通知应保持有效，直到用户点击或关闭它，而不是自动关闭。默认值为false。\n\n当这段代码执行时，浏览器会询问用户，是否允许该站点显示消息通知，如下图所示：\n\n![notification](http://cdn.mydearest.cn/blog/images/notification.png)\n\n只有用户点击了允许，授权了通知，通知才会被显示出来。\n\n## 授权\n\n**如何获取到用户点击的是“允许”还是“阻止”呢？**\n\nwindow的 Notification实例有一个 requestPermission 函数用来获取用户的授权状态：\n```js\n// 首先，我们检查是否具有权限显示通知\n// 如果没有，我们就申请权限\nif (window.Notification && Notification.permission !== \"granted\") {\n    Notification.requestPermission(function (status) {\n    // status是授权状态。\n    // 如果用户点击的允许，则status为'granted'\n    // 如果用户点击的禁止，则status为'denied'\n    \n    // 这将使我们能在 Chrome/Safari 中使用 Notification.permission\n    if (Notification.permission !== status) {\n            Notification.permission = status;\n        }\n    });\n}\n```\n> 注意：如果用户点击了授权右上角的关闭按钮，则status的值为default。\n\n之后，我们只需要判断 status 的值是否为granted，来决定是否显示通知。\n\n## 通知事件\n但是单纯的显示一个消息框是没有任何吸引力的，所以消息通知应该具有一定的交互性，在显示消息的前前后后都应该有事件的参与。\n\nNotification一开始就制定好了一系列事件函数，开发者可以很方面的使用这些函数处理用户交互：\n\n有：onshow,onclick,onerror,onclose。\n```js\nvar n = new Notification(\"桌面推送\", {\n\ticon: 'img/icon.png',\n\tbody: '这是我的第一条桌面通知。'\n});\n \n//onshow函数在消息框显示时触发\n//可以做一些数据记录及定时关闭消息框等\nn.onshow = function() {\n\tconsole.log('显示消息框');\n\t//5秒后关闭消息框\n\tsetTimeout(function() {\n\t\tn.close();\n\t}, 3000);\n};\n \n//消息框被点击时被调用\n//可以打开相关的视图，同时关闭该消息框等操作\nn.onclick = function() {\n\tconsole.log('点击消息框');\n\t// 打开相关的视图\n\tn.close();\n};\n \n//当有错误发生时会onerror函数会被调用\n//如果没有granted授权，创建Notification对象实例时，也会执行onerror函数\nn.onerror = function() {\n\tconsole.log('消息框错误');\n\t// 做些其他的事\n};\n \n//一个消息框关闭时onclose函数会被调用\nn.onclose = function() {\n\tconsole.log('关闭消息框');\n\t//做些其他的事\n};\n```\n\n## 项目实例\n[pwa版旅游站点H5](https://github.com/cosyer/pwa-tour)\n","tags":["工具"],"categories":["工具"]},{"title":"前端动画的实现方式总结","url":"%2F2020%2F%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93.html","content":"\n通常在前端中，实现动画的方案主要有6种：\n\n- js 直接实现\n\n- SVG（可伸缩矢量图形\n\n- CSS3 transition\n\n- CSS3 animation\n\n- Canvas动画\n\n- requestAnimationFrame\n\n---\n<!--more-->\n\n## js 直接实现动画\n> 其主要思想是通过setInterval或setTimeout方法的回调函数来持续调用改变某个元素的CSS样式以达到元素样式变化的效果。\n\n🌰\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style type=\"text/css\">\n        #rect {\n            width: 200px;\n            height: 200px;\n            background: #ccc;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"rect\"></div>\n    <script>\n        let elem = document.getElementById('rect');\n        let left = 0;\n        let timer = setInterval(function(){\n            if(left<window.innerWidth-200){\n                elem.style.marginLeft = left+'px';\n                left ++;\n            }else {\n                clearInterval(timer);\n            }\n        },16);\n    </script>\n</body>\n</html>\n```\n\n- 缺点：js 实现动画通常会导致页面频繁性重排重绘，消耗性能，一般应该在桌面端浏览器。在移动端上使用会有明显的卡顿。\n\n### Tip：为什么是16ms\n上面例子中，我们设置的setInterval时间间隔是16ms。一般认为人眼能辨识的流畅动画为每秒60帧，这里16ms比(1000ms/60)帧略小一些，但是一般可仍为该动画是流畅的。 \n\n在很多移动端动画性能优化时，一般使用16ms来进行节流处理连续触发的浏览器事件。例如对touchmove、scroll事件进行节流等。通过这种方式减少持续事件的触发频率，可以大大提升动画的流畅性。\n\n## SVG\n🌰\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n    *{\n        margin:0;\n        padding:0;\n    }\n    </style>\n</head>\n<body>\n    <svg id=\"box\" width=\"800\" height=\"400\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\">\n        <rect x=\"\" y=\"\" width=\"100\" height=\"100\" fill=\"rgb(255,0,0);\" stroke=\"\" stroke-width=\"\">\n            <set attributeName=\"x\" attributeType=\"XML\" to=\"100\" begin=\"4s\"/>\n            <animate attributeName=\"x\" attributeType=\"XML\" begin=\"0s\" dur=\"4s\" from=\"0\" to=\"300\"/>\n            <animate attributeName=\"y\" attributeType=\"XML\" begin=\"0s\" dur=\"4s\" from=\"0\" to=\"0\"/>\n            <animateTransform attributeName=\"transform\" begin=\"0s\" dur=\"4s\" type=\"scale\" from=\"1\" to=\"2\" repeatCount=\"1\" />\n            <animateMotion path=\"M10,80 q100,120 120,20 q140,-50 160,0\" begin=\"0s\" dur=\"4s\" repeatCount=\"1\" />\n        </rect>     \n    </svg>  \n</body>\n</html>\n```\n\n- 优缺点\n\nSVG的一大优势是含有较为丰富的动画功能，原生绘制各种图形、滤镜和动画，并且能被js调用。html是对dom的渲染，那么svg就是对图形的渲染。 \n但是，另一方面元素较多且复杂的动画使用svg渲染会比较慢，而且SVG格式的动画绘制方式必须让内容嵌入到HTML中使用。CSS3的出现让svg的应用变得相对少了。\n\n## CSS3 transition\ntransition是过渡动画。但是transition并不能实现独立的动画，只能在某个标签元素样式或状态改变时进行平滑的动画效果过渡，而不是马上改变。\n\n### Tips\n\n在移动端开发中，直接使用transition动画会让页面变慢甚至卡顿。所以我们通常添加transform:translate3D(0,0,0)或transform:translateZ(0)来开启移动端动画的GPU加速，让动画过程更加流畅。\n\n## CSS3 animation\nanimation 算是真正意义上的CSS3动画。通过对关键帧和循环次数的控制，页面标签元素会根据设定好的样式改变进行平滑过渡。而且关键帧状态的控制是通过百分比来控制的。\n\n- 优点\nCSS3最大的优势是摆脱了js的控制，并且能利用硬件加速以及实现复杂动画效果。\n\n## Canvas动画\n> canvas作为H5新增元素，是借助Web API来实现动画的。\n\n🌰\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n    *{\n        margin:0;\n        padding:0;\n    }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\" width=\"700\" height=\"550\"></canvas>\n    <script type=\"text/javascript\">\n        // 通过getContext()获取元素的绘制对象，通过clearRect不断清空画布并在新的位置上使用fillStyle绘制新矩形内容实现页面动画效果\n        let canvas = document.getElementById(\"canvas\");\n        let ctx = canvas.getContext(\"2d\");\n        let left = 0;\n        let timer = setInterval(function(){\n            ctx.clearRect(0,0,700,550);\n            ctx.beginPath();\n            ctx.fillStyle = \"#ccc\";\n            ctx.fillRect(left,0,100,100);\n            ctx.stroke();\n            if(left>700){\n                clearInterval(timer);\n            }\n            left += 1;\n        },16);\n    </script>\n</body>\n</html>\n```\n\n- 优点\nCanvas主要优势是可以应对页面中多个动画元素渲染较慢的情况，完全通过javascript来渲染控制动画的执行。可用于实现较复杂动画。\n\n## requestAnimationFrame\nrequestAnimationFrame是另一种Web API，原理与setTimeout和setInterval类似，都是通过javascript持续循环的方法调用来触发动画动作。但是requestAnimationFrame是浏览器针对动画专门优化形成的APi，在性能上比另两者要好。\n\n栗子🌰\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n    <style type=\"text/css\">\n        * {\n            margin:0;\n            padding:0;\n        }\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: #ccc;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"rect\"></div>\n    <script type=\"text/javascript\">\n    window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||\n    window.msRequestAnimationFrame;\n\n    let elem = document.getElementById(\"rect\");\n    let left = 0;\n    //自动执行持续性回调\n    requestAnimationFrame(step);\n    //持续该改变元素位置\n    function step() {\n        if(left<window.innerWidth-200){\n            left+=1;\n            elem.style.marginLeft = left+\"px\";\n            requestAnimationFrame(step);\n        }\n    }\n    </script>\n</body>\n</html>\n```\n\n## 总结\n复杂的动画是通过一个个简单的动画组合实现的。基于兼容性问题，通常在项目中，一般在\n\n- 桌面端浏览器推荐使用javascript直接实现动画或SVG方式；\n- 移动端可以考虑使用CSS3 transition、CSS3 animation、Canvas或requestAnimationFrame方式**。\n","tags":["布局"],"categories":["CSS"]},{"title":"TAR命令详解","url":"%2F2020%2FTAR%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.html","content":"在Linux中，压缩与解压用得最多的是 `tar` 命令。\n\n-c: 建立压缩档案\n-x：解压\n-t：查看内容\n-r：向压缩归档文件末尾追加文件\n-u：更新原压缩包中的文件\n\n以上五个是独立的命令参数，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。\n\n-z：有gzip属性的  gz\n-j：有bz2属性的   bz2\n\n-J ：有xz属性的   xz\n-Z：有compress属性的\n-v：显示所有过程\n-O：将文件解开到标准输出\n\n下面的参数-f是必须的\n\n-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。\n\n---\n<!--more-->\n\n## 栗子🌰\n### tar -cf all.tar *.jpg\n这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。\n\n### tar -rf all.tar *.gif\n这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。\n\n### tar -uf all.tar logo.gif\n这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。\n\n### tar -tf all.tar\n这条命令是列出all.tar包中所有文件，-t是列出文件的意思\n\n### tar -xf all.tar\n这条命令是解出all.tar包中所有文件，-t是解开的意思\n\n## 压缩\n```js\n// 将目录里所有jpg文件打包成tar.jpg\ntar -cvf jpg.tar *.jpg \n\n// 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\ntar -czf jpg.tar.gz *.jpg\n\n// 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\ntar -cjf jpg.tar.bz2 *.jpg\n\n// 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\ntar -cZf jpg.tar.Z *.jpg\n\n// rar格式的压缩，需要先下载rar for linux\nrar a jpg.rar *.jpg\n\n// zip格式的压缩，需要先下载zip for linux\nzip jpg.zip *.jpg \n```\n\n## 解压\n```js\n// 解压 tar包\ntar -xvf file.tar \n\n// 解压tar.gz\ntar -xzvf file.tar.gz\n\n// 解压 tar.bz2\ntar -xjvf file.tar.bz2\n\n// 解压tar.Z\ntar -xZvf file.tar.Z\n\n// 解压tar.xz\ntar -Jxvf fle.tar.xz\n\n// 解压rar\nunrar e file.rar \n\n// 解压zip\nunzip file.zip\n```\n\n## 总结\n```js\n1、*.tar 用 tar -xvf 解压\n\n2、*.gz 用 gzip -d或者gunzip 解压\n\n3、*.tar.gz和*.tgz 用 tar -xzf 解压   tar.xz  用 tar -Jxvf 解压\n\n4、*.bz2 用 bzip2 -d或者用bunzip2 解压\n\n5、*.tar.bz2用tar -xjf 解压\n\n6、*.Z 用 uncompress 解压\n\n7、*.tar.Z 用tar -xZf 解压\n\n8、*.rar 用 unrar e解压\n\n9、*.zip 用 unzip 解压\n\ntar -zcvf 1.tar.gz xxx\ntar -zxvf 1.tar.gz\n```\n","tags":["shell"],"categories":["工具"]},{"title":"算法题练习","url":"%2F2020%2F%E7%AE%97%E6%B3%95%E9%A2%98%E7%BB%83%E4%B9%A0.html","content":"\n# 五大算法\n- 贪心算法：局部最优解法\n- 分治算法：分成多个小模块，与原问题性质相同\n- 动态规划：每个状态都是过去历史的一个总结\n- 回溯法：发现原先选择不优时，退回重新选择\n- 分支限界法：按广度优先策略搜索问题的解空间树，适合求解最优化问题\n\n## 数据树\n- 二叉树: 最多只有两个子节点\n  - 完全二叉树\n    - 若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都连续集中在最左边\n  - 满二叉树\n    - 深度为 h, 有 n 个节点，且满足 n = 2^h - 1\n  - 平衡二叉树\n    - 它或者是一颗空树，或它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树\n  - 最优二叉树(哈夫曼树)\n    - 树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。\n\n- 二叉查找树: 是一种特殊的二叉树，能有效地提高查找效率\n  - 小值在左，大值在右\n  - 节点 n 的所有左子树值小于 n，所有右子树值大于 n\n\n![binary-search-tree](http://cdn.mydearest.cn/blog/images/binary-search-tree.png)\n\n- 遍历节点\n  - 前序遍历\n    - 根节点\n    - 访问左子节点，回到 1\n    - 访问右子节点，回到 1\n  - 中序遍历\n    - 先访问到最左的子节点\n    - 访问该节点的父节点\n    - 访问该父节点的右子节点， 回到 1\n  - 后序遍历\n    - 先访问到最左的子节点\n    - 访问相邻的右节点\n    - 访问父节点， 回到 1\n\nDLR--前序遍历（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）\n\n![dlr](http://cdn.mydearest.cn/blog/images/dlr.png)\n\nLDR--中序遍历（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）\n\n![ldr](http://cdn.mydearest.cn/blog/images/ldr.png)\n\nLRD--后序遍历（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）\n\n![lrd](http://cdn.mydearest.cn/blog/images/lrd.png)\n\n- 插入与删除节点\n\n---\n<!--more-->\n\n## 写出一个方法输出1-100内的所有素数\n解析：\n由素数（质数）定义可知：\n\n- ① 0、1都不是质数，那么最小的质数就是2。\n- ② 除了1和它自身，不能被其他数整除，那么代码表达式表示为：\n\n```js\ni % j === 0\n```\n- 代码实现\n\n```js\nfunction fn() {\n  const arr = []\n  for (let i = 2; i <= 100; i++) {\n    let bl = false\n    for (let j = 2; j <= i; j++) {\n      if (i === j) continue\n      i % j === 0 && (bl = true)\n    }\n    !bl && arr.push(i)\n  }\n  return arr\n}\nconsole.log(fn()) \n```\n\n## (数组中第K大元素)给定一个整数数组，实现快速排序算法进行升序排列。如[2, 5, 8, 9, 3] =>[2, 3, 5, 8, 9]\n解析：（分治法）\n将一个列表分割为左右两块，然后再将字列表再进行分割为左右两块，如何反复，知道子元素长度为1时，结束！\n- 代码实现\n```js\nfunction qSort(arr) {\n  if (arr.length <= 1) return arr\n  const index = Math.floor(arr.length / 2)\n  const midVal = arr.splice(index, 1)[0]\n  const left = [],\n    right = []\n  arr.forEach(item => {\n    if (item < midVal) left.push(item)\n    else right.push(item)\n  })\n  return [...qSort(left), midVal, ...qSort(right)]\n}\nqSort([2, 5, 8, 9, 3])\n```\n\n## 求一个字符串中最长的非重复连续子串\n```js\nfunction find(s) {\n    var str = '';//存放当前最大无重复项字符串\n    var len = 0;//存放当前最大无重复项字符串长度\n    for(var i=0;i<s.length;i++){\n        var char = s.charAt(i);\n        var index = str.indexOf(char);\n        if(index === -1){  //遍历s将元素挨个放入到str中，每放入一次判断str中是否有重复项\n            str += char;\n            len = len<str.length?str.length:len;//记录最大长度项,每次重新记录str进行判断，是否大于上次一次最大项\n        }\n        else{\n            str = str.substr(index + 1) + char; //从当前重复项开始重新记录str\n        }\n    }\n    return len;\n}\n// 'adasdddddddfghti' 6\n```\n\n## 求字符串数组的最长公共前缀\n> 比如输入: [\"flower\",\"flow\",\"flight\"]，输出: \"fl\"\n\n```js\nvar longestCommonPrefix = function(strs) {\n    if (strs === null || strs.length === 0) return \"\";\n    if(strs.length === 1) return strs[0]\n    let min = 0, max = 0\n    for(let i = 1; i < strs.length; i++) {\n        if(strs[min] > strs[i]) min = i\n        if(strs[max] < strs[i]) max = i\n    }\n    for(let j = 0; j < strs[min].length; j++) {\n        if(strs[min].charAt(j) !== strs[max].charAt(j)) {\n            return strs[min].substring(0, j)\n        }\n    }\n    return strs[min]\n};\n```\n\n## 实现二叉树(构建、遍历)\n```js\nfunction TreeCode() {\n    let BiTree = function (ele) {\n        this.data = ele;\n        this.lChild = null;\n        this.rChild = null;\n    }\n\n    this.createTree = function () {\n        let biTree = new BiTree('A');\n        biTree.lChild = new BiTree('B');\n        biTree.rChild = new BiTree('C');\n        biTree.lChild.lChild = new BiTree('D');\n        biTree.lChild.lChild.lChild = new BiTree('G');\n        biTree.lChild.lChild.rChild = new BiTree('H');\n        biTree.rChild.lChild = new BiTree('E');\n        biTree.rChild.rChild = new BiTree('F');\n        biTree.rChild.lChild.rChild = new BiTree('I');\n        return biTree;\n    }\n}\n\n//前序遍历\nfunction ProOrderTraverse(biTree) {\n    if (biTree == null) return;\n    console.log(biTree.data);\n    ProOrderTraverse(biTree.lChild);\n    ProOrderTraverse(biTree.rChild);\n}\n\n//中序遍历\nfunction InOrderTraverse(biTree) {\n    if (biTree == null) return;\n    InOrderTraverse(biTree.lChild);\n    console.log(biTree.data);\n    InOrderTraverse(biTree.rChild);\n}\n\n//后续遍历\nfunction PostOrderTraverse(biTree) {\n    if (biTree == null) return;\n    PostOrderTraverse(biTree.lChild);\n    PostOrderTraverse(biTree.rChild);\n    console.log(biTree.data);\n}\n\nlet myTree = new TreeCode();\nconsole.log(myTree.createTree());\nconsole.log('前序遍历')\nProOrderTraverse(myTree.createTree());\nconsole.log('中序遍历')\nInOrderTraverse(myTree.createTree());\nconsole.log('后续遍历')\nPostOrderTraverse(myTree.createTree());\n```\n\n## 二叉树的非递归遍历\n### 深度优先非递归(栈的先进后出)DFS\n```js\nfunction DepthFirstSearch(biTree) {\n    let stack = [];\n    stack.push(biTree);\n\n    while (stack.length != 0) {\n        let node = stack.pop();\n        console.log(node.data);\n        if (node.rChild) {\n            stack.push(node.rChild);\n        }\n        if (node.lChild) {\n            stack.push(node.lChild);\n        }\n\n    }\n\n}\n```\n\n### 广度优先非递归(队列的先进先出)BFS\n```bash\nfunction BreadthFirstSearch(biTree) {\n    let queue = [];\n    queue.push(biTree);\n    while (queue.length != 0) {\n        let node = queue.shift();\n        console.log(node.data);\n        if (node.lChild) {\n            queue.push(node.lChild);\n        }\n        if (node.rChild) {\n            queue.push(node.rChild);\n        }\n    }\n\n}\n```\n\n## 一个数组，里面是排好序的数字，输入一个数字怎么能找到它的index\n\n### 把这些数字放到对象的key里，index变成value，然后直接取 时间复杂度O(n) => O(1)\n\n### 二分法查找\n```js\nlet arr = [0, 1, 2, 4, 5, 6, 7, 8];\nlet arr2 = [88, 77, 66, 55, 44, 33, 22, 11];\n\nBinarySearch(arr2, 77);\nBinarySearch(arr, 2);\n\nfunction BinarySearch(arr, target) {\n    let s = 0;\n    let e = arr.length - 1;\n    let m = Math.floor((s + e) / 2);\n    let sortTag = arr[s] <= arr[e];//确定排序顺序\n\n    while (s < e && arr[m] !== target) {\n        if (arr[m] > target) {\n            sortTag && (e = m - 1);\n            !sortTag && (s = m + 1);\n        } else {\n            !sortTag && (e = m - 1);\n            sortTag && (s = m + 1);\n        }\n        m = Math.floor((s + e) / 2);\n    }\n\n    if (arr[m] == target) {\n        console.log('找到了,位置%s', m);\n        return m;\n    } else {\n        console.log('没找到');\n        return -1;\n    }\n\n}\n```\n\n## 洗牌(乱序)算法\n### 时间复杂度:O(n²)\n```js\nfunction shuffle(arr) {\n  return arr.sort(function() {\n      return Math.random() - 0.5;\n  });\n}\n```\n\n### 时间复杂度:O(n)空间复杂度O(1)\n```js\nfunction shuffle(arr) {\n  var newArr = [];\n  for(var i = 0, len = arr.length; i < len; i++) {\n    var j = Math.floor(Math.random() * (len - i));\n    newArr[i] = arr[j];\n    arr.splice(j, 1)\n  }\n  return newArr;\n}\n```\n\n## 两数之和\n[2,7,11,88,34],9 => [0,1]\n\n### 双循环\n```js\nfunction twoSum(arr, target) {\n  var result = []\n  for (let m=0;m<arr.length -1;m++) {\n    for (let n= m+1;n<arr.length;n++) {\n      if(arr[m]+arr[n]===target){\n        result.push(m,n)\n        return result\n      }\n    }\n  }\n}\n```\n\n### Map\n```js\nfunction(arr, target) {\n let result = new Map()\n    for(let i=0;i<arr.length;i++){\n      if(result.has(target-arr[i])){\n        return [result.get(target-nums[i]),i] \n      }\n      result.set(nums[i],i)\n    }\n};\n```\n\n## 假设有130个苹果，你我轮流拿，每次可拿1-5个，如何保证你拿到最后一个苹果\n巴什博奕嘛保证剩最后6个给对面取，先取者可必胜，第一次取4个，剩126个，对面随便取，取的时候保证一直剩余6的倍数，最后一定出现剩6个苹果的情况。\n\n## 手动控制并发请求fetchWithLimit\n```js\nfunction fetchWithLimit(urls, max, callback) {\n  const urlCount = urls.length;\n  const requestsQueue = [];\n  const results = [];\n  let i = 0;\n  const handleRequest = (url) => {\n    const req = fetch(url).then(res => {\n      const len = results.push(res);\n      if (len < urlCount && i + 1 < urlCount) {\n        requestsQueue.shift();\n        handleRequest(urls[++i])\n      } else if (len === urlCount) {\n        'function' === typeof callback && callback(results)\n      }\n    }).catch(e => {\n      results.push(e)\n    });\n    if (requestsQueue.push(req) < max) {\n      handleRequest(urls[++i])\n    }\n  };\n  handleRequest(urls[i])\n}\n```\n","tags":["算法"],"categories":["JS"]},{"title":"vue面试题记录","url":"%2F2020%2FvueInterview.html","content":"\n### vue 双向绑定的原理\n采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调，实现视图刷新。\n\n具体流程：\nVue中先遍历data选项中所有的属性（发布者）用Object.defineProperty劫持这些属性将其转为getter/setter。读取数据时候会触发getter。修改数据时会触发setter。\n\n然后给每个属性对应new Dep()，Dep是专门收集依赖、删除依赖、向依赖发送消息的。先让每个依赖设置在Dep.target上，在Dep中创建一个依赖数组，先判断Dep.target是否已经在依赖中存在，不存在的话添加到依赖数组中完成依赖收集，随后将Dep.target置为上一个依赖。\n\n组件在挂载过程中都会new一个Watcher实例。这个实例就是依赖（订阅者）。Watcher第二参数是一个函数，此函数作用是更新且渲染节点。在首次渲染过程，会自动调用Dep方法来收集依赖，收集完成后组件中每个数据都绑定上该依赖。当数据变化时就会在setter中通知对应的依赖进行更新。在更新过程中要先读取数据，就会触发Wacther的第二个函数参数。一触发就再次自动调用Dep方法收集依赖，同时在此函数中运行patch（diff运算)来更新对应的DOM节点，完成了双向绑定。\n\n- 每一个组件默认都会创建一个 Watcher，自定义的 watch 和 computed 方法也会创建 Watcher \n\n### Object.defineProperty()实现双向绑定的缺点\n1. 只能监听某个属性，不能监听整个对象\n2. 需要使用for in遍历对象属性绑定监听\n3. 不能监听数组，需要重写数组方法进行特异性操作\n4. 会污染原对象\n\n---\n<!--more-->\n\n### v-show和v-if有什么区别\n\n- v-if（初始化不会渲染）\nv-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染条件为假时，则什么也不做——直到条件第一次变为真时才开始渲染条件块，能用在<template>上。\n\n- v-show（初始化会渲染）\nv-show就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于css的display进行切换。\n\n所以，v-if适用于切换不频繁的场景，v-show适用于切换频繁的场景，不能用在<template>上。\n\n### class和style如何动态绑定\n\nclass可以通过对象语法和数组语法进行动态绑定：\n- 对象语法\n```js\n<div v-bind:class=\"{active: isActive, 'text-danger': hasError }\"></div>\ndata: {\n    isActive: true,\n    hasError: false\n}\n```\n\n- 数组语法\n```js\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\ndata: {\n    activeClass: 'active',\n    errorClass: 'text-danger'\n}\n```\nstyle也可以通过对象语法和数组语法进行动态绑定\n\n### 理解vue里的单向数据流\n所有的prop都使得其父子prop之间形成一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来不行，这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流难以解释.\n\n额外地，每次父级组件发生更新时，子组件中的所有prop都会刷新为最新的值，这意味着你不应该在一个子组件内部改变prop，如果你这样做了，vue会在浏览器的控制台发出警告，子组件想修改时，只能通过$emit派发一个自定义事件，父组件接收到后，由父组件修改.\n\n> 双向数据流是指数据从父级向子级传递数据，子级可以通过一些手段改变父级向子级传递的数据。\n\n### computed和watch的区别和运用场景\n- computed：是计算属性，依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值发生改变时下一次获取computed的值时候才会重新计算computed的值。避免在模板中放入太多的逻辑，导致模板过重且难以维护。当未发生改变时，则会返回上一次的数据。\n\n- watch：更多的是观察作用，类似于某些数据的监听回调，每当监听的数据发生变化时都会执行回调进行后续操作。\n\n- methods: 每次渲染时都需要重新执行。\n\n运用场景：\n\n- 当我们需要进行数值计算，并依赖于其他数据时，应该使用computed，因为可以利用computed的缓存特性，避免每次获取值时都要重新计算。\n\n- 但我们需要在数据变化时执行异步或开销较大的操作时应该使用watch，使用watch选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的。\n\n### 直接给一个数组项赋值，vue能检测到吗\n- 由于js的限制(引用类型)，vue不能检测到以下数组的变动(对象属性的添加和删除)：\n\n- 当你利用索引直接设置一个数组项时，例如vm.item[indexOfItem] = newValue\n- 当你修改数组的长度时，例如vm.items.length = newLength\n\n为了解决第一个问题，vue提供了以下操作方法：\n```js\nVue.set(vm.items, indexOfItem, newValue)\n\nVue.$set(vm.items, indexOfItem, newValue)\n\nVue.$set(this.data,”key”,value) // 动态添加单个属性\n\n// 动态添加多个属性 \nthis.obj = Object.assign({}, this.obj, {\n  age: 18,\n  name: 'Chocolate',\n})\n\nVue.items.splice(indexOfItem, 1, newValue)\n```\n\n为了解决第二个问题，vue提供了以下操作方法：\n```js\nvm.items.splice(newLength)\n```\n\n- Vue 是不能检测对象属性的添加或删除\n```js\ndata() {\n    return {\n        obj:{\n            name:'Vue'\n        }\n    };\n},\nmounted() {\n    this.name = 'zs' // 不是响应式的\n    this.$set(this.obj,'name','lisi') //响应式 解决添加\n    // 用Object.assign来解决第二种情况。解决对象的删除\n    // Vue.delete\n},\n```\n### delete和Vue.delete的区别\ndelete 只是被删除的元素变成了empty/undefined，其他元素的键值还是不变的。而Vue.delete直接删除了数组，改变了数组的键值。\n\n### vue生命周期的理解（10个）\n- 生命周期是什么(创建到销毁的过程)\nvue实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载dom->渲染更新->渲染卸载等一些过程，我们称这是vue的生命周期\n\n- 各个生命周期的作用\n  - beforeCreate：组件被创建之初，组件的属性生效之前\n  - created：组件实例已经完全创建，属性也绑定，但是真实的dom还没有生成，$el还不能用(vue实例的数据对象data有了，el和数据对象data都为undefined，还\n  未初始化。)\n  - beforeMount：在挂载开始之前被调用，相关的render函数首次被调用\n  - mounted：el被新创建的vm.$el替换，并挂载到实例上去后调用该钩子\n  - beforeUpdate：组件数据更新之前调用，发生在虚拟dom打补丁之前 \n  - updated：组件数据更新之后\n  - activated：keep-alive专属，组件被激活时调用\n  - deactivated：keep-alive专属，组件被销毁时调用\n  - beforeDestroy：组件被销毁前\n  - destroyed：组件被销毁后调用\n\n- _init_\n  - initLifecycle/Event，往vm上挂载各种属性\n  - callHook: beforeCreate: 实例刚创建\n  - initInjection/initState: 初始化注入和 data 响应性\n  - created: 创建完成，属性已经绑定， 但还未生成真实dom\n  - 进行元素的挂载： $el / vm.$mount()\n  - 是否有template: 解析成render function\n    - *.vue文件: vue-loader会将<template>编译成render function\n  - beforeMount: 模板编译/挂载之前\n  - 执行render function，生成真实的dom，并替换到dom tree中\n  - mounted: 组件已挂载\n\n- update:\n  - 执行diff算法，比对改变是否需要触发UI更新\n  - flushScheduleQueue\n    - watcher.before: 触发beforeUpdate钩子\t\t\n    - watcher.run(): 执行watcher中的 notify，通知所有依赖项更新UI\n  - 触发updated钩子: 组件已更新\n\n- actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活\n- destroy:\n  - beforeDestroy: 销毁开始\n  - 销毁自身且递归销毁子组件以及事件监听\n    - remove(): 删除节点\n    - watcher.teardown(): 清空依赖\n    - vm.$off(): 解绑监听\n  - destroyed: 完成后触发钩子\n\n```js\nnew Vue({})\n\n// 初始化Vue实例\nfunction _init() {\n\t // 挂载属性\n    initLifeCycle(vm) \n    // 初始化事件系统，钩子函数等\n    initEvent(vm) \n    // 编译slot、vnode\n    initRender(vm) \n    // 触发钩子\n    callHook(vm, 'beforeCreate')\n    // 添加inject功能\n    initInjection(vm)\n    // 完成数据响应性 props/data/watch/computed/methods\n    initState(vm)\n    // 添加 provide 功能\n    initProvide(vm)\n    // 触发钩子\n    callHook(vm, 'created')\n\t\t\n\t // 挂载节点\n    if (vm.$options.el) {\n        vm.$mount(vm.$options.el)\n    }\n}\n\n// 挂载节点实现\nfunction mountComponent(vm) {\n\t // 获取 render function\n    if (!this.options.render) {\n        // template to render\n        // Vue.compile = compileToFunctions\n        let { render } = compileToFunctions() \n        this.options.render = render\n    }\n    // 触发钩子\n    callHook('beforeMount')\n    // 初始化观察者\n    // render 渲染 vdom， \n    vdom = vm.render()\n    // update: 根据 diff 出的 patchs 挂载成真实的 dom \n    vm._update(vdom)\n    // 触发钩子  \n    callHook(vm, 'mounted')\n}\n\n// 更新节点实现\nfuntion queueWatcher(watcher) {\n\tnextTick(flushScheduleQueue)\n}\n\n// 清空队列\nfunction flushScheduleQueue() {\n\t // 遍历队列中所有修改\n    for(){\n\t    // beforeUpdate\n        watcher.before()\n         \n        // 依赖局部更新节点\n        watcher.update() \n        callHook('updated')\n    }\n}\n\n// 销毁实例实现\nVue.prototype.$destory = function() {\n\t // 触发钩子\n    callHook(vm, 'beforeDestory')\n    // 自身及子节点\n    remove() \n    // 删除依赖\n    watcher.teardown() \n    // 删除监听\n    vm.$off() \n    // 触发钩子\n    callHook(vm, 'destoryed')\n}\n```\n\n### vue父子组件生命周期钩子函数的执行顺序\n- 加载渲染过程\n父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted\n\n- 子组件更新过程\n父beforeUpdate->子beforeUpdate->子updated->父updated\n\n- 父组件更新过程\n父beforeUpdate->父updated\n\n- 销毁过程\n父beforeDestroy->子beforeDestroy->子destroyed->父destroy\n\n### 在哪个生命周期内调用异步请求\n可以在函数created，beforeMount，mounted中进行调用，因为在这三个钩子函数中data已经可以创建，可以将服务端返回的数据进行赋值，但是比较推荐在created钩子函数中调用异步请求，因为：\n\n- 能更快的获取到服务端数据，减少页面loading时间\n- ssr不支持beforeMount，mounted钩子函数，所以放在created中有助于一致性\n\n- mounted里能够操作dom\n\n### 在什么阶段才能访问操作DOM\n在钩子函数mounted被调用之前，vue已经把编译好的模板挂载到页面上，所以在mounted中可以访问操作dom，vue具体的生命周期。\n\n### 父组件可以监听到子组件的生命周期吗\n- 手动设置$emit来发布监听\n```js\n// parent\n<Child @mounted=\"fn\" />\n// child\nmounted() {\n    this.$emit(\"mounted\");\n}\n```\n\n- @hook\n```js\n// parent\n<Child @hook:mounted=\"fn\" />\nfn() {\n    console.log('get')\n}\n// child\nmounted() {\n    console.log('emit');\n```\n\n### 谈谈你对keep-alive的了解\nkeep-alive是vue内置的一个组件，可以使被包含的组件保留状态，避免重复渲染，其有以下特性：\n\n- 一般结合路由和动态组件使用，用于缓存组件\n- 提供include和exclude属性，两者都支持字符串或正则表达式，include表示只有名字匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比include高\n- 对应两个钩子函数actived和deactivated\n\n### 组件中的data为什么是个函数\n因为组件是拿来复用的，且js里的对象是引用关系，如果组件中的data是一个对象，那么这样作用域没有隔离，子组件中的data属性值会相互影响，如果组件中的data是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data属性值不会互相影响，而new Vue的实例是不会被复用的，因此不存在引用对象的问题。\n\n### v-model的原理\n我们在vue项目中主要使用v-model指令在表单input，textarea，select等元素上创建双向绑定，我们知道v-model本质上不过是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：\n\n- text和textarea元素使用value属性和input事件\n- checkbox和radio使用checked和change\n- select字段将value作为prop并将change作为事件\n\n### vue组件间通信有哪几种方式（6种）\n- props和$emit\n适用父子组件通信\n\n- ref和$parent $children\nref：如果在普通dom上使用，引用指向的就是dom元素，如果用在子组件上，引用就指向组件实例 $parent/$children：访问父子实例\n\n- EventBus（$emit/$on）\n这种方法通过一个空的vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子，隔代，兄弟组件\n\n- $attrs/$listeners\n$attrs：包含了父作用域里不被prop所识别（且获取）的特性绑定（class和style除外）。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定（class和style除外），并且可以通过v-bind=\"$attrs\"传入内部组件。通常配合inheritAttrs选项一起使用\n\n$listeners：包含了父作用域中的v-on事件监听器，它可以通过v-on=\"$listeners\"传入内部组件\n\n- provide、inject\n祖先组件通过provide来提供变量，然后在子孙组件中通过inject来注入变量，provide / inject API主要解决了跨级组件间的通信问题，不过他的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立一种主动提供和依赖注入的关系\n\n- vuex\nvuex是一个专为vue应用程序开发的状态管理模式，每一个vuex应用的核心就是store，store基本上就是一仓库，它包含着你的应用中大部分的状态\n\nvuex的状态存储是响应式的，当vue从store中读取状态时候，若store中的状态发生变化，那么相应的组件也会相应的得到高效更新\n\n改变store中的状态的唯一的途径就是显式地提交mutation，这样使我们可以方便地跟踪每一个状态的变化\n\n### 你使用过vuex吗\nvuex是一个专门为vue应用程序开发的状态管理模式，每一个vuex应用的核心是store，store基本上就是一个容器，它包含着你的应用中大部分的状态（state）\n\n主要包括以下几个模块：\n\n- state：定义了应用状态的数据结构，可以在这里设置默认的初始状态\n- Getters：允许组件从State中获取数据，mapGetters辅助函数仅仅是将store中的getter映射到局部计算属性\n- Mutations：是唯一更改store中状态的方法，且必须是同步函数\n- Actions：用于提交mutation，而不是直接更改状态，可以包含任意的异步操作\n- Modules：允许将单一的Store拆分成多个store且同时保存在单一的状态树里\n\n### vuex解决了什么问题\n1. 多个组件依赖同一状态，多层嵌套繁琐，兄弟组件没办法传值通信。\n\n2. 不同组件的行为需要修改同一状态\n\n### Vuex中状态是对象时，使用时要注意什么？\n因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许，所以先用深度克隆复制对象，再修改。\n\n### 组件中批量使用Vuex的state状态\n```js\nimport {mapState} from 'vuex'\nexport default{\n    computed:{\n        ...mapState(['price','number'])\n    }\n}\n```\n\n### Vuex中要从state派生一些状态出来，且多个组件使用它\n使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。\n```js\nconst store = new Vuex.Store({\n    state: {\n        price: 10,\n        number: 10,\n        discount: 0.7,\n    },\n    getters: {\n        total: state => {\n            return state.price * state.number\n        },\n        discountTotal: (state, getters) => {\n            return state.discount * getters.total\n        },\n        getTodoById: (state) => (id) =>{\n            return state.todos.find(todo => todo.id === id)\n        }\n    },\n});\n```\n```js\ncomputed: {\n    total() {\n        return this.$store.getters.total\n    },\n    discountTotal() {\n        return this.$store.getters.discountTotal\n    },\n    getTodoById() {\n        return this.$store.getters.getTodoById\n    },\n    ...mapGetters(['total','discountTotal']), // 批量使用getter属性\n    ...mapGetters({\n        myTotal:'total',\n        myDiscountTotal:'discountTotal',\n    }) // 取别名\n},\nmounted(){\n    console.log(this.getTodoById(2).done)//false\n}\n```\n- 在getter中可以通过第三个参数rootState访问到全局的state,可以通过第四个参数rootGetters访问到全局的getter。\n- 在mutation中不可以访问全局的state和getter，只能访问到局部的state。\n- 在action中第一个参数context中的context.rootState访问到全局的state，context.rootGetters访问到全局的getter。\n\n### 在组件中多次提交同一个mutation,action\n```js\nmethods:{\n    ...mapMutations({\n        setNumber:'SET_NUMBER',\n    }),\n    ...mapActions({\n        setNumber:'SET_NUMBER',\n    })\n}\n```\nthis.setNumber(10)相当调用this.$store.commit('SET_NUMBER',10)\n\n### Vuex中action和mutation有什么区别？\n1. action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态。\n2. action 可以包含任意异步操作。mutation只能是同步操作。\n3. 提交方式不同，action 是用this.$store.dispatch('ACTION_NAME',data)来提交。mutation是用this.$store.commit('SET_NUMBER',10)来提交。\n4. 接收参数不同：\n```js\n{\n    state,      // 等同于 `store.state`，若在模块中则为局部状态\n    rootState,  // 等同于 `store.state`，只存在于模块中\n    commit,     // 等同于 `store.commit`\n    dispatch,   // 等同于 `store.dispatch`\n    getters,    // 等同于 `store.getters`\n    rootGetters // 等同于 `store.getters`，只存在于模块中\n}\n```\n多个actions，A结束后再执行其他操作\n```js\nactions:{\n    async actionA({commit}){\n        //...\n    },\n    async actionB({dispatch}){\n        await dispatch ('actionA')//等待actionA完成\n        // ... \n    }\n}\n```\n\n### 命名空间\n```js\nexport default{\n    namespaced: true,\n    state,\n    getters,\n    mutations,\n    actions\n}\n```\n- 怎么在带命名空间的模块内提交全局的mutation和action？\n```js\nthis.$store.dispatch('actionA', null, { root: true })\nthis.$store.commit('mutationA', null, { root: true })\n```\n\n### 在Vuex插件中怎么监听组件中提交mutation和action？\n```js\nexport default function createPlugin(param) {\n    return store => {\n        store.subscribe((mutation, state) => {\n            console.log(mutation.type)//是那个mutation\n            console.log(mutation.payload)\n            console.log(state)\n        })\n        // store.subscribeAction((action, state) => {\n        //     console.log(action.type)//是那个action\n        //     console.log(action.payload)//提交action的参数\n        // })\n        store.subscribeAction({\n            before: (action, state) => {//提交action之前\n                console.log(`before action ${action.type}`)\n            },\n            after: (action, state) => {//提交action之后\n                console.log(`after action ${action.type}`)\n            }\n        })\n    }\n}\n```\n\n### 在v-model上怎么用Vuex中state的值？\n```js\n<input v-model=\"message\">\n// ...\ncomputed: {\n    message: {\n        get () {\n            return this.$store.state.message\n        },\n        set (value) {\n            this.$store.commit('updateMessage', value)\n        }\n    }\n}\n```\n\n### vue router全局导航守卫\n三个参数\n- to：即将要进入的目标 路由对象。\n- from：当前导航正要离开的路由对象。\n- next：函数，必须调用，不然路由跳转不过去。\n\nnext()：进入下一个路由。\nnext(false)：中断当前的导航。\nnext('/')或next({ path: '/' }) : 跳转到其他路由，当前导航被中断，进行新的一个导航。\n\n- router.beforeEach：全局前置守卫。\n- router.beforeResolve：全局解析守卫。\n- router.afterEach：全局后置钩子。\n\n### 路由独享守卫\n```js\nconst router = new VueRouter({\n    routes: [\n        {\n            path: '/foo',\n            component: Foo,\n            beforeEnter: (to, from, next) => {\n            // ...\n            }\n        }\n    ]\n})\n```\n\n### 组件内导航守卫\n- beforeRouteLeave：在失活的组件里调用离开守卫。\n- beforeRouteUpdate：在重用的组件里调用,比如包含<router-view />的组件。\n- beforeRouteEnter：在进入对应路由的组件创建前调用。\n\n### router-link\n<router-link>是Vue-Router的内置组件，在具有路由功能的应用中作为声明式的导航使用。类似react的Link标签\n```html\n<router-link to=\"home\">Home</router-link>\n<router-link :to=\"'home'\">Home</router-link>\n<router-link :to=\"{ path: 'home' }\">Home</router-link>\n<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link>\n<router-link :to=\"{ path: 'user', query: { userId: 123 }}\">User</router-link>\n```\n注册在router-link上事件无效解决方法:\n使用@click.native。原因：router-link会阻止click事件，.native指直接监听一个原生事件\n\n在ie和firefox无效：\n1. 使用a标签不用Button\n2. 使用Button和Router.navigate方法\n\n### params和query的区别\nquery需要path引入，params需要name引入\nthis.$route.query.name、this.$route.params.query\n注意点：query刷新不会丢失query数据，params刷新会丢失数据\n\n### 组件内监听路由的变化\n只能用在包含<router-view />的组件内\n1. \n```js\nwatch: {\n    '$route'(to, from) {\n        //这里监听\n    },\n}\n```\n\n2. \n```js\nbeforeRouteUpdate (to, from, next) {\n    //这里监听\n},\n```\n\n### 切换新路由的滚动条处理\n```js\nconst router = new Router({\n    mode: 'history',\n    base: process.env.BASE_URL,\n    routes,\n    scrollBehavior(to, from, savedPosition) {\n        if (savedPosition) {\n            return savedPosition;\n        } else {\n            return { x: 0, y: 0 };\n        }\n    }\n});\n```\n\n### 路由传参获取方式\n1. meta：路由元信息，写在routes配置文件中。\n```js\n{\n    path: '/home',\n    name: 'home',\n    component: load('home'),\n    meta: {\n        title: '首页'\n    },\n},\n```\n> this.$route.meta.title\n\n2. query\n```js\nthis.$router.push({\n    path:'/home',\n    query: {\n        userId:123\n    }\n})\n```\n> this.$route.query.userId\n\n3. params\n```js\n{\n    path: '/home/:userId',\n    name: 'home',\n    component: load('home'),\n},\n// 注意用params传参，只能用命名的路由（用name访问）\nconst userId = '123'\nthis.$router.push({ name: 'home', params: { userId } })\n// this.$route.params\n```\n\n### 实现动态加载路由\n- 使用Router的实例方法addRoutes来实现动态加载路由，一般用来实现菜单权限。\n\n- 使用时要注意，静态路由文件中不能有404路由，而要通过addRoutes一起动态添加进去。\n\n```js\nwebpack< 2.4 时\n{ \n    path:'/', \n    name:'home',\n    components:resolve=>require(['@/components/home'],resolve)\n} \nwebpack> 2.4 时\n{ \n    path:'/', \n    name:'home', \n    components:()=>import('@/components/home')\n}\n```\n\n### 路由之间跳转\n1. 声明式\n通过使用内置组件<router-link :to=\"/home\">来跳转 or router-link :to=\"{name:'index'}\">\n\n2. 编程式\n```js\nthis.$router.push({ path:'home' })\nthis.$router.replace({ path: '/home' })\nthis.$router.push({name:'组件名')};\n```\n$router和$route的区别\n> $route为当前router跳转对象，里面可以获取name、path、query、params等\n> $router为VueRouter实例，想要导航到不同URL，则使用router.push方法，返回上一个历史$router.to(-1)\n\n### 打开新窗口\n```js\nconst obj = {\n    path: xxx,//路由地址\n    query: {\n       mid: data.id//可以带参数\n    }\n};\nconst {href} = this.$router.resolve(obj);\nwindow.open(href, '_blank');\n```\n\n### 动态绑定Class和Style\n```html\n<!--第一种对象语法 -->\n<div class=\"test\" :class=\"{active:actived,'active-click': clicked&&actived}\"></div>\n<!-- 第二种数组语法 -->\n<div class=\"test\" :class=\"[actived?activeClass : '', clicked&&actived?activeClickClass : '']\"></div>\n<!-- 第三种对象和数组混合 -->\n<div :class=\"[testClass,{active:actived},{'active-click':clicked&&actived}]\"></div>\n<!-- 第四种对象和计算属性(推荐) -->\n<div :class=\"classObject\"></div>\n```\n\n### 过滤器(filter)\n```js\n<div><span>{{money | moneyFilter(0.15)}}</span>美元</div>\n<div><span>{{money | moneyFilter(0.12)}}</span>英镑</div>\nfilters: {\n    moneyFilter: function(val, ratio) {\n        return Number(val * ratio).toFixed(2);\n    }\n}\n```\n除了用在插值上还可以用在v-bind表达式上。\n\n### computed中的属性名和data中的属性名可以相同吗？也不能和method中属性同名\n不能同名，因为不管是computed属性名还是data数据名还是props数据名都会被挂载在vm实例上，因此这三个都不能同名。\n\n### watch的属性使用箭头函数定义可以吗？\n不可以。this会是undefind,因为箭头函数中的this指向的是定义时的this，而不是执行时的this，所以不会指向Vue实例的上下文。\n\n### watch怎么深度监听对象变化\n监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；\n```js\nwatch:{\n   a:{\n       handler:function(val,oldval){\n           \n       },\n       deep:true, // 一层层遍历给属性都加上监听器\n       immediate: true // 组件加载立即触发回调函数执行\n   },\n   'obj.a': {\n\n   }\n}\n```\n\n### 强制刷新组件\n- this.$forceUpdate()。\n- 组件上加上key，然后变化key的值。\n\n### 访问子组件实例或者子元素\n1. ref\n先用ref特性为子组件赋予一个ID引用<base-input ref=\"myInput\"></<base-input>\n\n比如子组件有个focus的方法，可以这样调用this.$refs.myInput.focus()；\n比如子组件有个value的数据，可以这样使用this.$refs.myInput.value。\n\n2. 子组件访问父组件\nthis.$parent\n\n### 组件什么时候下被销毁\n- 没有使用keep-alive切换\n- v-if=\"false\"\n- 执行vm.$destroy()\n\n### $event.target和$event.currentTarget有什么区别\n$event.currentTarget始终指向事件所绑定的元素，而$event.target指向事件发生时的元素。\n\n### 事件修饰符和表单修饰符\n\n- 事件修饰符\n\n.stop：阻止事件传递；\n.prevent： 阻止默认事件；\n.capture ：在捕获的过程监听，没有capture修饰符时都是默认冒泡过程监听；\n.self：当前绑定事件的元素才能触发；\n.once：事件只会触发一次；\n.passive：默认事件会立即触发，不要把.passive和.prevent一起使用，因为.prevent将不起作用。\n\n- 表单修饰符.number .lazy .trim\n\n```\n<comp :foo.sync=\"bar\"></comp>\n```\n相当于\n```\n<comp :foo=\"bar\" @update:foo=\"val => bar = val\"></comp>\n\n// this.$emit('update:foo', newValue)\n```\n\n要注意顺序很重要，用@click.prevent.self会阻止所有的点击，而@click.self.prevent只会阻止对元素自身的点击。\n\n### 说说你对Vue的表单修饰符.lazy的理解。\ninput标签v-model用lazy修饰之后，并不会立即监听input的value的改变，会在input失去焦点之后，才会监听input的value的改变。\n\n### 监听键盘事件\n使用按键修饰符 <input @keyup.enter=\"submit\">按下回车键时候触发submit事件。\n- .enter\n- .tab\n- .delete (捕获“删除”和“退格”键)\n- .esc\n- .space\n- .up\n- .down\n- .left\n- .right\n\n### v-on绑定多个方法\n```html\n<template>\n    <div v-on:{click:a,dblclick:b}></div>\n</template>\n<script>\n    methods:{\n        a(){\n            alert(1)\n        },\n        b(){\n            alert(2)\n        }\n    }\n</script>\n```\n\n### css样式当前组件有效\n```html\n<style lang=\"less\" scoped></style>\n```\n原理：vue通过在DOM结构以及css样式上加上唯一的标记`data-v-xxxxxx`，保证动态属性唯一，达到样式私有化，不污染全局的作用。\n\n编译后：\n```html\n<template>    \n    <span data-v-3e5b2a80 class=\"textScoped\">scoped测试</span>\n</template>\n<script>\n\n</script>\n<style scoped>    \n    .textScoped[data-v-3e5b2a80]{        \n        color: red;    \n    }\n</style>\n```\n\n### 渲染模板保留注释\n- 在组件中将comments选项设置为true\n- <template comments> ... <template>\n\n### 在created和mounted这两个生命周期中请求数据有什么区别呢？\n在created中，页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态，DOM节点没出来，无法操作DOM节点。在mounted不会这样，比较好。\n\n### Vue组件里的定时器要怎么销毁？\n- 如果页面上有很多定时器，可以在data选项中创建一个对象timer，给每个定时器取个名字一一映射在对象timer中，\n在beforeDestroy构造函数中for(let k in this.timer){clearInterval(k)}；\n\n- 如果页面只有单个定时器，可以这么做。\n```js\nconst timer = setInterval(() =>{}, 500);\nthis.$once('hook:beforeDestroy', () => {\n   clearInterval(timer);\n})\n```\n\n### Vue中能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？\n- push()、pop()、shift()、unshift()、splice()、sort()、reverse()，这些方法在Vue中被重新定义了，故可以监听到数组变化；\n- filter()、concat()、slice()，这些方法会返回一个新数组，也可以监听到数组的变化。\n\n### 定义全局方法\n1. 挂载在Vue的prototype上\n2. 利用全局混入mixin\n3. \n```js\nthis.$root.$on('demo',function(){\n    console.log('test');\n})\nthis.$root.$emit('demo')；\nthis.$root.$off('demo')；\n// Mustache的web模板引擎\n```\n\n### 捕获组件的错误信息\n- errorCaptured是组件内部钩子，当捕获一个来自子孙组件的错误时被调用，接收error、vm、info三个参数，return false后可以阻止错误继续向上抛出。\n\n- errorHandler为全局钩子，使用Vue.config.errorHandler配置，接收参数与errorCaptured一致，2.6后可捕捉v-on与promise链的错误，可用于统一错误\n处理与错误兜底。\n\n### vue SSR\nvue是构建客户端应用程序的框架，默认情况下，可以在浏览器中输出vue组件，进行生成dom和操作dom，然而，也可以将同一个组件渲染为服务端的html字符串，将他们直接发送到客户端，然后将这些静态标记激活为客户端上可以交互的应用程序。\n\n即ssr的意思就是vue在服务端完成将标签渲染成整个html片段的工作，然后将片段直接返回给客户端使用\n\n- ssr优点：\n\n  - 更好的seo：因为spa页面的内容是通过ajax获取，而搜索引擎爬取工具并不会等待ajax一步完成后再抓取页面内容，所以在spa中是抓取不到页面通过ajax获取到的内容；而ssr是直接由服务器返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取到渲染好的页面\n\n  - 更快的内容到达时间（首屏加载快）：spa会等待所有vue编译后的js文件都下载完成后，才开始进行也免得渲染，文件下载需要一定的时间等，所以首屏加载需要时间，而ssr直接由服务器渲染好页面返回显示，无需等待js文件再去渲染，所以ssr有更快的内容到达时间\n\n- ssr缺点：\n\n  - 更多的开发条件限制：例如服务端渲染只支持beforeCreate和created两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序spa不同，服务端渲染应用程序，需要处于nodejs server中才能运行\n\n  - 更多的服务器负载\n\n### nextTick\n在下次dom更新循环结束之后执行延迟回调，可用于获取更新后的dom状态。\n\n- 新版本中默认是microtasks, v-on中会使用macrotasks\n```js\n// 修改数据\nvm.msg = 'Hello'\n// DOM 还没有更新\nVue.nextTick(function () {\n  // DOM 更新了\n  ...   //DOM操作\n})\n\n// 作为一个 Promise 使用\nVue.nextTick()\n    .then(function () {\n    // DOM 更新了\n    })\n```\n\n```\nVue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。\n例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。\n```\n> dom更新为什么是一个异步操作因为它提升了渲染效率。\n\n### 数据响应(数据劫持)\n数据响应的实现由两部分构成: 观察者( watcher ) 和 依赖收集器( Dep )，其核心是 defineProperty 这个方法，它可以重写属性的 get 与 set 方法，从而完成监听数据的改变。\n\n> 1. 对需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化\n\n> 2. compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图\n\n> 3. Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:\n①在自身实例化时往属性订阅器(dep)里面添加自己\n②自身必须有一个update()方法\n③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调\n\n> 4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。\n\n```js\nlet data = {a: 1}\n// 数据响应性\nobserve(data)\n\n// 初始化观察者\nnew Watcher(data, 'name', updateComponent)\ndata.a = 2\n\n// 简单表示用于数据更新后的操作\nfunction updateComponent() {\n    vm._update() // patchs\n}\n\n// 监视对象\nfunction observe(obj) {\n\t// 遍历对象，使用 get/set 重新定义对象的每个属性值\n  Object.keys(obj).map(key => {\n      defineReactive(obj, key, obj[key])\n  })\n}\n\nfunction defineReactive(obj, k, v) {\n    // 递归子属性\n    if (type(v) == 'object') observe(v)\n    \n    // 新建依赖收集器\n    let dep = new Dep()\n    // 定义get/set\n    Object.defineProperty(obj, k, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n        \t  // 当有获取该属性时，证明依赖于该对象，因此被添加进收集器中\n            if (Dep.target) {\n                dep.addSub(Dep.target)\n            }\n            return v\n        },\n        // 重新设置值时，触发收集器的通知机制\n        set: function reactiveSetter(nV) {\n            v = nV\n            dep.nofify()\n        },\n    })\n}\n\n// 依赖收集器\nclass Dep {\n    constructor() {\n        this.subs = []\n    }\n    addSub(sub) {\n        this.subs.push(sub)\n    }\n    notify() {\n        this.subs.map(sub => {\n            sub.update()\n        })\n    }\n}\n\nDep.target = null\n\n// 观察者\nclass Watcher {\n    constructor(obj, key, cb) {\n        Dep.target = this\n        this.cb = cb\n        this.obj = obj\n        this.key = key\n        this.value = obj[key]\n        Dep.target = null\n    }\n    addDep(Dep) {\n        Dep.addSub(this)\n    }\n    update() {\n        this.value = this.obj[this.key]\n        this.cb(this.value)\n    }\n    before() {\n        callHook('beforeUpdate')\n    }\n}\n```\n\n### 虚拟dom原理实现\n- 创建 dom 树\n\n- 树的diff，同层对比，输出patchs(listDiff/diffChildren/diffProps)\n  - 没有新的节点，返回\n  - 新的节点tagName与key不变， 对比props，继续递归遍历子树\n    - 对比属性(对比新旧属性列表):\n      - 旧属性是否存在与新属性列表中\n      - 都存在的是否有变化\n      - 是否出现旧列表中没有的新属性\n\n  - tagName和key值变化了，则直接替换成新节点\n\n- 渲染差异\n  - 遍历patchs， 把需要更改的节点取出来\n  - 局部更新dom\n\n\n- patch函数 oldvnode vnode\n  - 如果两个节点不一样，直接用新节点替换老节点；\n  - 如果两个节点一样，\n​\t  - 新老节点一样，直接返回；\n​     - 老节点有子节点，新节点没有：删除老节点的子节点；\n    ​ - 老节点没有子节点，新节点有子节点：新节点的子节点直接append到老节点；\n    ​ -\t都只有文本节点：直接用新节点的文本节点替换老的文本节点；\n    ​ -\t都有子节点：updateChildren\n\n```js\n// diff算法的实现\nfunction diff(oldTree, newTree) {\n\t // 差异收集\n    let pathchs = {}\n    dfs(oldTree, newTree, 0, pathchs)\n    return pathchs\n}\n\nfunction dfs(oldNode, newNode, index, pathchs) {\n    let curPathchs = []\n    if (newNode) {\n        // 当新旧节点的 tagName 和 key 值完全一致时\n        if (oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) {\n        \t  // 继续比对属性差异\n            let props = diffProps(oldNode.props, newNode.props)\n            curPathchs.push({ type: 'changeProps', props })\n            // 递归进入下一层级的比较\n            diffChildrens(oldNode.children, newNode.children, index, pathchs)\n        } else {\n        \t  // 当 tagName 或者 key 修改了后，表示已经是全新节点，无需再比\n            curPathchs.push({ type: 'replaceNode', node: newNode })\n        }\n    }\n\n\t // 构建出整颗差异树\n    if (curPathchs.length) {\n    \t\tif(pathchs[index]){\n    \t\t\tpathchs[index] = pathchs[index].concat(curPathchs)\n    \t\t} else {\n    \t\t\tpathchs[index] = curPathchs\n    \t\t}\n    }\n}\n\n// 属性对比实现\nfunction diffProps(oldProps, newProps) {\n    let propsPathchs = []\n    // 遍历新旧属性列表\n    // 查找删除项\n    // 查找修改项\n    // 查找新增项\n    forin(olaProps, (k, v) => {\n        if (!newProps.hasOwnProperty(k)) {\n            propsPathchs.push({ type: 'remove', prop: k })\n        } else {\n            if (v !== newProps[k]) {\n                propsPathchs.push({ type: 'change', prop: k , value: newProps[k] })\n            }\n        }\n    })\n    forin(newProps, (k, v) => {\n        if (!oldProps.hasOwnProperty(k)) {\n            propsPathchs.push({ type: 'add', prop: k, value: v })\n        }\n    })\n    return propsPathchs\n}\n\n// 对比子级差异\nfunction diffChildrens(oldChild, newChild, index, pathchs) {\n\t\t// 标记子级的删除/新增/移动\n    let { change, list } = diffList(oldChild, newChild, index, pathchs)\n    if (change.length) {\n        if (pathchs[index]) {\n            pathchs[index] = pathchs[index].concat(change)\n        } else {\n            pathchs[index] = change\n        }\n    }\n\n\t // 根据 key 获取原本匹配的节点，进一步递归从头开始对比\n    oldChild.map((item, i) => {\n        let keyIndex = list.indexOf(item.key)\n        if (keyIndex) {\n            let node = newChild[keyIndex]\n            // 进一步递归对比\n            dfs(item, node, index, pathchs)\n        }\n    })\n}\n\n// 列表对比，主要也是根据 key 值查找匹配项\n// 对比出新旧列表的新增/删除/移动\nfunction diffList(oldList, newList, index, pathchs) {\n    let change = []\n    let list = []\n    const newKeys = getKey(newList)\n    oldList.map(v => {\n        if (newKeys.indexOf(v.key) > -1) {\n            list.push(v.key)\n        } else {\n            list.push(null)\n        }\n    })\n\n    // 标记删除\n    for (let i = list.length - 1; i>= 0; i--) {\n        if (!list[i]) {\n            list.splice(i, 1)\n            change.push({ type: 'remove', index: i })\n        }\n    }\n\n    // 标记新增和移动\n    newList.map((item, i) => {\n        const key = item.key\n        const index = list.indexOf(key)\n        if (index === -1 || key == null) {\n            // 新增\n            change.push({ type: 'add', node: item, index: i })\n            list.splice(i, 0, key)\n        } else {\n            // 移动\n            if (index !== i) {\n                change.push({\n                    type: 'move',\n                    form: index,\n                    to: i,\n                })\n                move(list, index, i)\n            }\n        }\n    })\n\n    return { change, list }\n}\n```\n\n### Proxy 相比于 defineProperty 的优势\n- 数组变化也能监听到\n- 不需要深度遍历监听(遍历每一个属性)\n\n```js\nlet data = { a: 1 }\nlet reactiveData = new Proxy(data, {\n\tget: function(target, name){\n\t\t// ...\n\t},\n\t// ...\n})\n```\n\n### vue-router\n- mode\n  - hash\n  - history\n- 跳转\n  - this.$router.push()\n  - <router-link to=\"\"></router-link>\n- 占位\n  - <router-view></router-view>\n\n### 为什么在v-for中使用key？\n为了标识每个唯一的节点，方便比较，v-for中加key可以减少渲染次数，提升渲染性能。\n\n### Vuex页面刷新数据丢失怎么解决？\n使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中\n\n### vue项目的优化\n1. v-if和v-show区分场景使用\n\n2. computed 和 watch 区分场景使用\n\n3. v-for 遍历必须加key，key最好是id值，如果采用index当插入数据时索引会发生变化，且避免同时使用v-if(用计算属性过滤数据)\n\n4. 图片懒加载\n\n5. 路由懒加载\n\n6. 第三方插件按需引入\n\n7. 长列表(虚拟列表)\n> 无限列表加载到底部请求api，用v-for循环数据这样是欠妥当的。随着数据的加载，dom会越来越多，造成性能的开销大，对客户端造成压力。虚拟列表保证dom数量一定，渲染可视区的dom，通过替换数据来实现长列表的显示。\n\n8. 释放组件资源(beforeDestroy移除监听)\n\n9. 首屏优化 mixins抽离公共代码\n\n### vue父子组件实现双向绑定实例\n```\n<Child :name=\"name\" :change=\"changeName\"/>\n\nprops:{\n    name:{\n        type:String,\n        required: false\n    }\n},\ndata() {\n    newName:''\n},\nwatch:{\n    name(val){\n        this.newName = val\n    },\n    newName(val){\n        this.$emit('change', val)\n    }\n}\n```\n\n### 自定义v-model\n自定义 v-model，设置子组件 model 属性，设置 v-model 侦听的属性值，同时绑定属性变化时执行的事件，实现自定义 v-model，即双向绑定。\n```\n// v-model只是一个语法糖\n<input type=\"text\" v-model=\"price\"/>\n\n<input type=\"text\" :value=\"price\" @input=\"price=$event.target.value\" />\n```\n- Vue.extend方法创建一个组件\n```js\n// 注册组件\nVue.component(\"base-checkbox\", {\n    model:{\n        prop:'checked', // 绑定属性\n        event:'change', // 抛出事件\n    },\n    props:{\n        checked: boolean\n    },\n    templete:`<input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change',$event.target.value)\"/>`\n})\n\n<base-checkbox v-model=\"value\"></base-checkbox>\n```\n\n### provide/inject有什么用？\n> 常用的父子组件通信方式都是父组件绑定要传递给子组件的数据，子组件通过`props`属性接收，一旦组件层级变多时，采用这种方式一级一级传递值非常麻烦，而且代码可读性不高，不便后期维护。\n\n> vue提供了`provide`和`inject`帮助我们解决多层次嵌套嵌套通信问题。在`provide`中指定要传递给子孙组件的数据，子孙组件通过`inject`注入祖父组件传递过来的数据。\n\n> `provide`和`inject`主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。\n```js\nprovide() {\n    return {\n        elForm: this\n    }\n}\n\ninject: ['elForm']\n\n\nprovide:{\n    name: 'cosyer'\n}\n\ninject:{\n    newName: {\n        from: 'name',\n        default: ''\n    }\n}\n```\n\n### assets和static的区别\n- assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。\n\n- static中的文件则不会被打包。\n\n> 建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。\n\n### slot插槽分发\n很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件\n中slot组件的位置了。\n\n### v-clock指令的作用\n- 解决页面闪烁问题(会显示插值表达式{{message}})\n如果网速慢，而该标签内容是变量没有请求响应回来的时候，页面上先不显示该标签（vue给该标\n签加了css样式），当响应回来的时候改标签默认将css样式去除。\n\n`此指令可以解决使用插值表达式页面闪烁问题`将该指令加在html标签中时，可以在该文件中加\nstyle属性为display：none\n```js\n<div class=\"#app\" v-cloak>\n    <p>{{name}}</p>\n</div>\n\n[v-cloak]{\n    display: none;\n}\n```\n\n### 封装vue组件的过程\n1. 建立组件模板、架子写写样式，考虑好组件的基本逻辑\n2. 准备好组件的数据输入，定好props里面的数据、类型\n3. 准备好组价的数据输出，定好暴露出来的方法\n\n### 常用UI库\n#### 移动端\n- [mint-ui](http://mint-ui.github.io/#!/zh-cn)\n\n- [Vant](https://youzan.github.io/vant/#/zh-CN/home)\n\n- [VUX](https://vux.li/)\n\n- [cube-ui](https://didi.github.io/cube-ui/)\n\n#### pc端\n- [element-ui](https://element.eleme.cn/2.13/#/zh-CN/component/\ninstallation）\n\n- [Ant Design of Vue](https://www.antdv.com/docs/vue/introduce-cn/)\n\n- [iview/viewui/view-design](https://iviewui.com/)\n\n- [Avue](https://avuejs.com/)\n\n- [vuetify](https://vuetifyjs.com/)\n\n### 常用配置\n#### publicPath\n1. cli2 config/index.js\n```js\nbuild: {\n    assetsPublicPath: './'\n}\n```\n2. cli3 vue.config.js\n```js\nmodule.exports = {\n    publicPath: './'\n}\n```\n部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径\n上，例如https://www.my-app.com/。如果应用被部署在一个子路径上，\n你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.\ncom/my-app/，则设置publicPath为/my-app/\n\n```js\nproxy: { \n    \"/api\": { //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在ajax中使用/api/api1路径,其请求路径会解析\n    // http://192.168.0.118:9999/api1，当然你在浏览器上看到的还是http://localhost:8080/api/api1;\n    target: \"http://192.168.0.118:9999\",\n    //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意\n    changeOrigin: true,\n    pathRewrite: {\n        //把多余的路径置为''\n        \"api\": \"\"\n    }\n}\n```\n\n### vue3\n1. createApp\n- vue2.x\n```js\nimport Vue from \"vue\";\nimport App from './App.vue'\n\nnew Vue({\n  render: (h) => h(App)\n}).$mount(\"#app\");\n```\n\n- vue3新特性\n> createApp 会产生一个 app 实例，该实例拥有全局的可配置上下文\n```js\nimport { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n```\n\n2. globalProperties\n```js\napp.config.globalProperties.foo = 'bar'\n\napp.component('child-component', {\n  mounted() {\n    console.log(this.foo) // 'bar'\n  }\n})\n```\n> 添加可在程序内的任何组件实例中访问的全局属性。当存在键冲突时，组件属性将优先替代掉Vue2.x的 Vue.prototype属性放到原型上的写法\n\n```js\n// Vue2.x\nVue.prototype.$http = () => {}\n\n// Vue3\nconst app = Vue.createApp({})\napp.config.globalProperties.$http = () => {}\n```\n\n3. 更快\n\n- 重写虚拟DOM (Virtual DOM Rewrite)\n\n随着虚拟 DOM 重写，我们可以期待更多的 编译时（compile-time）提示来减少 运行时（runtime）开销。重写将包括更有效的代码来创建虚拟节点。\n\n- 优化插槽生成(Optimized Slots Generation)\n\n在当前的 Vue 版本中，当父组件重新渲染时，其子组件也必须重新渲染。 使用 Vue 3 ，可以单独重新渲染父组件和子组件。\n\n- 静态树提升(Static Tree Hoisting)\n\n使用静态树提升，这意味着 Vue 3 的编译器将能够检测到什么是静态组件，然后将其提升，从而降低了渲染成本。它将能够跳过未整个树结构打补丁的过程。\n\n- 静态属性提升（Static Props Hoisting）\n\n此外，我们可以期待静态属性提升，其中 Vue 3 将跳过不会改变节点的打补丁过程。\n\n- 基于 Proxy 的观察者机制\n\n- 更小\nVue已经非常小了，在运行时（runtime）压缩后大约 20kb 。 但我们可以期待它会变得更加小，新的核心运行时压缩后大概 10kb 。\n- 使其更具可维护性\n不仅会使用 TypeScript（允许在编辑器中进行高级的类型检查和有用的错误和警告） ，而且许多软件包将被解耦，使所有内容更加模块化。\n- 更多的原生支持\n运行时内核也将与平台无关，使得 Vue 可以更容易地与任何平台（例如Web，iOS或Android）一起使用。\n- 更易于开发使用\n当我们需要在 Vue 中共享两个组件之间的行为时，我们通常使用 Mixins 。然而，Evan 正在尝试使用 Hooks API 来避免来自 Mixins 的一些问题，并且更适合\n- 使用惯用的 Vue 代码。\n使用 Time Slicing，将 JS 的执行分解为几个部分，如果有用户交互需要处理，这些部分将提供给浏览器。\n","tags":["vue"],"categories":["Vue"]},{"title":"Immer中文文档","url":"%2F2020%2FImmer%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3.html","content":"\n# Immer 中文文档\n\n## 前言\n\n[Immer](https://github.com/mweststrate/immer) 是 mobx 的作者写的一个 immutable 库，核心实现是利用 ES6 的 proxy，几乎以最小的成本实现了 js 的不可变数据结构，简单易用、体量小巧、设计巧妙，满足了我们对JS不可变数据结构的需求。  \n无奈网络上完善的文档实在太少，所以自己写了一份，本篇文章以贴近实战的思路和流程，对 Immer 进行了全面的讲解。\n\n## 目录\n\n-   [数据处理存在的问题](#数据处理存在的问题)\n-   [解决引用类型对象被修改的办法](#解决引用类型对象被修改的办法)\n-   [immer功能介绍](#immer功能介绍)\n    - [安装immer](#安装immer)\n    - [immer如何fix掉那些不爽的问题](#immer如何fix掉那些不爽的问题)\n    - [概念说明](#概念说明)\n    - [常用api介绍](#常用api介绍)\n-   [用immer优化react项目的探索](#用immer优化react项目的探索)\n    - [抛出需求](#抛出需求)\n    - [优化setState方法](#优化setState方法)\n    - [优化reducer](#优化reducer)\n-   [参考文档](#参考文档)\n\n---\n<!--more-->\n\n## 数据处理存在的问题\n\n先定义一个初始对象，供后面例子使用：\n首先定义一个`currentState`对象，后面的例子使用到变量`currentState`时，如无特殊声明，都是指这个`currentState`对象\n```javascript\nlet currentState = {\n  p: {\n    x: [2],\n  },\n}\n```\n\n哪些情况会一不小心修改原始对象？\n\n```javascript\n// Q1\nlet o1 = currentState;\no1.p = 1; // currentState 被修改了\no1.p.x = 1; // currentState 被修改了\n\n// Q2\nfn(currentState); // currentState 被修改了\nfunction fn(o) {\n  o.p1 = 1;\n  return o;\n};\n\n// Q3\nlet o3 = {\n  ...currentState\n};\no3.p.x = 1; // currentState 被修改了\n\n// Q4\nlet o4 = currentState;\no4.p.x.push(1); // currentState 被修改了\n```\n\n## 解决引用类型对象被修改的办法\n\n1. 深度拷贝，但是深拷贝的成本较高，会影响性能；\n2. [ImmutableJS](https://github.com/facebook/immutable-js)，非常棒的一个不可变数据结构的库，可以解决上面的问题，But，跟 Immer 比起来，ImmutableJS 有两个较大的不足：  \n  - 需要使用者学习它的数据结构操作方式，没有 Immer 提供的使用原生对象的操作方式简单、易用；\n  - 它的操作结果需要通过`toJS`方法才能得到原生对象，这使得在操作一个对象的时候，时刻要主要操作的是原生对象还是 ImmutableJS 的返回结果，稍不注意，就会产生意想不到的 bug。\n\n看来目前已知的解决方案，我们都不甚满意，那么 Immer 又有什么高明之处呢？\n\n## immer功能介绍\n\n### 安装immer\n\n欲善其事必先利其器，安装 Immer 是当前第一要务\n\n```shell\nnpm i --save immer\n```\n\n### immer如何fix掉那些不爽的问题\n\nFix Q1、Q3\n```js\nimport produce from 'immer';\nlet o1 = produce(currentState, draft => {\n  draft.p.x = 1;\n})\n```\n\nFix Q2\n```js\nimport produce from 'immer';\nfn(currentState); // currentState 被修改了\nfunction fn(o) {\n  return produce(o, draft => {\n    draft.p1 = 1;\n  })\n};\n```\n\nFix Q4\n```js\nimport produce from 'immer';\nlet o4 = produce(currentState, draft => {\n  draft.p.x.push(1);\n})\n```\n\n是不是使用非常简单，通过小试牛刀，我们简单的了解了 Immer ，下面将对 Immer 的常用 api 分别进行介绍。\n\n\n### 概念说明\n\nImmer 涉及概念不多，在此将涉及到的概念先行罗列出来，阅读本文章过程中遇到不明白的概念，可以随时来此处查阅。\n\n- currentState  \n  被操作对象的最初状态\n\n- draftState  \n  根据 currentState 生成的草稿状态，它是 currentState 的代理，对 draftState 所做的任何修改都将被记录并用于生成 nextState 。在此过程中，currentState 将不受影响\n\n- nextState  \n  根据 draftState 生成的最终状态\n\n- produce 生产  \n  用来生成 nextState 或 producer 的函数\n\n- producer 生产者  \n  通过 produce 生成，用来生产 nextState ，每次执行相同的操作\n\n- recipe 生产机器  \n  用来操作 draftState 的函数\n\n\n### 常用api介绍\n\n使用 Immer 前，请确认将`immer`包引入到模块中\n\n```js\nimport produce from 'immer'\n```\nor  \n```js\nimport { produce } from 'immer'\n```\n\n这两种引用方式，produce 是完全相同的\n\n#### produce\n\n*备注：出现`PatchListener`先行跳过，后面章节会做介绍*\n\n##### 第1种使用方式：\n\n语法：  \n`produce(currentState, recipe: (draftState) => void | draftState, ?PatchListener): nextState`\n\n例子1：\n```js\nlet nextState = produce(currentState, (draft) => {\n\n})\n\ncurrentState === nextState; // true\n```\n\n例子2：\n```js\nlet currentState = {\n  a: [],\n  p: {\n    x: 1\n  }\n}\n\nlet nextState = produce(currentState, (draft) => {\n  draft.a.push(2);\n})\n\ncurrentState.a === nextState.a; // false\ncurrentState.p === nextState.p; // true\n```\n\n由此可见，对 draftState 的修改都会反应到 nextState 上，而 Immer 使用的结构是共享的，nextState 在结构上又与 currentState 共享未修改的部分，共享效果如图：\n\n![change-tree](http://cdn.mydearest.cn/blog/images/change-tree.gif)\n\n##### 自动冻结功能\n\nImmer 还在内部做了一件很巧妙的事情，那就是通过 produce 生成的 nextState 是被冻结（freeze）的，（Immer 内部使用`Object.freeze`方法，只冻结 nextState 跟 currentState 相比修改的部分），这样，当直接修改 nextState 时，将会报错。\n这使得 nextState 成为了真正的不可变数据。\n\n例子：\n```js\nlet nextState = produce(currentState, (draft) => {\n  draft.p.x.push(2);\n})\n\ncurrentState === nextState; // true\n```\n\n##### 第2种使用方式\n\n利用高阶函数的特点，提前生成一个生产者 producer\n\n语法：  \n`produce(recipe: (draftState) => void | draftState, ?PatchListener)(currentState): nextState`\n\n例子：\n```js\nlet producer = produce((draft) => {\n  draft.x = 2\n});\nlet nextState = producer(currentState);\n```\n\n\n##### recipe的返回值\n\nrecipe 是否有返回值，nextState 的生成过程是不同的：  \nrecipe 没有返回值时：nextState 是根据 recipe 函数内的 draftState 生成的；  \nrecipe 有返回值时：nextState 是根据 recipe 函数的返回值生成的；  \n\n```js\nlet nextState = produce(\n  currentState, \n  (draftState) => {\n    return {\n      x: 2\n    }\n  }\n)\n```\n\n此时，nextState 不再是通过 draftState 生成的了，而是通过 recipe 的返回值生成的。\n\n##### recipe中的this\n\n recipe 函数内部的`this`指向 draftState ，也就是修改`this`与修改 recipe 的参数 draftState ，效果是一样的。  \n**注意：此处的 recipe 函数不能是箭头函数，如果是箭头函数，`this`就无法指向 draftState 了**\n\n```js\nproduce(currentState, function(draft){\n  // 此处，this 指向 draftState\n  draft === this; // true\n})\n```\n\n#### patch补丁功能\n\n通过此功能，可以方便进行详细的代码调试和跟踪，可以知道 recipe 内的做的每次修改，还可以实现时间旅行。\n\nImmer 中，一个 patch 对象是这样的:\n```typescript\ninterface Patch {\n  op: \"replace\" | \"remove\" | \"add\" // 一次更改的动作类型\n  path: (string | number)[] // 此属性指从树根到被更改树杈的路径\n  value?: any // op为 replace、add 时，才有此属性，表示新的赋值\n}\n```\n\n语法：\n```typescript\nproduce(\n  currentState, \n  recipe,\n  // 通过 patchListener 函数，暴露正向和反向的补丁数组\n  patchListener: (patches: Patch[], inversePatches: Patch[]) => void\n)\n\napplyPatches(currentState, changes: (patches | inversePatches)[]): nextState\n```\n\n例子：\n\n```js\nimport produce, { applyPatches } from \"immer\"\n\nlet state = {\n  x: 1\n}\n\nlet replaces = [];\nlet inverseReplaces = [];\n\nstate = produce(\n  state,\n  draft => {\n    draft.x = 2;\n    draft.y = 2;\n  },\n  (patches, inversePatches) => {\n    replaces = patches.filter(patch => patch.op === 'replace');\n    inverseReplaces = inversePatches.filter(patch => patch.op === 'replace');\n  }\n)\n\nstate = produce(state, draft => {\n  draft.x = 3;\n})\nconsole.log('state1', state); // { x: 3, y: 2 }\n\nstate = applyPatches(state, replaces);\nconsole.log('state2', state); // { x: 2, y: 2 }\n\nstate = produce(state, draft => {\n  draft.x = 4;\n})\nconsole.log('state3', state); // { x: 4, y: 2 }\n\nstate = applyPatches(state, inverseReplaces);\nconsole.log('state4', state); // { x: 1, y: 2 }\n```\n\n`state.x`的值4次打印结果分别是：`3、2、4、1`，实现了时间旅行，\n可以分别打印`patches`和`inversePatches`看下，\n\n`patches`数据如下：\n```js\n[\n  {\n    op: \"replace\",\n    path: [\"x\"],\n    value: 2\n  },\n  {\n    op: \"add\",\n    path: [\"y\"],\n    value: 2\n  },\n]\n```\n\n`inversePatches`数据如下：\n```js\n[\n  {\n    op: \"replace\",\n    path: [\"x\"],\n    value: 1\n  },\n  {\n    op: \"remove\",\n    path: [\"y\"],\n  },\n]\n```\n\n可见，`patchListener`内部对数据操作做了记录，并分别存储为正向操作记录和反向操作记录，供我们使用。\n\n至此，Immer 的常用功能和 api 我们就介绍完了。\n\n接下来，我们看如何用 Immer ，提高 React 、Redux 项目的开发效率。\n\n\n## 用immer优化react项目的探索\n\n首先定义一个`state`对象，后面的例子使用到变量`state`或访问`this.state`时，如无特殊声明，都是指这个`state`对象\n```js\nstate = {\n  members: [\n    {\n      name: 'ronffy',\n      age: 30\n    }\n  ]\n}\n```\n\n### 抛出需求\n\n就上面定义的`state`，我们先抛一个需求出来，好让后面的讲解有的放矢：  \n**members 成员中的第1个成员，年龄增加1岁**\n\n### 优化setState方法\n\n#### 错误示例\n\n```js\nthis.state.members[0].age++;\n```\n只所以有的新手同学会犯这样的错误，很大原因是这样操作实在是太方便了，以至于忘记了操作 State 的规则。\n\n下面看下正确的实现方法\n\n#### setState的第1种实现方法\n\n```js\nconst { members } = this.state;\nthis.setState({\n  members: [\n    {\n      ...members[0],\n      age: members[0].age + 1,\n    },\n    ...members.slice(1),\n  ]\n})\n```\n\n#### setState的第2种实现方法\n\n```js\nthis.setState(state => {\n  const { members } = state;\n  return {\n    members: [\n      {\n        ...members[0],\n        age: members[0].age + 1,\n      },\n      ...members.slice(1)\n    ]\n  }\n})\n```\n\n以上2种实现方式，就是`setState`的两种使用方法，相比大家都不陌生了，所以就不过多说明了，接下来看下，如果用 Immer 解决，会有怎样的烟火？\n\n#### 用immer更新state\n\n```js\nthis.setState(produce(draft => {\n  draft.members[0].age++;\n}))\n```\n\n是不是瞬间代码量就少了很多，阅读起来舒服了很多，而且更易于阅读了。\n\n### 优化reducer\n\n#### immer的produce的拓展用法\n\n在开始正式探索之前，我们先来看下 produce [第2种使用方式](#第2种使用方式)的拓展用法:\n\n例子：\n```js\nlet obj = {};\n\nlet producer = produce((draft, arg) => {\n  obj === arg; // true\n});\nlet nextState = producer(currentState, obj);\n```\n\n相比 produce 第2种使用方式的例子，多定义了一个`obj`对象，并将其作为 producer 方法的第2个参数传了进去；可以看到， produce 内的 recipe 回调函数的第2个参数与`obj`对象是指向同一块内存。  \nok，我们在知道了 produce 的这种拓展用法后，看看能够在 Redux 中发挥什么功效?\n\n#### 普通reducer怎样解决上面抛出的需求\n\n```js\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'ADD_AGE':\n      const { members } = state;\n      return {\n        ...state,\n        members: [\n          {\n            ...members[0],\n            age: members[0].age + 1,\n          },\n          ...members.slice(1),\n        ]\n      }\n    default:\n      return state\n  }\n}\n```\n\n#### 集合immer,reducer可以怎样写\n\n```js\nconst reducer = (state, action) => produce(state, draft => {\n  switch (action.type) {\n    case 'ADD_AGE':\n      draft.members[0].age++;\n  }\n})\n```\n\n可以看到，通过 produce ，我们的代码量已经精简了很多；  \n不过仔细观察不难发现，利用 produce 能够先制造出 producer 的特点，代码还能更优雅：\n\n```js\nconst reducer = produce((draft, action) => {\n  switch (action.type) {\n    case 'ADD_AGE':\n      draft.members[0].age++;\n  }\n})\n```\n\n好了，至此，Immer 优化 reducer 的方法也讲解完毕。\n\nImmer 的使用非常灵活，多多思考，相信你还可以发现 Immer 更多其他的妙用！\n\n\n## 参考文档\n\n- [官方文档](https://github.com/mweststrate/immer)\n- [Introducing Immer: Immutability the easy way](https://hackernoon.com/introducing-immer-immutability-the-easy-way-9d73d8f71cb3)\n","tags":["解决方案"],"categories":["工具"]},{"title":"鼠标点击爱心和富强特效","url":"%2F2020%2F%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E7%88%B1%E5%BF%83%E5%92%8C%E5%AF%8C%E5%BC%BA%E7%89%B9%E6%95%88.html","content":"\n## 爱心\n```js\n!function(e, t, a) {\n    function r() {\n        for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = \"left:\" + s[e].x + \"px;top:\" + s[e].y + \"px;opacity:\" + s[e].alpha + \";transform:scale(\" + s[e].scale + \",\" + s[e].scale + \") rotate(45deg);background:\" + s[e].color + \";z-index:99999\");\n        requestAnimationFrame(r)\n    }\n    function n() {\n        var t = \"function\" == typeof e.onclick && e.onclick;\n        e.onclick = function(e) {\n            t && t(),\n            o(e)\n        }\n    }\n    function o(e) {\n        var a = t.createElement(\"div\");\n        a.className = \"heart\",\n        s.push({\n            el: a,\n            x: e.clientX - 5,\n            y: e.clientY - 5,\n            scale: 1,\n            alpha: 1,\n            color: c()\n        }),\n        t.body.appendChild(a)\n    }\n    function i(e) {\n        var a = t.createElement(\"style\");\n        a.type = \"text/css\";\n        try {\n            a.appendChild(t.createTextNode(e))\n        } catch(t) {\n            a.styleSheet.cssText = e\n        }\n        t.getElementsByTagName(\"head\")[0].appendChild(a)\n    }\n    function c() {\n        return \"rgb(\" + ~~ (255 * Math.random()) + \",\" + ~~ (255 * Math.random()) + \",\" + ~~ (255 * Math.random()) + \")\"\n    }\n    var s = [];\n    e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame ||\n    function(e) {\n        setTimeout(e, 1e3 / 60)\n    },\n    i(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),\n    n(),\n    r()\n} (window, document);\n```\n---\n<!--more-->\n\n## 富强\n```js\n//定义获取词语下标\nvar a_idx = 0;\njQuery(document).ready(function($) {\n    //点击body时触发事件\n    $(\"body\").click(function(e) {\n    //需要显示的词语\n    var a = new Array(\"富强\",\"民主\", \"文明\", \"和谐\",\"自由\", \"平等\", \"公正\",\"法治\", \"爱国\", \"敬业\",\"诚信\", \"友善\");\n    //设置词语给span标签\n    var $i = $(\"<span/>\").text(a[a_idx]);\n    //下标等于原来下标+1  余 词语总数\n    a_idx = (a_idx + 1)% a.length;\n    //获取鼠标指针的位置，分别相对于文档的左和右边缘。\n    //获取x和y的指针坐标\n    var x = e.pageX, y = e.pageY;\n    //在鼠标的指针的位置给$i定义的span标签添加css样式\n    $i.css({\"z-index\" : 999999999999999999999999999999999999999999999999999999999999999999999,\n        \"top\" : y - 20,\n        \"left\" : x,\n        \"position\" : \"absolute\",\n        \"font-weight\" : \"bold\",\n        \"color\" : \"#ff6651\"\n        });\n    //在body添加这个标签\n    $(\"body\").append($i);\n        //animate() 方法执行 CSS 属性集的自定义动画。\n        //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。\n        //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp\n        $i.animate({\n        //将原来的位置向上移动180\n            \"top\" : y - 180,\n                \"opacity\" : 0\n         //1500动画的速度\n        }, 1500, function() {\n        //时间到了自动删除\n            $i.remove();\n        });\n    });\n});\n```\n\n## 加入收藏\n```js\n// <a href=\"javascript:void(0)\" onclick=\"shoucang(document.title,window.location)\">加入收藏</a>\n\nfunction shoucang(sTitle, sURL) {\n    try {\n        window.external.addFavorite(sURL, sTitle);\n    }\n    catch (e) {\n        try {\n            window.sidebar.addPanel(sTitle, sURL, \"\");\n        }\n        catch (e) {\n            alert(\"加入收藏失败，请使用Ctrl+D进行添加\");\n        }\n    }\n}\n```\n\n## 设为首页\n```js\n// <a href=\"javascript:void(0)\" onclick=\"SetHome(this,window.location)\">设为首页</a>\n\nfunction SetHome(obj, vrl) {\n    try {\n        obj.style.behavior = 'url(#default#homepage)'; obj.setHomePage(vrl);\n    }\n    catch (e) {\n        if (window.netscape) {\n            try {\n                netscape.security.PrivilegeManager.enablePrivilege(\"UniversalXPConnect\");\n            }\n            catch (e) {\n                alert(\"此操作被浏览器拒绝！\\n请在浏览器地址栏输入“about:config”并回车\\n然后将 [signed.applets.codebase_principal_support]的值设置为'true',双击即可。\");\n            }\n            var prefs = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefBranch);\n            prefs.setCharPref('browser.startup.homepage', vrl);\n        } else {\n            alert(\"您的浏览器不支持，请按照下面步骤操作：1.打开浏览器设置。2.点击设置网页。3.输入：\" + vrl + \"点击确定。\");\n        }\n    }\n}\n```\n\n## 图片不存在显示默认图片\n- 分析：特别注意 onerror，当图片不存在时，将触发 onerror，而 onerror 中为 img 指定一个默认图片。也就是说图片存在则显示 pic.gif，图片不存在将显示默认图片。\n\n- 存在的问题：如果默认图片也不存在，则继续触发 onerror，导致循环，故出现错误。如果图片存在，但网络很不通畅，也可能触发 onerror。\n```js\n<img src=\"abc.jpg\" οnerrοr=\"nofind()\" />\n<script type=\"text/javascript\">\nfunction nofind(){\n  var img=event.srcElement;\n  img.src=\"def\"; //替换的图片\n  img.οnerrοr=null; //控制不要一直触发错误\n}\n</script>\n```\n","tags":["源码"],"categories":["JS"]},{"title":"实现compose","url":"%2F2020%2F%E5%AE%9E%E7%8E%B0compose.html","content":"\n实现compose函数的五种思路\n\n- 面向过程\n- 函数组合（reduce）\n- 函数交织（AOP编程）\n- Promise（sequence）\n- Generator（yield）\n\n---\n<!--more-->\n\n## 什么是compose\n\ncompose就是执行一系列的任务（函数），比如有以下任务队列：\n```js\nlet tasks = [step1, step2, step3, step4]\n```\n\n每一个step都是一个步骤，按照步骤一步一步的执行到结尾，这就是一个compose。\n\n- 第一个函数是多元的（接受多个参数），后面的函数都是单元的（接受一个参数）\n- 执行顺序的自右向左的\n- 所有函数的执行都是同步的（异步的后面文章会讲到）\n\n举个例子:\n```js\nlet init = (...args) => args.reduce((ele1, ele2) => ele1 + ele2, 0)\nlet step2 = (val) => val + 2\nlet step3 = (val) => val + 3\nlet step4 = (val) => val + 4\n\n// 组成任务队列\nsteps = [step4, step3, step2, init]\n// 使用compose组合这个队列并执行\nlet composeFunc = compose(...steps)\nconsole.log(composeFunc(1, 2, 3))\n```\n\n执行过程\n> 6 -> 6 + 2 = 8 -> 8 + 3 = 11 -> 11 + 4 = 15\n\n所以流程就是从init自右到左依次执行，下一个任务的参数是上一个任务的返回结果，并且任务都是同步的，这样就能保证任务可以按照有序的方向和有序的时间执行。\n\n## 实现compose的五种思路\n\n### 面向过程\n\n这个思路就是使用递归的过程思想，不断的检测队列中是否还有任务，如果有任务就执行，并把执行结果往后传递，这里是一个局部的思维，无法预知任务何时结束。直观上最容易结束和理解。\n\n```js\nconst compose = function(...args) {\n  let length = args.length\n  let count = length - 1\n  let result\n  return function f1 (...arg1) {\n    result = args[count].apply(this, arg1)\n    if (count <= 0) {\n      count = length - 1\n      return result\n    }\n    count--\n    return f1.call(null, result)\n  }\n}\n```\n\n### 函数组合\n这个思路是一种函数组合的思想，将函数两两组合，不断的生成新的函数，生成的新函数挟裹了函数执行的逻辑信息，然后再两两组合，不断的传递下去，这种思路可以提前遍历所有任务，将任务组合成一个可以展开的组合结构，最后执行的时候就像推导多米诺骨牌一样。\n```js\n// 组合过程\nf1 = (...arg) => step2.call(null, init.apply(null, arg))\nf2 = (...arg) => step3.call(null, f1.apply(null, arg))\nf3 = (...arg) => step4.call(null, f2.apply(null, arg))\n\n// 实现\nconst _pipe = (f, g) => (...arg) => g.call(null, f.apply(null, arg))\nconst compose = (...args) => args.reverse().reduce(_pipe, args.shift())\n```\n\n### 函数交织（AOP）\n这个实现的灵感来自javascript设计模式中的高阶函数，因为compose的任务在本质上就是函数执行，再加上顺序，所以可以把实现顺序执行放到函数本身，对函数的原型进行方法的绑定。方法的作用对象是函数，面向对象封装的数据，面向函数封装的是函数的行为。\n\n需要对函数绑定两个行为 before 和 after，before执行函数多元部分（启动），after执行函数单元部分。\n```js\nFunction.prototype.before = function(fn) {\n  const self = this\n  return function(...args) {\n    let result = fn.apply(null, args)\n    return self.call(null, result)\n  }\n}\n \nFunction.prototype.after = function(fn) {\n  const self = this\n  return function(...args) {\n    let result = self.apply(null, args)\n    return fn.call(null, result)\n  }\n}\n```\n这里对函数进行方法的绑定，返回的是带着函数执行的规则的另外一个函数，在这里是次序的排列规则，对返回的函数依然可以进行链式调用。\n```js\n// compose实现\nconst compose = function(...args) {\n  let before = args.pop()\n  let start = args.pop()\n  if (args.length) {\n    return args.reduce(function(f1, f2) {\n      return f1.after(f2)\n    }, start.before(before))\n  }\n  return start.before(before)\n}\n\n// 执行过程\nconst compose = function(...args) {\n  let before = args.pop()\n  let start = args.pop()\n  if (args.length) {\n    return args.reduce(function(f1, f2) {\n      return f1.after(f2)\n    }, start.before(before))\n  }\n  return start.before(before)\n}\n```\n\n### Promise\nES6引入了Promise，Promise可以指定一个sequence，来规定一个执行then的过程，then函数会等到执行完成后，再执行下一个then的处理。启动sequence可以使用Promise.resolve()这个函数。构建sequence可以使用reduce。\n```js\nconst compose = function(...args) {\n  let init = args.pop()\n  return function(...arg) {\n    return args.reverse().reduce(function(sequence, func) {\n      return sequence.then(function(result) {\n        return func.call(null, result)\n      })\n    }, Promise.resolve(init.apply(null, arg)))\n  }\n}\n```\n\n### Generator\nGenerator主要使用yield来构建协程，采用中断，处理，再中断的流程。可以事先规定好协程的执行顺序，然后再下次处理的时候进行参数（结果）交接，有一点要注意的是，由于执行的第一个next是不能传递参数的，所以第一个函数的执行需要手动调用，再空耗一个next，后面的就可以同步执行了。\n```js\n// 构建generator\nfunction* iterateSteps(steps) {\n  let n\n  for (let i = 0; i < steps.length; i++) {\n    if (n) {\n      n = yield steps[i].call(null, n)\n    } else {\n      n = yield\n    }\n  }\n}\n\n// 实现compose\nconst compose = function(...steps) {\n  let g = iterateSteps(steps)\n  return function(...args) {\n    let val = steps.pop().apply(null, args)\n    // 这里是第一个值\n    console.log(val)\n    // 因为无法传参数 所以无所谓执行 就是空耗一个yield\n    g.next()\n    return steps.reverse.reduce((val, val1) => g.next(val).value, val)\n  }\n}\n```\n","tags":["设计模式"],"categories":["JS"]},{"title":"面试经验分享","url":"%2F2020%2F%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB.html","content":"\n## 面试流程\n\n大公司面试无论是实习还是校招，普遍存在面试轮次多，面试周期长的特点，就拿腾讯来说，如果你想成为暑期实习生，大概需要四到五轮面试，3-4 轮技术面+一轮 HR 面试，每次面试时间大概在 0.5-1 小时之间，推荐对自己能力没有把握或者缺少工作经验的同学尽可能在大三下学期找找实习，去自己想去的公司实习，因为大三的暑期实习既可以丰富你的履历，并且实习期间好好表现都是可以相对容易地通过转正，拿到校招 offer。\n\n在申请实习或者校招 offer 的时候，尽可能多找人帮忙内推，因为大公司部门比较多，你如果直接从官网上网申的话，简历不容易被人查看，找认识的师兄师姐帮忙内推的优势在于：\n\n1. 能够更有效增加你的简历的曝光，让部门主管能够直接查阅到你的简历\n2. 加快面试进度，联系师兄师姐提前知道面试结果\n3. 内推或者网申(可能有笔试)完之后，就等待面试官打电话给你，一般他们会跟你通过电话或者短信确认现在是否方便或者约个时间进行面试，面试的方式也分为电话面试，视频面试，现场面试等等。\n\n---\n<!--more-->\n\n无论是哪种类型的面试，内容大致上都是一致的(除了现场面试可能要求你手写代码外)，我将专业技能面试分为以下几个部分：\n\n1. 自我介绍\n2. 计算机基础知识\n3. 前端知识\n4. 面试者提问环节\n\n### 自我介绍\n首先是自我介绍，面试前最好能够准备一段不少于 30 秒的自我介绍并对着镜子反复练习，可以介绍介绍你的名字，学校，专业，对你投递岗位的理解等等，在面试过程中尽可能流利地叙述，而不是介绍时磕磕碰碰，给面试官留下不好的印象。\n\n### 计算机基础知识\n第二部分是计算机基础知识，对于应届生来说，面试官无非喜欢考察计算机网络，操作系统，数据结构与算法这三大类。当然根据你应聘的岗位有所不同，如果你是应聘一名前端工程师，考察网络的知识相对较多，对于操作系统、数据结构和算法的考察会相对较少，如果你是应聘一个后端工程师的话，那么涉及到操作系统的知识肯定会相对更多。同理算法工程师就会涉及到更多数据结构和算法的知识。\n\n面试网络知识的话，可以多准备 HTTP/TCP 相关的知识，比如我就常被问到：\n\n> HTTP 状态码，从浏览器打开一个网址背后都经历了什么\n> TCP 与 UDP 的区别，为什么 TCP 需要三次握手，四次挥手等等\n\n### 前端知识\n\n第三大块也就是你应聘的岗位相关的知识内容了，比如拿前端来说，一般前端知识可以分为三大块：语言基础，框架以及实践。\n\n语言基础一般会考察你对 JS 语言本身的理解，比如说：闭包，继承，作用域，this 用法，ES6 语法等等，也会问你关于 HTML/CSS 的基础知识。\n\n框架的话不仅仅是局限于考察对框架的用法，一般是结合你的简历内容来进行提问，比如你在简历上写你熟悉 React，面试官可能就会问你 virtual-dom 是怎么实现的，Redux 设计思想等等，如果你简历上写熟悉 Vue，那可能就会问你数据双向绑定是怎么实现的等等。\n\n还有就是你的实践部分，这部分面试官会结合你的简历提到的一些经历，比如你有什么实习经历阿，或者在学校做过什么项目来进行提问。可能会像这样问你：\n\n> 你在这个项目中（或者实习经历）遇到最大的挑战(难题)是什么，你怎么解决的\n> 你在项目开发的过程中运用了什么技术，为什么会使用到这些技术等等\n\n### 面试者提问环节\n一般面试结束后面试官都会问你，还有什么问题想问我，这时候你可以就你感兴趣的内容进行提问，比如我一般就会问下面类型的问题：\n\n1. 如果我有幸被录用了，我会从事什么样的工作内容\n2. 团队组织结构是怎么样的，主要负责什么样的产品\n3. 工作平时加班多吗，一般几点下班\n4. 就刚才的面试来看，你觉得我有什么不足之处\n这就是标准的面试过程，面试结束后如果你通过面试的话，一般一周内会给答复或者进行下一轮面试。\n\n最后需要强调的是，公司面试周期一般都会比较长，可能你从二月底开始面试，到了四月份你才会收到 offer，所以你应该多投投几家公司，不要在一棵树上吊死，不要抱着非 xxx 公司不去的心态，因为面试这种东西其实是很玄学的，七分实力，三分运气，可能你觉得良好，但是面试官却把你 pass 掉了，所以放平常心，多试试几家公司，说不定会有意外的收获。\n\n\n## 面试准备\n前面介绍了面试流程中的一些注意事项，下面就来说说如何去做面试前的准备。我将面试准备分为三个部分：\n1. 准备简历\n2. 专业知识梳理\n3. 面试结束后\n\n### 准备简历\n我看很多人写的简历，发现他们写的都很啰嗦，让人一眼看过去抓不住重点，我建议最好把简历精简一下，控制在 1-2 页，写的经历和项目跟你应聘的岗位有强相关，无关的经历就不要写了，写了反而显得啰嗦。\n\n另外还有三点需要注意：\n\n1. 描述经历或者项目的时候尽可能描述跟自己负责的模块，无关的内容就不要写了，不然被问到了可能会问惨你\n2. 写完简历的时候最好以 pdf 的格式进行存储，这样保证面试官打开的时候排版不会乱掉\n3. 简历名称最好写成像 姓名-应聘岗位-xx大学-xx专业-手机号，这样方便 HR 保留存储你的简历，不要直接取名为简历就直接发给 HR\n\n简历是你获得面试的第一步，简历的好坏需要自己用心准备，希望同学们提前认真地准备好一份觉得让自己满意的简历，以免到时候太仓促。\n\n### 专业知识梳理\n这部分内容肯定是需要通过自己的不断积累的，不可能说你看了两天 JS 语法就跑来面试，学了两天 Java 就来面试后端工程师。\n\n我们经常会通过网上文章学习内容，我的建议：善于使用浏览器的书签帮助你自己整体知识。\n\n1. 比如说你今天看到一篇文章，但是没时间看完消化，你可以把它放到一个书签(do it later)以免之后找不到，等自己有时间了再回过头来继续看\n2. 将自己看过的，觉得不错的文章进行分类整理放在书签中，方便以后面试前可以复习\n\n网路上学习技术的途径也很多：\n\n1. 如果想看别人写的文章，可以多逛逛掘金、知乎专栏等等\n2. 如果像通过看视频来学习的话，可以通过慕课网平台，上面有不少高质量视频可以学习\n3. 遇到问题善用搜索引擎，基本上你遇到的问题都可以通过谷歌/Stackoverflow 上得到答案\n\n每个岗位都有自己不同的知识体系，在其它领域我也不是专业的，就不班门弄斧了，我就拿前端工程师角度来看，作为一名前端工程师，至少要对整体知识体系有自己的理解.\n\n### 面试结束后\n面试其实很多情况下都是很类似的，有的时候一面和二面的面试官都会问到相同的问题，所以在面试结束可以总结总结刚才面试中遇到的问题，为什么答不上来，如果是之前没准备的知识，可以去复习复习，这样下次再碰到类似的题目，你就可以对答如流了。\n\n## 最后\n祝各位同学能够找到自己满意的offer！\n","tags":["面试"],"categories":["知识"]},{"title":"观察者模式VS发布订阅模式","url":"%2F2020%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8FVS%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html","content":"\n![subscribe](http://cdn.mydearest.cn/subscribe.png)\n\n从图中可以看出：\n\n- 观察者与目标（被观察者）是直接进行交互的，包括订阅和触发。\n- 发布订阅模式是透过一个中间者当调度中心，相关的订阅与发布都由调度中心来进行协调。（适合更复杂的场景）\n\n两者的优缺点：\n\n- 观察者模式：优点就是一一对应，比较直观明了，占用内存资源容易进行回收。缺点就是两者耦合。\n- 发布订阅模式：优点就是一方面实现了发布者与订阅者之间的解耦，中间者可在两者操作之间进行更细粒度的控制。如：条件过滤发布，权限控制等等。缺点就是整一个中间调度会越来越庞大，需要手动清除里面的发布回调。\n\n举个栗子：\n\n- 观察者模式：彩票中心里，管理员充当目标对象（被观察者），彩民充当观察者，当管理员说公布一等奖号码时，即给各个观察者发布了消息，然后彩民（观察者）就收到发布消息，进行自己的后续操作（兑奖）。\n\n- 发布订阅模式：每家每户向牛奶订购中心订购了牛奶，但是各家的牛奶品牌不一样，有燕塘、蒙牛等等。当燕塘牛奶来货了，订阅中心就给订购燕塘的各家各户派发燕塘牛奶。同理，当蒙牛到货时，订阅中心发布蒙牛的牛奶。\n\n---\n<!--more-->\n\n## 观察者模式实现\n![observer](http://cdn.mydearest.cn/blog/images/observer.jpeg)\n\n首先目标对象（被观察者）称为`Subject`，有若干个观察者`Observer`进行观察。当`Subject`被某些对应事件驱动了，则通知相对应的观察者，调用其回调操作。\n\n代码实现如下：\n```js\n// 被观察者\nclass Subject {\n    constructor () {\n        this.obs = [];\n    }\n    // 添加观察者\n    addObserver (ob) {\n        this.obs.push(ob);\n    }\n    // 通知所有观察者\n    notify () {\n        this.obs.forEach(ob => {\n            ob.update();\n        });\n    }\n}\n\n// 观察者\nclass Observer{\n  update(){\n    console.log('update');\n  }\n}\n\n// 测试\nlet subject = new Subject();\nlet ob = new Observer();\n// 目标添加观察者了\nsubject.addObserver(ob);\n// 目标发布消息调用观察者的更新方法了\nsubject.notify();   //update\n```\n\n## 发布订阅模式实现\n首先要构造一个总线控制中心，负责中间操作，实现以下三个功能：\n\n- 订阅xxx消息\n- 发布xxx消息\n- 取消订阅xxx消息\n\n代码实现如下：\n```js\nconst eventProxy = {\n  onList: {},\n\n  // 订阅\n  on: function (key, fn) {\n    if (!this.onList[key]) {\n      this.onList[key] = []\n    }\n    this.onList[key].push(fn)\n  },\n\n  // 取消订阅\n  off: function(key, fn) {\n    if (!this.onList[key]) return false\n\n    let fnIndex = this.onList[key].indexOf(fn)\n    if (fnIndex === -1) return false\n    this.onList[key].splice(fnIndex, 1)\n    return true\n  },\n  \n  // 发布\n  emit: function(...args) {\n    if (!args.length) return\n\t\n    // 如果没有任何订阅则返回  \n    const key = args[0]\n    if (!this.onList[key] || !this.onList[key].length) return\n\t\n    // 发布对应的订阅事件\n    const subscriber = this.onList[key]\n    const newArgs = args.slice(1)\n    subscriber.forEach(cb => {\n      cb.apply(null, newArgs)\n    })\n  }\n}\n```\n","tags":["设计模式"],"categories":["JS"]},{"title":"Shell入门教程","url":"%2F2020%2FShell%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html","content":"\n## 脚本运行\n建立一个文本文件demo，以.sh结尾的或者不需要后缀都可以。\n```shell\n#!/bin/bash\nNUM=10\nprintf \"输出数字$NUM\\n\"\necho $NUM\n```\n\n通过sh或者bash命令运行脚本，sh scriptname 运行一个Bash脚本将会禁止所有Bash的扩展特性。\n```shell\n# 你能够运行它用命令\nsh demo\n\n# 另外也也可以用bash来执行\nbash demo\n```\n\n脚本以\"#!\"行开头，行将会命令解释器(sh或是bash)。`#!/bin/rm` 当你运行这个脚本时，除了这个脚本消失了之外，你不会发现更多其他的东西。\n\n## 注释\n以#开头的行就是注释，会被解释器忽略。注释行前面也可以有空白字符。\n```shell\n# 这是一个注释\n```\n\n## 命令分隔符\n分号;命令分割符，分割符允许在同一行里有两个或更多的命令。\n```shell\necho hello; echo there         # 输出 hello 和 there\nfilename='cosyer'               # 变量文件名\nif [ -x \"$filename\" ]; then    # 注意：\"if\" and \"then\"需要分隔符\n  echo \"File $filename exists.\"; cp $filename $filename.bak\nelse\n  echo \"File $filename not found.\"; touch $filename\nfi; echo \"File test complete.\n```\n\n## 结束符\n双分号;;，case语句分支的结束符。\n```shell\nread Keypress\ncase \"$Keypress\" in\n  [[:lower:]]   ) echo \"Lowercase letter\";;\n  [[:upper:]]   ) echo \"Uppercase letter\";;\n  [0-9]         ) echo \"Digit\";;\n  *             ) echo \"Punctuation, whitespace, or other\";;\nesac      #  允许字符串的范围出现在[]中,\n          #+ 或者POSIX风格的[[中.\nexit 0\n```\n\n---\n<!--more-->\n\n## 句号/圆点\n作为一个文件名的组成部分.，当点.以一个文件名为前缀时，起作用使该文件变成了隐藏文件。这种隐藏文件ls一般是不会显示出来的。\n\n作为目录名时，单个点（.）表示当前目录，两个点(..)表示上一级目录（或称为父目录）。\n\n点(.)字符匹配。作为正则表达式的一部分,匹配字符时，单点（.）表示匹配任意一个字符。\n\n## 引号\n引号一个很重要的作用是保护命令行上的一个参数不被shell解释，而把此参数传递给要执行的程序来处理它。\n```shell\necho \"$(ls -al)\"\n```\n\n### 单引号\n```shell\nstr='this is a string'\n```\n单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。单引号字串中不能出现单引号（对单引号使用转义符后也不行）。\n\n### 双引号\n```shell\nyour_name='cosyer'\nstr=\"Hello, I know your are \\\"$your_name\\\"! \\n\"\n```\n双引号里可以有变量，双引号里可以出现转义字符。\n\n## 命令替换\n命令替换\"`\"，将会重新分配一个命令甚至是多个命令的输出；它会将命令的输出如实地添加到另一个上下文中。\n```shell\nscript_name=`basename $0`\necho \"The name of this script is $script_name.\"\n\ntextfile_listing=`ls *`\n# 变量中包含了当前工作目录下所有的*文件\necho $textfile_listing\n```\n\n## 操作符\n\n### 赋值\n变量赋值，初始化或改变一个变量的值，通用的变量赋值操作符，可以用于数值和字符串的赋值\n```shell\nvar=27\ncategory=minerals  # \"=\"字符后面不能加空白字符.\n\n# = 用于测试操作符\nif [ \"$string1\" = \"$string2\" ]\n# if [ \"X$string1\" = \"X$string2\" ] 会更安全,\n# 它为了防止其中有一个字符串为空时产生错误信息.\n# (增加的\"X\"字符可以互相抵消.) \nthen\n   command\nfi\n```\n\n### 计算操作符\n| 操作符 | 描述 | 操作符 | 描述 | 操作符 | 描述 |\n| ---- | ---- | ---- | ---- |---- | ---- |\n| `+` | 加 | `/` | 除 | `**` | 求幂 |\n| `-` | 减 | `*` | 乘 | `%` | 求模 |\n\n```shell\n# Bash在版本2.02引入了\"**\"求幂操作符.\nlet \"z=5**3\"\necho \"z = $z\"   # z = 125\n\n# 求模（它返回整数整除一个数后的余数）\nlet \"y=5 % 3\"\necho \"y = $y\"   # y = 2\n```\n\n| 操作符 | 描述 | \n| ---- | ---- | \n| `+=` | 加等(plus-equal) 把原变量值增加一个常量并重新赋值给变量 |\n| `-=` | 减等(minus-equal) 把原变量值减少一个常量并重新赋值给变量 |\n| `*=` | 乘等(times-equal) 把原变量值乘上一个常量并重新赋值给变量 |\n| `/=` | 除等(slash-equal) 把原变量值除以一个常量并重新赋值给变量 |\n| `%=` | 模等(mod-equal) 把原变量值除以一个常量整除（即取模）并重新赋余数的值给变量 |\n\n```shell\nlet \"var += 5\" # 会使变量var值加了5并把值赋给var.\nlet \"var *= 4\" # 使变量var的值乘上4并把值赋给var.\n```\n\n### 位操作符\n位操作符很少在脚本中使用。他们主要用于操作和测试从端口或sockets中读到的数据。“位运算”更多地用于编译型的语言，比如说C和C++，它们运行起来快地像飞。\n\n| 操作符 | 描述 | 操作符 | 描述 |\n| ---- | ---- | ---- | ---- |\n| `<<` | 位左移（每移一位相当乘以2） | `|` | 位或 |\n| `<<=` | 位左移赋值 | `|=` | 位或赋值 |\n| `>>` | 位右移（每移一位相当除以2） | `~` | 位反 |\n| `>>=` | \"位右移赋值\"（和<<=相反） | `!` | 位非 |\n| `&` | 位与 | `^` | 位或 |\n| `&=` | 位于赋值 | `^=` | 位或赋值 |\n\n\n```shell\n# <<=\n# \"位左移赋值\"\nlet \"var <<= 2\" 结果使var的二进制值左移了二位（相当于乘以4）\n```\n\n### 逻辑操作符\n\n逻辑与`&&`\n\n```shell\nif [ $condition1 ] && [ $condition2 ]\n# 等同于:  if [ $condition1 -a $condition2 ]\n# 如果condition1和condition2都为真则返回真...\nfi;\n\nif [[ $condition1 && $condition2 ]]    # Also works.\n# 注意&&操作不能在[ ... ]结构中使用.\nfi;\n```\n\n逻辑或`||`\n\n```shell\nif [ $condition1 ] || [ $condition2 ]\n# 等同于:  if [ $condition1 -o $condition2 ]\n# 如果condition1和condition2有一个为真则返回真...\nfi;\nif [[ $condition1 || $condition2 ]]    # Also works.\n# 注意||操作不能在[ ... ]结构中使用.\nfi;\n```\n\n使用&&和||进行混合条件测试。在算术计算的环境中，&&和||操作符也可以使用。\n\n```shell\necho $(( 1 && 2 )) $((3 && 0)) $((4 || 0)) $((0 || 0))\n# 1 0 1 0\n```\n\n### 逗号操作符\n\n逗号`,`操作符连接两个或更多的算术操作。所有的操作都被求值(可能会有副作用)，但只返回最后一个操作的结构。\n\n```shell\nlet \"t1 = ((5 + 3, 7 - 1, 15 - 4))\"\necho \"t1 = $t1\"               # t1 = 11\n\nlet \"t2 = ((a = 9, 15 / 3))\"  # 初始化\"a\"并求\"t2\"的值.\necho \"t2 = $t2    a = $a\"     # t2 = 5    a = 9\n```\n\n## 变量\n\n变量，是脚本编程中的如何进行数据表现的办法。它们可以在算术计算中作为操作数，在一个字符串表达式中作为符号表达抽象的意义或是其他的其它意义。变量是表示计算机内存中保存一种数据需要占的一个位置或一组的位置的标识。\n\n### 变量值\n\n如果variable1是一个变量的名字，那么$variable1就是引用这个变量的值――即这个变量它包含的数据。\n\n```shell\nt1=12\necho $t1\n```\n\n一个未初始化的变量有一个”null”值――表示从没有被赋值过（注意null值不等于零）。在一个变量从未赋值之前就使用它通常会引起问题。然而，仍然有可能在执行算术计算时使用一个未初始化的变量。\n\n```shell\necho \"$uninitialized\"      # (blank line)\nlet \"uninitialized += 5\"   # Add 5 to it.\necho \"$uninitialized\"      # 5\n\n#  结论:\n#  一个未初始化的变量没有值，\n#  但是似乎它在算术计算中的值是零。\n#  这个无法证实（也可能是不可移植）的行为。\n```\n\n### 定义变量\n\n```shell\n# 变量名不加美元符号\nyour_var=\"elaine\"\n# 重新定义\nyour_var=\"newname\"\n```\n\n**注意⚠️**\n\n1. 首个字符必须为字母（a-z，A-Z）。\n1. 中间不能有空格，可以使用下划线（_），等号左右也不能有空格。\n1. 不能使用标点符号。\n1. 不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n### 只读变量\n\n```shell\n#!/bin/bash\ngithub=\"https://jaywcjlove.github.io\"\nreadonly github\ngithub=\"https://www.github.com\"\n\n# 运行脚本，结果如下：\n/bin/sh: NAME: This variable is read only.\n```\n\n### 使用变量\n\n```shell\nyour_var=\"github\"\necho $your_var\necho ${your_var}\necho \"your name is ${your_var}-l\"\n```\n\n### 删除变量unset\n\n变量被删除后不能再次使用。unset 命令不能删除只读变量。\n\n```shell\nmyUrl=\"https://jaywcjlove.github.io\"\nunset myUrl\necho $myUrl\n```\n\n### 变量类型\n\n不同与许多其他的编程语言，Bash不以\"类型\"来区分变量。本质上来说，Bash变量是字符串，但是根据环境的不同，Bash允许变量有整数计算和比较。其中的决定因素是变量的值是不是只含有数字。\n\n1. **局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。\n2. **环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。\n3. **shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行\n\n### 内部变量\n\n| 内部变量 | 说明 |\n| ---- | ---- |\n| $BASH | Bash二进制程序文件的路径 |\n| $BASH_ENV | 该环境变量保存一个Bash启动文件路径，当启动一个脚本程序时会去读该环境变量指定的文件。 |\n| $BASH_SUBSHELL | 一个指示子shell(subshell)等级的变量。它是Bash版本3新加入的。 |\n| $BASH_VERSINFO[n] | 这个数组含有6个元素，指示了安装的Bash版本的信息。它和$BASH_VERSION相似，但它们还是有一些小小的不同。|\n| $BASH_VERSION | 安装在系统里的Bash版本。|\n| $DIRSTACK | 在目录堆栈里面最顶端的值(它受pushd和popd的控制) |\n| $EDITOR | 由脚本调用的默认的编辑器，一般是vi或是emacs。 |\n| $EUID | 有效用户ID | \n| $FUNCNAME | 当前函数的名字 |\n| $GLOBIGNORE | 由通配符(globbing)扩展的一列文件名模式。|\n| $GROUPS | 目前用户所属的组|\n| $HOME | 用户的家目录，通常是/home/username |\n| $HOSTNAME | 在系统启动时由一个初始化脚本中用hostname命令给系统指派一个名字。然而，gethostname()函数能设置Bash内部变量E$HOSTNAME。|\n| $HOSTTYPE | 机器类型，像$MACHTYPE一样标识系统硬件。|\n| $IFS | 内部字段分隔符 |\n| $IGNOREEOF | 忽略EOF：在退出控制台前有多少文件结尾标识（end-of-files,control-D）会被shell忽略。|\n| $LC_COLLATE | 它常常在.bashrc或/etc/profile文件里被设置，它控制文件名扩展和模式匹配的展开顺序。|\n| $LINENO | 这个变量表示在本shell脚本中该变量出现时所在的行数。它只在脚本中它出现时有意义，它一般可用于调试。|\n| $MACHTYPE | 机器类型，识别系统的硬件类型。|\n| $OLDPWD | 上一次工作的目录(\"OLD-print-working-directory\",你上一次进入工作的目录)|\n| $TZ | 时区 |\n| $MAILCHECK | 每隔多少秒检查是否有新的信件 |\n| $OSTYPE | 操作系统类型 |\n| $MANPATH man | 指令的搜寻路径 |\n| $PATH | 可执行程序文件的搜索路径。一般有/usr/bin/, /usr/X11R6/bin/, /usr/local/bin,等等。|\n| $PIPESTATUS | 此数组变量保存了最后执行的前台管道的退出状态。相当有趣的是，它不一定和最后执行的命令的退出状态一样。|\n| $PPID | 一个进程的$PPID变量保存它的父进程的进程ID(pid)。用这个变量和pidof命令比较。|\n| $PROMPT_COMMAND | 这个变量在主提示符前($PS1显示之前)执行它的值里保存的命令。|\n| $PS1 | 这是主提示符（第一提示符），它能在命令行上看见。|\n| $PS2 | 副提示符（第二提示符），它在期望有附加的输入时能看见。它显示像\">\"的提示。|\n| $PS3 | 第三提示符。它在一个select循环里显示 (参考例子 10-29)。|\n| $PS4 | 第四提示符，它在用-x选项调用一个脚本时的输出的每一行开头显示。它通常显示像\"+\"的提示。|\n| $PWD | 工作目录(即你现在所处的目录) ，它类似于内建命令pwd。|\n| $REPLY | 没有变量提供给read命令时的默认变量．这也适用于select命令的目录，但只是提供被选择的变量项目编号而不是变量本身的值。 |\n| $SECONDS | 脚本已运行的秒数。|\n| $SHELLOPTS | 已经激活的shell选项列表，它是一个只读变量。|\n| $SHLVL | SHELL的嵌套级别．指示了Bash被嵌套了多深．在命令行里，$SHLVL是1，因此在一个脚本里，它是2 |\n| $TMOUT | 如果$TMOUT环境变量被设为非零值时间值time，那么经过time这么长的时间后，shell提示符会超时．这将使此shell退出登录 |\n| $UID | 用户ID号，这是当前用户的用户标识号，它在/etc/passwd文件中记录。|\n\n### 位置参数\n\n| 参数处理 | 说明 |\n| ---- | ---- |\n| `$#` | 传递到脚本的参数个数 |\n| `$*` | 以一个单字符串显示所有向脚本传递的参数。如\"∗\"用「\"」括起来的情况、以\"1 2…n\"的形式输出所有参数。 |\n| `$$` | 脚本运行的当前进程ID号 |\n| `$!` | 后台运行的最后一个进程的ID号 |\n| `$@` | 与∗相同，但是使用时加引号，并在引号中返回每个参数。如\"@\"用「\"」括起来的情况、以\"1\"\"2\" … \"$n\" 的形式输出所有参数。 |\n| `$-` | 显示Shell使用的当前选项，与set命令功能相同。 |\n| `$?` | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |\n\n### 字串移动\n\n`${string#substring}`从$string左边开始，剥去最短匹配$substring子串。  \n`${string##substring}`从$string左边开始，剥去最长匹配$substring子串。  \n`${string%substring}` 从$string结尾开始，剥去最短匹配$substring子串。  \n`${string%%substring}`从$string结尾开始，剥去最长匹配$substring子串。  \n\n```shell\nString=abcABC123ABCabc\n#       ├----┘     ┆\n#       └----------┘\n\necho ${String#a*C}      # 123ABCabc\n# 剥去匹配'a'到'C'之间最短的字符串.\n\necho ${String##a*C}     # abc\n# 剥去匹配'a'到'C'之间最长的字符串.\n\n\nString=abcABC123ABCabc\n#       ┆           ||\n#       └------------┘\n\necho ${String%b*c}      # abcABC123ABCa\n# 从$String后面尾部开始，剥去匹配'a'到'C'之间最短的字符串.\n\necho ${String%%b*c}     # a\n# 从$String后面尾部开始，剥去匹配'a'到'C'之间最长的字符串.\n```\n\n### 用awk处理字符串\n\nBash脚本可以调用awk的字符串操作功能来代替它自己内建的字符串操作符\n\n```shell\nString=23skidoo1\n#      012345678    Bash\n#      123456789    awk\n# 注意上面两个程序对索引的不同处理:\n# Bash把字符串的第一个字符的标号称为'0'。\n# Awk把字符串的第一个字符的标号称为'1'。\n\necho ${String:2:4} # position 3 (0-1-2), 4 characters long\n                                         # skid\n\n# 在awk中与Bash的${string:pos:length}等同的是substr(string,pos,length)。\necho | awk '{ \n  print substr(\"'\"${String}\"'\",3,4)      # skid\n}'\n#  用一个空的\"echo\"由管道传一个空的输入给awk,\n#+ 这样就不必提供一个文件名给awk。\nexit 0\n```\n\n## for/while\n\n重复一些命令的代码块,如果条件不满足就退出循环。\n\n### for\n\n在循环的每次执行中，arg将顺序的存取list中列出的变量，下面是一个基本的循环结构。\n\n> for arg in [list]  \n> do   \n>    command(s)...   \n> done  \n\n每个`[list]`中的元素都可能包含多个参数，在处理参数组时，这是非常有用的，使用set命令来强制解析每个`[list]`中的元素。并且分配每个解析出来的部分到一个位置参数中。\n\n循环的一个简单例子\n\n```shell\nfor planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto\ndo\n  echo $planet  # 每个行星被单独打印在一行上.\ndone\n```\n\n### while\n\n一个while循环可以有多个判断条件，但是只有最后一个才能决定是否退出循环。然而这需要一种有点不同的循环语法。\n\n> while [condition]  \n> do   \n>   command...   \n> done  \n\n```shell\n# --------------------------\n# 简单的while循环\n# --------------------------\nvar0=0\nLIMIT=10\n\nwhile [ \"$var0\" -lt \"$LIMIT\" ]\ndo\n  echo -n \"$var0 \"        # -n 将会阻止产生新行。\n  #             ^           空格,数字之间的分隔。\n  var0=`expr $var0 + 1`   # var0=$(($var0+1))  也可以。\n                          # var0=$((var0 + 1)) 也可以。\n                          # let \"var0 += 1\"    也可以。\ndone                      # 使用其他的方法也行。\n# --------------------------\n# 多条件的while循环\n# --------------------------\nvar1=unset\nprevious=$var1\n\nwhile echo \"previous-variable = $previous\"\n      echo\n      previous=$var1\n      [ \"$var1\" != end ] # 记录之前的$var1.\n      # 这个\"while\"循环中有4个条件, 但是只有最后一个能控制循环.\n      # 退出状态由第4个条件决定.\ndo\necho \"Input variable #1 (end to exit) \"\n  read var1\n  echo \"variable #1 = $var1\"\ndone \nexit 0\n```\n\n### until\n\n这个结构在循环的顶部判断条件，并且如果条件一直为false那就一直循环下去。(与while相反)。\n\n> until [condition-is-true]  \n> do   \n>   command...   \n> done  \n\n**注意⚠️**\n\n1. until循环的判断在循环的顶部，这与某些编程语言是不同的。\n2. 与for循环一样，如果想把do和条件放在一行里，就使用\";\"。\n\n> until [condition-is-true] ; do\n\n```shell\nEND_CONDITION=end\nuntil [ \"$var1\" = \"$END_CONDITION\" ]\n# 在循环的顶部判断条件.\ndo\n  echo \"Input variable #1 \"\n  echo \"($END_CONDITION to exit)\"\n  read var1\n  echo \"variable #1 = $var1\"\ndone\nexit 0\n```\n\n### 嵌套循环\n\n嵌套循环就是在一个循环中还有一个循环，内部循环在外部循环体中。\n\n```shell\nouter=1             # 设置外部循环计数.\n# 开始外部循环.\nfor a in 1 2 3 4 5\ndo\n  echo \"Pass $outer in outer loop.\"\n  echo \"---------------------\"\n  inner=1           # 重设内部循环的计数.\n\n  # ===============================================\n  # 开始内部循环.\n  for b in 1 2 3 4 5\n  do\n    echo \"Pass $inner in inner loop.\"\n    let \"inner+=1\"  # 增加内部循环计数.\n  done\n  # 内部循环结束.\n  # ===============================================\n\n  let \"outer+=1\"    # 增加外部循环的计数.\n  echo              # 每次外部循环之间的间隔.\ndone               \n# 外部循环结束.\n\nexit 0\n```\n\n### 循环控制\n\n影响循环行为的命令 `break`， `continue`， break命令将会跳出循环，continue命令将会跳过本次循环下边的语句，直接进入下次循环。\n\n**continue：** continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。\n\n```shell\nLIMIT=19  # 上限\n\necho \"Printing Numbers 1 through 20 (but not 3 and 11).\"\n\na=0\n\nwhile [ $a -le \"$LIMIT\" ]\ndo\n  a=$(($a+1))\n  if [ \"$a\" -eq 3 ] || [ \"$a\" -eq 11 ]  # Excludes 3 and 11.\n  then\n    continue      # 跳过本次循环剩下的语句.\n  fi\n  echo -n \"$a \"   # 在$a等于3和11的时候,这句将不会执行.\ndone \n```\n\n**break：** break命令允许跳出所有循环（终止执行后面的所有循环）。\n\n下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，就要使用break命令。\n\n```shell\nwhile :\ndo\n    echo -n \"Input a number between 1 to 5: \"\n    read aNum\n    case $aNum in\n        1|2|3|4|5) echo \"Your number is $aNum!\"\n        ;;\n        *) echo \"You do not select a number between 1 to 5, game is over!\"\n            break\n        ;;\n    esac\ndone\n```\n\n⚠️ 在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：\n\n```shell\nbreak n #表示跳出第 n 层循环。\n```\n\n## case/select\n\ncase/select依靠在代码块的顶部或底部的条件判断来决定程序的分支。\n\n### case\n\ncase它允许通过判断来选择代码块中多条路径中的一条。它的作用和多个if/then/else语句相同，是它们的简化结构，特别适用于创建目录。\n\n> case \"$variable\" in   \n>   ?\"$condition1\" )   \n>   ?command...   \n>   ?;;   \n>   ?\"$condition2\" )   \n>   ?command...   \n>   ?;;   \n> esac  \n\n- 对变量使用`\"\"`并不是强制的，因为不会发生单词分离。\n- 每句测试行，都以右小括号`)`结尾。\n- 每个条件块都以两个分号结尾`;;`。\n- case块的结束以esac(case的反向拼写)结尾。\n\n```shell\nclear # 清屏.\n\necho \"          我的简历\"\necho \"          ------- \"\necho \"下面通过shell脚本输出我的简历\" \necho\necho \"[B]asicinfo, 基本信息\"\necho \"[E]ducation, 教育经历\"\necho \"[I]tskill, IT 技能\"\necho\nread person\ncase \"$person\" in\n# 注意,变量是被引用的.\n  \"B\" | \"b\" )\n  # 接受大写或小写输入.\n  echo\n  echo \"小弟调调\"\n  echo \"手  机 : 136*****13\"\n  echo \"E-mail :wowohoo@qq.com\"\n  echo \"首  页 : http://JSLite.io\"\n  ;;\n  # 注意,在每个选项后边都需要以;;结尾.\n\n  \"E\" | \"e\" )\n  # 接受大写或小写输入.\n  echo \"■ 2003年9月 到 2006年8月\"\n  echo \"----------------------------\"\n  echo \"› 学校 : 野鸟高中\"\n  echo \"› 专业 : 艺术类\"\n  echo \"› 学历 : 高中\"\n  ;;\n  # 后边的[I]tskill的信息在这里就省略了.\n          * )\n   # 默认选项.\n   # 空输入(敲RETURN).\n   echo\n   echo \"没有数据！\"\n  ;;\nesac\nexit 0\n```\n\n\n### select\n\nselect结构是建立菜单的另一种工具，这种结构是从ksh中引入的。\n\n> select variable [in list]  \n> do   \n>   ?command...   \n>   ?break   \n> done  \n\n用select来创建菜单\n\n```shell\nPS3='选择你喜欢的蔬菜: ' # 设置提示符字串.\n\necho\nselect vegetable in \"豆\" \"胡萝卜\" \"土豆\" \"洋葱\" \"芜菁甘蓝\"\ndo\n  echo\n  echo \"你最喜欢的蔬菜是 $vegetable 。\"\n  echo \"讨厌!\"\n  echo\n  break  # 如果这里没有'break'会发生什么?\ndone\nexit 0\n```\n\n如果忽略了in list列表,那么select命令将使用传递到脚本的命令行参数($@),或者是函数参数(当select是在函数中时）与忽略in list时的for语句相比较：**for variable [in list]**\n\n```shell\nPS3='选择你喜欢的蔬菜:  '\necho\nchoice_of(){\n  select vegetable\n  # [in list] 被忽略, 所以'select'用传递给函数的参数.\n  do\n    echo\n    echo \"你最喜欢的蔬菜是  $vegetable。\"\n    echo \"讨厌!\"\n    echo\n    break\n  done\n}\n\nchoice_of \"豆\" \"米饭\" \"胡萝卜\" \"土豆\" \"洋葱\" \"芜菁甘蓝\"\n#         $1   $2     $3      $4    $5     $6\n#         传递给choice_of() 函数的参数\n\nexit 0\n```\n\n## 函数\n\n和\"真正的\"编程语言一样，Bash也有函数，虽然在某些实现方面稍有些限制。 一个函数是一个子程序，用于实现一串操作的代码块(code block)，它是完成特定任务的\"黑盒子\"。 当有重复代码，当一个任务只需要很少的修改就被重复几次执行时, 这时你应考虑使用函数。\n\n```shell\nfunction function_name { \n  command... \n} \n# 或\nfunction_name () { \n  command... \n} \n```\n\n在一个函数内嵌套另一个函数也是可以的，但是不常用。\n\n```shell\nf1 (){\n  f2 (){ # nested\n    echo \"Function \\\"f2\\\", inside \\\"f1\\\".\"\n  }\n}  \nf2  #  引起错误.\n    #  就是你先\"declare -f f2\"了也没用.\n\nf1  #  什么也不做,因为调用\"f1\"不会自动调用\"f2\".\nf2  #  现在,可以正确的调用\"f2\"了,\n    #+ 因为之前调用\"f1\"使\"f2\"在脚本中变得可见了.\n```\n\n### 局部变量\n\n如果变量用local来声明，那么它只能在该变量声明的代码块(block of code)中可见，这个代码块就是局部\"范围\"。\n\n```shell\n# 在函数内部的全局和局部变量.\nfunc ()\n{\n  local loc_var=23       # 声明为局部变量.\n  echo                   # 使用内建的'local'关键字.\n  echo \"\\\"loc_var\\\" in function = $loc_var\"\n  global_var=999         # 没有声明为局部变量.\n                         # 默认为全局变量. \n  echo \"\\\"global_var\\\" in function = $global_var\"\n}  \n\nfunc\n# 现在，来看看是否局部变量\"loc_var\"能否在函数外面可见.\necho \"\\\"loc_var\\\" outside function = $loc_var\"\n                                   # $loc_var outside function = \n                                   # 不, $loc_var不是全局可访问的.\necho \"\\\"global_var\\\" outside function = $global_var\"\n                                      # $global_var outside function = 999\n                                      # $global_var 是全局可访问的.\nexit 0\n#  与In contrast to C相比, 在函数内声明的Bash变量只有在\n#+ 它被明确声明成局部的变量时才是局部的\n```\n\n⚠️ ：在函数调用之前，所有在函数内声明且没有明确声明为local的变量都可在函数体外可见\n\n```shell\nfunc (){\n  global_var=37    #  在函数还没有被调用前\n                   #+ 变量只在函数内可见. \n}                  #  函数结束\necho \"global_var = $global_var\"  # global_var =\n                                 #  函数\"func\"还没有被调用,\n                                 #+ 所以变量$global_var还不能被访问.\nfunc\necho \"global_var = $global_var\"  # global_var = 37\n                                 # 已经在函数调用时设置了值.\n```\n\n### 函数参数\n\n在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 `$n` 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数\n\n```shell\nfunWithParam(){\n    echo \"第一个参数为 $1 !\"\n    echo \"第二个参数为 $2 !\"\n    echo \"第十个参数为 $10 !\"\n    echo \"第十个参数为 ${10} !\"\n    echo \"第十一个参数为 ${11} !\"\n    echo \"参数总数有 $# 个!\"\n    echo \"作为一个字符串输出所有参数 $* !\"\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n```\n\n### 函数返回值\n\n定义一个带有return语句的函数。函数返回值在调用该函数后通过 `$?` 来获得。\n\n```shell\nfunWithReturn(){\n    echo \"这个函数会对输入的两个数字进行相加运算...\"\n    echo \"输入第一个数字: \"\n    read aNum\n    echo \"输入第二个数字: \"\n    read anotherNum\n    echo \"两个数字分别为 $aNum 和 $anotherNum !\"\n    return $(($aNum+$anotherNum))\n}\nfunWithReturn\necho \"输入的两个数字之和为 $? !\"\n\n# 这个函数会对输入的两个数字进行相加运算...\n# 输入第一个数字: \n# 1\n# 输入第二个数字: \n# 2\n# 两个数字分别为 1 和 2 !\n# 输入的两个数字之和为 3 !\n```\n\n⚠️ `$10` 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。\n\n**特殊字符用来处理参数：**\n\n| 参数处理 | 说明 |\n| ---- | ----  |\n| $# | 传递到脚本的参数个数  |\n| $* | 以一个单字符串显示所有向脚本传递的参数  |\n| $$ | 脚本运行的当前进程ID号  |\n| $! | 后台运行的最后一个进程的ID号  |\n| $@ | 与$*相同，但是使用时加引号，并在引号中返回每个参数。  |\n| $- | 显示Shell使用的当前选项，与set命令功能相同。  |\n| $? | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。  |\n\n## 测试\n\n### 测试结构\n\n一个if/then结构能包含嵌套的比较和测试。\n\n```shell\necho \"Testing \\\"false\\\"\"\nif [ \"false\" ]              #  \"false\"是一个字符串.\nthen\n  echo \"\\\"false\\\" is true.\" #+ 它被测试为真.\nelse\n  echo \"\\\"false\\\" is false.\"\nfi            # \"false\"为真.\n```\n\nElse if 和 elif\n\nelif是else if的缩写。作用是在一个if/then里嵌入一个内部的if/then结构。\n\n`[[]]`结构比Bash版本的`[]`更通用。用`[[ ... ]]`测试结构比用`[ ... ]`更能防止脚本里的许多逻辑错误。比如说，`&&`,`||`,`<`和`>`操作符能在一个`[[]]`测试里通过，但在`[]`结构会发生错误。\n\n`(( ))`结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及`[]`结构的讨论刚好相反。\n\n### 文件测试操作符\n\n如果下面的条件成立返回真。\n\n| 操作符 | 描述 |\n| ---- | ---- |\n| -e | 文件存在 |\n| -a | 文件存在，这个和-e的作用一样. 它是不赞成使用的，所以它的用处不大。 |\n| -f | 文件是一个普通文件(不是一个目录或是一个设备文件) |\n| -s | 文件大小不为零 |\n| -d | 文件是一个目录 |\n| -b | 文件是一个块设备(软盘，光驱，等等。) |\n| -c | 文件是一个字符设备(键盘，调制解调器，声卡，等等。) |\n| -p | 文件是一个管道 |\n| -h | 文件是一个符号链接 |\n| -L | 文件是一个符号链接 |\n| -S | 文件是一个socket |\n| -t | 文件(描述符)与一个终端设备相关。|\n| -r | 文件是否可读 (指运行这个测试命令的用户的读权限) |\n| -w | 文件是否可写 (指运行这个测试命令的用户的读权限) |\n| -x | 文件是否可执行 (指运行这个测试命令的用户的读权限) |\n| -g | 文件或目录的设置-组-ID(sgid)标记被设置。 |\n| -u | 文件的设置-用户-ID(suid)标志被设置 |\n| -k | 粘住位设置 |\n| -N | 文件最后一次读后被修改 |\n| f1 -nt f2 | 文件f1比f2新 |\n| f1 -ot f2 | 文件f1比f2旧 |\n| f1 -ef f2 | 文件f1和f2 是相同文件的硬链接 |\n| ! | \"非\" -- 反转上面所有测试的结果(如果没有给出条件则返回真)。|\n\n**注意⚠️**\n\n1. `-t` 这个测试选项可以用于检查脚本中是否标准输入 ([ -t 0 ])或标准输出([ -t 1 ])是一个终端。\n1. `-g` 如果一个目录的sgid标志被设置，在这个目录下创建的文件都属于拥有此目录的用户组，而不必是创建文件的用户所属的组。这个特性对在一个工作组里的同享目录很有用处。\n\n### 比较操作符\n\n二元比较操作符比较两个变量或是数值。注意整数和字符串比较的分别。\n\n**整数比较**\n\n| 比较操作符 | 描述 | 例子 |\n| ---- | ---- | ---- |\n| `-eq` | 等于 | `if [ \"$a\" -eq \"$b\" ]` |\n| `-ne` | 不等于 | `if [ \"$a\" -ne \"$b\" ]` | \n| `-gt` | 大于 | `if [ \"$a\" -gt \"$b\" ]` |\n| `-ge` | 大于等于 | `if [ \"$a\" -ge \"$b\" ]` |\n| `-lt` | 小于 | `if [ \"$a\" -lt \"$b\" ]` |\n| `-le` | 小于等于 | `if [ \"$a\" -le \"$b\" ]` |\n| `<` | 小于(在双括号里使用) | `((\"$a\" < \"$b\"))` |\n| `<=` | 小于等于 (在双括号里使用) | `((\"$a\" <= \"$b\"))` |\n| `>` | 大于 (在双括号里使用) | `((\"$a\" > \"$b\"))` |\n| `>=` | 大于等于(在双括号里使用) | `((\"$a\" >= \"$b\"))` |\n\n**字符串比较**\n\n| 比较操作符 | 描述 | 例子 |\n| ---- | ---- | ---- |\n| = | 等于 | `if [ \"$a\" = \"$b\" ]` |\n| == | 等于，它和=是同义词。 | `if [ \"$a\" == \"$b\" ]` |\n| != | 不相等，操作符在[[ ... ]]结构里使用模式匹配. | `if [ \"$a\" != \"$b\" ]` |\n| < | 小于，依照ASCII字符排列顺序，注意\"<\"字符在[ ] 结构里需要转义 | `if [[ \"$a\" < \"$b\" ]]` `if [ \"$a\" \\< \"$b\" ]` |\n| > | 大于，依照ASCII字符排列顺序，注意\">\"字符在[ ] 结构里需要转义. | `if [[ \"$a\" > \"$b\" ]]` `if [ \"$a\" \\> \"$b\" ]`| \n| -z | 字符串为\"null\"，即是指字符串长度为零。 | - |\n| -n | 字符串不为\"null\"，即长度不为零。 | - |\n\n**混合比较**\n\n| 比较操作符 | 描述 | 例子 |\n| ---- | ---- | ---- |\n| -a | 逻辑与，如果exp1和exp2都为真，则exp1 -a exp2返回真。 | `if [ \"$exp1\" -a \"$exp2\" ]` |\n| -o | 逻辑或，只要exp1和exp2任何一个为真，则exp1 -o exp2 返回真。 | `if [ \"$exp1\" -o \"$exp2\" ]` |\n\n在一个混合测试中，把一个字符串变量引号引起来可能还不够。如果$string变量是空的话，表达式`[ -n \"$string\" -o \"$a\" = \"$b\" ]`在一些Bash版本中可能会引起错误。安全的办法是附加一个外部的字符串给可能有空字符串变量比较的所有变量，`[ \"x$string\" != x -o \"x$a\" = \"x$b\" ]` (x字符可以互相抵消)\n\n## 操作字符串\n\nBash已经支持了令人惊讶的字符串操作的数量。不一致的命令语法和冗余的功能，导致真的学起来有困难。\n\n### 字符串长度\n\n```shell\nString=abcABC123ABCabc\n\necho ${#String}                 # 15\necho `expr length $String`      # 15\necho `expr \"$String\" : '.*'`    # 15\n```\n\n匹配字符串开头的字串的长度，下面两种方法的 $substring 是一个正则表达式。\n\n`expr match \"$string\" '$substring'`   \n`expr \"$string\" : '$substring'`   \n\n```shell\nString=abcABC123ABCabc\n#       └------┘\n#       \necho `expr match \"$String\" 'abc[A-Z]*.2'`   # 8\necho `expr \"$String\" : 'abc[A-Z]*.2'`       # 8\n```\n\n### 索引\n\n`expr index $string $substring` 在字符串$string中$substring第一次出现的数字位置\n\n```shell\nString=abcABC123ABCabc\necho `expr index \"$String\" C12`             # 6\n                                             # C 字符的位置.\n\necho `expr index \"$String\" 1c`              # 3\n# 'c' (in #3 position) matches before '1'.\n```\n\n### 字串提取\n\n`${string:position}` 把$string中从第$postion个字符开始字符串提取出来。如果$string是\"*\"或\"@\"，则表示从位置参数中提取第$postion后面的字符串。  \n`${string:position:length}` 把$string中$postion个字符后面的长度为$length的字符串提取出来。\n\n```shell\n# 字串提取\nString=abcABC123ABCabc\n#       0123456789.....\n#       以0开始计算.\n\necho ${String:0}                            # abcABC123ABCabc\necho ${String:1}                            # bcABC123ABCabc\necho ${String:7}                            # 23ABCabc\necho ${String:7:3}                          # 23A\n                                            # 提取的字串长为3\n\n# 有没有可能从字符串的右边结尾处提取?\n    \necho ${String:-4}                           # abcABC123ABCabc\n# 默认是整个字符串，就相当于${parameter:-default}.\n# 然而. . .\n\necho ${String:(-4)}                         # Cabc \necho ${String: -4}                          # Cabc\n# 这样,它可以工作了.\n# 圆括号或附加的空白字符可以转义$position参数.\n```\n\n## 转义字符\n\n在单个字符前面的转义符`\\`告诉shell不必特殊解释这个字符，只把它当成字面上的意思。但在一些命令和软件包里，比如说echo和sed,转义一个字符可能会引起一个相反的效果－－因为它们可能触发那个字符的特殊意思。\n\n`\\r` 回车  \n`\\n` 换行  \n`\\c` 不换行  \n`\\t` 水平制表符  \n`\\v` 垂直制表符  \n`\\a` 表示“警告”（蜂鸣或是闪动）  \n`\\\\` 反斜杠字符  \n`\\0ddd` 将自负表示成1到3的八进制数值  \n\n\n## 退出/退出状态\n\n`$?` 变量用于测试脚本中的命令执行结果非常的有用。\n\n```shell\necho hello\necho $?    # 因为上一条命令执行成功，打印0。\n\nlskdf      # 无效命令。\necho $?    # 因为上面的无效命令执行失败，打印一个非零的值。\n\nexit 113   # 返回113状态码给shell。\n           # 可以运行脚本结束后立即执行命令\"echo $?\" 检验。\n\n#  依照惯例,命令'exit 0'表示执行成功,\n#  当产生一个非零退出值时表示一个错误或是反常的条件。\n```\n\n### 变量间接引用\n\n假设一个变量的值是第二个变量的名字。这样要如何才能从第一个变量处重新获得第二个变量的值？例如，`a=letter_of_alphabet`和`letter_of_alphabet=z`，是否能由a引用得到z ? 这确实可以办到，这种技术被称为间接引用。\n\n```shell\na=letter_of_alphabet   # 变量\"a\"保存着另外一个变量的名字.\nletter_of_alphabet=z\n# 直接引用.\necho \"a = $a\"          # a = letter_of_alphabet\n\n# 间接引用.\neval a=\\$$a\necho \"Now a = $a\"      # 现在 a = z\nexit 0\n```\n\n### 双括号结构\n\n用`((...))`结构来使用C风格操作符来处理变量。[demo26](./example/demo26)\n\n```shell\n(( a = 23 ))  # 以C风格来设置一个值，在\"=\"两边可以有空格.\necho \"a (initial value) = $a\"\n\n(( a++ ))     # C风格的计算后自增.\necho \"a (after a++) = $a\"\n\n(( a-- ))     # C风格的计算后自减.\necho \"a (after a--) = $a\"\n\n\n(( ++a ))     # C风格的计算前自增.\necho \"a (after ++a) = $a\"\n\n(( --a ))     # C风格的计算前自减.\necho ","tags":["shell"],"categories":["工具"]},{"title":"Angular组件通讯","url":"%2F2020%2FAngular%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html","content":"\n组件通讯，意在不同的指令和组件之间共享信息。\n\n## 父->子 input\n```\n// parent.html\n<child [content]=\"i\"></child>\n\n// child.ts\n@Input() content:string;\n```\n\n## 子->父 output\n```\n// parent.html\n<child (changeNumber)=\"changeNumber($event)\"></child>\n\n// child.ts\n@Output() changeNumber: EventEmitter<number> = new EventEmitter();\n\nthis.changeNumber(1);\n```\n\n---\n<!-- more -->\n\n## 子获取父实例\n```\n// child.ts\nimport { Component, Input, EventEmitter, Output,Host,Inject,forwardRef } from '@angular/core';\n\nconstructor( @Host() @Inject(forwardRef(() => ParentPage)) app: ParentPage) {\n    app.content // 获取父实例的参数\n}\n```\n\n## 父获取子实例\n```\n@ViewChild(ChildPage) child:ChildPage;\n\nthis.child.content //获取子实例的参数\n```\n\n## service 公共的\n```\n// parent.ts\nimport{myService}from '../child/myService'\n\n实例化 service.i++;\n\n// child.ts\nservice.i\n```\n记得在app.module.ts 加上providers\n\n## EventEmitter(eventbus)\n```\n// eventbus.service.ts\nimport {Component,Injectable,EventEmitter} from '@angular/core';\n@Injectable()\nexport class myService {\n    change: EventEmitter<number>;\n\n    constructor(){\n        this.change = new EventEmitter();\n    }\n}\n\n// parent.ts\nservice.change.emit('123');\n\n// child.ts\nservice.change.subscribe((value:string)=>{})\n```\n\n## 订阅\n```\n// service\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\n\n@Injectable()\nexport class myService {\n\n    private Source = new Subject<any>();\n    Status$ = this.Source.asObservable();\n    StatusMission(message: any) {\n        this.Source.next(message);\n    }\n}\n// parent.ts\nthis.service.StatusMission('123');\n\n// child.ts\nthis.subscription = service.Status$.subscribe(message => {});\n\nngOnDestroy() {\n    this.subscription.unsubscribe();\n}\n```\n\n以上七种组件与组件的通讯方式，可以选择应用于适合的场景。\n\n顺带介绍下重载当前路由，在Angular中，当点击当前路由的链接时，默认是忽略的。\n\n## 糟糕的解决方案\n1. 跳出去，再跳回来。\n2. 让浏览器刷新整个页面。\n然而目前我们可以通过 `onSameUrlNavigation` 来解决这个问题。\n\n`onSameUrlNavigation` 有两个值'reload'和'ignore'。默认为'ignore'。\n- 定义当路由器收到一个导航到当前 URL 的请求时应该怎么做。 默认情况下，路由器将会忽略这次导航。但这样会阻止类似于 \"刷新\" 按钮的特性。 使用该选项可以配置导航到当前 URL 时的行为。\n\n- 路由启动配置\n```js\n// app.routing.module.ts\nimports: [RouterModule.forRoot(routes, {onSameUrlNavigation: 'reload'})]\n```\n`reload`并不会真正的执行加载工作，它只是重新触发了路由上的events事件循环。也可以动态配置reload\n```js\nthis.router.onSameUrlNavigation = 'reload';\nthis.router.navigateByUrl(this.router.url).then(() => {\n    this.router.onSameUrlNavigation = 'ignore';\n});\n```\n\n- Route配置\n一系列的路由事件在何种情况下应该被触发，此时我们需要配置 runGuardsAndResolvers 选项，它有3个可选值。\n1. paramsChange 只有当参数变化时才重新启动，例如 'article/:id'，参数指的就是这里的id。\n\n2. paramsOrQueryParamsChange 当参数或查询参数变化时重新启动。例如：'article/:category?limit=10，参数指 'category'，查询参数指'limit'；\n\n3. always 无论何种情况都重新启动\n\n```js\nexport const routes: Routes = [\n   {\n       path: 'article/:id',\n       component: ArticleComponent,\n       runGuardsAndResolvers: 'paramsChange',\n   }\n]\n```\n\n- 组件中处理路由事件\n```js\nexport class ArticleComponent implement OnInit, OnDestroy {\n   subscription: Subscription;\n   constructor(private router: Router) { }\n   ngOnInit() {\n       this.subscription = this.router.events.pipe(\n           filter(event => event instanceOf NavigationEnd)\n       ).subscribe(_ => {...}) // 执行业务操作\n   }\n   ngOnDestroy() {\n       this.subscription.unsubscribe(); // 不要忘记处理手动订阅\n   }\n}\n```","tags":["angular"],"categories":["Ng"]},{"title":"javascript设计模式","url":"%2F2019%2Fjavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","content":"\n## 概念\n设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢\n的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。\n\n## 设计原则（5个）\n\n### S – Single Responsibility Principle 单一职责原则\n- 一个程序只做好一件事\n- 如果功能过于复杂就拆分开，每个部分保持独立\n\n### O – OpenClosed Principle 开放/封闭原则\n- 对扩展开放，对修改封闭\n- 增加需求时，扩展新代码，而非修改已有代码\n\n### L – Liskov Substitution Principle 里氏替换原则\n- 子类能覆盖父类\n- 父类能出现的地方子类就能出现\n\n### I – Interface Segregation Principle 接口隔离原则\n- 保持接口的单一独立\n- 类似单一职责原则，这里更关注接口\n\n### D – Dependency Inversion Principle 依赖倒转原则\n- 面向接口编程，依赖于抽象而不依赖于具\n- 使用方只关注接口而不关注具体类的实现\n\n## 设计模式的类型\n如果从作用上来划分，JavaScript设计模式大概分为五种设计类型：\n\n| 创建型设计模式 | 结构型设计模式|行为型设计模式|技巧型设计模式|架构型设计模式|\n|:--------|:---------|:---------|:---------|:---------|\n| 简单工厂模式 | 外观模式 |模板方法模式|链模式|同步模块|\n| 工厂方法模式 |适配器模式|观察者模式|委托模式|异步模块模式|\n| 抽象工厂模式 |代理模式|状态模式|数据访问对象模式|Widget模式|\n| 建造者模式 |装饰者模式|策略模式|节流模式|MVC模式|\n| 原型模式 |桥接模式|职责链模式|简单模板模式|MVP模式|\n| 单例模式 |组合模式|命令模式|惰性模式|MVVM模式|\n|         |享元模式|访问者模式|参与者模式||\n|         |       |中介者模式|等待者模式||\n|         |       |备忘录模式|||\n|         |       |迭代器模式|||\n|         |       |解释器模式|||\n\n---\n<!--more-->\n\n## 第 33 章 异国战场-参与者模式\n\n- 参与者模式：在特定的作用域中执行给定的函数,并将参数原封不动地传递。\n\n### 事件绑定方法\n```js\nlet A = {\n    event: {}\n};\n// 事件模块（事件绑定方法）\nA.event.on = function (dom, type, fn) {\n    // 绑定 w3c 标准事件\n    if (dom.addEventListener) {\n        dom.addEventListener(type, fn, false);\n    // 绑定 ie 标准事件\n    } else if (dom.attachEvent) {\n        dom.attachEvent('on' + type, fn);\n    // 绑定 dom 事件\n    } else {\n        dom['on' + type] = fn;\n    }\n};\n```\n\n```js\n/*上面存在的问题， addEventListener 没有办法在回调函数中传递参数， 做如下的修改*/\nA.event.on2 = function (dom, tyoe, fn, data) {\n    if (dom.addEventListener) {\n        dom.addEventListener(type, function (e) {\n            // 在dom环境中调用fn,并传递事件对象以及参数\n            fn.call(dom, e, data)\n        }, false);\n    }\n    // .............\n};\n```\n通过 call 和 apply 方法使我们在特定作用域中执行某个函数并传入参数。\n\n### 实现 bind 方法\n```js\n/*\n* 上面的方法确实是解决了参数传递的问题， 但是引发了一个新的问题\n* 新的问题就是添加的是匿名函数导致事件回调函数不能移除了\n* 为了解决这个问题， 就引入了bind 闭包\n* */\nlet bind = function (fn, context) {\n    // 闭包返回新函数\n    return function () {\n        // 对 fn 装饰并返回\n        return fn.apply(context, arguments)\n    }\n};\n\n// 对于bind 方法的测试\nlet demoObj = {\n    title: '这是一个例子'\n};\nlet demoFn = function () {\n    console.log(this.title)\n};\nlet bindFn = bind(demoFn, demoObj);\ndemoFn();               // undefined\nbindFn();               // '这是一个例子'\n```\nbindFn返回了结果，因为 bindFn 在执行时 demoObj 参与了进来并提供了作用域。\n\n```js\n/*\n* 实际应用\n* */\nlet button = document.getElementsByTagName('button')[0];\nlet p = document.getElementsByTagName('p')[0];\n// 输出参数和 this 对象\nlet demoFn = function () {\n    console.log(arguments, this);\n};\n\n// 当没有传入参与对象式 浏览器下 this 指向 Window\nlet bindFn = bind(demoFn);\nbutton.addEventListener('click', bindFn); // [MouseEvent]  Window\n\n// 传入button this 指向了button\nbindFn = bind(demoFn, button); // [MouseEvent] <button>按钮</button>\n\n// 传入P this 指向了P\nbindFn = bind(demoFn, p); // [MouseEvent] <p>p</p>\n\nbutton.removeEventListener('click', bindFn)\n```\n不使用实现的 bind 方法，我们也可以用原生的 bind\n\n```js\nlet bindFN = demoFn.bind()\n```\n\n### 函数柯里化\n```js\n/*\n* 第一个需求是添加事件和移除事件已经成功了\n* 第二个需求就是函数添加额外的自定义参数\n* 这个时候就需要借助于函数柯里化了\n* 函数柯里化： 根据传递的参数不同， 让一个函数存在多种状态， 处理的是函数。\n* */\n```\n\n函数柯里化（function currying）又称部分求值。一个函数首先会接受一些参数，接受了这些参数后，\n\n该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包里被保存起来。待到函数真正需要求值的时候，之前传入的参数都会被一次性用于求值。\n\n把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。\n\n```js\nlet curry = function (fn) {\n    // 缓存数组的 slice 方法\n    let Slice = [].slice;\n    // 从第二个参数开始截取\n    let args = Slice.call(arguments, 1);\n    // 闭包返回新函数\n    return function () {\n        // arguments 类数组 转化为数组\n        let addArgs = Slice.call(arguments),\n            // 拼接参数\n            allArgs = args.concat(addArgs);\n            // 返回新函数\n        return fn.apply(null, allArgs);\n    }\n};\n// 柯里化的测试\nlet add = function (num1, num2) {\n    return num1 + num2;\n};\nlet add5 = function (num) {\n    return add(5, num)\n};\nconsole.log(add(1, 2));          // 3\nconsole.log(add5(6));           // 11\n\nadd5 = curry(add, 5);\nconsole.log(add5(6));           // 11\nlet add7and8 = curry(add, 7, 8);\nconsole.log(add7and8());        // 15\n```\n对 add 方法的多态扩展不需要再声明函数了。\n\n\n### 通过柯里化重写 bind\n```js\n/*\n* 通过柯里化重写bind\n* */\nlet bind = function (fn, context) {\n    let Slice = Array.prototype.slice,\n        args = Slice.call(arguments, 2);\n    return function () {\n        let addArgs = Slice.call(arguments),\n            allArgs = addArgs.concat(args);\n        return fn.apply(context, allArgs);\n    }\n};\n// 测试\nlet demoData1 = {\n    text: '这是第一组数据'\n};\nlet demoData2 = {\n    text: '这是第二组数据'\n};\nbindFn = bind(demoFn, button, demoData1); // [MouseEvent, Object] <button>按钮</button>\nbindFn = bind(demoFn, button, demoData1, demoData2); // [MouseEvent, Object, Object] <button>按钮</button>\n\n```\n以之前的 button 为例，我们现在能在回调函数中获取传递的自定义的数据了。\n\n```js\nlet bindFn = demoFn.bind(button, demoData1); // [Object, MouseEvent] <button>按钮</button> 事件对象放后面的\n```\n\n```js\n/*\n* 为了浏览器兼容性的实现， 我们需要给未提供bind方法的浏览器添加bind方法\n* */\nif(Function.prototype.bind === undefined) {\n    Function.prototype.bind = function (context) {\n        let Slice = Array.prototype.slice,\n            args = Slice.call(arguments, 1);\n        return () => {\n            let addArgs = Slice.call(arguments),\n                allArgs = args.concat(addArgs);\n            return this.apply(context, allArgs);\n        }\n    }\n}\n```\n\n### 总结\n对于函数绑定，将函数以函数指针（函数名的方式传递），使函数在被绑定对象上的作用域中执行，可以顺利访问到对象内部的数据。缺点会消耗更多的内存执行速度会稍慢。比较常用于事件，setTimeout等异步逻辑的回调函数。\n\n对于函数柯里化则是将接受多个参数的函数转化成接受一部分参数的新函数，余下的参数保存下来。当调用式传入的参数和保存的参数一起执行。因为要保存参数到闭包内，所以同样也会多消耗些资源。\n\n## 第 34 章  入场模式-等待者模式\n\n- 等待者模式: 通过对多个异步进程进行监听，来触发未来的动作。(构建简易Promise对象，实现状态机)\n\n- 场景: 不能确定先后的异步逻辑，但需要等待所有异步逻辑的完成。所有成功后执行成功回调，有一个失败就执行失败的回调函数。\n\n不需要实时监听所有异步逻辑是否完成，只需要监听注册的异步逻辑的状态发生改变时，对所有的异步逻辑的状态进行一次确认迭代。\n\n### 接口拆分\n一个等待者对象内部定义了3个数组，分别存储监听对象，成功回调和失败回调；1个监控对象的类，有2个属性（成功状态和失败状态），2个方法（成功和失败方法）；私有方法_exec来处理成功或失败的回调；3个共有方法接口：when（监听异步逻辑）、done（添加成功回调）、fail（添加失败回调）\n\n```js\n// 等待者对象\nvar Waiter = function() {\n    // 注册了等待对象容器\n    var dfd = [] ;\n    // 成功回调方法容器\n    var doneArr = [] ;\n    // 失败回调方法容器\n    var failArr = [] ;\n    // 缓存Array方法slice\n    var _slice = Array.prototype.slice;\n    // 保存当前等待者对象\n    var that = this ;\n\n    // 监控对象类\n    var Primise = function() {\n        // 监控对象是否解决成功状态\n        this.resolved = false;\n        // 监控对象是否解决失败状态\n        this.rejected = false;\n    }\n    // 监控对象类原型方法\n    Primise.prototype = {\n        // 解决成功\n        resolve : function() {},\n        // 解决失败\n        reject : function() {}\n    }\n\n    // 创建监控对象\n    that.Deferred = function() {\n        return new Primise() ;\n    }\n\n    // 回调执行方法\n    function _exec(arr) {}\n\n    // 监控异步方法 参数：监控对象\n    that.when = function() {}\n\n    // 解决成功回调函数添加方法\n    that.done = function() {}\n\n    // 解决失败回调函数添加方法\n    that.fail = function() {}\n}\n```\n\n### 监控对象类原型方法\n```js\nPrimise.prototype = {\n    // 解决成功\n    resolve : function() {\n        // 设置当前监控对象解决成功\n        this.resolved = true ;\n        // 如果没有监控对象则取消执行\n        if(!dfd.length) {\n            return;\n        }\n        // 遍历所有注册了的监控对象\n        for(var i = dfd.length - 1; i >= 0; i--) {\n            // 如果有任意一个监控对象没有被解决或者解决失败则返回\n            if(dfd[i] && !dfd[i].resolved || dfd[i].rejected) {\n                return;\n            }\n            // 清除监控对象 成功了就不需要再监控\n            dfd.splice(i, 1);\n        }\n        // 执行解决成功回调方法\n        _exec(doneArr);\n    },\n    // 解决失败\n    reject : function() {\n        // 设置当前监控对象解决失败\n        this.rejected = true;\n        // 如果没有监控对象则取消执行\n        if(!dfd.length) {\n            return;\n        }\n        // 清除所有监控对象\n        dfd.splice(0);\n        // 执行解决成功回调方法\n        _exec(failArr);\n    }\n}\n```\n\n### 回调执行方法\n```js\nfunction _exec(arr){\n    var i = 0;\n    var len = arr.length;\n    // 遍历回调数组执行回调\n    for(; i < len; i++) {\n        try {\n            // 执行回调函数\n            arr[i] && arr[i]();\n        }catch(e) {\n\n        }\n    }\n}\n```\n\n### 监控异步方法 参数：监控对象\n```js\nthat.when = function() {\n    // 设置监控对象\n    dfd = _slice.call(arguments);\n    // 获取监控对象数组长度\n    var i = dfd.length;\n    // 向前遍历监控对象，最后一个监控对象的索引值为length-1\n    for(--i; i >= 0; i--) {\n        // 如果不存在监控对象，或者监控对象已经解决，或者不是监控对象\n        if(!dfd[i] || dfd[i].resolved || dfd[i].rejected || !dfd[i] instanceof Primise) {\n            // 清理内存，清除当前监控对象\n            dfd.splice(i, 1);\n        }\n    }\n    // 返回等待者对象\n    return that;\n}\n```\n\n### 解决成功回调函数添加方法\n```js\nthat.done = function() {\n    // 向成功回调函数容器中添加回调方法\n    doneArr = doneArr.concat(_slice.call(arguments));\n    // 返回等待者对象\n    return that;\n}\n```\n\n### 解决失败回调函数添加方法\n```js\nthat.fail = function() {\n    // 向失败回调函数容器中添加回调方法\n    failArr = failArr.concat(_slice.call(arguments));\n    // 返回等待者对象\n    return that;\n}\n```\n\n### 测试\n```js\n// 创建一个等待者对象\nvar waiter = new Waiter();\n\n// 第一个彩蛋，3秒停止\nvar first = (function() {\n    // 创建监听对象\n    var dtd = waiter.Deferred();\n    setTimeout(function() {\n        console.log('first finish');\n        // 发布解决成功问题\n        dtd.resolve();\n        // 发布解决失败问题\n        // dtd.reject();\n    }, 3000) ;\n    // 返回监听对象\n    return dtd;\n})();\n\n// 第二个彩蛋，6秒后停止\nvar second = (function() {\n    // 创建简体你对象\n    var dtd = waiter.Deferred();\n    setTimeout(function() {\n        console.log('second finish');\n        // 发布解决成功消息\n        dtd.resolve();\n        // 发布解决失败问题\n        // dtd.reject();\n    }, 6000);\n    // 返回监控对象\n    return dtd;\n})();\n\n// 监听两个彩蛋的工作状态，并执行相应的成功回调函数与失败回调函数\nwaiter\n    // 监听两个彩蛋\n    .when(first, second)\n    // 添加成功回调函数\n    .done(function() {\n        console.log('success');\n    }, function() {\n        console.log('success again');\n    })\n    // 添加失败回调函数\n    .fail(function() {\n        console.log('fail');\n    });\n```\n\n### 应用场景\n```js \n// 封装get请求\nvar ajaxGet = function(url, success, fail) {\n    var xhr = new XMLHttpRequest();\n    // 创建监测对象\n    var dtd = waiter.Deferred();\n    xhr.onload = function(event) {\n        // 请求成功\n        if(xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {\n            success && success() ;\n        // 请求失败 \n        }else {\n            dtd.reject() ;\n            fail && fail() ;\n        }\n    } ;\n    xhr.open('get', url, true);\n    xhr.send(null);\n}\n  \n// 长轮询\n(function getAjaxData() {\n    // 保存当前函数\n    var fn = arguments.callee;\n    setTimeout(function() {\n        $.get('./test.php', function() {\n            console.log('轮询一次');\n            // 再一次执行轮询\n            fn();\n        });\n    }, 5000);\n})();\n```\n\n### 总结\n等待者模式适合用于处理比较耗时的操作比如定时器操作、异步请求等。等待者模式提供了抽象非阻塞的解决方案。通过创建 Promise 对象，对应状态变化返回响应，同时监听这些响应信息，并为之提供相应的回调，根据状态执行相应的回调方法。\n","tags":["知识"],"categories":["JS"]},{"title":"事件机制","url":"%2F2019%2F%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html","content":"\n事件机制的核心就是发布-订阅模式。维护一个对象，对象的 key 存的是事件 type，对应的 value 为触发相应 type 的回调函数，即 listeners，然后 trigger 时遍历通知，即 forEach 进行回调执行。\n\n```js\nclass EventTarget {\n    constructor() {\n        this.listener = [];\n    }\n\n    // 监听事件\n    on(type, callback) {\n        // 如果是第一次监听该事件，则初始化数组\n        if (!this.listeners[type]) this.listeners[type] = [];\n        this.listeners[type].push(callback);\n    }\n\n    // 只监听一次\n    once(type, callback) {\n        if (!this.listeners[type]) this.listeners[type] = [];\n        // once 只触发一次，触发后 off 即可 回调函数加上标识\n        callback._once = true;\n        this.listeners[type].push(callback); \n    }\n\n    // 取消监听\n    off(type, callback) {\n        const listeners = this.listeners[type];\n        if (Array.isArray(listeners)) {\n            // filter 返回新的数组，会每次对 this.listeners[type] 分配新的空间\n            // this.listeners[type] = listeners.filter(l => l !== callback);\n            // 根据 type 取消对应的回调\n            const index = listeners.indexOf(callback);\n            // 用 splice 要好些，直接操作原数组\n            this.listeners[type].splice(index, 1);\n            // 如果回调为空，删除对该事件的监听\n            if (this.listeners[type].length === 0) delete this.listeners[type];\n        }\n    }\n\n    // 执行 扳机社\n    trigger(event) {\n        // type 为必传属性\n        const { type } = event;\n        if (!type) throw new Error('没有要触发的事件！');\n        // 判断是否之前对该事件进行监听了\n        const listeners = this.listeners[type];\n        if (!listeners) throw new Error(`没有对象监听 ${type} 事件！`);\n        if (!event.target) event.target = this;\n        listeners.forEach(l => {\n            l(event);\n            // 如果通过 once 监听，执行一次后取消\n            if (l._once) this.off(type, l);\n        });\n    }\n}\n```\n\n```js\n// 测试\nfunction handleMessage(event) { console.log(`message received: ${ event.message }`); }\n\nfunction handleMessage2(event) { console.log(`message2 received: ${ event.message }`); }\n\nconst target = new EventTarget();\n\ntarget.on('message', handleMessage);\ntarget.on('message', handleMessage2);\ntarget.trigger({ type: 'message', message: 'hello custom event' }); // 打印 message，message2\n\ntarget.off('message', handleMessage);\ntarget.trigger({ type: 'message', message: 'off the event' }); // 只打印 message2\n\ntarget.once('words', handleMessage);\ntarget.trigger({ type: 'words', message: 'hello2 once event' }); // 打印 words\ntarget.trigger({ type: 'words', message: 'hello2 once event' }); // 报错：没有对象监听 words 事件！\n```\n","tags":["深入理解"],"categories":["JS"]},{"title":"关于requestAnimationFrame","url":"%2F2019%2F%E5%85%B3%E4%BA%8ErequestAnimationFrame.html","content":"\n在JS中，我们可以使用 `setTimeout` 和 `setIntarval` 实现动画，但是 H5 的出现，让我们又多了两种实现动画的方式，分别是 CSS 动画（`transition`、`animation`）和 H5的`canvas` 实现。除此以外，H5还提供了一个专门用于请求动画的API，让 DOM 动画、canvas动画、svg动画、webGL动画等有一个专门的刷新机制。\n\n> 传统的javascript 动画是通过定时器 setTimeout 或者 setInterval 实现的。但是定时器动画一直存在两个问题\n- 动画的循时间环间隔不好确定(推荐的最佳循环间隔是17ms（大多数电脑的显示器刷新频率是60Hz，1000ms/60）)\n- 定时器第二个时间参数只是指定了多久后将动画任务添加到浏览器的UI线程队列中，如果UI线程处于忙碌状态，那么动画不会立刻执行\n\n### 1. 定义\n`requestAnimationFrame` 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。\n\n```js\nwindow.requestAnimationFrame(callback)\n```\n\n* callback：下一次重绘之前更新动画帧所调用的函数，**callback仅有一个参数，为DOMHighResTimeStamp参数，表示requestAnimationFrame()开始执行回调函数的时刻。**\n* 返回值：一个 long 类型整数，唯一标志元组在列表中的位置，你可以传这个值给`cancelAnimationFrame()` 以取消动画。\n\n在使用和实现上， `requestAnimationFrame` 与 `setTimeout` 类似。举个例子：\n\n```js\nlet count = 0;\nlet rafId = null;\n/**\n * 回调函数\n * @param time requestAnimationFrame 调用该函数时，自动传入的一个时间\n */\nfunction requestAnimation(time) {\n  console.log(time); // 打印执行requestAnimation函数的时刻\n  // 动画没有执行完，则递归渲染\n  if (count < 5) {\n    count++;\n    // 渲染下一帧\n    rafId = window.requestAnimationFrame(requestAnimation);\n  }\n}\n// 渲染第一帧\nwindow.requestAnimationFrame(requestAnimation);\n```\n\n### 2.怎样执行\n* 首先判断 `document.hidden` 属性是否可见（true），可见状态下才能继续执行以下步骤\n* 浏览器清空上一轮的动画函数\n* `requestAnimationFrame` 将回调函数追加到动画帧请求回调函数列表的末尾\n  **注意：当执行 requestAnimationFrame(callback)的时候，不会立即调用 callback 回调函数，只是将其放入回调函数队列而已，同时注意，每个 callback回调函数都有一个 cancelled 标志符，初始值为 false，并对外不可见。**\n* 当页面可见并且动画帧请求callback**回调函数列表**不为空时，浏览器会**定期**将这些回调函数加入到浏览器 UI 线程的队列中（**由系统来决定回调函数的执行时机**）。当浏览器执行这些 callback 回调函数的时候，会判断每个元组的 callback 的cancelled标志符，只有 **cancelled 为 false** 时，才执行callback回调函数。\n\n### 3. 优点\n1. `requestAnimationFrame` 自带**函数节流**功能，采用**系统时间间隔**，保持最佳绘制效率，不会因为间隔时间的过短，造成过度绘制，增加页面开销，也不会因为间隔时间过长，造成动画卡顿，不流程，影响页面美观。\n   浏览器的重绘频率一般会和显示器的刷新率保持同步。大多数采用 W3C规范，浏览器的渲染页面的标准频率也为 60 FPS（frames/per second）即每秒重绘60次，**requestAnimationFrame的基本思想是 让页面重绘的频率和刷新频率保持同步**，即每 1000ms / 60 = **16.7ms**执行一次。\n   通过 `requestAnimationFrame` 调用回调函数引起的页面重绘或回流的时间间隔和显示器的刷新时间间隔相同。所以  `requestAnimationFrame`  不需要像 `setTimeout` 那样传递时间间隔，而是浏览器通过系统获取并使用显示器刷新频率。例如在某些高频事件（resize，scroll 等）中，使用 `requestAnimationFrame` 可以防止在一个刷新间隔内发生多次函数执行，这样保证了流程度，也节省了开销\n2. 另外，该函数的**延时效果是精确的**，没有`setTimeout`或`setInterval`不准的情况（JS是单线程的，`setTimeout` 任务被放进异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列的任务是否需要开始执行，造成时间延时）。\n   `setTimeout`**的执行只是在内存中对图像属性进行改变，这个改变必须要等到下次浏览器重绘时才会被更新到屏幕上**。如果和屏幕刷新步调不一致，就可能导致中间某些帧的操作被跨越过去，直接更新下下一帧的图像。即 **掉帧**\n   使用  `requestAnimationFrame` 执行动画，最大优势是**能保证回调函数在屏幕每一次刷新间隔中只被执行一次**，这样就不会引起丢帧，动画也就不会卡顿\n3. 节省资源，节省开销\n   在之前介绍`requestAnimationFrame`执行过程，我们知道只有当页面激活的状态下，页面刷新任务才会开始，才执行 `requestAnimationFrame`，当页面隐藏或最小化时，会被暂停，页面显示，会继续执行。**节省了 CPU 开销**。\n   **注意：当页面被隐藏或最小化时，定时器`setTimeout`仍在后台执行动画任务，此时刷新动画是完全没有意义的（实际上 FireFox/Chrome 浏览器对定时器做了优化：页面闲置时，如果时间间隔小于 1000ms，则停止定时器，与`requestAnimationFrame`行为类似。如果时间间隔>=1000ms，定时器依然在后台执行）**\n   ```js\n   // 在浏览器开发者工具的Console页执行下面代码。\n   // 当开始输出count后，切换浏览器tab页，再切换回来，可以发现打印的值从离开前的值继续输出\n   let count = 0;\n       function requestAnimation() {\n           if (count < 100) {\n               count++;\n               console.log(count);\n               requestAnimationFrame(requestAnimation);\n           }\n       }\n   requestAnimationFrame(requestAnimation);\n   ```\n4. 能够在动画流刷新之后执行，即**上一个动画流会完整执行**\n\n### 4. 实现\n我们可以使用 `requestAnimationFrame` 实现`setInterval`及 `setTimeout`\n\n```js\n// setInterval实现\nfunction setInterval(callback, interval) {\n    let timer\n    const now = Date.now\n    let startTime = now()\n    let endTime = startTime\n    const loop = () ={\n        timer = window.requestAnimationFrame(loop)\n        endTime = now()\n        if (endTime - startTime >= interval) {\n            startTime = endTime = now()\n            callback(timer)\n        }\n    }\n    timer = window.requestAnimationFrame(loop)\n    return timer\n}\n\nlet a = 0\nsetInterval(timer ={\n    console.log(a)\n    a++\n    if (a === 3) window.cancelAnimationFrame(timer)\n}, 1000)\n// 0\n// 1\n// 2\n```\n\n```js\n// setTimeout 实现\nfunction setTimeout(callback, interval) {\n    let timer\n    const now = Date.now\n    let startTime = now()\n    let endTime = startTime\n    const loop = () ={\n        timer = window.requestAnimationFrame(loop)\n        endTime = now()\n        if (endTime - startTime >= interval) {\n            callback(timer)\n            window.cancelAnimationFrame(timer)\n        }\n    }\n    timer = window.requestAnimationFrame(loop)\n    return timer\n}\n\nlet a = 0\nsetTimeout(timer ={\n    console.log(a)\n    a++\n}, 1000)\n// 0\n```\n\n### 5. 参考\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)\n","tags":["深入理解"],"categories":["JS"]},{"title":"git相关问题场景和命令","url":"%2F2019%2Fgit%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%E5%92%8C%E5%91%BD%E4%BB%A4.html","content":"\n### 一、必备知识点\n![git](http://cdn.mydearest.cn/blog/images/git.png)\n\n---\n<!--more-->\n\n#### 仓库\n1. **Remote:** 远程主仓库；\n2. **Repository：** 本地仓库；\n3. **Index：** Git追踪树,暂存区；\n4. **workspace：** 本地工作区（即你编辑器的代码）\n\n### 二、git add 提交到暂存区，出错怎么办\n一般代码提交流程为：**工作区** -`git status` 查看状态 -`git add .` 将所有修改加入**暂存区**-`git commit -m \"提交描述\"` 将代码提交到 **本地仓库** -`git push` 将本地仓库代码更新到 **远程仓库**\n\n#### 场景1：工作区\n当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令` git checkout -- file`。\n\n```js\n// 丢弃工作区的修改\ngit checkout -- <文件名>\n```\n\n#### 场景2：暂存区\n当你不但改乱了工作区某个文件的内容，还 `git add` 添加到了暂存区时，想丢弃修改，分两步，第一步用命令 `git reset HEAD file`，就回到了场景1，第二步按场景1操作。\n\n```js\ngit reset HEAD <文件名// 把暂存区的修改撤销掉（unstage），重新放回工作区。\n```\n\n### 三、git commit 提交到本地仓库，出错怎么办？\n#### 1. 提交信息出错\n更改 commit 信息\n\n```js\ngit commit --amend -m“新提交消息”\n```\n\n#### 2. 漏提交\ncommit 时，遗漏提交部分更新，有两种解决方案：\n\n* 方案一：再次 commit\n  ```js\n  git commit -m 提交消息\n  ```\n  \n  \n  此时，git 上会出现两次 commit\n* 方案二：遗漏文件提交到之前 commit 上\n  ```js\n  git add missed-file // missed-file 为遗漏提交文件\n  git commit --amend --no-edit\n  ```\n  \n  \n  `--no-edit` 表示提交消息不会更改，在 git 上仅为一次提交\n\n#### 3. 提交错误文件，回退到上一个 commit 版本，再 commit\n##### git reset\n删除指定的 commit\n\n```js\n// 修改版本库，保留暂存区，保留工作区\n// 将版本库软回退1个版本，软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。\ngit reset --soft HEAD~1\n\n// 修改版本库，修改暂存区，修改工作区\n// 将版本库回退1个版本，不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本\ngit reset --hard HEAD~1\n// git版本回退，回退到特定的commit_id版本，可以通过git log查看提交历史，以便确定要回退到哪个版本(commit 之后的即为ID);\ngit reset --hard commit_id \n```\n\n##### git revert\n撤销 某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销\n\n作为一次最新的提交\n\n```js\n// 撤销前一次 commit\ngit revert HEAD\n// 撤销前前一次 commit\ngit revert HEAD^\n// (比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。\ngit revert commit\n```\n\n`git revert`是提交一个新的版本，将需要`revert`的版本的内容再反向修改回去，\n版本会递增，不影响之前提交的内容\n\n##### `git revert` 和 `git reset` 的区别\n* `git revert`是用一次新的commit来回滚之前的commit，`git reset`是直接删除指定的commit。\n* 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为`git revert`是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是`git reset`是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。\n* `git reset` 是把HEAD向后移动了一下，而`git revert`是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。\n\n### 四、常用命令\n#### 1. 初始开发 git 操作流程\n* 克隆最新主分支项目代码 `git clone 地址`\n* 创建本地分支 `git branch 分支名`\n* 查看本地分支 `git branch`\n* 查看远程分支 `git branch -a`\n* 切换分支  `git checkout 分支名 ` (一般修改未提交则无法切换，大小写问题经常会有，可强制切换  `git checkout 分支名 -f`  非必须慎用)\n* 将本地分支推送到远程分支 `git push <远程仓库<本地分支>:<远程分支>`\n\n#### 2. git fetch\n将某个远程主机的更新，全部/分支 取回本地（此时之更新了Repository）它取回的代码对你本地的开发代码没有影响，如需彻底更新需合并或使用`git pull`\n\n#### 3. git pull\n拉取远程主机某分支的更新，再与本地的指定分支合并（相当与fetch加上了合并分支功能的操作）\n\n#### 4. git push\n将本地分支的更新，推送到远程主机，其命令格式与`git pull`相似\n\n#### 5. 分支操作\n* 使用 Git 下载指定分支命令为：`git clone -b 分支名仓库地址`\n* 拉取远程新分支 `git checkout -b serverfix origin/serverfix`\n* 合并本地分支 `git merge hotfix`：(将 hotfix 分支合并到当前分支)\n* 合并远程分支 `git merge origin/serverfix`\n* 删除本地分支 `git branch -d hotfix`：(删除本地 hotfix 分支)\n* 删除远程分支 `git push origin --delete serverfix` \nor\n```js\ngit branch -D master; //删除本地master分支\ngit push origin :master; //删除远程master分支\n\ngit pull origin master:master // 远程:本地\ngit push origin master:master // 本地:远程\ngit push --set-upstream origin master // 将本地分支与远程同名分支相关联\n```\n* 上传新命名的本地分支：`git push origin newName`;\n* 创建新分支：`git branch branchName`：(创建名为 branchName 的本地分支)\n* 切换到新分支：`git checkout branchName`：(切换到 branchName 分支)\n* 创建并切换分支：`git checkout -b branchName`：(相当于以上两条命令的合并)\n* 查看本地分支：`git branch`\n* 查看远程仓库所有分支：`git branch -a`\n* 本地分支重命名： `git branch -m oldName newName`\n* 重命名远程分支对应的本地分支：`git branch -m oldName newName`\n* 把修改后的本地分支与远程分支关联：`git branch --set-upstream-to origin/newName`\n\n### 五、优化操作\n#### 1. 拉取代码 pull --rebase\n在团队协作过程中，假设你和你的同伴在本地中分别有各自的新提交，而你的同伴先于你 `push` 了代码到远程分支上，所以你必须先执行 `git pull` 来获取同伴的提交，然后才能` push` 自己的提交到远程分支。\n\n而按照 Git 的默认策略，如果远程分支和本地分支之间的提交线图有分叉的话（即不是 fast-forwarded），Git 会执行一次 `merge` 操作，因此产生一次没意义的提交记录，从而造成了像上图那样的混乱。\n\n其实在 pull 操作的时候，，使用 `git pull --rebase `选项即可很好地解决上述问题。 加上 `--rebase` 参数的作用是，提交线图有分叉的话，Git 会 rebase 策略来代替默认的 merge 策略。\n\n假设提交线图在执行 pull 前是这样的：\n\n```\n                 A---B---C  remotes/origin/master\n                /\n           D---E---F---G  master\n```\n\n如果是执行 `git pull` 后，提交线图会变成这样：\n\n```\n                 A---B---C remotes/origin/master\n                /         \\\n           D---E---F---G---H master\n```\n\n结果多出了 `H` 这个没必要的提交记录。如果是执行 `git pull --rebase` 的话，提交线图就会变成这样：\n\n```\n                       remotes/origin/master\n                           |\n           D---E---A---B---C---F'---G'  master\n```\n\n`F` `G` 两个提交通过 `rebase` 方式重新拼接在 `C` 之后，多余的分叉去掉了，目的达到。\n\n##### 小结\n大多数时候，使用 `git pull --rebase `是为了使提交线图更好看，从而方便 code review。\n\n不过，如果你对使用 git 还不是十分熟练的话，我的建议是 `git pull --rebase `多练习几次之后再使用，因为 **rebase 在 git 中，算得上是『危险行为』**。\n\n另外，还需注意的是，使用 `git pull --rebase `比直接 pull 容易导致冲突的产生，如果预期冲突比较多的话，建议还是直接 pull。\n\n注意：\ngit pull = git fetch + git merge\ngit pull --rebase = git fetch + git rebase\n\n#### 2. 合代码 merge --no-ff\n上述的 `git pull --rebase` 策略目的是修整提交线图，使其形成一条直线，而即将要用到的 `git merge --no-ff <branch-name>` 策略偏偏是反行其道，刻意地弄出提交线图分叉出来。\n\n假设你在本地准备合并两个分支，而刚好这两个分支是 fast-forwarded 的，那么直接合并后你得到一个直线的提交线图，当然这样没什么坏处，但如果你想更清晰地告诉你同伴：**这一系列的提交都是为了实现同一个目的**，那么你可以刻意地将这次提交内容弄成一次提交线图分叉。\n\n执行 `git merge --no-ff <branch-name>` 的结果大概会是这样的：\n\n![git merge --no-ff](http://cdn.mydearest.cn/blog/images/git-chain1.png)\n\n中间的分叉线路图很清晰的显示这些提交都是为了实现 **complete adjusting user domains and tags**\n\n##### 更进一步\n往往我的习惯是，在合并分支之前（假设要在本地将 feature 分支合并到 dev 分支），会先检查 feature 分支是否『部分落后』于**远程 dev 分支**：\n\n```\ngit checkout dev\ngit pull # 更新 dev 分支\ngit log feature..dev\n```\n\n如果没有输出任何提交信息的话，即表示 feature 对于 dev 分支是 up-to-date 的。如果有输出的话而马上执行了 `git merge --no-ff` 的话，提交线图会变成这样：\n\n![git-merge](http://cdn.mydearest.cn/blog/images/git-chain2.png)\n\n所以这时在合并前，通常我会先执行：\n\n```\ngit checkout feature\ngit rebase dev\n```\n\n这样就可以将 feature 重新拼接到更新了的 dev 之后，然后就可以合并了，最终得到一个干净舒服的提交线图。\n\n**再次提醒：像之前提到的，rebase 是『危险行为』，建议你足够熟悉 git 时才这么做，否则的话是得不偿失的。**\n\n##### 总结\n使用 `git pull --rebase` 和 `git merge --no-ff` 其实和直接使用 `git pull` `git merge` 得到的代码应该是一样。\n\n使用 `git pull --rebase` 主要是为是将提交的线图平坦化，而 `git merge --no-ff` 则是刻意制造分叉。\n\ngit rebase 和 git merge 主要的区别在于是否保留分支的 commit 提交节点，rebase 会给你一个简洁的线性历史树。rebase 适合小分支，大分支还是使用 merge --squash。\n\n### 六、SSH\n#### 1. 查看是否生成了 SSH 公钥\n```\n$ cd ~/.ssh\n$ ls\nid_rsa      id_rsa.pub      known_hosts\n```\n\n其中 id_rsa 是私钥，id_rsa.pub 是公钥。\n\n#### 2. 如果没有那就开始生成，设置全局的user.name与user.email\n```js\ngit config --list // 查看是否设置了user.name与user.email，没有的话，去设置\n// 设置全局的user.name与user.email\ngit config --global user.name \"XX\"\ngit config --global user.email \"XX\"\n```\n\n#### 3. 输入 ssh-keygen 即可（或`ssh-keygen -t rsa -C \"email\"`）\n```\n$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Users/schacon/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /Users/schacon/.ssh/id_rsa.\nYour public key has been saved in /Users/schacon/.ssh/id_rsa.pub.\nThe key fingerprint is:\n```\n\n#### 4. 生成之后获取公钥内容，输入 cat ~/.ssh/id_rsa.pub 即可， 复制 ssh-rsa 一直到 .local这一整段内容\n```\n$ cat ~/.ssh/id_rsa.pub\nssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU\nGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3\nPbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA\nt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En\nmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx\nNrRFi9wrf+M7Q== schacon@agadorlaptop.local\n```\n\n#### 5. 打开 GitLab 或者 GitHub，点击头像，找到设置页\n#### 6. 左侧找到 SSH keys 按钮并点击，输入刚刚复制的公钥即可\n### 七、暂存\n`git stash` 可用来暂存当前正在进行的工作，比如想 pull 最新代码又不想 commit ， 或者另为了修改一个紧急的 bug ，先 stash，使返回到自己上一个 commit,，改完 bug 之后再 stash pop , 继续原来的工作；\n\n* 添加缓存栈： `git stash` ;\n* 查看缓存栈： `git stash list` ;\n* 推出缓存栈： `git stash pop` ;\n* 取出特定缓存内容： `git stash apply stash@{1}` ;\n\n### 八、文件名过长错误\nFilename too long warning: Clone succeeded, but checkout failed.\n\n```\ngit config --system core.longpaths true\n```\n\n### 九、邮箱和用户名\n#### 查看\n```\ngit config user.name\n\ngit config user.email\n```\n\n#### 修改\n```\ngit config --global user.name \"username\"\n\ngit config --global user.email \"email\"\n```\n\n### 十、.gitignore 更新后生效：\n```\ngit rm -r --cached .\ngit add .\ngit commit -m .gitignore is now working\n```\n\n### 十一、同步Github fork 出来的分支\n1、配置remote，指向原始仓库\n\n```\ngit remote add upstream https://github.com/cosyer/jelly.git\n```\n\n2、上游仓库获取到分支，及相关的提交信息，它们将被保存在本地的 upstream/master 分支\n\n```\ngit fetch upstream\n# remote: Counting objects: 75, done.\n# remote: Compressing objects: 100% (53/53), done.\n# remote: Total 62 (delta 27), reused 44 (delta 9)\n# Unpacking objects: 100% (62/62), done.\n# From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY\n# * [new branch] master -upstream/master\n```\n\n3、切换到本地的 master 分支\n\n```\ngit checkout master\n# Switched to branch 'master'\n```\n\n4、把 upstream/master 分支合并到本地的 master 分支，本地的 master 分支便跟上游仓库保持同步了，并且没有丢失本地的修改。\n\n```\ngit merge upstream/master\n# Updating a422352..5fdff0f\n# Fast-forward\n# README | 9 -------\n# README.md | 7 ++++++\n# 2 files changed, 7 insertions(+), 9 deletions(-)\n# delete mode 100644 README\n# create mode 100644 README.md\n```\n\n5、上传到自己的远程仓库中\n\n```\ngit push \n```\n\n### git合并多个commit\n过去总是使用`git reset --soft`回退到之前的状态，再 commit 后 push orgin master -f 强推到远程库，能够覆盖掉之前的 commit 。\n\n但在团队协作时，每次 commit 前还需要 rebase upstream，这会自动将一些其他人做的修改也自动merge到本地的源码中。如果此时希望覆盖前一次 commit ，reset 到之前的状态后，再次 commit 的内容就包含了其他人的修改，这不是我们希望看到的。因此，我们需要使用 git rebase -i 。\n\n#### 基本步骤\n- 1. git log查看所有commit的情况，找到自己想要合并的commit之前的那个commit的ssh码(前7位)；\n- 2. git rebase -i 43jk2l3ba343，这样会弹出一个文本编辑器；git reset --soft  HEAD^ 上个commit ^^上上个commit HEAD~6；\n- 3. 修改pick为squash会将这个commit合并到前一个commit中，保存退出；\n- 4. 提示写下新的commit message，之前的message可以用#注释掉，保存退出；\n- 5. 此时再git log就会发现，两个commit被合并到一个commit中。\n\n### 修改push到远程的commit\n- git log\n- git rebase -i \n- pick修改为edit\n- git commit --amend 修改新的commit message保存\n- git rebase --continue\n- git push -f\n\n### Commit message 前缀规范提要\n| code      | info          \n|---------- |-------------- |\n| **feat**:msg | 新功能 feature | \n| **fix**:msg | 修复bug| \n| **merge**:msg | merge 信息| \n| **docs**:msg | 文档修改 | \n| **style**:msg | 格式，不影响代码运行的变动 | \n| **refactor**: msg | 重构即不是新增功能，也不是修改bug的代码变动 | \n| **test**:msg | 增加测试| \n| **chore**:msg | 构建过程或辅助工具的变动| \n| **rm**:msg | 删除文件或代码 | \n\n### 恢复误删除的stash\n```bash\n# 显示所有不可访问对象\ngit fask --unreachable\n\ngit show 302063e31742cbce7c5fdb917edf520183154cc1 > D:\\recovery\\backup.txt\n```\n\n> 在使用 git fsck –unreachable 命令输出的很多文件里面，有很多是带有 commit 和 tree 的标识的，这些可以使用 git stash apply 加标记号进行找回。而 blob 的文件是只能手动拷贝的，或者像上面一样使用> 输出到指定的路径去\n\n### git push 报 HTTP Basic: Access denied 错误\n- 永久记住密码\n`git config --global credential.helper store`\n\n如果没`--global`，则在当前项目下的.git/config文件中添加。\n\n- 默认记住15分钟\n> git config --global credential.helper cache\n\n- 自定义配置记住1小时：\n> git config --global credential.helper 'cache –timeout=3600'\n\n解决方案： \n1. 如果账号密码有变动 用这个命令 `git config --system --unset credential.helper` (清除用户名密码)重新输入账号密码应该就能解决了 \n2. 如果用了第一个命令 还不能解决问题那么 用这个命令： \n`git config –global http.emptyAuth true`\n\n### 查看git上个人代码量\n```bash\ngit log --author=\"username\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' -\n```\n\n### 统计每个人的增删行数\n```bash\ngit log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' -; done\n```\n\n### 查看仓库提交者排名前 5\n```bash\ngit log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5\n```\n\n### 贡献者统计\n```bash\ngit log --pretty='%aN' | sort -u | wc -l\n```\n\n### 提交数统计\n```bash\ngit log --oneline | wc -l\n```\n\n### 参考\n本文参考了 [洁癖者用 Git：pull --rebase 和 merge --no-ff](http://hungyuhei.github.io/2012/08/07/better-git-commit-graph-using-pull---rebase-and-merge---no-ff.html)\n\n[Git常用命令参考手册](https://github.com/xjh22222228/git-manual)\n\n[高质量的Git中文教程](https://github.com/geeeeeeeeek/git-recipes)\n\n[Git Cheat Sheet](https://shfshanyue.github.io/cheat-sheets/git)\n","tags":["git"],"categories":["工具"]},{"title":"npm总结","url":"%2F2019%2Fnpm%E6%80%BB%E7%BB%93.html","content":"\n### 一. package.json 解读\n```js\n{\n\t\"name\": \"hello world\", // 项目名称\n\t\"version\": \"0.0.1\", // 版本号：大版本.次要版本.小版本\n\t\"author\": \"张三\",\n\t\"description\": \"第一个node.js程序\",\n\t\"keywords\":[\"node.js\",\"javascript\"], // 关键词，有助于 npm search 发现\n\t\"repository\": { // 存储库，指定代码所在位置（如果git repo在GitHub上，那么该npm docs 命令将能够找到文件位置。）\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://path/to/url\"\n\t},\n\t\"license\":\"MIT\", // 指定包许可证，详细可见[SPDX许可证ID的完整列表](https://spdx.org/licenses/)\n\t\"engines\": {\"node\": \"0.10.x\"}, // 指定该模块运行的平台，可以指定 node 版本、npm 版本等\n\t\"bugs\":{\"url\":\"http://path/to/bug\",\"email\":\"bug@example.com\"}, // 项目问题跟踪器的URL和应报告问题的电子邮件地址。\n\t\"contributors\":[{\"name\":\"李四\",\"email\":\"lisi@example.com\"}],\n    \"bin\": { // 指定内部命令对应的可执行文件的位置，在 scripts 中就可以简写\n    \t\"webpack\": \"./bin/webpack.js\"\n  \t},\n    \"main\": \"lib/webpack.js\", // 指定加载的模块入口文件，require('moduleName')就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。\n    \"config\" : { \"port\" : \"8080\" }, // 用于添加命令行的环境变量（用户在运行 scripts 命令时，就默认在脚本文件中添加 process.env.npm_package_config_port，用户可以通过 npm config set foo:port 80 命令更改这个值）\n\t\"scripts\": { // 指定运行脚本的 npm 命令行缩写\n\t\t\"start\": \"node index.js\"\n\t},\n    \"peerDependencies\": { // 指定项目安装必须一起安装的模块及其版本号，（注意：从 npm 3.0 开始，peerDependencies不会再默认安装）\n    \t\"chai\": \"1.x\"\n  \t},\n\t\"dependencies\": { // 指定项目运行所依赖的模块\n\t\t\"express\": \"latest\",\n\t\t\"mongoose\": \"~3.8.3\",\n\t\t\"handlebars-runtime\": \"~1.0.12\",\n\t\t\"express3-handlebars\": \"~0.5.0\",\n\t\t\"MD5\": \"~1.2.0\"\n\t},\n\t\"devDependencies\": { // 指定项目开发所需要的模块\n\t\t\"bower\": \"~1.2.8\",\n\t\t\"grunt\": \"~0.4.1\",\n\t\t\"grunt-contrib-concat\": \"~0.3.0\",\n\t\t\"grunt-contrib-jshint\": \"~0.7.2\",\n\t\t\"grunt-contrib-uglify\": \"~0.2.7\",\n\t\t\"grunt-contrib-clean\": \"~0.5.0\",\n\t\t\"browserify\": \"2.36.1\",\n\t\t\"grunt-browserify\": \"~1.3.0\",\n\t},\n    \"browser\": { // 指定该模板供浏览器使用的版本\n  \t\t\"tipso\": \"./node_modules/tipso/src/tipso.js\"\n\t},\n    \"preferGlobal\": true, // 表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。\n}\n```\n\n`package.json` 在 node 和 npm 环节都要使用，node 在调用 `require` 的时候去查找模块，会按照一个次序去查找，`package.json` 会是查找中的一个环节。npm 用的就比较多，其中的 `dependencies` 字段就是本模块的依赖的模块清单。每次`npm update`的时候，npm会自动的把依赖到的模块也下载下来。当`npm install` 本模块的时候，会把这里提到的模块都一起下载下来。通过package.json,就可以管理好模块的依赖关系。\n\n关于更多规范，请看官方[npm-package.json](https://docs.npmjs.com/files/package.json.html)\n\n---\n<!--more-->\n\n### 二. 版本号规范\n* **指定版本**：比如`1.2.2`，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n* **波浪号（tilde）+指定版本**：比如`~1.2.2`，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n* **插入号（caret）+指定版本**：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。**需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。**\n* **latest**：安装最新版本。\n\n### 三. npm install 与 **npm update**\n* 如果本地 `node_modules` 已安装，再次执行 `install` 不会更新包版本, 执行 `update` 才会更新; 而如果本地 `node_modules` 为空时，执行 `install/update` 都会直接安装更新包;\n* `npm update` 总是会把包更新到符合 `package.json` 中指定的 semver(语义化版本) 的**最新**版本号——本例中符合 `^1.8.0` 的最新版本为 `1.15.0`\n* 一旦给定 `package.json`, 无论后面执行 `npm install` 还是 `update`, `package.json` 中的 webpack 版本一直顽固地保持 一开始的 `^1.8.0` 岿然不动\n\n### 四. npm i 与 **npm install**\n实际使用的区别点主要如下：\n\n* 用`npm i`安装的模块无法用`npm uninstall`删除，用`npm un`才卸载掉\n* `npm i`会帮助检测与当前 node 版本最匹配的 npm 包版本号，并匹配出来相互依赖的 npm 包应该提升的版本号\n* 部分 npm 包在当前 node 版本下无法使用，必须使用建议版本\n* 安装报错时 install 肯定会出现 `npm-debug.log`  文件，`npm i`不一定\n\nnpm install 步骤\n1. 查询node_modules目录之中是否已经存在指定模块\n2. 若存在，不再重新安装\n3. 若不存在npm 向 registry 查询模块压缩包的网址、下载压缩包，存放在根目录下的.npm目录里、解压压缩包到当前项目的node_modules目录\n\n### 五. npm devDependencies 与 dependencies\n`--save-dev`\n\n或\n\n`—save`\n\n首先需要说明的是 Dependencies一词的中文意思是依赖和附属的意思，而dev则是 develop（开发）的简写。\n\n所以它们的区别在 package.json 文件里面体现出来的就是，使用 `--save-dev` 安装的 插件，被写入到 devDependencies 域里面去，而使用 `—save` 安装的插件，则是被写入到 dependencies 区块里面去。\n\n那 package.json 文件里面的 devDependencies  和 dependencies 对象有什么**区别**呢？\n\n**devDependencies  里面的插件只用于开发环境，不用于生产环境，而 dependencies  是需要发布到生产环境的**。\n\n比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies\n\n### 六. 全局安装与本地安装\n通过 `-g` 来安装的包，将包安装成全局可用的可执行命令。\n\n#### 1. 全局安装， 将包安装成全局可用的可执行命令\n```js\n// 全局安装 babel-cli\nbabel app.js\n```\n\n#### 2. 本地安装\n```js\n// 本地安装 babel-cli\nnode_modules/.bin/babel app.js\n```\n\n#### 3. 修改全局安装默认路径\n* 设置自定义的全局安装路径\n  ```js\n  npm config set prefix \"/usr/local/npm\" // 自定义的全局安装路径\n  npm config set cache \"/usr/local/npm\" // 自定义的全局安装路径\n  ```\n* 设置环境变量\n  切到  ~/.bash_profile 文件中配置路径：\n  ```js\n  GNPM_PATH=/usr/local/npm\n  export GNPM_PATH\n  export PATH=$PATH:$GNPM_PATH/bin  // 将 /usr/local/npm/bin 追加到 PATH 变量中\n  export NODE_PATH=$PATH:$GNPM_PATH/lib/node_modules // 指定 NODE_PATH 变量\n  ```\n  \n  \n  操作系统中都会有一个`PATH`环境变量，想必大家都知道，当系统调用一个命令的时候，就会在PATH变量中注册的路径中寻找，如果注册的路径中有就调用，否则就提示命令没找到。\n  而 `NODE_PATH` 就是`NODE`中用来 **寻找模块所提供的路径注册环境变量** 。我们可以使用上面的方法指定`NODE_PATH` 环境变量。\n  使用 `npm config list` 查看配置\n\n### 七. npm 包命令\n```js\nnpm list -g --depth 0 // 查看全局安装过的包 -g:全局的安装包 list：已安装的node包 –depth 0：深度0\nnpm view <packageName// 查看npm服务器中包版本号 \nnpm info <packageName// npm服务器更多信息，更多版本号\nnpm ls <packageName// 本地包\nnpm ls <packageName-g // 全局安装包\nnpm docs // 打开包git目录\n\n// 注意：npm build 与 npm start 是项目中常用的命令，注意它们有什么不同\nnpm start [--<args>] // 在 package.json 文件中定义的 \"scripts\" 对象中查找 \"start\" 属性，执行该属性定义的命令，如果没有定义，默认执行 node server.js 命令\nnpm build [<package-folder>] // 其中，<package-folder为其根目录中包含一个 package.json 文件的文件夹，这是由 npm link 命令和 npm install 命令组成的管道命令，通常在安装过程中被调用。如果想要直接运行它，则运行 npm run build\n```\n\n还有其他的 钩子命令，具体项目中我还没用到，你可以自行了解。\n\npackage.json 中 scripts 常用命令：\n\n```js\n// 删除目录\n\"clean\": \"rimraf dist/*\",\n\n// 本地搭建一个 HTTP 服务\n\"serve\": \"http-server -p 9090 dist/\",\n\n// 打开浏览器\n\"open:dev\": \"opener http://localhost:9090\",\n\n// 实时刷新\n \"livereload\": \"live-reload --port 9091 dist/\",\n\n// 构建 HTML 文件\n\"build:html\": \"jade index.jade dist/index.html\",\n\n// 只要 CSS 文件有变动，就重新执行构建\n\"watch:css\": \"watch 'npm run build:css' assets/styles/\",\n\n// 只要 HTML 文件有变动，就重新执行构建\n\"watch:html\": \"watch 'npm run build:html' assets/html\",\n\n// 部署到 Amazon S3\n\"deploy:prod\": \"s3-cli sync ./dist/ s3://example-com/prod-site/\",\n\n// 构建 favicon\n\"build:favicon\": \"node scripts/favicon.js\",\n```\n\n### 八. 简写形式\n```js\nnpm start   // 是 npm run start 的简写\nnpm stop    // 是 npm run stop 的简写\nnpm test    // 是 npm run test 的简写\nnpm restart // 是 npm run stop && npm run restart && npm run start 的简写\n```\n\n### 九. process\n我们可以通过环境变量`process.env`对象，拿到 npm 所有的配置变量。其中 npm 脚本可以通过`npm_config_`前缀，拿到 npm 的配置变量。通过`npm_package_`前缀，拿到`package.json`里面的字段。\n\n```js\nconsole.log(process.env.npm_package_name); // chejianer\nconsole.log(process.env.npm_package_version); // 1.0.0\nconsole.log(process.env); // ... \n```\n\n对于 **全局模式安装的包（通过 -g 来安装的包，将包安装成全局可用的可执行命令，并不意味着任何地方都可以通过 require() 来引用它）**：它会通过 bin 字段配置，将实际脚本链接到 Node 可执行目录下，例如\n\n```js\n\"bin\": {\n  \"webpack\": \"./bin/webpack.js\"\n},\n```\n\n通过全局安装的包都安装到一个统一的目录下，可以通过以下方式获得:\n\n```js\npath.resolve(process.execPath, \"..\", \"..\", \"lib\", \"node_modules\") \n// 例如：/usr/local/lib/node_modules\n```\n\n### 十. npm 发布包\n* **创建一个空文件**：\n\n```js\n// lib/index.js\nexports.sayHello = function () {\n    return \"Hello An!\";\n};\n```\n\n* **运行：`npm init`**\n\n```js\npackage name: (module) hello-an\nversion: (1.0.0) 0.1.0\ndescription: a hello-an package\nentry point: (hello.js) \ntest command: \ngit repository: \nkeywords: hello an\nauthor: sisterAn\nlicense: (ISC) MIT\nAbout to write to /Users/lianran777/Study/node/chejianer_node/module/package.json:\n\n{\n  \"name\": \"hello-an\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a hello-an package\",\n  \"main\": \"hello.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\n    \"hello\",\n    \"an\"\n  ],\n  \"author\": \"sisterAn\",\n  \"license\": \"MIT\"\n}\n\n\nIs this OK? (yes) \n```\n\n* **注册 npm 包仓库账号**\n\n```js\nnpm adduser\n```\n\n* **上传包**\n\n```js\nnpm publish . // package.json 所在目录\n\nnpm publish --tag beta // 上传beta版本\n```\n\n在这个过程中，npm 会将目录打包成一个存档文件，然后上传到官方源仓库中\n\n* **管理包权限**\n\n```js\nnpm owner add <user[<@scope>/]<pkg>\nnpm owner rm <user[<@scope>/]<pkg>\nnpm owner ls [<@scope>/]<pkg>\n```\n\n在自己的项目中安装包 `npm install`，通过 `npm ls` 分析模块路径找到的所有包，并生成依赖树。\n\n### 常见错误\n1. Unable to look up github.com (port 9418)\n\n```js\ngit config --global url.\"https://\".insteadOf git://\n```\n再重新`npm install`，问题解决。\n\n2. 清除包缓存\n```js\nnpm cache clean --force\n```\n\n3. 淘宝镜像\n```js\nnpm config set registry https://registry.npm.taobao.org\n\n// cnpm\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n// 还原\nnpm config set registry https://registry.npmjs.org\n```\n","tags":["工具"],"categories":["知识"]},{"title":"浏览器兼容问题总结","url":"%2F2019%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html","content":"\n1. png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.\n\n2. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一\n\n3. IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。\n\n浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 10px;}\n\n这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 _display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)\n\n```css\n.bb{\n    background-color:red;/*所有识别*/\n    background-color:#00deff\\9; /*IE6、7、8识别*/\n    +background-color:#a200ff;/*IE6、7识别*/\n    _background-color:#1e0bd1;/*IE6识别*/\n}\n```\n---\n<!--more-->\n\n4. IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()\n获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。\n\n5. IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。\n\n6. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; \n\n7. 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:\n\n`LoVe HAte` 原则\nL-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}\n\n8. 样式初始化\n- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n\n- 初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。\n\n最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）\n```css\nbody, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }\nbody, button, input, select, textarea { font:12px/1.5tahoma, arial, \\5b8b\\4f53; }\nh1, h2, h3, h4, h5, h6{ font-size:100%; }\naddress, cite, dfn, em, var { font-style:normal; }\ncode, kbd, pre, samp { font-family:couriernew, courier, monospace; }\nsmall{ font-size:12px; }\nul, ol { list-style:none; }\na { text-decoration:none; }\na:hover { text-decoration:underline; }\nsup { vertical-align:text-top; }\nsub{ vertical-align:text-bottom; }\nlegend { color:#000; }\nfieldset, img { border:0; }\nbutton, input, select, textarea { font-size:100%; }\ntable { border-collapse:collapse; border-spacing:0; }\n```\n\n9. CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？\n\n对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.\n如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.\n仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.\n\n10. 让页面里的字体变清晰，变细用CSS怎么做？\n-webkit-font-smoothing: antialiased;\n\n11. display:inline-block 什么时候会显示间隙？\n移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing\n\n12. ul标签内外边距问题ul标签在IE6\\IE7中，有个默认的外边距，但是在IE8以上及其他浏览器中有个默认的内边距。\n解决方法：统一设置ul的内外边距为0\n\n13. IE6下图片的下方有空隙\n解决方法：给img设置display:block;\n\n14. IE6下两个float之间会有个3px的bug\n解决办法：给右边的元素也设置float:left;  \n\n15. IE6下没有min-width的概念，其默认的width就是min-width  \n\n16. IE6下在使用margin:0 auto;无法使其居中\n解决办法：为其父容器设置text-align:center;\n\n17. 被点击过后的超链接不再具有hover和active属性\n解决办法:按lvha的顺序书写css样式，\n- \":link\": a标签还未被访问的状态；\n- \":visited\": a标签已被访问过的状态；\n- \":hover\": 鼠标悬停在a标签上的状态；\n- \":active\": a标签被鼠标按着时的状态；\n\n18. 标准事件绑定\naddEventListener/attachEvent、event.target/event.srcElement、XMLHttpRequest/ActiveXObject('Microsoft.XMLHTTP')\n\n- 获取dom的父子节点\nparentNode/parentElement\n","tags":["兼容性"],"categories":["知识"]},{"title":"租房须知","url":"%2F2019%2F%E7%A7%9F%E6%88%BF%E9%A1%BB%E7%9F%A5.html","content":"## 文档目的\n\n希望这篇文档能够帮助到北上广深杭等租房漂泊的同学在找房的时候规避一些明显的问题。\n\n这里枚举了一些常见问题，适当参考文档作出一个判断，或许可以减少租客和房东都不开心的情况的出现，并节约时间。\n\n作为租客，即使在预算并不充裕，或者稍低于目标区域平均价格的时候，也可以找到靠谱的房子，只要策略得当。\n\n希望看过文档的同学可以少遇到居住不舒服的房子，至少，不要遇到居住那么不舒服的房子 :D\n\n---\n<!--more-->\n\n## 租房要点\n\n**一般原则：**\n\n* 尽量提前进行房源的寻找，不要等到房子到期、或者旺季（财年结束跳槽季、毕业季、实习季）的时候进行。\n* 尽量寻找直租房屋，不推荐经过“转交”的房源，除非你对转手房源的人信得过。\n* 寻找房源前，请确定清楚预算和期望居住的区域，提高找房效率，避免无意义时间浪费。\n\n**特殊情况下的一般推荐策略：** \n\n### 如果租房者时间紧迫\n\n- 不太介意暂时没有独立的空间，请优先在公司群、公司或高校BBS、同学群中进行询问，看看是否有人愿意同你分享房子或者信息，相对知根知底的同事、同学比陌生人靠谱的概率大的多。\n- 请在本地寻找当地相对最大最正规的中介连锁。\n- 如果行李不多，部分青旅可以扛几天。（12年有同事这么经历过）\n\n### 如果一定要和中介打交道\n\n如果有可能，尽可能不要租中介的房子，尤其是市场占有率低的小中介，可能发生以下问题：\n\n1. 代理人中途跑路或以各种各样的方式进行诈骗。\n2. 合约到期后，以各种手段侵占押金。\n3. 屋内财务不翼而飞。\n\n**黑名单：**\n\n开来营，活跃于回龙观，霍营，龙泽地区，从2011年开始行骗至今，据不完全统计已有数百人上当受骗，其本人依靠骗来的钱财，购置了一处房产，买了一辆50多w的豪车，雇佣了保镖以及打手数人。被骗人员多次报警，起诉，均无果，任由开来营继续逍遥法外。\n\n### 有幸遇到房东直租\n\n“好”房东很重要，如果感觉气场不和，请不要将就，对双方都不好。\n\n- 因为供暖排水门锁证件等偶发的琐事产生沟通的时候，房东与你于之前的租客进行对比“之前租客都没问题”，请小心，推荐和爽快的人沟通，可以避免下面的许多问题（房子质量好同样可以大概率避免问题）。\n- **不要急于交定金/押金，多数是套路**（房源确实抢手的时期，房东靠谱，交全款也没事）\n- 去现场看房子的时候，如果房子很破，屋内东西乱丢，99%是二房东或者刚买来专门用来出租的屋子，请多留意屋子中的排水和保暖问题。\n- 靠谱房东，在你看房子的时候，多数会主动跟你沟通和妥协：“这个灯不好，我下午给你换了”对比“这个将就一下也能用”好坏立辨，但也请判别是否是专业中介，只说不做的那种...\n\n### 期望合租的房客\n\n不论是为了节约租房成本，控制房租在个人经济支出比重，还是考虑有个互相照应、结识新朋友，来到大城市的前期，合租是个不错的选择。\n\n- 你单枪匹马，屋子已经有其他房客入住\n\t- 尽可能了解到对方是从事什么职业，以及是否为常住人员。避免和经常流动的人员同住，发生潜在的安全隐患以及财物损失。\n\t- 尽可能了解房屋基础安全设施是否到位\n\t\t- 是否存在老化的煤气管道、开关，房东是否愿意修理或者更换，或者允许租客修理替换。\n\t\t- 是否存在随处可见的烟头。\n\t\t- 是否存在同住房客随意带陌生人留宿的现象\n- 你和小伙伴组队租房\n\t- 大家觉得都OK最重要\n\t- 其他参考上面的事项\n\n### 相对靠谱的房子来源\n\n任何一个平台、渠道信息量大之后，难免出现“有效信息质量下降”，诸如赶某网、5某网、搜某网、豆某小组等网站，上面的中介&伪装成中介的骗子居多，如使用该渠道，请仔细辨别：\n\n- 请优先使用校园论坛、朋友介绍、公司BBS、熟人IM社群等信息，但是同样需要仔细辨别信息真实程度。\n- 除了主动或者被动（被相关信息网站标记）显示是中介的，包含以下信息大概率为二房东：\n\t- 对标题做过特别优化等内容、发布内容格式特别“规范化”，例如：五道口地铁附近三室一厅朝南房主直急租月付季付当面可谈（巴不得内容全部在标题中体现）。\n\t- 房子照片可以在其他非租房信息发布的地方被搜到，多数为效果图、设计图等。推荐使用搜索引擎以图搜图来判别。\n\t\t- 同一手机号码发布多条不在同一地点的房源，基本是骗子类型的中介。\n\t\t- 张贴满大街的广告并非一般房东所为，一般为二房东或者小中介。\n\t- 黑中介的特点无非是：\n\t\t- **广泛投放性价比高出市场对信息**：在各种分类信息网站或者论坛投放大量描述红红绿绿、价格远低于市场价、描述看起来很好、效果图惊艳的房子。\n\t\t- **避免直接与客户进行沟通露馅**：打电话联系他们，会被对方草草挂掉，然后短信回复你，告知你一个公司的所在地，让你来公司办理入住业务。\n\t\t- **在看房之前急于促成租房合同**：去公司之后，一个劲保证你想要住的地方绝对有房子，先签合同会有专人带你看房。交完佣金之后，可能会给你一套破烂到不行的房子。\n\t\t- **电话里沟通过的房子在带看的时候进行更换**：电话里沟通好的房子，见面后告知刚被出租出去，恰好有另外一个惊喜的房子在等待你；在你不满意时，就带你去一个别的小区（不是你原计划居住的小区），带你去的小区往往是居住条件不好，房子多没人住的小区。同时，房东会因为找中介给佣金而提高房价。\n\t\t- 这样你用高价住了破房子还甩给了黑中介一笔佣金。\n\n### 可能被夸大描述的信息\n\n在签合同入住之前，请客观对房子进行评价，对房屋信息做到眼见为实，而不是轻信描述信息。\n\n- 大\n- 安静\n- 朝向南\n- 有某设施\n- 低时间成本\n- 超高的性价比\n\n展开描述一下：\n\n- 房子的平米数据很漂亮，但是有的二房东可以把一个70平米的房子拆成4个25平米的房子租出去。\n- 建议在房子内多待一阵，计划长租可以白天晚上都去房子里看看，街道、邻居是否过分喧哗。\n- 朝向这个是玄学、西南向的房子不太好住。\n- 带阳台、带窗户。注意，“带”和“带有用的”是两回事。\n- 离地铁 5～10 分钟，可能需要特别的大长腿，或者步幅特别快。\n\n总之，基本上除了地方可以勉强信一下，其他信息在眼见为实之前基本不要轻信。\n\n- 如果是中介，不要相信不要中介费，羊毛出在羊身上。\n- 如果找中介，请找靠谱中介。所谓靠谱，就是必须至少十几家以上连锁，店面名字你听说过。不然貌似省下来的中介费，最终很有可能会从诸如说你破坏东西扣除或者赖着不给你的押金、签合同时突然增加的卫生费（丫才不给你打扫）等等方式找回来。为了省心，请选靠谱中介。\n- 如果不确定中介是否靠谱，可以搜中介名称+骗子，然后自行鉴定。\n- 提前至少两周开始找房子，多打电话，中介一律屏蔽（不然烦死你）。多看房，找到房东之后看房本。合同一定要签，不要犯傻。\n- 如果和中介签合同，尤其不是靠谱中介，合同的每一个字都要看，不要相信他所说的话，合同他都有不承认的时候。\n- 永远不要信，我是房东，我出差在外面，请转账给我老婆。\n- **签合同的小技巧**合同中约定（例如必需水电的故障需要3日内修好，或者说好给你个衣柜之类）的内容房东有时会拒绝执行，在签署合同的时候，首先一切以合同为准，其次在约定中补充*如果不能满足允许房客随时退房，押金不得以任何理由扣留，已经交的租金按日计算返还*，一般会比较有效。\n\n### 签订合同前建议获取的信息\n\n- 先了解和你沟通的出租人**是否有权利出租该房屋**。\n\t- 必须验明房东产权证，验看出租人的身份证是否与产权证一致。\n\t- 代替家人（公公／婆婆／表亲）进行房屋出租的“房东”，是否为戏精租客扮演的二房东，如果是真的亲戚代理房东进行出租，如果出了问题，她能代理和解决么。\n\t- 尽量不要和房东朋友（基友／闺蜜）代理房东出租房屋产生合作，减少不必要麻烦。\n- 租客是否有权再次出租、转租房屋，如果是房东一般不允许出租，转租也是比较抵触的。\n- 房东是否能提供或者办理《房屋租赁许可证》，一般建议到当地街道派出所进行办理，对房东也是一种保护，不过这个会牵扯到一些额外的费用，许多房东会回避掉。\n\t- 该许可证也可能会因为特殊原因没有，如回迁房。\n- 查看房屋的实际使用条件与状况\n\t- 房子的实际使用面积是否能够接受\n\t- 房子的隔音效果是否能接受（邻居、街道）\n\t- 房子的家具是否有严重的气味（装修、家具、环境等因素）\n\t- 窗户是否严密，开关是否正常（漏风）\n\t- 如果阳台没有包裹，建议不要租，会有蚊虫、灰尘，以及保暖隐患。\n\t- 如果周围有工地和马路，不要租，会很喧哗，特殊情况，会喧哗到很晚。\n\t- 如果是老房子，房屋下水（洗手池/马桶/地漏）有问题，不要租，轻则影响自己，重则淹了楼下。\n\t- 如果是老房子，门锁有问题，房东含糊换锁或者不可以换锁的话，不要租。\n\t- 附加：电梯的使用（搬家/购置东西）\n\t- 如果缺少的东西，房东是否能补齐\n\t- 有条件的话，最好可以试住一到两天。检查的时候看不出问题，住进去潜在问题就会出来。\n- 简单了解治安状况\n\t- 小区、单元是否有门禁系统、或者物业保安值守。\n\t- 一般距离地铁越近的小区，流动性越大，距离地铁有十几分钟的走路时间的小区可能是不错的选择（共享单车、顺风车）。\n- 房子周围设施是否相对方便\n\t- 交通措施是否过度单一或者匮乏\n\t- 是否有社区医疗应急（附近有大医院可忽略）\n\t- 附近吃喝的地方多吗（依赖外卖、自己做饭可忽略）\n\t- 便利店、超市、购物中心是否存在，如果购置东西并非全部依赖在线，需要考虑线下购物的便利性。\n\t- 如果只是为了距离上班地点近，可以舍弃一些或者全部\n- **针对在上海的同学们：** 需要提前和与你签协议的人沟通，是否能办理居住证，办理居住证对于希望常驻上海的同学来说很重要，因为有些东西（买车买房小孩上学之类）是要看居住证的年限的。建议将*必须要办理居住证，否则随时可退房*作为补充条款写入。\n- **针对有小孩的同学们** 提前和房东沟通可否办理租住手续（官方），现在租住同权，如果租住的是学区房小孩可以在该学区上学，但是有的时候一些自己有小孩的房东可能会拒绝。\n- 明确公用的基础设施的使用和维修：对于群租的同学来说，**卫生间（热水器，洗衣机），厨房（煤气灶、冰箱、微波炉）**很可能是公用的，当公用的设施损坏以后，维修的责任需要在合同中厘清，并且规定维修时间，以防止房东或者二房东推脱责任，或者拖延不予维修。\n\n### 明确费用\n\n明确以下费用由谁承担，可以注明数字时间的费用建议进行备注说明。\n\n- 水费\n\t- 是否分冷水/热水/清洁用水，如果区分单独确定费用。\n\t- 比如北京热水涨价汹涌，问清楚价格，和充值方式（特别远的话，使用的话，多充值一点）。\n\t- 热水可能以非常长的时间为缴纳周期，入住时，确保热水费用之前房东和中介是正常缴纳的。（遇到过几年没缴纳过热水费的自如房子）\n- 电费\n\t- 缴费方式，自己交电卡，有无电卡，还是代缴，价格。\n\t- 是否为商用电（部分住宅是商用电）\n- 煤气费\n\t- 酒店公寓可能没有煤气，不存在煤气费一说。\n\t- 如果依赖此项目，优先查看。\n\t- 煤气费可能以非常长的时间为缴纳周期，入住时，确保煤气费用之前房东和中介是正常缴纳的。（遇到过几年没缴纳过煤气费的自如房子）\n- 电话费\n\t- 有的房子不存在此项，但是有的房子会是和房东手机绑定一起的。\n\t- 如果是合租的人绑定手机，那么要查看单子缴费是月度/季度/年度。\n-  电视费用\n\t- 即使你不使用这个设备，这个费用也要询问的，以免账单突然多出一年费用。\n- 卫生费\n- 物业费\n- 网费\n- 供暖费\n\t- 仅限北方，明确暖气费谁来承担，到了冬天才发现合同上未见说明。租金是承担了暖气费的标准的价格，但是却要自己交。以及暖气片存在位置会不会和合租人员产生缴费分歧。\n- 维修费和附带影响\n\t- 房东仓促做防水，防水坏掉了，楼下水漫金山，要维修，你可能要一半个月不能用卫生间。\n\t- 年代久远的空调因漏气/坏件，还要租客你承担费用的情况，另外如果是发生在南方冬天...\n\t- 灯泡这类易耗品最好也问下，一年不到，不知道是质量问题还是电压，换了4/5个，直到换了LED灯\n- 损坏赔偿\n\t- 如果存在某些情况，这个时候赔偿是补新，还是几倍价格，还是如何，确认清楚\n- 另外需要查看是否有欠费\n\t- 曾经遇到欠费600多的煤气费的业主出国，居委会三天两头上门找\n- 租赁期间对房屋修缮\n\t- 房屋以及附属设备出现问题或者故障，由谁维护，费用由谁承担\n\n### 租金支付\n\n- 租金由出租人收取，是承租人使用房屋的对价;\n- 物业管理费则由物业管理公司收取，是物业公司以自己的经营活动为所有业主、租户提供服务所收取的费用，二者不是一个法律关系，不能混为一谈。\n- 但如双方在合同中对于此项无具体约定，则出租人无权要求承租人支付物业管理费。\n- 签订租赁合同时要仔细阅读合同条款，对于模糊内容要详加询问，并落实于字面。\n\t- 在双方签订《房屋租赁合同》时最好将屋内所有物品详列一份清单，作为其合同附件收好。\n\t- 如果可能多复印一份，我和舍友租房子，结果都找不到合同了。\n\t- 合同明确租期内，房东是否可以涨价\n\t- 合同明确押金以及押金退换方式（**这里是深水区**）\n\t- 留意退房时卫生的字眼，比如“退房时房屋没有打扫干净，要扣200押金”。退房时的卫生要做到什么程度，要和房东提前明确，最好留录音和租房前的房屋照片。避免退房时被恶心房东刁难。\n- 如果万一不可避免地与奇葩房东发生冲突，可以参考以下维权案例\n\t- [DIY 打官司](https://g.leaskh.com/2014/11/13/DIY-打官司-目录/)\n\n### 退房退租\n\n- 不管出于什么原因，请尽早至少半个月，推荐一个月，和房东说明，以免耽误房东再次转租，影响自己的押金和人品。\n- 在退房前，如果钥匙丢失，不能如数退还给房东。建议尽可能配一把钥匙。以免房东以影响安全的名义要你换锁。其实就是变相要扣押金，不要给他开口的机会。\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"webpack","url":"%2F2019%2Fwebpack.html","content":"\n## 谈谈你对webpack的看法\nwebpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。\n\n> webpack 最出色的功能之一就是，除了 JavaScript，还可以通过 loader 引入任何其他类型的文件。\n\n## webpack的基本功能和工作原理？\n- 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等\n- 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等\n- 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载\n- 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件\n- 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器\n- 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过\n- 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。\n\n- Entry（入口）：Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。\n- Output（出口）：指示 webpack 如何去输出、以及在哪里输出\n- Module（模块）：在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。\n- Chunk（代码块）：一个 Chunk 由多个模块组合而成，用于代码合并与分割。\n- Loader（模块转换器）：用于把模块原内容按照需求转换成新内容。\n- Plugin（扩展插件）：在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件，并改变输出结果\n\n## webpack构建过程\n- 从entry里配置的module开始递归解析entry依赖的所有module\n- 每找到一个module，就会根据配置的loader去找对应的转换规则\n- 对module进行转换后，再解析出当前module依赖的module\n- 这些模块会以entry为单位分组，一个entry和其所有依赖的module被分到一个组Chunk\n- 最后webpack会把所有Chunk转换成文件输出\n- 在整个流程中webpack会在恰当的时机执行plugin里定义的逻辑\n\n1. 初始化：解析webpack配置参数，生成 Compiler 实例\n2. 注册插件：调用插件的apply方法，给插件传入compiler实例的引用，插件通过compiler调用Webpack提供的API，让插件可以监听后续的所有事件节点。\n3. 入口：读取入口文件\n4. 解析文件：使用loader将文件解析成抽象语法树 AST\n5. 生成依赖图谱：找出每个文件的依赖项（遍历）\n6. 输出：根据转换好的代码，生成 chunk\n7. 生成最后打包的文件\n\n## webpack打包原理\n将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载\n---\n<!--more-->\n\n## 什么是webpack，与gulp,grunt有什么区别\n- webpack是一个模块打包工具，可以递归地打包项目中的所有模块，最终生成几个打包后的文件。\n- 区别：webpack支持代码分割，模块化（AMD,CommonJ,ES2015），全局分析。gulp 是任务执行器(task runner)：就是用来自动化处理常见的开发任务，例如项目的检查(lint)、构建(build)、测试(test)\n\n## 什么是entry,output?\n- entry 入口，告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/index.js\n- output 出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist\n\n## 什么是loader，plugins?\n- loader是用来告诉webpack如何转换某一类型的文件，并且引入到打包出的文件中\n- plugins(插件)作用更大，可以打包优化，资源管理和注入环境变量(plugin是一个含有 apply 方法的类)\n\napply 方法中接收一个 compiler 参数，也就是 webpack实例。由于该参数的存在 plugin 可以很好的运用 webpack 的生命周期钩子，在不同的时间节点做一些操作。\n\n### 手写一个loader\nloader就是一个node模块(导出为函数的JS模块)，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的this上下文访问Loader API。传入上一个loader的结果或者资源文件。\n```js\n// 定义 reverse-txt-loader.js\nmodule.exports = function(src) {\n  //src是原文件内容（abcde），下面对内容进行处理，这里是反转\n  var result = src.split('').reverse().join(''); \n  //返回JavaScript源码，必须是String或者Buffer\n  return `module.exports = '${result}'`;\n}\n// 使用\n{\n\ttest: /\\.txt$/,\n\tuse: [\n\t\t{\n\t\t\t'./path/reverse-txt-loader'\n\t\t}\n\t]\n    // use: {\n    //     loader: './path/reverse-txt-loader',\n    //     include: path.resolve(__dirname, 'src'),// 指定需要转译的文件夹\n    //     exclude: path.resolve(__dirname, 'node_modules'),// 指定转译时忽略的文件夹  \n    // }\n},\n```\n注意点：\n- 编写 Loader 时要遵循单一职责，每个 Loader 只做一种\"转义\"工作。每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback()方法，将内容返回给 webpack。 还可以通过 this.async()生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。\n- Loader 运行在 Node.js 中，我们可以调用任意 Node.js 自带的 API 或者安装第三方模块进行调用\n- Webpack 传给 Loader 的源内容默认都是 UTF-8 格式编码的字符串，当某些场景下 Loader 处理二进制文件时，需要通过 exports.raw = true 告诉 Webpack 该 Loader 是否需要二进制数据\n- 尽可能的异步化 Loader，如果计算量很小，同步也可以\n- Loader 是无状态的，我们不应该在 Loader 中保留状态\n- 使用 loader-utils 和 schema-utils 为我们提供的实用工具\n\n### 手写一个plugin\n```js\nclass DemoWebpackPlugin {\n    constructor () {\n        console.log('初始化 插件')\n    }\n    apply (compiler) {\n    }\n}\n\nmodule.exports = DemoWebpackPlugin\n```\n\n## 什么是bundle,chunk,module?\nbundle是webpack打包出来的文件，chunk是webpack在进行模块的依赖分析的时候，代码分割出来的代码块，module是开发中的单个模块。\n\n## 如何自动生成webpack配置？\n可以用一些官方脚手架\n\n- webpack-cli\n- vue-cli\n\n```js\n// 首先安装\nnpm install -g @vue/cli\n// 新建项目hello\nvue create hello\n```\n\nnuxt-cli\n```js\n// 确保安装了npx,npx在npm5.2.0默认安装了\n// 新建项目hello\nnpx create-nuxt-app hello\n```\n\n## webpack如何配置单页面和多页面的应用程序？\n```js\n// 单个页面\nmodule.exports = {\n    entry: './path/to/my/entry/file.js'\n}\n\n// 多页面应用程序\nmodule.entrys = {\n    entry: {\n        pageOne: './src/pageOne/index.js',\n        pageTwo: ['./src/pageTwo/index.js', \"./src/pageTwo/main.js\"],\n    }\n}\n```\n多入口可以通过 HtmlWebpackPlugin 分开注入\n```js\nplugins: [\n  new HtmlWebpackPlugin({\n    chunks: ['pageOne'],\n    filename: 'test.html',\n    template: 'src/assets/test.html'\n  })\n]\n```\n\n## 几个常见的loader\n- file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件\n- url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去\n- source-map-loader：加载额外的 Source Map 文件，以方便断点调试\n- image-loader：加载并且压缩图片文件\n- babel-loader：把 ES6 转换成 ES5\n- css-loader：加载 CSS，支持模块化、压缩、文件导入等特性\n- style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。\n- eslint-loader：通过 ESLint 检查 JavaScript 代码\n\n## 几个常见的plugin\n- define-plugin：定义环境变量\n- terser-webpack-plugin：通过TerserPlugin压缩ES6代码\n- html-webpack-plugin 为html文件中引入的外部资源，可以生成创建html入口文件\n- mini-css-extract-plugin：分离css文件\n- clean-webpack-plugin：删除打包文件\n- happypack：实现多线程加速编译\n\n```js\nvar UglifyJSPlugin = require('uglifyjs-webpack-plugin');\nvar webpack = require('webpack');\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\nvar providePlugin = new webpack.ProvidePlugin({$: 'jquery', jQuery: 'jquery', 'window.jQuery': 'jquery'});\nmodule.exports = {\n    entry: {\n        index: './src/js/index.js',\n        goodsInfo: './src/js/goodsInfo.js'\n    },\n    output: {\n        filename: '[name].js',\n        path: __dirname + '/out',\n        publicPath: 'http://localhost:8080/out'\n    },\n    module: {\n        rules: [\n            {test: /.js$/, use: ['babel-loader']},\n            // // {test: /.css$/, use: ['style-loader','css-loader']},\n            // {\n            //     test: /.css$/,\n            //     use: ExtractTextPlugin.extract({\n            //       fallback: \"style-loader\",\n            //       use: \"css-loader\"\n            //     })\n            // },\n            {test: /.jpg|png|gif|svg$/, use: ['url-loader?limit=8192&name=./[name].[ext]']}, \n            {test: /.less$/, use: ['style-loader', 'css-loader', 'less-loader']}\n        ]\n    },\n    plugins: [\n        new UglifyJSPlugin(),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \"commons\",\n            filename: \"commons.js\",\n            minChunks:2}),  \n        new ExtractTextPlugin(\"[name].css\"), \n        providePlugin     \n    ],\n    externals: {\n    // 从输出的 bundle 中排除 echarts 依赖\n    echarts: 'echarts',\n  }\n}\n```\n\n## webpack-dev-server\n1. 用express启一个服务\n2. sockjs与页面互动。\n\n底层一方面使用webpack在服务器端进行构建打包，一方面在客户端注入runtime以便和服务器端建立联系。还提供了代理功能，代理有很多应用场景，举几个简单的例子：本地数据接口模拟、远端接口调试、分拆接\n口到不同的远端服务器等。\n\n### 自动刷新\n- iframe模式 http://[host]:[port]/webpack-dev-server/[path]\n✦ 无需额外的配置\n✦ 顶部条可以显示编译信息\n✦ 浏览器的地址不会跟着页面URL变动\n\n- inline模式 http://[host]:[port]/[path]\n✦ 需要额外的配置\n✦ 编译信息只能在命令行和浏览器console中查看\n✦ 浏览器的地址和页面URL同步\n\n### 热替换HMR 只支持inline模式\n> webpack-dev-server --inline --hot\n\n### 哈希值计算方式\nwebpack给我们提供了三种哈希值计算方式，分别是 hash 、chunkhash 和 contenthash。\n- hash：跟整个项目的构建相关，构建生成的文件hash值都是一样的，只要项目里有文件更改，整个项目构建的hash值都会更改。\n- chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的hash值。\n- contenthash：由文件内容产生的hash值，内容不同产生的contenthash值也不一样。\n\n### devServer配置\n- devServer.compress， 启用gzip压缩。\n- devServer.contentBase，告诉服务器从哪里提供内容。 只有在你想要提供静态文件时才需要。\n- devServer.host， 指定host。 使用0 .0 .0 .0 可以让局域网内可访问。\n- devServer.hot， 启用 webpack 的模块热替换特性（ Hot Module Replacement）。\n- devServer.inline， 模式切换。 默认为内联模式， 使用false切换到iframe模式。\n- devServer.open， 启动webpack - dev - server后是否使用浏览器打开首页。\n- devServer.port， 监听端口号。 默认8080。\n- devServer.proxy， 代理， 对于另外有单独的后端开发服务器API来说比较适合。\n- devServer.publicPath， 设置内存中的打包文件的输出目录。 区别于output.publicPath。\n- devServer.historyApiFallback，回退:支持历史API。\n- devServer.progress，让编译的输出内容带有进度和颜色。\n\n![webpack-hmr](http://cdn.mydearest.cn/blog/images/webpack-hmr.png)\n\n注释：绿色是webpack控制区域，蓝色是webpack-dev-server控制区域，红色是文件系统，青色是项目本身。\n\n第一步：webpack监听文件变化并打包（1，2）\nwebpack-dev-middleware 调用 webpack 的 api 对文件系统 watch，当文件发生改变后，webpack 重新对文件进行编译打包，然后保存到内存中。 打包到了内存中，不生成文件的原因就在于访问内存中的代码比访问文件系统中的文件更快，而且也减少了代码写入文件的开销\n\n第二步： webpack-dev-middleware对静态文件的监听（3）\nwebpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念\n\n第三步：devServer 通知浏览器端文件发生改变（4）\nsockjs 在服务端和浏览器端建立了一个 webSocket 长连接，以便将 webpack 编译和打包的各个阶段状态告知浏览器，最关键的步骤还是 webpack-dev-server 调用 webpack api 监听 compile的 done 事件，当compile 完成后，webpack-dev-server通过 _sendStatus 方法将编译打包后的新模块 hash 值发送到浏览器端。\n\n第四步：webpack 接收到最新 hash 值验证并请求模块代码（5，6）\nwebpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器（执行步骤11），也就没有后面那些步骤了。\n\n第五步：HotModuleReplacement.runtime 对模块进行热更新（7,8,9）\n是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。\n\n第六步：HotModulePlugin 将会对新旧模块进行对比（10）\nHotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用 ，第一个阶段是找出 outdatedModules 和 outdatedDependencies。第二个阶段从缓存中删除过期的模块和依赖。第三个阶段是将新的模块添加到 modules 中，当下次调用 __webpack_require__ (webpack 重写的 require 方法)方法的时候，就是获取到了新的模块代码了。\n\n### 使用场景\n\n工具的使用是分场景的，Rollup的使用场景是，你的代码基于 ES6 模块编写，并且你做的东西是准备给他人使用的。\n\n有一句经验之谈：在开发应用时使用 Webpack，开发库时使用 Rollup。\n","tags":["打包"],"categories":["工具"]},{"title":"成为优秀程序员的建议","url":"%2F2019%2F%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BB%BA%E8%AE%AE.html","content":"\n### 1. 善用google⭐   \n作为一名程序员，你要知道如何搜索问题的答案。学会有效的使用google，你将节省大量开发时间。  \n\n### 2. 谨慎承诺超额交付⭐\n让你的团队知道一项任务需要三周的时间，并在两周内完成，这比让他们知道相反的情况要好。通过谨慎承诺和超额交付，你会建立信任。\n   \n### 3. 善待产品设计人员，他们是你的朋友   \n产品设计人员为用户的痛点提供解决方案。向他们学习，团结一致地构建有效的产品。\n\n### 4. 找到一名导师  \n找到一个可以学习和借鉴的人。如果你需要技术指导，[Coding Coach](https://codingcoach.io/)会是一个不错的地方。\n\n### 5. 成为一名导师   \n做一个别人可以学习和借鉴的人。你可以尝试在[Coding Coach](https://codingcoach.io/)成为别人的导师。\n\n### 6. 写些有用的评论\n写下有用的回答而不是问为什么，mark和灌水也没什么意思。\n\n---\n<!--more-->\n\n### 7. 合理的命名变量和函数名  \n函数和变量应该准确地表示它们的用途，因此myCoolFunction不是一个好名字。\n\n### 8. 给自己放个假   \n我们都需要时间来缓解压力。去一个你一直想去的地方放个假。你的大脑和同事都会感谢你的。\n\n### 9. 删除无用代码⭐   \n没有理由积累更多技术债务。\n\n### 10. 学会阅读代码⭐ \n阅读代码是一项非常宝贵的被低估的技能。\n\n### 11. 找到健康工作和生活平衡点   \n结束一周的工作之后，周末放松一下。关闭工作通知，删除手机上的应用程序。\n\n### 12. 只安排必要的会议 \n能用邮件解决的就没必要开会，如果非要开，也应该让会议简短高效。\n\n### 13. 结对编程   \n结对编程可以让你同时扮演老师和学生的角色。\n\n### 14. 写好邮件\n邮件的内容应该简洁而清晰，抓住重点。没人会想看你的四页邮件，兄弟。\n\n### 15. 加入社区⭐\n和志同道合的人在一起会激励你走出低谷。\n\n### 16. 清理你的分支⭐\n清理你的版本控制分支，就像在你的岳父母来访之前清理你的房子一样。如果你不再需要，请删掉它，不删留着过年啊。\n\n### 17. 接纳萌新\n包容点，不要告诉别人不够好，不能进入这个行业，每个人都是有价值。\n\n### 18. 活到老学到老   \n你选择了一个需要不断学习的职业，学会爱上它。\n\n### 19. 永不言弃   \n这并不容易，但是我们都是从同一个地方开始，你也能做到。  \n\n### 20. 敢于接受有挑战性的任务⭐ \n如果任务没有挑战，它就不会帮助你成长。\n\n### 21. 项目开始前明确需求⭐\n在开撸之前，你应该了解验收标准，这将为你节省时间和痛苦。\n\n### 22. 工欲善其事，必先利其器⭐   \n拥有一套你熟悉的工具，了解哪些工具服务于哪些目的，以及项目何时可以从使用这些工具中获益。\n\n### 23. 我们需要建设性的批评   \n向信任的同事和朋友寻求建设性的批评，它将帮助你更优秀。 \n\n### 24. 保持开放思维⭐\n技术在变化，而且变化得很快。不要反对新技术，学习它，然后形成自己的观点。 \n\n### 25. 保持在技术前沿，不要掉队⭐\n通过关注出版物，博客，播客和科技新闻，及时了解最新的科技新闻。\n\n### 26. 专注于解决问题⭐ \n锻炼自己解决问题的能力，强大的解决问题的能力能够帮助你应付一切，专注于解决问题的方法。\n\n### 27. 保持谦虚⭐\n三人行必有我师，无论你什么头衔，什么公司，都要保持谦逊。\n\n### 28. 不光要代码写的好，PPT也要讲得好  \n学习如何吸引你的听众，并给出有效的演示。\n\n### 29.  选型如买菜，也要货比三家⭐     \n给自己更多选择，在开展工作前，调研尽可能多的解决方案。\n\n### 30. 找到自己的定位⭐   \n科技产业也有很多分类，找到你最感兴趣的领域，并成为一名专家。\n\n### 31. 养成好习惯⭐   \n试着建立一致的、健康的习惯，比如保持专注，合理安排时间，出席会议，从最重要的任务开始。这可能需要一些时间来适应，但从长远来看是值得的。\n\n### 32. 学会debug⭐ \n探索浏览器调试器工具。学习使用IDE调试的细节。通过学习最有效的调试问题和跟踪错误的方法，再困难的bug也能搞定。\n\n### 33. 锻炼你现有的技能⭐     \n并不是说你已经掌握了一项技能就不需要再锻炼它。业精于勤荒于嬉，除非有意识地提高技能，否则技能会随着时间的推移而消失。而这个行业又发展得如此之快，坚持练习是很重要的。从“我一直都是这样做的”的心态中走出来，进入“有没有更好的方法来做这件事”的心态。  \n\n仅仅是因为你现在拥有六块腹肌，不意味着你就可以每天吃一个🍩。\n\n### 34. 了解原因⭐   \n有时你必须表达自己的意见，因此了解其背后的原因非常重要。为什么解决方案A比解决方案B更好？提供有效的论据，你的意见将更加可靠。\n\n### 35. 了解自己的价值   \n技术也是商品，应该得到适当的报酬。了解你所在地区的行业平均水平。如果你赚的钱少了，是时候和你的老板谈谈，追求你应得的。\n\n### 36. 不要害怕寻求帮助⭐   \n如果你被困在一个问题上，花了太多时间寻找解决方案，是时候寻求帮助了。我们都是人，我们都需要帮助，寻求同事的援助并不可耻。\n\n### 37. 学会学习⭐ \n人们学习的方式不同，有些人通过视频教程学得最好，有些人通过阅读书籍学得最好。弄清楚你的学习风格，然后努力实践。\n\n### 38. 与人为善   \n有时你会被要求向同事提供反馈，友善一点，你可以对某位同事不够积极表达看法，而不是出言不逊。\n\n### 39. 休息一下 \n连续敲8个小时代码几乎是不可能，你很快就会筋疲力尽，犯很多错误。所以设个闹钟来提醒自己停下来休息一下。去散散步，和同事一起喝杯咖啡，远离屏幕会对你的工作效率和质量产生积极的影响。\n\n### 40. 跟踪你的学习进度\n学习编程需要时间，当你看不到进展时，你会感到非常沮丧。所以跟踪你的成就和实现目标的进展非常重要。在你的电脑旁边放一个小清单，每次你完成一件事，把它写下来，不管它有多小，最终将会从量变到质变。\n\n### 41. 不要依赖库和框架⭐\n掌握一个框架和库不如深入学习这门语言，没有必要一个接一个的学习这些库和框架，但是理解框架和库如何实现可以帮助你写出更简洁强壮的代码。\n\n### 42. 学会爱上代码审查\n让别人阅读和分析你的代码可能会让你不安，但是可以提供宝贵的反馈，这会让你成为一个更好的程序员。而且你也应该提高进行良好代码评审的能力。\n\n### 43. 多方位全面学习\n学习其他领域的基础知识, 如设计、营销、前端开发或后端开发。它将帮助你成为一个更全面的程序员。\n\n### 44. 不要选择熟悉的技术，而应该是正确的⭐   \n每个项目都有不同的需求，因此我们必须为这项工作选择合适的工具。尽管选择以前使用过的技术很方便，但是如果它们不适合项目的需要，应该探索其他替代方案。\n\n### 45. 勇于承担责任⭐   \n所有人都会犯错，在你的职业生涯中，你会犯很多很多的错误。因此，当你犯了错误时，站出来承担责任是很重要的，它将与你的团队成员和管理层建立信任。\n\n### 46. 检查自己的代码⭐   \n在发起PR请求之前，检查自己的代码，如果这是同事的工作，你会发表什么评论？在请求代码审查之前首先尝试自己诊断问题或错误非常重要，就像考试交卷前应该自己检查一遍。\n\n### 47. 从失败中吸取教训⭐   \n失败只是没有达到预期的结果，并不一定是件坏事。在我们的职业生涯中，我们会面临很多失败，从失败中学习下次你能做些什么。   \n\n### 48. 正视自己的缺点   \n了解你自己，你的缺点是什么?也许你总是在推送之前忘记更新测试，或者你真的不擅长回复电子邮件。了解你的弱点，这样你就能积极地改善它们。\n\n### 49. 保持好奇心⭐   \n这个行业在不断发展，所以好奇心很重要。如果你不明白什么，不管是项目需求还是一行代码，大声说出来。没有人会因为你要求说明而批评你，你会因此创造出更好的代码。   \n\n### 50. 不要试图学习一切⭐\n世界上有无穷无尽的知识宝库，你不可能征服它。选择几个要掌握的主题，其余的就不要管了。你可以获得其他领域的相关知识，但你不可能掌握所有内容。\n\n### 51.  该舍弃就舍弃\n仅仅因为你写了一些代码并不意味着你需要对它产生感情。没有人喜欢他们所做的工作被丢弃，但是代码有一个生命周期，所以没有必要一直保留着它。\n\n### 52.  团队支持\n优秀的团队相互支持，这为尝试新事物创造了一个安全的空间，而不用担心受到惩罚。\n\n### 53. 在社区中寻找鼓舞\n在行业里找几个你钦佩的人。它会激励你继续你的项目或尝试新事物\n\n### 54. 重视并且珍惜你的工作\n不管你有多少经验或者你的职位是什么，你的工作都是有价值的，给予它应有的价值。\n\n### 55. 排除干扰\n关掉闲置的通知、短信、电子邮件和社交媒体会帮助你集中精力，最大化你的工作日。晚30分钟回复你朋友的信息，他死不了，真有事就打电话了。\n\n### 56. 乐于助人\n试着支持你的团队成员，无论是参加一个重要的演讲，还是在他们遇到困难时帮助他们。\n\n### 57. 不要吝啬你的赞美⭐\n如果有人做得很好，告诉他们。正面反馈是与团队成员建立信任和帮助他们事业发展的好方法。他们也更有可能帮助你\n\n### 58. 测试你的代码⭐\n测试是很重要的。单元测试、回归测试、集成测试、端到端测试。测试你的代码，你的产品将会更加稳定。\n\n### 59. 制定应对计划\n当你收到一个新功能需求或bug修改时，先制定应对计划，你需要什么来解决这个问题或开发这个特性？花几分钟来做这件事，也许后面可以为你节省数小时的沮丧。\n\n### 60. 掌握伪代码\n伪代码是一项很好的技能，因为它允许你在不浪费时间编写代码的情况下考虑复杂的问题。将一种方法写在纸上，运行不同的测试用例，看看缺陷在哪里。\n\n### 61. 记录你的成就\n如果你在工作中获得了嘉奖，把它写下来。如果你开发了一个重要的功能，把它写下来。你会拥有一些积累、沉淀，它将有助于你职业晋升亦或在某一艰难的日子鼓舞你的士气。\n\n### 62. 学习编程基础⭐ \n学习一些基本的排序和搜索算法以及数据结构。它们与语言无关，可以帮助你跨语言解决问题。\n\n### 63. 选择长期维护的技术\n尽管测试最新的技术很有趣，但是选择那些在企业应用程序中易于维护的技术。你们的团队将在未来的岁月里感谢你们。\n\n### 64. 学习设计模式⭐\n设计模式是构建代码的有效工具。你可能不是每个项目都需要它们，但是对它们有一个基本的了解将有助于构建更大的应用程序。\n\n### 65. 化繁为简⭐\n不要编写复杂的代码来展示你高超的编程技能，而要着眼于可读性和简单性。这将使你的团队成员更容易做出贡献。\n\n### 66. 还清技术债务\n技术债务可能会对性能产生巨大影响，所以如果能够重构，就应该重构。（这个建议绝对是好的，但是现实中要面临诸多问题）\n\n### 67. 优先小版本迭代\n与其每个月发布一次大规模的升级，不如更频繁地发布较小的变更。这样你不太可能会引入bug和破坏更改。\n\n### 68. 尽早并经常提交⭐\n尽早提交和经常提交是确保你的工作保持干净的最好方法，并且还可以减少意外地恢复重要更改的压力。\n\n### 69. 了解何时寻求帮助\n你不仅不应该害怕寻求帮助，而且你应该学会什么时候寻求帮助。在寻求帮助之前，你应该试着解决问题，并记录下你尝试的事情。但是当你被一个简单的问题难住一个多小时的时候，代价大于收益，你应该向同事求助。\n\n### 70. 问一些有效的问题⭐\n当你问问题的时候，要尽可能的具体，（可以参考github提issue的要求）。\n\n### 71. 工作中及时寻求反馈\n你的工作不需要完成就能得到反馈。如果你不确定方向，请一位值得信赖的同事来检查你的解决方案的有效性。\n\n### 72. 阅读文档⭐\n文档是关于技术的最纯粹的事实来源，因此学习阅读文档可以快速帮助你成为专家。\n\n###　73. 尽可能做出各种尝试⭐\n没有什么能阻止你尝试解决问题的方法，你有什么损失呢？\n\n### 74. 在会议上积极发言\n你的想法和意见是有价值的，所以参加会议将有助于你与你的团队和管理层建立融洽的关系。\n\n### 75. 跨团队协作\n如果你有机会和公司里的其他团队一起工作，那就去争取吧。\n\n### 76. 保持项目热情\n当你每周工作40个小时时，花时间做你感兴趣的项目是很重要的（72小时的话更要如此）。它们可以帮助你重新找回对编程的热爱，并尝试你在工作中可能无法接触到的新技术。\n\n### 77. 确定你的职业目标⭐\n对你的职业生涯有一个理想的轨迹是很重要的。如果你不这样做，你就是在没有目标的情况下射箭。\n\n### 78. 加入到讨论中来⭐\n在博客上发表评论，参与Twitter主题，参与社区活动，做一个积极的旁观者会比单纯的旁观学到更多东西。\n\n### 79. 确定任务优先级\n学会确定任务的优先顺序将有助于提高您的工作效率，建立一个日常任务和长期任务待办事项列表，并按最重要的顺序排序。\n\n### 80. 不要忽略细节\n细节可以在项目中产生很大的影响。\n\n### 81. 信任你的同事\n你的同事因为他们的技能而被雇佣，交给他们工作，并相信他们能完成。\n\n### 82. 学会委托\n如果你处于领导地位，学习如何有效地委派任务。它会节省你的时间，你不能做所有的事。\n\n### 83. 不要拿自己和别人比较\n你唯一应该比较的是昨天的自己。\n\n### 84. 找到你的盟友\n学习编程将是一个漫长而不怎么容易的过程，和那些帮助你成长并鼓励你坚持下去的人在一起。\n\n### 85. 不要想一步登天⭐\n一开始考虑太多做一个大而全的项目会让你不堪重负。构建时要考虑可伸缩性，但在需要时才开始扩展。这样你就不会用不必要的膨胀来压倒你的团队，而是保持了成长的能力。\n\n### 86. 衡量性能影响⭐\n如果你想使用一种很酷的新技术，你应该权衡这样做的性能影响。你能在不影响性能的情况下实现类似的功能吗？如果可以，你可能需要重新考虑你的方法了。\n\n### 87. 技术歧视不可取⭐\n不要歧视新技术或新想法，对学习新技能的可能性保持开放的心态，也不要歧视他人，我们都值得尊重。（也不要歧视旧技术，即使现在前端框架盛行，但你也不能说Jquery就没有任何可取之处。）\n\n### 88. 申请你不能胜任的工作\n你永远不可能满足工作的所有要求，所以抓住机会申请吧，你有什么损失呢？\n\n### 89. 模块化你的代码\n你可以在一个长文件中编写所有代码，但这是不可维护的。通过模块化，我们确保代码易于理解和测试。\n\n### 90. 不要只是做代码的搬运工⭐\n如果你要复制并粘贴[Stack Overflow](https://stackoverflow.com/)中的解决方案，你应该确切地理解它的作用，有意识地选择要引入的代码。\n\n### 91. 创造一个舒适的工作环境⭐\n如果你喜欢你的工作环境和技术设置，你会更有动力去工作，所以还在等什么？\n\n### 92. 记住你来自哪里\n我们都是从同一个地方开始的，随着你的技能和职位的发展，不要忘记你来自哪里，不要膨胀。\n\n### 93. 试着保持乐观\n如果出了什么问题，试着乐观一点。明天是新的一天。乐观会帮助你的团队充满活力和精神健康。\n\n### 94. 不断重新评估你的工作流程⭐\n仅仅因为某样东西现在有效，并不意味着它永远有效。重新评估你的工作流程，并在必要时做出调整。\n\n### 95. 学会在家办公\n如果你有能力在家工作，那就学会有效地在家工作。找一个独立的办公空间，远离干扰。[Boneskull](https://dev.to/boneskull/pro-tips-for-devs-working-at-home-3b63)写了一篇很棒的关于在家工作的文章，你应该看看。\n\n### 96. 无障碍代码\n无障碍不是事后才想到的，也不一定很难，每个人都应该能够使用你的产品。\n\n### 97. 遵守你的承诺⭐\n如果你告诉别人你会在某一天完成某件事，要信守承诺。如果你不能在截止日期前完成任务，那就早点说出来。\n\n### 98. 积极主动\n如果你有额外的精力，找一个任务来帮助你的团队，他们会很感激你是主动的。\n\n### 99. 创建一个令人惊叹的作品集\n一个优秀的作品集让你与众不同，使用它作为展示你的编程和设计技巧的机会！\n\n### 100. 记住你喜欢编程的原因⭐\n你进入这个行业是因为它激发了你的兴趣，如果你感到沮丧和怨恨，休息一下，给自己空间重新点燃你对编程的激情。\n\n### 101. 分享你的知识⭐\n如果你学到了一些很酷的东西，不要吝惜分享它，参加当地的技术交流会，在午餐时间教你的同事或学员，分享你的知识可以让更多人受益同时自己也能巩固提高。\n\n完结撒花 🎉🎉🎉\n\n这就是我关于成为一个优秀程序员的全部建议，希望你们喜欢。\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"Commit Message规范","url":"%2F2019%2FCommit%20Message%E8%A7%84%E8%8C%83.html","content":"\n在团队开发中，commit message（提交说明）就如同代码注释一样重要。良好的commit message能让团队中的其他成员对你的每次提交的目的、\n\n涉及的代码范围及作用一目了然，方便日常的查询和帮助其他成员更好的帮你Code Review，必要时还能方便的生成Change log。\n\n---\n<!--more-->\n\n## Commit message格式\n\n```js\n// 格式：<type>(<scope>): <subject>\n```\n\n1. type：\n`必填` 用于说明commit的类型。总共7个标识：\n\n- feat： 新增feature\n- fix: 修复bug\n- docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等\n- style: 仅仅修改了空格、格式缩进、变量名等等，不改变代码逻辑\n- refactor: 代码重构，没有加新功能或者修复bug\n- perf: 优化相关，比如提升性能、体验\n- test: 测试用例，包括单元测试、集成测试等\n- chore: 改变构建流程、或者增加依赖库、工具等\n- revert: 回滚到上一个版本\n\n2. scope：\n`可选` scope用于说明 commit 影响的范围，比如数据层、控制层、视图层或者目录甚至文件等等，视项目不同而不同。\n\n3. subject：\n`必填` subject是 commit 目的的简短描述，不超过50个字符。\n\n- 约定好commit message的语言，对我们来说最好使用中文\n- 最好以动词开头（如使用英文请使用第一人称现在时，并且第一个字母小写）\n- `<scope>`之后的冒号后面留一个英文输入法的空格\n- 结尾不加句号或其他标点符号\n- 若此次commit是解决某个issue应该在行末尾注明并加链接，如：...(#101)\n\n## git commit中使用emoji\n```js\ngit commit -m \":tada: Initialize Repo\"\n```\n\n|emoji\t|emoji代码|\tCommit说明|\n|:---|:---|:---|\n|🎨 (调色板) |:art: |改进代码结构/代码格式|\n|⚡️ (闪电) |:zap: |提升性能|\n|🐎 (赛马)\t|:racehorse:\t|提升性能|\n|🔥 (火焰)\t|:fire:\t|移除代码或文件|\n|🐛 (bug)\t|:bug: |修复 bug|\n|🚑 (急救车)\t|:ambulance: |重要补丁|\n|✨ (火花)\t|:sparkles:\t|引入新功能|\n|📝 (铅笔)\t|:pencil:\t|撰写文档|\n|🚀 (火箭)\t|:rocket:\t|部署功能|\n|💄 (口红)\t|:lipstick:\t|更新 UI 和样式文件|\n|🎉 (庆祝)\t|:tada:\t|初次提交|\n|✅ (白色复选框)\t|:white_check_mark:\t|增加测试|\n|🔒 (锁)\t|:lock:\t|修复安全问题|\n|🍎 (苹果)\t|:apple:\t|修复 macOS 下的问题|\n|🐧 (企鹅)\t|:penguin:\t|修复 Linux 下的问题|\n|🏁 (旗帜)\t|:checked_flag:\t|修复 Windows 下的问题|\n|🔖 (书签)\t|:bookmark:\t|发行/版本标签|\n|🚨 (警车灯)\t|:rotating_light:\t|移除 linter警告|\n|🚧 (施工)\t|:construction:\t|工作进行中|\n|💚 (绿心)\t|:green_heart:\t|修复 CI 构建问题|\n|⬇️ (下降箭头)\t|:arrow_down:\t|降级依赖|\n|⬆️ (上升箭头)\t|:arrow_up:\t|升级依赖|\n|👷 (工人)\t|:construction_worker: |添加 CI 构建系统|\n|📈 (上升趋势图)\t|:chart_with_upwards_trend:\t|添加分析或跟踪代码|\n|🔨 (锤子)\t|:hammer:\t|重大重构|\n|➖ (减号)\t|:heavy_minus_sign:\t|减少一个依赖|\n|🐳 (鲸鱼)\t|:whale:\t|Docker 相关工作|\n|➕ (加号)\t|:heavy_plus_sign:\t|增加一个依赖|\n|🔧 (扳手)\t|:wrench:\t|修改配置文件|\n|🌐 (地球)\t|:globe_with_meridians:\t|国际化与本地化|\n|✏️ (铅笔)\t|:pencil2:| typo|\n\n\n## Commit message检查工具\n\n1. [commitizen](https://github.com/commitizen/cz-cli): 一个撰写合格 Commit message 的工具；\n\n2. [validate-commit-msg](https://github.com/kentcdodds/validate-commit-msg): 用于检查 Node 项目的 Commit \n\nmessage 是否符合格式。\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"提问的智慧","url":"%2F2019%2F%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7.html","content":"\n## 提问之前\n\n在向别人提出一个技术问题之前，请尝试从以下几个途径去寻找答案：\n\n1. Google\n\n2. Stackoverflow\n\n3. 相应的社区\n\n4. 官方文档\n\n5. 项目的Issue\n\n6. 项目源码（看个人能力）\n\n## 提问之时\n\n以上尝试无果的情况下向别人提出问题时：\n\n1. 认真做足相关功课，并整理好提问思路\n\n2. 礼多人不怪，一定要谦虚礼貌\n\n3. 清楚描述使用的环境、需求及问题的症状，语言要精简\n\n4. 能够提供一些问题的必要的截图、例子或者错误信息\n\n## 提问结束\n\n1. 一定要表示感谢，不管问题有没有得到解决\n\n2. 如果问题解决，在论坛或者社区一定要 留下你的解决方案并加以必要的说明，方便后人(我深受其害)；哪怕是问的身边的人，有价值的问题也要在博客上做记录\n\n3. 如果以上方法都尝试了还是解决不了那就先放一放，说不定过两天就有思路了\n\n4. 再不行，那就换个思路或者方案来解决你的需求吧\n\n参考资料：\n\nhttps://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"效率工作","url":"%2F2019%2F%E6%95%88%E7%8E%87%E5%B7%A5%E4%BD%9C.html","content":"\n1. 时间常有，时间在于优先。\n\n2. 时间总会有的：每天只计划 4～5 小时真正的工作。\n\n3. 当你在状态时，就多干点；不然就好好休息：有时候会连着几天不是工作状态，有时在工作状态时却又能天天忙活 12 小时，这都很正常的。\n\n4. 重视你的时间，并使其值得重视：你的时间值 1000 美元/小时，你得动起来。\n\n5. 不要多任务，这只会消耗注意力；保持专注，一心一用。\n\n6. 养成工作习惯，并持之以恒，你的身体会适应的。\n\n7. 在有限的时间内，我们总是非常专注并且有效率。\n\n8. 进入工作状态的最佳方式就是工作，从小任务开始做起，让工作运转起来。\n\n9. 迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” 。动手做，胜过任何完美的想象。\n\n10. 工作时间越长，并不等于效率越高。\n\n11. 按重要性工作，提高效率。\n\n12. 有会议就尽早安排，用于准备会议的时间往往都浪费掉了。\n\n13. 把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。\n\n14. 一整天保持相同的工作环境。在项目/客户之间切换，会效率低。\n\n15. 工作—放松—工作=高效(番茄工作法)。\n\n> 番茄工作法是弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n\n16. 把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。\n\n17. 从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。\n\n18. 必须清楚白天必须完成的那件事，是什么。 只去做那件有着最大影响的事情。\n\n19. 把任务按时间分段，就能感觉它快被搞定了。\n\n20. 授权并擅用他人的力量。—君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！\n\n21. 把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。—好汉不提当年勇。\n\n22. 给所有事情都设定一个期限。不要让工作无期限地进行下去。\n\n23. 针对时间紧或有压力的任务，设置结束时间，万事皆可终结。\n\n24. 多记，多做笔记。\n\n25. 进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。\n\n26. 休息，休息一下～。","tags":["杂谈"],"categories":["杂谈"]},{"title":"ES6Proxy","url":"%2F2019%2FES6Proxy.html","content":"\nProxy，代理，是ES6新增的功能，可以理解为代理器（即由它代理某些操作）。\n\nProxy 对象用于定义或修改某些操作的自定义行为，可以在外界对目标对象进行访问前，对外界的访问进行改写。\n\nProxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。\n\n---\n<!--more-->\n\n### 1. Proxy 定义\n```js\nvar proxy = new Proxy(target, handler)\n```\n\n`new Proxy()`表示生成一个 Proxy 实例\n\n* target：目标对象\n* handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。\n\n**注意：要实现拦截操作，必须是对 Proxy 实例进行操作，而不是针对目标对象 target 进行操作。**\n\n首先，看个例子：\n\n```js\nlet handler = {\n    get: function(target, key, receiver) {\n        console.log(`getter ${key}!`)\n        return Reflect.get(target, key, receiver)\n    },\n    set: function(target, key, value, receiver) {\n    \tconsole.log(`setter ${key}=${value}`)\n\t\treturn Reflect.set(target, key, value, receiver)\n\t}\n}\nvar obj = new Proxy({}, handler)\nobj.a = 1 // setter a=1\nobj.b = undefined // setter b=undefined\n\nconsole.log(obj.a, obj.b) \n// getter a!\n// getter b!\n// 1 undefined\n\nconsole.log('c' in obj, obj.c)\t\n// getter c!\n// false undefined\n```\n\n在这个例子中，proxy 拦截了get和set操作。\n\n再看一个例子：\n\n```js\nlet handler = {\n    get: function(target, key, receiver) {\n        return 1\n    },\n  \tset: function (target, key, value, receiver) {\n    \tconsole.log(`setting ${key}!`);\n    \treturn Reflect.set(target, key, value, receiver);\n  \t}\n}\nvar obj = new Proxy({}, handler)\nobj.a = 5 // setting a!\nconsole.log(obj.a) // 1\n```\n\n则由上面代码看出：**Proxy 不仅是拦截了行为，更是用自己定义的行为覆盖了组件的原始行为**。\n\n**若`handler = {}`，则代表 Proxy 没有做任何拦截，访问 Proxy 实例就相当于访问 target 目标对象。**这里不再演示，有兴趣的可以自己举例尝试。\n\n### 2. Proxy handler方法（拦截方法）\n* `get(target, key, receiver)`：拦截 target 属性的读取\n* `set(target, key, value, receiver)`：拦截 target 属性的设置\n* `has(target, key)`：拦截 `key in proxy` 的操作，并返回是否存在（boolean值）\n* `deleteProperty(target, key)`：拦截 `delete proxy[key]`的操作，并返回结果（boolean值）\n* `ownKeys(target)`：拦截`Object.getOwnPropertyName(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for ... in`循环。并返回目标对象所有自身属性的属性名数组。注意：**`Object.keys()`的返回结果数组中只包含目标对象自身的可遍历属性**\n* `getOwnPropertyDescriptor(target, key)`：拦截 `Object.getOwnPropertyDescriptor(proxy, key)`，返回属性的描述对象\n* `defineProperty(target, key, desc)`：拦截`Object.defineProperty(proxy, key, desc)`、`Object.defineProperties(proxy, descs)`，返回一个 boolean 值\n* `preventExtensions(target)`：拦截`Object.preventExtensions(proxy)`，返回一个 boolean 值\n* `getPrototypeOf(target)`：拦截`Object.getPrototypeOf(proxy)`，返回一个对象\n* `isExtensible(target)`：拦截`Object.isExtensible(proxy)`，返回一个 boolean 值\n* `setPrototypeOf(target, key)`：拦截`Object.setPrototypeOf(proxy, key)`，返回一个 boolean 值。如果目标对象是函数，则还有两种额外操作可以被拦截\n* `apply(target, object, args)`：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`\n* `construct(target, args)`：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`\n\n总共 13 个拦截方法，下面进行简要举例说明，更多可见阮一峰老师的 [《ECMAScript 6 入门》](https://link.juejin.im/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fproxy)\n\n#### 1. get，set\n`get`方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n\n`set`拦截 target 属性的设置，可以接受四个参数，依次为目标对象、属性名、value和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n\n```js\nlet target = {foo: 1}\nlet proxy = new Proxy(target, {\n    get(target, key, receiver) {\n        console.log(`getter ${key}!`)\n        return target[key]\n    },\n    set: function(target, key, value, receiver) {\n        console.log(`setter ${key}!`)\n        target[key] = value;\n    }\n})\n\nlet obj = Object.create(proxy)\nconsole.log(obj.foo) \n// getter foo!\n// 1\n```\n\n#### 2. has\n拦截 propKey in proxy 的操作，返回一个布尔值。\n\n```js\n// 使用 has 方法隐藏某些属性，不被 in 运算符发现\nvar handler = {\n    has (target, key) {\n        if (key.startsWith('_')) {\n            return false;\n        }\n        return key in target;\n    }\n};\nvar foo = { _name: 'foo', name: 'foo' };\nvar proxy = new Proxy(foo, handler);\nconsole.log('_name' in proxy); // false\nconsole.log('name' in proxy); // true\n```\n\n#### 3. ownKeys\n拦截自身属性的读取操作。并返回目标对象所有自身属性的属性名数组。具体返回结果可结合 MDN [属性的可枚举性和所有权](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)\n\n* `Object.getOwnPropertyName(proxy)`\n* `Object.getOwnPropertySymbols(proxy)`\n* `Object.keys(proxy)`\n* `for ... in`循环\n\n```js\nlet target = {\n  _foo: 'foo',\n  _bar: 'bar',\n  name: 'An'\n};\n\nlet handler = {\n  ownKeys (target) {\n    return Reflect.ownKeys(target).filter(key =key.startsWith('_'));\n  }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n  console.log(target[key]);\n}\n// \"An\"\n```\n\n#### 4. apply\napply 拦截 Proxy 实例作为函数调用的操作，比如函数的调用（`proxy(...args)`）、call（`proxy.call(object, ...args)`）、apply（`proxy.apply(...)`）等。\n\n```js\nvar target = function () { return 'I am the target'; };\nvar handler = {\n  apply: function () {\n    return 'I am the proxy';\n  }\n};\n\nvar proxy = new Proxy(target, handler);\n\nproxy();\n// \"I am the proxy\"\n```\n\nProxy 方法太多，这里只是将常用的简要介绍，更多请看阮一峰老师的 [《ECMAScript 6 入门》](https://link.juejin.im/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fproxy)\n\n### 和Object.defineProperty()的对比\ndefineProperty存在以下问题：\n1. 不能监听数组的变化\n2. 必须遍历对象的每个属性\n3. 必须深层遍历嵌套的对象(vue walk方法)\n\n也需要嵌套\n```js\nlet obj = {\n  info: {\n    name: 'eason',\n    blogs: ['webpack', 'babel', 'cache']\n  }\n}\nlet handler = {\n  get (target, key, receiver) {\n    console.log('get', key)\n    // 递归创建并返回\n    if (typeof target[key] === 'object' && target[key] !== null) {\n      return new Proxy(target[key], handler)\n    }\n    return Reflect.get(target, key, receiver)\n  },\n  set (target, key, value, receiver) {\n    console.log('set', key, value)\n    return Reflect.set(target, key, value, receiver)\n  }\n}\nlet proxy = new Proxy(obj, handler)\n// 以下两句都能够进入 set\nproxy.info.name = 'Zoe'\nproxy.info.blogs.push('proxy')\n```\n","tags":["深入理解"],"categories":["JS"]},{"title":"linux安装mongodb及常见命令","url":"%2F2019%2Flinux%E5%AE%89%E8%A3%85mongodb%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/mongodb.jpg, MongoDB, MongoDB %}\n\nMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。\n---\n<!--more-->\n\n## 安装、配置\n```shell\n## 下载\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.6.5.tgz\n\n## 解压\ntar -zxvf mongodb-linux-x86_64-3.6.5.tgz \n\n## 移动到指定目录\nmv  mongodb-linux-x86_64-3.6.5/ /usr/local/mongodb\n\n## MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：当前终端有效(可跳过)\nexport PATH=/usr/local/mongodb/bin:$PATH\n\n## 到根目录创建文件夹 或者mongodb下\nmkdir data/db\nmkdir data/log\n\n## vim /etc/profile 添加到全局命令\nexport PATH=/usr/local/mongodb/bin:$PATH \n\n## 如果有多个\nexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:/usr/local/mongodb/bin:$PATH\n\n## 保存，退出，然后运行\nsource /etc/profile\n```\n\n```shell\n## mongodb.conf\ndbpath=/usr/local/mongodb/db\nlogpath=/usr/local/mongodb/log/mongodb.log\nbind_ip=0.0.0.0\nfork=true\n```\n\n```shell\n## 关闭\nps -ef|grep mongod\nkill -9\n\n## 后台启动 开启用户认证\nnohup mongod --auth -f /usr/local/mongodb/mongodb.conf > myLog.log 2>&1 &\n\nnohup mongod -f /usr/local/mongodb/mongodb.conf > myLog.log 2>&1 &\n```\n\n## 常见命令\n\n### 设置用户和命令\n```shell\n## 创建管理员\nmongo\n\nuse admin\n\ndb.createUser(\n  {\n    user: \"testuser\",\n    pwd: \"testpassword\",\n    roles: [ { role: \"readWriteAnyDatabase\", db: \"admin\" } ]\n  }\n)\n\n## 认证登录\ndb.auth(\"admin\", \"password\")\n\n## 显示当前系统用户\ndb.system.users.find()\n\n## 删除用户(删除用户的时候需要切换到用户管理的数据库才可以删除)\ndb.dropUser(\"testuser\")\n\n## 修改密码\ndb.addUser('testUser','111')\n\ndb.changeUserPassword('tank2','test')\n\n## 修改用户权限\ndb.updateUser(\"cosyer\",{roles:[ {role:\"root\",db:\"admin\"} ]})\n```\n\n### mongoose账号密码连接\n```js\n// mongodb://admin:123456@localhost:27017 //有用户名密码的情况\nmongoose.connect(\"mongodb://user:pwd@111.231.121.29/ticket\", {\n  authSource: \"admin\",\n  useMongoClient: true\n});\n```\n\n## 导入导出表字段\n```js\nmongoexport -d book -c books -o books.json --type json\n\nmongoimport -d book -c books --file /home/mongodump/articles.json --type json\n```\n\n## 备份恢复数据库\n```js\nmongodump -h 127.0.0.1 -d book -o D:\\iview-book-admin\\static\\js\n\nmongorestore -h dbhost -d book --dir D:\\iview-book-admin\\static\\js\\book\n```\n","tags":["数据库"],"categories":["工具"]},{"title":"blur事件与click事件冲突的解决办法","url":"%2F2019%2Fblur%E4%BA%8B%E4%BB%B6%E4%B8%8Eclick%E4%BA%8B%E4%BB%B6%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html","content":"\n在处理表单登录的过程中，遇到了一个问题，当我们在输入框输入内容输入框获取到焦点时，输入框后面会出现一个图标删除已输入的内容，因此删除图标会绑定一个click事件，但是当我们点击图标的时候，也触发了input的blur事件，blur事件会让input失去焦点时隐藏删除的图标，并且blur事件先于图标的click事件执行，因此这时候点击图标并不会删除输入框已输入的内容，而是图标消失了。还有弹窗输入框blur同时点击取消按钮关闭，也会出现需要点击2次的情况。\n\n<p align=\"center\"><img src=\"http://cdn.mydearest.cn/blog/images/blur.png\" alt=\"blur img\"></p>\n\n---\n<!--more-->\n\n- blur事件：当元素失去焦点时触发blur事件；blur 事件仅发生于表单元素上。在新浏览器中，该事件可用于任何元素，blur和focus事件不会冒泡，其他表单事件都可以。\n\n- click事件：当点击元素时触发click事件；所有元素都有此事件，会产生冒泡。\n\n### 原因分析\n> blur事件比click事件先触发，而javascript为单线程，同一时间只能执行处理一个事件，所以当blur执行时，导致其后续click事件并不会执行。\n\n### 方案一 加定时器延时触发blur事件\n\n缺点：设置多久的延时是一个难以两全的问题，时间太短不能保证click事件的100%触发，时间太长则会造成卡顿的感觉，影响用户体验。\n\n### 方案二 将click事件改为mousedown事件，mousedown事件是优先于blur事件执行\n\n缺点：鼠标按下便触发了事件，不收起、长按也会触发，可能造成用户体验不好。还需要判断是否是鼠标左键点击(event.button===0)。\n\n### 方案三 给click所在元素再添加一个mousedown事件，在其中执行event.preventDefault()阻止浏览器默认事件，这样点击按钮时输入框就不会失去焦点了\n\n缺点：如果是弹窗下次打开时，焦点仍然存在。\n\n### 方案四 动态绑定移除blur事件\n\n**推荐方案三和四**\n","tags":["解决方案"],"categories":["知识"]},{"title":"前端模块化发展扩展","url":"%2F2019%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E6%89%A9%E5%B1%95.html","content":"\nJavaScript 一开始并没有内建模块化支持，也几乎没有模块化这种概念。当时没那么大的需求，搞个模块化显得大材小用啊。随着互联网的发展，尤其是 2006 年 ajax 技术的出现和之后 Web 2.0 的兴起，越来越多的业务逻辑向前端转移，前端开发的复杂程度和代码量逐渐提升。这时，由于缺乏模块化概念，JavaScript 的一些问题便凸显出来：代码难以复用、容易出现全局变量污染和命名冲突、依赖管理难以维护等等。一开始，开发者们使用诸如暴露全局对象、自执行函数等方法来规避这些问题，但仍无法从根本上解决问题。\n\n<!-- more -->\n\n## CommonJS\n\n2009 年，基于将 JavaScript 应用于服务端的尝试，ServerJS 诞生了。之后 ServerJS 更名为 CommonJS，并逐步发展为一个完整的模块规范。简称 CMD(Common Module Definition)\n\n[CommonJS官网](http://www.commonjs.org/)\n[CommonJS阮一峰](http://javascript.ruanyifeng.com/nodejs/module.html)\n\nCommonJS 为模块的使用定义了一套 API。比如，它定义了全局函数 require，通过传入模块标识来引入其他模块，如果被引入的模块又依赖了其他模块，那么会依次加载这些模块；通过 module.exports 向外部暴露 API，以便其他的模块引入。\n\n由于 CommonJS 是使用`同步方式`加载模块的，即只有加载完成才能进行接下来的操作，因此当应用于浏览器端时会受到网速的限制。\n\nCommonJS对模块的定义主要分为模块引用、模块定义和模块标识3个部分。\n\n```js\nconst $ = require('jquery')\n\n// 定义私有方法\nfunction log (...arg) {\n  console.log(...arg)\n}\n// 定义公有方法\nfunction sayHello () {\n  const el = $('body')\n  log('zhouyu, hello', el)\n}\n// 暴露公有方法\nmodule.exports = {\n  sayHello\n}\n```\n\n## AMD\n\n之后，在 CommonJS 组织的讨论中，AMD(Asynchronous Module Definition)应运而生。和 CommonJS 不同的是，它使用`异步方式`加载模块，因此更适合被浏览器端采用。AMD 用全局函数 define 来定义模块，它需要三个参数：模块名称、模块的依赖数组、所有依赖都可用之后执行的回调函数(该函数按照依赖声明的顺序，接收依赖作为参数)。\n\n[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)\n[AMD中文](https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)\n\n``` JS\ndefine(['jquery'], function ($) {\n  // 定义私有方法\n  function log (...arg) {\n    console.log(...arg)\n  }\n  // 定义公有方法\n  function sayHello () {\n    const el = $('body')\n    log('zhouyu, hello', el)\n  }\n  // 暴露公有方法\n  return sayHello\n})\n```\n\n## UMD\n\n如果需要同时支持 CommonJS 和 AMD 两种格式，那么可以使用 UMD(Universal Module Definition)。事实上，UMD 通过一系列 if/else 判断来确定当前环境支持的模块体系，因此多数情况下 UMD 格式的模块会占用更大的体积。\n\n``` js\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery'], factory)\n  } else if (typeof exports === 'object') {\n    // Nodejs 或 CommonJS\n    module.exports = factory(require('jquery'))\n  } else {\n    // 浏览器全局变量(root 即 window)\n    root.returnExports = factory(root.jQuery)\n  }\n}(this, function ($) {\n  // 定义私有方法\n  function log (...arg) {\n    console.log(...arg)\n  }\n  // 定义公有方法\n  function sayHello () {\n    const el = $('body')\n    log('zhouyu, hello', el)\n  }\n  // 暴露公有方法\n  return sayHello\n}));\n```\n\n## ES6 Modules\n\n无论是 CommonJS，AMD 还是 UMD，它们都不是标准的 JavaScript 模块解决方案。换句话说，它们都没有被写进 ECMA 的规范中。直到 2015 年 6 月，TC39 委员会终于将 Modules 写进 ECMAScript 2015 中，标志着原生模块新时代的到来。至此，JavaScript 文件有了两种形式：脚本(自 JavaScript 诞生起我们就在使用的)和模块(即 ECMAScript 2015 Modules)。下面就让我们来一起探索 ECMAScript 2015 Modules(以下简称 ES6 Modules)\n\n[ES6 Modules](http://www.ecma-international.org/ecma-262/6.0/#sec-modules)\n[ES6阮一峰](http://es6.ruanyifeng.com/#docs/module)\n\n``` js\nimport $ from('jquery')\n\n// 定义私有方法\nfunction log (...arg) {\n  console.log(...arg)\n}\n// 定义公有方法\nfunction sayHello () {\n  const el = $('body')\n  log('zhouyu, hello', el)\n}\n\nexport default sayHello\n```\n\n## ES6 Modules 现状\n\n时至今日，几大主流浏览器都在积极推进支持原生 ES6 Modules 的工作，部分浏览器的技术预览版也已经初步完成了这一使命。可以通过 [caniuse](https://caniuse.com/#search=module) 查看目前浏览器的支持情况。\n\n## 使用 Babel 和 webpack\n\n由于绝大多数浏览器都不支持 ES6 Modules，所以目前如果想使用它的语法，需要借助 Babel 和 webpack，即通过 Babel 将代码编译为 ES5 的语法，然后使用 webpack 打包成目标格式。\n\n## 直接使用 ES6 Modules\n\n有些游览器已经支持 ES6 Modules，我们利用 `<script type=\"module\">`(默认是 defer)来使用。\n\n## 其他探索\n\n* 动态加载方案 `import()`\n\n``` js\nconst load = async (url) => {\n  const module = await import(url)\n  console.log(module, window[tempGlobal])\n}\n```\n\n``` js\nfunction load (url) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script')\n    const tempGlobal = '__tempModuleLoadingVariable' + Math.random().toString(32).substring(2)\n    script.type = 'module'\n    script.textContent = `import * as m from \"${url}\"; window.${tempGlobal} = m;`\n\n    script.onload = () => {\n      resolve(window[tempGlobal])\n      delete window[tempGlobal]\n      script.remove()\n    }\n\n    script.onerror = () => {\n      reject(new Error('Failed to load module script with URL ' + url))\n      delete window[tempGlobal]\n      script.remove()\n    }\n\n    document.documentElement.appendChild(script)\n  })\n}\n```\n\n* 基于 ES6 Modules 的 `module-pusher` 尝试\n","tags":["模块化"],"categories":["知识"]},{"title":"健康指标","url":"%2F2019%2F%E5%81%A5%E5%BA%B7%E6%8C%87%E6%A0%87.html","content":"\n接上次的[维生素](https://mydearest.cn/2019/%E7%BB%B4%E7%94%9F%E7%B4%A0.html)😊，罗列一些生活中需要知道健康指标。\n\n<!-- more -->\n\n# 血糖\n\n血中的葡萄糖称为血糖。\n\n血糖的来源包括：①食物消化、吸收；②肝内储存的糖原分解；③脂肪和蛋白质的转化。\n\n血糖的去路包括：①氧化转变为能量；②转化为糖原储存于肝脏、肾脏和肌肉中；③转变为脂肪和蛋白质等其他营养成分加以储存。\n\n胰岛是体内调节血糖的血糖浓度的主要器官，肝脏储存肝糖元。此外，血糖浓度还受神经、内分泌激素的调节。\n\n## 血糖值\n\n### 空腹血糖\n\n全血血糖(手指)。血浆血糖(静脉)。\n\n空腹血糖正常值，全血血糖：3.89～6.11 mmol/L，血浆血糖：3.90～6.90 mmol/L\n\n空腹全血血糖 ≥ 6.70 mmol/L，血浆血糖 ≥ 7.80 mmol/L，2 次重复测定可诊断为糖尿病。\n\n### 餐后血糖\n\n餐后 1 小时：血糖 6.7-9.4 mmol/L。最多也不超过 11.1 mmol/L。\n\n餐后 2 小时：血糖 ≤ 7.8 mmol/L。\n\n餐后 3 小时：第三小时后恢复正常，各次尿糖均为阴性。\n\n### 孕妇血糖\n\n空腹不超过 5.1 mmol/L。\n\n餐后 1 小时不得超过 10.0 mmol/L 才是血糖的正常水平。\n\n## 糖尿病\n\n糖尿病患者的空腹血糖参考值：\n\n轻度糖尿病：7.0~8.4 mmol/L，中度糖尿病：8.4~11.1 mmol/L，重度糖尿病：大于 11.1 mmol/L。\n\n## 药物\n\n二甲双胍。\n\n1. 二甲双胍片首选用单纯饮食控制及体育锻炼治疗无效的2型糖尿病，特别是肥胖的2型糖尿病。\n2. 本品与胰岛素合用，可减少胰岛素用量，防止低血糖发生。\n3. 可与磺酰脲类降血糖药合用，具协同作用。\n\n服用本品时应尽量避免饮酒。\n\n## 哪些食物降血糖\n\n1.饮食宜清淡，忌辛辣，低糖、低油、低盐，按时饮食\n\n2.可以吃：苦瓜、洋葱、山药、海带、魔芋多吃，冬瓜、芹菜、菠菜、藕等少吃\n\n3.可以吃：柚子、苹果、橘子、樱桃、草莓、梨、桃等升糖指数比较低，西瓜吃靠近瓜皮的，不吃瓜心\n\n4.不能吃：香蕉、山楂、柿子、枣子\n\n5.多喝凉白开，不要憋尿\n\n6.检测足部，保护足部\n\n7.多做足部运动，踮脚、脚趾抓地、泡完脚后用掌心搓脚心\n\n8.不含糖的甜味剂，比如木糖醇、三氯蔗糖、阿斯巴甜、甜菊糖苷这类甜味剂；如果含有这些的食品，可以少量食用。燕麦片\n\n多吃：冬瓜、苦瓜、洋葱、山药、海带、魔芋、芹菜、菠菜、木耳、藕\n\n### 燕麦片\n\n燕麦片是燕麦粒轧制而成，呈扁平状，直径约相当于黄豆粒，形状完整的一种食品。燕麦煮出来高度粘稠，其中 beta 葡聚糖健康成分所带来的，具有降血脂、降血糖、高饱腹的效果，长期食用具有减肥功效。此外，燕麦中含有丰富的维生素 B1、B2、E、叶酸等，可以改善血液循环、缓解生活工作带来的压力；含有的钙、磷、铁、锌、锰等矿物质也有预防骨质疏松、促进伤口愈合、防止贫血的功效。\n\n### 魔芋\n\n降血糖、降血脂、降血压、散毒、养颜、通脉、减肥、通便、开胃。\n\n生魔芋有毒，必须煎煮 3 小时以上才可食用。\n\n消化不良的人，每次食量不宜过多。\n\n有皮肤病的人少食。\n\n魔芋性寒，有伤寒感冒症状的应少食用。\n\n### 海带\n\n海带是一种营养价值很高的蔬菜，同时具有一定的药用价值。含有丰富的碘等矿物质元素。海带含热量低、蛋白质含量中等、矿物质丰富。研究发现，海带具有降血脂、降血糖、调节免疫、抗凝血、抗肿瘤、排铅解毒和抗氧化等多种生物功能。\n\n吃海带后不要马上喝茶(茶含鞣酸)，也不要立刻吃酸涩的水果(酸涩水果含植物酸)。\n\n吃多也不好，会得甲亢。\n\n### 山药\n\n具有滋养强壮，助消化，敛虚汗，止泻之功效，主治脾虚腹泻、肺虚咳嗽、糖尿病消渴、小便短频、遗精、妇女带下及消化不良的慢性肠炎。\n\n# 血压\n\n是指血液在血管内流动时作用于单位面积血管壁的侧压力，它是推动血液在血管内流动的动力。在不同血管内被分别称为动脉血压、毛细血管压和静脉血压，通常所说的血压是指体循环的动脉血压。\n\n影响动脉血压的因素主要有五个方面：①每搏输出量；②外周阻力；③心率；④主动脉和大动脉管壁的弹性；⑤循环血量与血管容量。\n\n## 血压值\n\n收缩压：高压。舒张压：低压。\n\n正常成人安静状态下的血压范围较稳定，正常范围收缩压 90～139 mmHg，舒张压 60～89 mmHg，脉压 30～40 mmHg。\n\n高血压：未使用抗高血压药的前提下，18 岁以上成人收缩压 ≥ 140 mmHg 和(或)舒张压 ≥ 90mmHg。\n\n低血压：未使用抗高血压药的前提下，18 岁以上成人收缩压 < 90 mmHg 和(或)舒张压 < 60mmHg。\n\n## 哪些食物降血压\n\n### 茄子\n\n降低胆固醇，降血脂、降血压，防治胃癌，治疗慢性胃炎、肾炎水肿，防治坏血病及促进伤口愈合，清热解毒。\n\n消化不良、容易腹泻、脾胃虚寒、便溏症状的人不宜多吃。\n\n秋后的茄子有一定的毒素，不要吃。\n\n### 白萝卜\n\n清肠排毒，促进消化，增强食欲，防癌抗癌，降血压\n\n### 芹菜\n\n降低胆固醇，降血压\n\n【芹菜+鸡肉】容易伤元气。\n\n【芹菜+兔肉】容易引起脱皮。\n\n# BMI 指数\n\n身体质量指数，简称体质指数，又称体重.\n\n体质指数(BMI)= 体重(kg)÷ 身高(m)^ 2\n\n成人的BMI数值：\n  - 过轻：低于 18.5\n  - 正常：18.5-23.9\n  - 过重：24-27\n  - 肥胖：28-32\n  - 非常肥胖：高于 32\n\n60 / (1.68 * 1.68) = 21.26\n\n65 / (1.68 * 1.68) = 23.04\n\n67 / (1.68 * 1.68) = 23.74\n\n60 / (1.70 * 1.70) = 20.77\n\n65 / (1.70 * 1.70) = 22.50\n\n69 / (1.70 * 1.70) = 23.88\n\n60 / (1.72 * 1.72) = 20.29\n\n65 / (1.72 * 1.72) = 21.98\n\n70 / (1.72 * 1.72) = 23.67\n\n# 其他\n\n## 韭菜\n\n补肾，健胃，提神，降低胆固醇。\n\n春食则香，夏食则臭。\n\n【韭菜+菠菜】同食会有滑肠作用，容易引起腹泻。\n\n【韭菜+牛肉】发 热动火，引起牙齿肿痛，口疮。\n\n【韭菜+白酒】引起胃炎，胃溃肠病复发。\n\n【韭菜+蜂蜜】同食容易引起腹泻。","tags":["杂谈"],"categories":["杂谈"]},{"title":"EventLoop","url":"%2F2019%2FEventLoop.html","content":"\n## 描述事件队列的过程？\n\n- js是单线程的，会出现阻塞问题，因此有了任务队列的出现\n- 主线程同步执行任务，异步的工作一般会交给其他线程完成，然后回调函数会放到任务队列中\n- 等候主线程执行完毕后再执行任务队列中的操作\n\n![event-queue](http://cdn.mydearest.cn/blog/images/event-queue.png)\n\n> 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；\n\n> 异步任务指的是，不进入主线程、而进入\"任务队列\"（task queue）的任务，只有\"任务队列\"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。只要异步任务有了运行结果，就在\"任务队列\"之\n中放置一个事件。\n\n![task-queue](http://cdn.mydearest.cn/blog/images/task-queue.png)\n任务队列中存着的是异步任务，这些异步任务一定要等到执行栈清空后才会执行。\n\n同步就是发出一个请求后什么事都不做，一直等待请求返回后才会继续做事；异步就是发出请求后继续去做其他事，这个请求处理完成后会通知你，这时候就可以处理这个回应了。\n\n---\n<!--more-->\n\n## 什么是宏任务什么是微任务？\nscript(宏任务) - 清空微任务队列 - 执行一个宏任务 - 清空微任务队列 - 执行一个宏任务， 如此往复。\n1.先执行script里的同步代码（此时是宏任务）。碰到异步任务，放到任务队列。\n2.查找任务队列有没有微任务，有就把此时的微任务全部按顺序执行 （这就是为什么promise会比setTimeout先执行，因为先执行的宏任务是同步代码，setTimeout被放进任务队列了，setTimeout又是宏任务，在它之前先得执行微任务(就比如promise)）。\n3.执行一个宏任务（先进到队列中的那个宏任务），再把这次的宏任务和微任务放到任务队列。\n4.一直重复2、3步骤\n\n当满足执行条件时，宏任务(macroTask) 和 微任务(microTask) 会各自被放入对应的队列：宏队列(Macrotask Queue) 和 微队列(Microtask Queue) 中等待执行。\n先执行同步任务，然后所有微任务，一个宏任务，所有微任务，一个宏任务...\n\n![macro-micro](http://cdn.mydearest.cn/blog/images/macro-micro.png)\n\n## 哪些是宏任务哪些是微任务？\n\n### 宏任务(优先级由高到低)\n- 主线程同步代码\n- setTimeout\n- setImmediate node无\n- setInterval\n- requestAnimationFrame node无\n- I/O\n- UI rendering\n\n### 微任务(优先级由高到低)\n- process.nextTick 浏览器无\n- Promise.then\n- Object.observe(该方法已废弃)\n- MutationObserver node无\n\n### 微任务的意义\n减少更新时的渲染次数\n因为根据HTML标准，会在宏任务执行结束之后，在下一个宏任务开始执行之前，UI都会重新渲染。如果在microtask中就完成数据更新，当 macro-task结束就可以得到最新的UI了。如果新建一个 macro-task来做数据更新的话，那么渲染会执行两次。\n\n### 事件循环\n![eventloop](http://cdn.mydearest.cn/blog/images/eventloop.png)\n\njs引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空就会去Event Queue那里检查是否有等待被调用的函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event \nLoop（事件循环）\n\n1. 整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”；\n2. 同步任务会直接进入主线程依次执行；\n4. 异步任务会再分为宏任务和微任务；\n5. 宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中；\n6. 微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中；\n7. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务；\n上述过程会不断重复，这就是Event Loop事件循环；\n\n![summary-loop](http://cdn.mydearest.cn/blog/images/summary-loop.png)\n\n**精炼**事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表。\n\n### Node 的 Event Loop: 6个阶段\n- Timers: 定时器 Interval Timoout 回调事件，将依次执行定时器回调函数\n- Pending: 一些系统级回调将会在此阶段执行\n- Idle,prepare: 此阶段\"仅供内部使用\"\n- Poll: IO回调函数，这个阶段较为重要也复杂些，\n- Check: 执行 setImmediate() 的回调\n- Close: 执行 socket 的 close 事件回调\n\n### 区别总结\n![eventloop-diff](http://cdn.mydearest.cn/blog/images/eventloop-diff.png)\n```js\nsetTimeout(()=>{\n    console.log('timer1')\n    Promise.resolve().then(function() {\n        console.log('promise1')\n    })\n}, 0)\nsetTimeout(()=>{\n    console.log('timer2')\n    Promise.resolve().then(function() {\n        console.log('promise2')\n    })\n}, 0)\n```\n> 浏览器端运行结果：timer1=>promise1=>timer2=>promise2\n![navigator-eventloop](http://cdn.mydearest.cn/blog/images/navigator-eventloop.png)\n\nNode端运行结果分两种情况：\n\n如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果\n为timer1=>promise1=>timer2=>promise2\n\n如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。\n\n如果是第二个定时器还未在完成队列中，最后的结果为timer1=>promise1=>timer2=>promise2\n如果是第二个定时器已经在完成队列中，则最后的结果为timer1=>timer2=>promise1=>promise2(下文过程解释基于这种情况下)\n\n1. 全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；\n2. 首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；\n3. 至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2\n\n![node-eventloop](http://cdn.mydearest.cn/blog/images/node-eventloop.png)\n\n### 结论\n- Node端，microtask 在事件循环的各个阶段之间执行\n```js\nloop.forEach((阶段) => {\n    阶段全部任务();\n    nextTick全部任务();\n    microTask全部任务();\n});\nloop = loop.next;\n}\n```\n\n\n- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行\n```js\nwhile (true) {\n    宏任务队列.shift();\n    微任务队列全部任务();\n}\n```\n\n### 练习题\n```js\nconsole.log(1)\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\nvar promise = new Promise(function(resolve, reject) {\n    console.log(3)\n    resolve();\n})\npromise.then(function(){\n    console.log(4)\n})\nconsole.log(5)\n// 13542\n\nconsole.log(1)\nsetTimeout(()=>{\n    console.log(2)\n},0)\n\nvar intervalId = setInterval(function(){\n    console.log(3)\n}, 0)\nsetTimeout(function(){\n    console.log(10)\n    new Promise(function(resolve){\n        console.log(11)\n        resolve()\n    }).then(()=>{\n        console.log(12)\n    }).then(()=>{\n        console.log(13)\n        clearInterval(intervalId)\n    })\n}, 0)\nPromise.resolve().then(()=>{\n    console.log(7)\n}).then(()=>{\n    console.log(8)\n})\nconsole.log(9)\n// 1 9 7 8 2 3 10 11 12 13\n\nsetTimeout(()=>{\n    console.log(1)\n}, 0);\n\nnew Promise((resolve, reject)=>{\n    console.log(2);\n    resolve();\n}).then(()=>{\n    console.log(3);\n}).then(()=>{\n    console.log(4);\n});\n\nprocess.nextTick(()=>{\n    console.log(5);\n});\n\nconsole.log(6);\n// 2 6 5 3 4 1\n```\n\n```js\nconsole.log(1);\n\nsetTimeout(()=>{\n    console.log(2);   \n    new Promise((resolve,reject)=>{\n    console.log(3);\n    resolve()\n}).then(res=>{\n    console.log(4); \n})\n})\n\nnew Promise((resolve,reject)=>{\n    resolve()\n}).then(res=>{\n    console.log(5); \n}).then(res=>{\n    console.log(6);\n    \n})\n\nnew Promise((resolve,reject)=>{\n    console.log(7);\n    resolve()\n}).then(res=>{\n    console.log(8); \n}).then(res=>{\n    console.log(9);\n    \n})\n\nsetTimeout(()=>{\n    console.log(10);   \n    new Promise((resolve,reject)=>{\n    console.log(11);\n    resolve()\n}).then(res=>{\n    console.log(12); \n})\n})\n\nconsole.log(13);\n// 1 7 13 5 8 6 9 2 3 4 10 11 12\n```\n\n```js\n\nasync function async1() {\n    console.log('async1 start');\n    await async2();\n    console.log('async1 end');\n}\n\nasync function async2() {\n    console.log('async2');\n}\n\nconsole.log('script start');\n\nsetTimeout(function() {\n    console.log('setTimeout');\n}, 0)\n\nasync1();\n\nnew Promise(function(resolve) {\n    console.log('promise1');\n    resolve();\n}).then(function() {\n    console.log('promise2');\n});\n\nconsole.log('script end');\n\n// script start\n\n// async1 start\n\n// async2\n\n// promise1\n\n// script end\n\n// async1 end\n\n// promise2\n\n// setTimeout\n```\n\n## 参考\n[浏览器与Node的事件循环(Event Loop)有何区别?](https://juejin.im/post/5c337ae06fb9a049bc4cd218)\n","tags":["深入理解"],"categories":["JS"]},{"title":"前端模块化发展","url":"%2F2019%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95.html","content":"\n{% note info %}\n\n模块化就是将一个复杂的系统分解成多个独立的模块的代码组织方式。\n\n{% endnote %}\n\n前端模块化发展之路： IIFE（自执行函数）>>AMD(RequireJS实现)>>CMD(SeaJS实现)>>CommonJS(NodeJs)>>ES6 Modules(模块化直接成为了Javascript语言规范中的一部分)。\n\n# 一、前端模块化发展简介\n\n## 1.CommonJS(require / module.exports / exports)\n\n2009年，美国程序员Ryan Dahl创造了[node.js](http://nodejs.org/)项目，将javascript语言用于服务器端编程。这标志\"Javascript模块化编程\"正式诞生。nodeJs中的模块，一律为[CommonJS](https://\nen.wikipedia.org/wiki/CommonJS) 格式。\n\n### 1.1 语法风格\n\n```javascript\n//Math.js\nmodule.exports = {\n\t'add': function(a, b) {\n\t\treturn a + b;\n\t}\n}\n```\n\n```javascript\n//main.js\nconst Math = require('./Math');\nconsole.log(Math.add(2, 3));\nconsole.log('done');\n```\n\n![front-module](http://cdn.mydearest.cn/blog/images/front-module.png)\n\n---\n<!--more-->\n\n### 1.2 同步加载\n\n### 1.3 动态加载\n\n```javascript\n//main.js\nconst Math = require('./Ma' + 'th');//动态拼接\nconsole.log(Math.add(2, 3));\nconsole.log('done');\n```\n\n### 1.4 浏览器不支持CommonJS规范。\n\n浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。\n\n- module\n- exports\n- require\n- global\n\n可以使用工具进行转换，例如：[Browserify](http://browserify.org/)\n\n------\n\n## 2.AMD(require/define)\n\nCommonJS是主要为了JS在后端的表现制定的，它是不适合前端的。\n\n[AMD](http://github.com/amdjs/amdjs-api/wiki/AMD)是\"Asynchronous Module Definition\"的缩写，意思就是\"异步模块定义\"。\n\n**RequireJS**实现了AMD规范。下面以RequireJS为例，了解一下AMD规范。\n\n### requireJS原理\n\nrequire.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。\n\n### 2.1 语法风格\n\n```javascript\n//Math.js\ndefine([], function(){\n    return {\n        'add': function(a, b) {\n\t\t\treturn a + b;\n\t\t}\n    }\n})\n```\n\n```javascript\n//main.js\nrequire.config({\n    paths : {\n        \"math\" : \"Math\"\n    }\n});\nrequire(['math'], function (math) {\n\tconsole.log(math.add(2, 3));\n});\nconsole.log('done');\n//done\n//5\n```\n\n### 2.2 异步加载\n\n### 2.3 动态加载\n\n### 2.4 依赖前置，提前执行\n\n------\n\n## 3.CMD\n\nCMD是SeaJS 在推广过程中对模块定义的规范化产出。\n\n### 3.1 语法风格\n\n```js\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a');\n    a.doSomething();\n    //...\n    var b = require('./b');   // 依赖可以就近书写\n    b.doSomething();\n    // ... \n    require.async('./c',function(c){ //支持异步加载\n        c.doSomething();\n    });\n})\n\n// AMD 默认推荐的是\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n    a.doSomething();\n    //...\n    b.doSomething();\n    //...\n}) \n```\n\n### 3.2 AMD和CMD的区别\n\n1) **对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。**不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible（尽可能的懒加载，也称为延迟加载，即在需要的时候才加载）。\n\n2) **CMD 推崇依赖就近，AMD 推崇依赖前置。**虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。\n\n### 3.3 推荐链接\n\n[与 RequireJS 的异同](<https://github.com/seajs/seajs/issues/277>)\n\n[SeaJS官方文档](https://seajs.github.io/seajs/docs/)\n\n## es6(import/export)\n\n### require与import的区别\n- require支持 动态导入，import不支持，正在提案 (babel 下可支持)\n- require是 同步 导入，import属于 异步 导入\n- require是 值拷贝，导出值变化不会影响导入值；import指向**内存地址**，导入值会随导出值而变化\n\n# 二、Module\n\nES6中Module的特点\n\n- 浏览器，服务器通用\n- 静态加载\n\n## 1. 基本语法\n\n### 1.1 export\n\n一个模块就是一个独立的文件。`export`关键字用来输出该变量。可以输出变量，函数或类。\n\n```javascript\n// test.js\nexport var firstName = 'cheng';\nexport var lastName = 'zhang';\nexport var age = 18;\n```\n\n```javascript\n// test.js\nvar firstName = 'cheng';\nvar lastName = 'zhang';\nvar age = 18;\n\nexport { firstName, lastName, age };\n```\n\n可以使用`as`为输出变量重命名。\n\n```javascript\nvar firstName = 'cheng';\nvar lastName = 'zhang';\nvar age = 18;\n\nexport {\n\tfirstName as name, \n    lastName as lastname, \n    age\n};\n```\n\n需要特别注意的是，`export`**命令规定的是对外的接口**，必须与模块内部的变量建立一一对应关系。\n\n```javascript\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n```\n\n`export`语句输出的接口，与其对应的值是**动态绑定关系**，即通过该接口，可以取到模块内部实时的值。\n\n```javascript\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 1000);\n```\n\n`export`命令可以出现在模块的任何位置，只要处于**模块顶层**就可以。\n\n### 1.2 import\n\n其他 JS 文件通过`import`命令加载模块。大括号里面的变量名，必须与被导入模块（`test.js`）对外接口的名称相同。\n\n```javascript\n// main.js\nimport { firstName, lastName, age } from './test.js';\n\nfunction showName() {\n  console.log(firstName + ' ' + lastName);\n}\n//cheng zhang\n```\n\n`import`命令输入的变量都是**只读**的，因为它的本质是输入接口。\n\n```javascript\nimport {a} from './xxx.js'\n\na = {}; // Assignment to constant variable.\n```\n\n如果`a`是一个对象，改写`a`的属性是允许的。和const一样。\n\n```javascript\nimport {a} from './xxx.js'\n\na.foo = 'hello'; // 合法操作\n```\n\n可以用星号（`*`）指定一个对象，进行整体加载。\n\n```javascript\n// main.js\nimport * as test from './test.js';\n\nfunction showName() {\n  console.log(test.firstName + ' ' + test.lastName);\n}\n//cheng zhang\n\ntest.lastName = 'yun';\n//Cannot assign to read only property 'lastName' of object '[object Module]'\n//如果是对象，可以修改对象的属性。\n```\n\n`import`命令**具有提升效果**，会提升到整个模块的头部，首先执行。\n\n```javascript\nfoo();\n\nimport { foo } from 'my_module';\n```\n\n由于`import`是静态执行，所以**不能使用表达式和变量**。\n\n```javascript\n// 报错\nimport { 'f' + 'oo' } from 'my_module';\n```\n\n`import`语句**会执行所加载的模块**，因此可以有下面的写法。仅仅执行`lodash`模块，但是不输入任何值。\n\n```javascript\nimport 'lodash';\n```\n\n即使加载多次，也只会执行一次。也就是说，`import`语句是 **Singleton 模式**。\n\n### 1.3 单例模式解读\n\n```javascript\n//counter.js\nexport let counter = 1;\nexport function addCounter(){\n    counter++;\n}\naddCounter();\n```\n\n```javascript\n//main.js\nimport {counter, addCounter} from './counter';\nconsole.log('main:' + counter);\naddCounter();\nconsole.log('main:' + counter);\n\n//main:2\n//main:3\n```\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<title>module test</title>\n\t\t<script type=\"module\" src='main.js'></script>\n\t\t<script type=\"module\" src='main2.js'></script>\n\t</head>\n</html>\n```\n\n```javascript\n//main2.js\nimport {counter, addCounter} from './counter';\nconsole.log('main2:' + counter);\naddCounter();\nconsole.log('main2:' + counter);\n\n//main2:3\n//main2:4\n```\n\n### 1.4 export default\n\n使用`export default`可以不用关注输出模块中的变量名。\n\n```javascript\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n```\n\n```javascript\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n```\n\n`import`命令可以为该匿名函数指定任意名字。`import`命令后面，不使用大括号。\n\n```javascript\n// export-default.js\nfunction foo() {\n  console.log('foo');\n}\n\nexport default foo;\n```\n\n`export default`的本质，就是输出一个叫做`default`的变量或方法。\n\n`imort something from ..`.的本质，就是`import {default as something} from ...`\n\n```javascript\n// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n```\n\n```javascript\n// 正确\nexport default 42;\n\n// 报错\nexport 42;\n```\n\n所以`export default`是比较常用的方法：\n\n```javascript\n// MyClass.js\nexport default class { ... }\n\n// main.js\nimport MyClass from 'MyClass';\nlet o = new MyClass();\n```\n\n### 1.5 import&export混合使用\n\n```javascript\nexport { foo, bar } from 'my_module';\n\n// 可以简单理解为\nimport { foo, bar } from 'my_module';\nexport { foo, bar };\n```\n\n上面代码中，`export`和`import`语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，`foo`和`bar`**实际上并没有被导入当前模块**，只是相当于对外转发了这两个接口，导致**当前模块不能直接使用**`foo`和`bar`。\n\n```javascript\n// 接口改名\nexport { fooName as newName } from 'my_module';\n\n//具名接口改为默认接口\nexport { foo as default } from './someModule';\n\n//接口也可以改名为具名接口\nexport { default as es6 } from './someModule';\n```\n\n### 1.6 模块的继承\n\n```javascript\n//calculator.js\nexport function add(a, b) {\n  return a + b;\n}\n```\n\n```javascript\n//calculatorPlus.js\nexport * from './calculator.js';\nexport function multiply(a, b) {\n  return a * b;\n}\n```\n\n```javascript\n//main.js\nimport * as cal from './calculatorPlus.js';\n\ncal.add(2, 3);//5\ncal.multiply(2, 3);//6\n```\n\n### 1.7 import()\n\n`import()`提案是为了解决`import`**动态加载**，和**不能写在代码块中**的问题。\n\n```javascript\nimport(a + '.js')\n.then(...);\n      \nimport(f())\n.then(...);\n```\n\n```javascript\nif (condition) {\n  import('moduleA').then(...);\n} else {\n  import('moduleB').then(...);\n}\n```\n\n## 2. Module补充\n\n### 2.1 浏览器加载\n\nhtml中加载 ES6 模块，也使用`<script>`标签，但是要加入`type=\"module\"`属性。\n\n```html\n<script type=\"module\" src=\"./myModule.js\"></script>\n<!--等同于-->\n<script type=\"module\" src=\"./myModule.js\" defer></script>\n\n<script type=\"module\" src=\"./myModule.js\" async></script>\n```\n\n- `defer`:要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行。保证执行顺序。\n\n- `async`:一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。不能保证执行顺序。\n\n对于外部的模块脚本，要注意：\n\n- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。\n- 模块脚本自动采用严格模式，不管有没有声明`use strict`。\n- 模块之中，可以使用`import`命令加载其他模块（`.js`后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用`export`命令输出对外接口。\n- **模块之中，顶层的`this`关键字返回`undefined`，而不是指向`window`。也就是说，在模块顶层使用`this`关键字，是无意义的**。\n- 同一个模块如果加载多次，将只执行一次。\n\n### 2.2 循环加载\n\n```javascript\n// a.js\nimport {bar} from './b';\nconsole.log('a.js');\nconsole.log(bar);\nexport let foo = 'foo';\n```\n\n```javascript\n// b.js\nimport {foo} from './a';\nconsole.log('b.js');\nconsole.log(foo);\nexport let bar = 'bar';\n```\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<title>module test</title>\n\t\t<script type=\"module\" src='a.js'></script>\n\t</head>\n</html>\n<!--Cannot access 'foo' before initialization-->\n```\n\n------\n\n```javascript\n// a.js\nimport {bar} from './b';\nconsole.log('a.js');\nconsole.log(bar());\nfunction foo() { return 'foo' }\nexport {foo};\n```\n\n```javascript\n// b.js\nimport {foo} from './a';\nconsole.log('b.js');\nconsole.log(foo());\nfunction bar() { return 'bar' }\nexport {bar};\n```\n\n```javascript\n//b.mjs\n//foo\n//a.mjs\n//bar\n```\n\n因为函数具有提升作用。\n\n### 2.3 ES6模块和CommonJS模块的差异\n\n1. `import`和`export`是关键字，`require`不是。\n\n2. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。(详情见上方【单例模式解读】)\n\n3. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n             因为 CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n          ```javascript\n          //counter.js\n          let counter = 2;\n          function addCounter(){\n              counter++;\n          }\n          addCounter();\n          module.exports = {\n              counter,\n              addCounter: addCunter\n          }\n          ```\n\n          ```javascript\n          //main.js\n          var counter = require('./addCounter.js');\n\n          console.log('main:' + counter.counter);//3\n          counter.addCounter();\n          console.log('main:' + counter.counter);//3\n          ```\n4. **`this`指向不同**。ES6 模块之中，顶层的`this`指向`undefined`；CommonJS 模块的顶层`this`指向当前模块，这是两者的一个重大差异。\n","tags":["模块化"],"categories":["知识"]},{"title":"PWA手记","url":"%2F2019%2FPWA%E6%89%8B%E8%AE%B0.html","content":"\nPWA作为2018最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。\n\nPWA是Progressive Web App的英文缩写，也就是渐进式增强WEB应用。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验。\n\n一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的\n\n安装和离线等功能。\n\n我们需要理解的是，PWA不是某一项技术，或者某一个新的产物；而是一系列Web技术与标准的集合与应用。通过应用这些新的技术与标准，可以从安\n\n全、性能和体验三个方面，优化我们的Web App。所以，其实PWA本质上依然是一个Web App。\n---\n<!--more-->\n\n## 核心技术\n\n- Service Worker （可以理解为服务工厂）\n\n- Manifest （应用清单）\n\n- Push Notification（推送通知）\n\n## service worker (web worker)\n- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n- 一旦被 install，就永远存在，除非被 uninstall\n- 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源）\n- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n- 不能直接操作DOM出于安全的考虑，必须在 HTTPS 环境下才能工作\n- 异步实现，内部大都是通过 Promise 实现\n\nweb worker\nweb worker  是运行在后台的JavaScript，独立于其他脚本，不会影响页面的性能。\n\n应用场景：处理密集型数学计算、大数据集排序、数据处理(压缩、音频分析、图像处理等)、高流量网络通信\n\n浏览器一般有三类 web Worker\n\n- Dedicated Worker ：专用的 worker，只能被创建它的 JS 访问，创建它的页面关闭，它的生命周期就结束了。\n\n- Shared  Worker ：共享的 worker，可以被同一域名下的 JS 访问，关联的页面都关闭时，它的生命周期就结束了。\n\n- Service Worker ：是事件驱动的 worker，生命周期与页面无关，关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动。SW 作用于浏览器与服务器之间，相当于一个代理服务器。\n\n### Service Worker生命周期 \n看成红绿灯\n红 下载和解析\n黄 正在执行 还没准备好\n绿 随时可使用\n且第一次加载页面 sw还没有激活 不会处理任何请求 只有安装和激活后才能使用。（刷新页面和跳转新页面才会生效）\n\n- 步骤\n1. 用户导航到url\n2. 注册sw 过程中浏览器下载解析执行sw\n3. 一旦执行激活安装时间\n4. 安装成功就可以控制客户端功能事件\n\n### 全局变量\n- self: 表示 Service Worker 作用域, 也是全局变量\nSW 的默认作用域为基于当前文件 URL 的 ./。意思就是如果你在//example.com/foo/bar.js里注册了一个 SW，那么它默认的作用域为 //example.com/foo/。\n\n通过查看navigator.serviceWorker.controller是否为 null 来查看一个client是否被 SW 控制。\n- caches: 表示缓存\n- skipWaiting: 表示强制当前处在 waiting 状态的脚本进入 activate 状态（为了在页面更新的过程当中，新的 SW 脚本能够立刻激活和生效。无需刷新或者跳转新页面。）\n- clients: 表示 Service Worker 接管的页面\n- clients.claim() 在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。\n\n### Service Worker 注册\n```js\n// 检查当前浏览器是否支持sw\nif ('serviceWorker' in navigator) {\n    // 如果支持开始注册sw\n    navigator.serviceWorker\n        .register('./service-worker.js')\n        .then(registration => { \n            console,log('注册成功', registration)\n            // 消息推送 获取授权\n            // Notification.requestPermission(function(result) {\n            //         console.log('result', result)\n            //         if (result === 'granted') {\n            //             registration.showNotification('Vibration Sample', {\n            //                 body: 'Buzz! Buzz!',\n            //                 icon: './img/mario.png',\n            //                 vibrate: [200, 100, 200, 100, 200, 100, 200],\n            //                 tag: 'vibration-sample'\n            //             });\n            //         } else {\n            //             alert(result);\n            //         }     \n            // });\n            // 手动更新\n            // registration.update();\n        })\n        .catch(err => console.log('注册失败',err));\n}\n// 查看是否注册成功可以在 PC 上chrome 浏览器, 输入 chrome://inspect/#service-workers\n```\n\n### Service Worker 安装（处理静态缓存）\n\n1. 这个状态发生在 Service Worker 注册之后，是 sw 触发的第一个事件并且只触发一次。表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存。修改你的 SW 后，浏览器会认为这是一个新的 SW，从而会再触发这个新 SW 的install事件。\n\n2. e.waitUntil() 传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。如果 Promise 被拒绝，则安装失败，SW会进入 Redundant（ 废弃 ）状态。确保 Service Worker 不会在 waitUntil() 里面的代码执行完毕之前安装完成。\n\n3. sw 在安装成功和激活之前不会触发任何的 fetch 或 push 等事件。\n\n4. 默认情况下，页面的请求（fetch）不会通过 SW，除非它本身是通过 SW 获取的，也就是说，在安装 SW 之后，需要刷新页面才能有效果。\n\n5. clients.claim()可以改变这种默认行为。\n\nlocalStorage 的用法和 Service Worker cache 的用法很相似，但是由于 localStorage 是同步的用法，所以不允许在 Service Worker 中使用。 IndexedDB 也可以在 Service Worker 内做数据存储。\n\n```js\n// 首先定义需要缓存的路径, 以及需要缓存的静态文件的列表。\nvar cacheName = 'minimal-pwa-1'\n\nvar cacheList = [\n  '/',\n  \"index.html\",\n  \"main.css\",\n  \"e.png\"\n]\nself.addEventListener('install', e => {\n    console.log(\"安装事件，注册后触发只触发一次\");\n    e.waitUntil(\n        // 使用指定的缓存名来打开缓存\n        caches.open(cacheName)\n            .then(cache => {\n                console.log(\"加入缓存\", cacheList);\n                return cache.addAll(cacheList);\n            })\n            // 可加\n            .then(() => {\n                console.log('跳过等待')\n                return self.skipWaiting()\n            })\n    );\n});\n// self.oninstall = e => {}\n```\n\n###  Service Worker 激活（更新缓存）\n\n在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装，并且清除了其他的 worker 以及关联缓存的旧缓存资源，等待新的 Service Worker 线程被激活。\n\n```js\n// 激活 缓存更新\nself.addEventListener('activate', e => {\n    console.log('[ServiceWorker] Activate');\n    e.waitUntil(\n        caches.keys()\n            .then(keyList => Promise.all(keyList.map(key => {\n                if (key !== cacheName) {\n                    console.log('移除旧缓存', key);\n                    return caches.delete(key);\n                }\n            })))\n            // 可加\n            .then(() => {\n            return self.clients.matchAll()\n                .then(clients => {\n                if (clients && clients.length) {\n                    clients.forEach((v,i) => {\n                        // 发送字符串'sw.update'\n                        v.postMessage('sw '+i+' update')\n                    })\n                }\n                })\n            })\n            // return self.clients.claim();\n    );\n    // return self.clients.claim();\n});\n```\n\n### 已激活 （activated）\n\n在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、 sync (后台同步)、 push (推送)。\n\n### 废弃 （redunant）\n\n这个状态表示一个 Service Worker 的生命周期结束。\n\n这里特别说明一下，进入废弃 (redundant) 状态的原因可能为这几种：\n\n- 安装 (installing) 失败\n\n- 激活 (activating) 失败\n\n- 新版本的 Service Worker 替换了它并成为激活状态\n\n### 处理动态缓存\n监听捕获 fetch 事件，在 caches 中去 match 事件的 request ，如果 response 不为空的话就返回 response ，最后返回 fetch 请求，在 fetch 事件中我们也可以手动生成 response 返回给页面。\n```js\n// 捕获请求\nself.addEventListener('fetch', e => {\n    console.log('fetch事件', e.request.url);\n    e.respondWith(\n        caches.match(e.request)\n            .then(response => response || fetch(e.request))\n    );\n    // e.respondWith(\n    //     caches.match(e.request)\n    //         .then(response => {\n    //             if(response) {\n    //                 return response; // || fetch(e.request)\n    //             }\n    //             // 新的内容添加到缓存中\n    //             // 复制请求 请求是一个流 只能使用一次\n    //             var requestToCache = e.request.clone();\n    //             return fetch(requestToCache).then(function(response){\n    //                 if(!response || response.status !==200) {\n    //                     // 错误信息立即返回\n    //                     return response;\n    //                 }\n    //                 var responseToCache = response.clone();\n    //                 // 将响应添加到缓存中\n    //                 caches.open(cacheName).then(function (cache){\n    //                     cache.put(requestToCache, responseToCache);\n    //                 })\n    //             })\n    //         }) \n    // );\n\n    // 自定义响应\n    // e.respondWith(new Response('<p>it is a response</p>', {\n    //     headers:{\n    //         'Content-Type': 'text/html'\n    //     }\n    // }))\n});\n```\n\n通过存放到 Cache Storage 中，我们下次访问的时候如果是弱网或者断网的情况下，就可以不走网络请求，而直接就能将本地缓存的内容展示给用户，优化用户的弱网及断网体验。\n\n两种方式的比较\n\n- on install 的优点是第二次访问即可离线，缺点是需要将需要缓存的 URL 在编译时插入到脚本中，增加代码量和降低可维护性；\n\n- on fetch 的优点是无需更改编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线可用。\n\n### Service Worker 调试\n\n- 借助 Chrome 浏览器 debug\n使用 Chrome 浏览器，可以通过进入控制台 Application -> Service Workers 面板查看和调试。\n\n- 查看缓存\nService Worker 使用 Cache API 缓存只读资源，可以在 Chrome DevTools 上查看缓存的资源列表。\n\nhttp缓存：由服务器告知资源何时缓存和何时过期。sw缓存是对http缓存的增强\n\n### Service Worker 网络跟踪\n经过 Service Worker 的 fetch 请求 Chrome 都会在 Chrome DevTools Network 标签页里标注出来，其中：\n\n- 来自 Service Worker 的内容会在 Size 字段中标注为 from ServiceWorker\n\n- Service Worker 发出的请求会在 Name 字段中添加 ‘齿轮’ 图标。\n\n### Service Worker 功能性事件\n\n- fetch (请求)：当浏览器在当前指定的 scope 下发起请求时，会触发 fetch 事件，并得到传有 response 参数的回调函数，回调中就可以做各种代理缓存的事情了。\n\n- push (推送)：push 事件是为推送准备的。不过首先需要了解一下 Notification API 和 PUSH API。通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 Service Worker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。\n\n- sync (后台同步)：sync 事件由 background sync (后台同步)发出。background sync 配合 Service Worker 推出的 API，用于为 Service Worker 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C Web API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 chrome://flags/#enable-experimental-web-platform-features ，开启该功能，然后重启生效。\n\n## APP Manifest 与添加到主屏幕\n\n允许将站点添加至主屏幕，是 PWA 提供的一项重要功能\n\n1. 定义 manifest.json 配置添加到主屏幕功能\n\n2. 创建 manifest.json 文件，并将它放到你的站点目录中\n\n3. 在所有页面引入该文件\n\n4. 可以在 Service Worker 中监听 beforeinstallprompt 事件做一些应用内的行为处理\n\n```js\n{ \n    \"name\" : \"Minimal PWA\" , \n    \"short_name\" : \"PWA Demo\" , \n    \"display\" : \"standalone\" , \n    \"start_url\" : \"/\" , \n    \"theme_color\" : \"#313131\" , \n    \"background_color\" : \"#313131\" , \n    \"icons\" : [ \n        { \n        \"src\" : \"e.png\" , \n        \"sizes\" : \"256x256\" , \n        \"type\" : \"image/png\" \n        } \n    ] \n}\n```\n\n- name ：定义此PWA的名称。\n\n- icons ：定义一系列的图标以适应不同型号的设备。\n\n- theme_color ：主题颜色（影响手机状态栏颜色）。\n\n- background_color ：背景颜色。\n\n- start_url ：启动地址。由于PWA实际上是一个web页面，所以需要定义PWA 在启动时应该访问哪个地址。\n\n- display ：\"standalone\"表示其以类似原生APP的全屏方式启动。\n\n### IOS Safari 设置\n```js\n应用图标： \n<link rel=\"apple-touch-icon\" href=\"apple-touch-icon.png\" > \n启动画面： \n<link rel=\"apple-touch-startup-image\" href=\"launch.png\" > \n应用名称： \n<meta name=\"apple-mobile-web-app-title\" content=\"Todo-PWA\" > \n全屏效果： \n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" > \n设置状态栏颜色： \n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"#fff\" >\n```\n\n### window10 贴片图标\n```js\n<meta name=\"msapplication-TileImage\" content=\"images/logo/144x144.png\" > \n<meta name=\"msapplication-TileColor\" content=\"#2F3BA2\" >\n```\n\n### 在线生成 manifest.json 文件\n\n- https://app-manifest.firebaseapp.com/\n\n- https://tomitm.github.io/appmanifest/\n\n- https://brucelawson.github.io/manifest/\n\n### 参考资料\n\n1. [Web App Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest)\n\n2. [manifest.json 简介](https://lavas.baidu.com/doc/engage-retain-users/add-to-home-screen/introduction)\n\n## App Shell\n\nApp Shell，顾名思义，就是`壳`的意思，也可以理解为`骨架屏`，说白了就是在内容尚未加载完全的时候，优先展示页面的结构、占位图、主题和背景颜色等，它们都是一些被强缓存的html，css和javascript。\n\n要用好App Shell，就必须保证这部分的资源被Service Worker缓存起来。我们在组织代码的时候，可以优先完成App Shell的部分，然后把这部分代码分别打包构建出来。\n\n### 优势\n\n- 始终快速的可靠性能\n\n- 如同本机一样的交互\n\n- 数据的经济使用\n\n### 参考资料\n\n1. [App Shell 模型](https://developers.google.cn/web/fundamentals/architecture/app-shell)\n\n## 使用Offine-Plugin把网站升级成 PWA\n\n### 参考资料\n\n1. [offline-plugin](https://github.com/NekR/offline-plugin)\n\n2. [offline-plugin DEMO](https://offline-plugin.now.sh)\n\n3. [使用offline-plugin搭配webpack轻松实现PWA](https://segmentfault.com/a/1190000010669126)\n\n## 与PWA相关的开源框架\n\n### Lavas\n\n基于 Vue 的 PWA 解决方案，帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题\n\n1. [Lavas 官 网](https://lavas.baidu.com/)\n\n2. [Lavas GitHub](https://github.com/lavas-project/lavas)\n\n### 加载库\nimportScripts() // sw里的全局函数\n```js\nimportScripts('workbox-sw.prod.v1.1.0.js');\n\nconst workboxSW = new self.WorkboxSW();\n\nworkbox.precaching([\n  // 注册成功后要立即缓存的资源列表\n]);\n\n// html的缓存策略\nworkbox.routing.registerRoute(\n  new RegExp(''.*\\.html'),\n  workbox.strategies.networkFirst()\n);\n\nworkbox.routing.registerRoute(\n  new RegExp('.*\\.(?:js|css)'),\n  workbox.strategies.cacheFirst()\n);\n\nworkbox.routing.registerRoute(\n  new RegExp('https://your\\.cdn\\.com/'),\n  workbox.strategies.staleWhileRevalidate()\n);\n\nworkbox.routing.registerRoute(\n  new RegExp('https://your\\.img\\.cdn\\.com/'),\n  workbox.strategies.cacheFirst({\n    cacheName: 'example:img'\n  })\n);\n```\n通过 workbox.precaching 中的是 install 以后要塞进 caches 中的内容，workbox.routing.registerRoute 中第一个参数是一个正则，匹配经过 fetch 事件的所有请求，如果匹配上了，就走相应的缓存策略。\n\n## 注意事项\n- 避免改变 SW 的 URL（对index.html做了缓存，这样永远拿不到新的sw）","tags":["深入理解"],"categories":["JS"]},{"title":"use strict","url":"%2F2019%2Fuse%20strict.html","content":"\n严格模式是ES5引入的，更好的将错误检测引入代码的方法。顾名思义，使得JS在更严格的条件下运行。\n\n```js\n变量必须先声明，再使用\nfunction test(){\n\"use strict\";\nfoo = 'bar'; // Error\n}\n\n不能对变量执行delete操作\nvar foo = \"test\";\nfunction test(){}\n\ndelete foo; // Error\ndelete test; // Error\n\nfunction test2(arg) {\ndelete arg; // Error\n}\n对象的属性名不能重复\n{ foo: true, foo: false } // Error\n\n禁用eval()\n\n函数的arguments参数\nsetTimeout(function later(){\n// do stuff...\nsetTimeout( later, 1000 );\n}, 1000 );\n\n禁用with(){}\n\n不能修改arguments\n不能在函数内定义arguments变量\n不能使用arugment.caller和argument.callee。因此如果你要引用匿名函数，需要对匿名函数命名。\n```\n\n`严格模式`的优点：\n\n1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;\n\n2. 消除代码运行的一些不安全之处，保证代码运行的安全；\n\n3. 提高编译器效率，增加运行速度；\n\n4. 为未来新版本的Javascript做好铺垫。\n\n- 注：经过测试 IE6,7,8,9 均不支持严格模式。\n\n缺点：\n\n现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。\n\n---\n<!--more-->\n\n## 详细说明\n1.使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。\n\n2.变量在赋值之前必须声明,防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。\n\n3.取消this值的强制转换。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。在严格模式下，引用 null或未定义的 this 值会抛出错误。严格模式下，this不会指向window \n\n4.不允许重复的属性名称或参数值。当检测到对象中重复命名的属性，例如：\n```js\nvar object = {foo: \"bar\", foo: \"baz\"};\n\n// 或检测到函数中重复命名的参数时,例如：\n\nfunction foo(val1, val2, val1){}）\n\n// 严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。\n```\n5.使 eval() 更安全。在严格模式和非严格模式下， eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。\n\neval()没有被移除，但它在严格模式下发生了一些变化。最大的改变是：在eval()语句中声明的变量以及函数不会在包含域中创建。例如：\n```js\n(function() {\n\neval(\"var x = 10;\");  \n \n// 非严格模式下，x为10  \n// 严格模式下，x没有声明，抛出一个错误  \nalert(x);  \n})(); \n任意由eval()创建的变量或函数仍呆在eval()里。然而，你可以通过从eval()中返回一个值的方式实现值的传递：\n\n(function() {\n\nvar result = eval(\"var x = 10, y = 20; x + y\");  \n \n// 严格模式与非严格模式下都能正常工作（得到30）  \nalert(result);  \n}()); \n```\n6.在 delete 使用无效时抛出错误。 delete 操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。\n\n7.严格模式去除了with语句\n\n8.不能修改arguments ，不能在函数内定义arguments变量  ，不能使用arugment.caller和argument.callee。因此如果你要引用匿名函数，需要对匿名函数命名。  \n\n## 简洁说明\n\n- 变量必须声明后再使用\n- 函数的参数不能有同名属性，否则报错\n- 不能使用with语句\n- 不能对只读属性赋值，否则报错\n- 不能使用前缀 0 表示八进制数，否则报错\n- 不能删除不可删除的属性，否则报错\n- eval不会在它的外层作用域引入变量\n- eval和arguments不能被重新赋值\n- arguments不会自动反映函数参数的变化\n- 不能使用arguments.callee\n- 不能使用arguments.caller\n- 禁止this指向全局对象\n- 不能使用fn.caller和fn.arguments获取函数调用的堆栈\n- 增加了保留字（比如protected、static和interface）\n","tags":["知识"],"categories":["JS"]},{"title":"ES6Reflect对象","url":"%2F2019%2FES6Reflect%E5%AF%B9%E8%B1%A1.html","content":"\n## 介绍\nReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。\n\nReflect这个对象在新版本的chrome是支持的， ff比较早就支持Proxy和Reflect了，要让node支持Reflect可以安装[harmony-reflect](https://github.com/tvcutsem/harmony-reflect/);\n\nReflect不是构造函数， 要使用的时候直接通过Reflect.method()调用， Reflect有的方法和Proxy差不多， 而且多数Reflect方法原生的Object已经重新实现了。\n\n与大多数全局对象不同，Reflect没有构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）。\n\n---\n<!--more-->\n\n##  为什么使用\n\n- 更加有用的返回值\n\nReflect有一些方法和ES5中Object方法一样样的， 比如： Reflect.getOwnPropertyDescriptor和Reflect.defineProperty,  不过, Object.defineProperty(obj, name, desc)执行成功会返回obj， 以及其它原因导致的错误， Reflect.defineProperty只会返回false或者true来表示对象的属性是否设置上了，\n\n```js\ntry {\n  Object.defineProperty(obj, name, desc);\n  // property defined successfully\n} catch (e) {\n  // possible failure (and might accidentally catch the wrong exception)\n}\n```\n可以重构成\n```js\nif (Reflect.defineProperty(obj, name, desc)) {\n  // success\n} else {\n  // failure\n}\n```\n\n- 函数操作\n```js\nname in obj // Reflect.has(obj, name)\ndelete obj[name] // Reflect.deleteProperty(obj, name)\n```\n\n- 更加可靠的函数式执行方式： 在ES中， 要执行一个函数f，并给它传一组参数args， 还要绑定this的话， 要这么写：\n```js\nf.apply(obj, args) // apply有可能被篡改\nFunction.prototype.apply.call(f, obj, args) // Reflect.apply(f, obj, args)\n```\n\n- 可变参数形式的构造函数\n```js\nvar obj = new F(...args)\nvar obj = Reflect.construct(F, args)\n```\n\n- 控制访问器或者读取器的this\n```js\nobj.name\nobj['name']\nReflect.get(obj, name, wrapper)\nReflect.set(obj, name, value, wrapper)\n```\n\n访问器中不想使用自己的方法，而是想要重定向this到wrapper：\n```js\nvar  obj = {\n    set foo(value){\n        return this.bar();\n    }\n    bar(){\n        console.log(1)\n    }\n}\n\nvar wrapper = {\n    bar(){\n        console.log(2)\n    }\n}\nReflect.set(obj, \"foo\", \"value\", wrapper)\n```\n\n- 避免直接访问__proto__\n\n### Reflect.apply\nReflect.apply其实就是ES5中的 Function.prototype.apply() 替身， 执行Reflect.apply需要三个参数\n\n第一个参数为： 需要执行的函数；\n第二个参数为： 需要执行函数的上下文this；\n第三个参数为： 是一个数组或者伪数组， 会作为执行函数的参数；\n\n### Reflect.construct\nReflect.construct其实就是实例化构造函数，通过传参形式的实现， 执行的方式不同， 效果其实一样， construct的第一个参数为构造函数， 第二个参数由参数组成的数组或者伪数组， 第三个参数为一个超类， 新元素会继承这个超类；\n```js\nvar Fn = function(arg) {\n    this.args = [arg]\n};\nconsole.log( new Fn(1), Reflect.construct(Fn,[1]) ); // 输出是一样的\n\nvar d = Reflect.construct(Date, [2019, 5, 2]);\nd instanceof Date; // true\nd.getFullYear(); // 2019\n```\n\n### Reflect.defineProperty\nReflect.defineProperty返回的是一个布尔值， 通过直接赋值的方式把属性和属性值添加给对象返回的是一整个对象， 如果添加失败会抛错；\n```js\nvar obj = {};\nif( Reflect.defineProperty(obj, \"x\", {value : 7 }) ) {\n    console.log(\"added success\");\n}else{\n    console.log(\"添加失败\");\n};\n```\n\n### Reflect.deleteProperty\nReflect.deleteProperty和Reflect.defineProperty的使用方法差不多， Reflect.deleteProperty和 delete obj.xx的操作结果是一样， 区别是使用形式不同：一个是操作符，一个是函数调用；\n```js\nReflect.deleteProperty(Object.freeze({foo: 1}), \"foo\"); // false\ndelete Object.freeze({foo: 1}).foo; //输出：false；\n```\n\n### Reflect.get\n这个方法的有两个必须的参数： 第一个为obj目标对象， 第二个为属性名对象， 第三个是可选的，是作为读取器的上下文(this);\n```js\nvar obj = {};\nobj.foo = 1;\nconsole.log( obj.foo ); //输出：1;\nconsole.log( Reflect.get(obj, \"foo\") ) //输出：1;\n```\n\n### Reflect.getOwnPropertyDescritptor\n获取属性描述\n```js\nReflect.getOwnPropertyDescriptor({x: \"hello\"}, \"x\");\n//也可以这样获取：\nObject.getOwnPropertyDescriptor({x:\"1\"},\"x\");\n//这两个的区别是一个会包装对象， 一个不会：\nReflect.getOwnPropertyDescriptor(\"hello\",0); //抛出异常\nObject.getOwnPropertyDescriptor(\"hello\",0); //输出： {value: \"h\", writable: false, enumerable: true, configurable: false}\n```\n\n### Reflect.getPrototypeOf\n同Object.getPrototypeOf\n\n### Reflect.has\n同 in\n```js\nReflect.has({x:0}, \"x\") //输出： true；\n```\n\n### Reflect.isExtensible\n```js\n// 现在这个元素是可以扩展的；\nvar empty = {};\nReflect.isExtensible(empty); // === true\n\n// 使用preventExtensions方法， 让这个对象无法扩展新属性；\nReflect.preventExtensions(empty);\nReflect.isExtensible(empty); // === false\n\n// 这个对象无法扩展新属性， 可写的属性依然可以改动\nvar sealed = Object.seal({});\nReflect.isExtensible(sealed); // === false\n\n// 这个对象完全被冻结了\nvar frozen = Object.freeze({});\nReflect.isExtensible(frozen); // === false\n```\n\n### Reflect.ownKeys\n返回对象的keys\n```js\nconsole.log(Reflect.ownKeys({\"a\":0,\"b\":1,\"c\":2,\"d\":3})); //输出 ：[\"a\", \"b\", \"c\", \"d\"]\nconsole.log(Reflect.ownKeys([])); // [\"length\"]\n```\nreflect.ownKeys的排序是根据: 先显示数字， 数字根据大小排序，然后是 字符串根据插入的顺序排序， 最后是symbol类型的key也根据插入插入顺序排序;\n\n### Reflect.set\n```js\nvar obj = {};\nReflect.set(obj, \"prop\", \"value\"); // 输出：true\nconsole.log( obj.prop ); // 输出：\"value\"\n\nvar obj = {};\nReflect.set(obj); // 输出：true\n// 相当于 Reflect.set(obj, undefined, undefined);\n```\n\n### Reflect.setPrototypeOf\n修改对象的\\_\\_proto\\_\\_属性\n```js\nReflect.setPrototypeOf({}, Object.prototype); // 输出true\n\n// 给该对象数组[[Prototype]] 为null.\nReflect.setPrototypeOf({}, null); // true\n// 此时的obj.__proto__为undefined\n\n//把对象冻结以后重新设置[[prototype]]\nReflect.setPrototypeOf(Object.freeze({}), null); // false\n\n// 如果原型链循环依赖的话就会返回false.\nvar target = {};\nvar proto = Object.create(target);\nReflect.setPrototypeOf(target, proto); // false\n```","tags":["深入理解"],"categories":["JS"]},{"title":"深入了解HTTP","url":"%2F2019%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3HTTP.html","content":"\n## HTTP 特性\n- 基于TCP-IP协议 应用层协议 默认端口号80\n- 无连接无状态\n\n### 什么是无状态\n- 状态】的含义就是：客户端和服务器在某次会话中产生的数据\n- 那么对应的【无状态】就意味着：这些数据不会被保留\n- 通过增加cookie和session机制，现在的网络请求其实是有状态的\n- 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话\n\n## HTTP 报文    \n### 请求报文\nHTTP 协议是以 ASCII （a s ki）码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。\n\n- GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制\n- 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制\n- 参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里\n\n---\n<!--more-->\n\n### POST提交的方式\nHTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。\n\n但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 PHP、Python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。\n\n1. application/x-www-form-urlencoded\n这是最常见的 POST 数据提交方式。浏览器的原生 <form> 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。\n\n2. multipart/form-data\n使用表单上传文件时，必须让 <form> 表单的 enctype 等于 multipart/form-data。\n\n上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也只支持这两种方式（通过 <form> 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。\n\n随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 application/json，application/form-data，text/xml，乃至 application/x-protobuf 这种二进制格式，只要服务器可以根据 Content-Type 和 Content-Encoding 正确地解析出请求，都是没有问题的。\n\n### 响应报文\n- 状态行\n- 响应头(Response Header)\n- 响应正文\n\nGET 请求 304获取缓存\n第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。\n\n### 持久连接\n\n在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际上它是被附加到 HTTP 1.0协议上，如果客户端浏览器支持 Keep-Alive ，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。\n\n在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 \"Connection: close\" 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了。\n\n- HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。也就是默认都是持续连接的。在事务处理结束之后仍然保持在打开状态的TCP连接称之为持久连接。\n\n- HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。\n\n#### 当 HTTP 采用 keepalive 模式，当客户端向服务器发生请求之后，客户端如何判断服务器的数据已经发生完成？\n1. 使用消息首部字段 Conent-Length：Conent-Length表示实体内容长度，客户端可以根据这个值来判断数据是否接收完成。\n\n2. 使用消息首部字段 Transfer-Encoding：chunk在最后有一个空 chunked 块，表明本次传输数据结束。 \n\n### HTTP Pipelining（HTTP 管线化）\n默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3。\n\nHTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3\n\n### 会话跟踪\n1. 什么是会话？\n\n客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。\n\n2. 什么是会话跟踪？\n\n会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。\n\n3. 为什么需要会话跟踪？\n\n浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。\n\nCookie\n\nCookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,以便下次使用。\n\n客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。\n\nCookie 是可以被客户端禁用的。\n\nSession:\n\n每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。\n\n在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。\n\nSession 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。\n\n### 跨站攻击\n\n#### CSRF（Cross-site request forgery，跨站请求伪造）\n\n- 如何防范 CSRF 攻击？\n\n1. 关键操作只接受 POST 请求，get 不修改数据\n2. 验证码 强制用户必须与应用进行交互。\n3. 检测referer 通过Referer识别 根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。\n4. 请求校验\n\n#### XSS（Cross Site Scripting，跨站脚本攻击）\n\nXSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。\n\nXSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。\n\nXSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入js脚本，为了减轻这些攻击，需要在HTTP头部配上set-cookie：http-only这个属性可以防止xss，它会禁止js脚本访问cookie。secure这个属性告诉浏览器仅在请求为https时发送cookie。\n\n分为非持久型(反射型XSS)，一次攻击；存储型XSS存储到服务器上，多次攻击。\n\n- 如何防范 XSS\n1. cookie设置http-only，不允许js修改访问cookie\n2. 输入检查、输出检查，对变量输入到HTML页面的代码进行编码或转义\n\n### http缓存\n`缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。`\n浏览器缓存主要有以下几个优点：\n\n1. 减少重复数据请求，避免通过网络再次加载资源，节省流量。\n2. 降低服务器的压力，提升网站性能。\n3. 加快客户端加载网页的速度， 提升用户体验。\n\n浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：\n\n- 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。\n- 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。 不同浏览器的策略不同，在 Fire Fox 中，from cache 状态码是 304.\n\n>  from cache 会分为 from disk cache 和 from memory cache. 从内存中获取最快，但是是 session 级别的缓存，关闭浏览器之后就没有了。\n\n- 强缓存（from cache）强制浏览器使用本地缓存\n    - Cache-control(响应头)\n    - Expires(响应头)\n    - Pragma\n- 协商缓存（304还是要和服务器通信一次）\n    - last-modified(响应头)\n    - Etag(响应头)\n    - If-None-Match(请求头)\n    - If-Modified-Since(请求头)\n\n优先级\n>  Cache-Control  > Expires > Etag > Last-Modified\n\nHTTP 缓存机制流程图:\n![缓存机制流程图](http://cdn.mydearest.cn/blog/images/http-cache.jpeg)\n\n![流程图](http://cdn.mydearest.cn/blog/images/http-cache2.png)\n\n### 如何设置强缓存和协商缓存\n1. 后端服务器，写入代码逻辑中：\n```js\nres.setHeader('max-age': '3600 public')\nres.setHeader(etag: '5c20abbd-e2e8')\nres.setHeader('last-modified': Mon, 24 Dec 2018 09:49:49 GMT)\n```\n\n2. Nginx 配置\n```js\nadd_header Cache-Control \"max-age=3600\"\n```\n\n## HTTPS基本过程\nHTTPS即 HTTP over TLS，是一种在加密信道进行HTTP内容传输的协议\n\n> TLS 的早期版本叫做 SSL。SSL 的 1.0, 2.0, 3.0 版本均已经被废弃，出于安全问题考虑广大浏览器也不再对老旧的 SSL 版本进行支持了，因此这里我们就统一使用 TLS 名称了。","tags":["http"],"categories":["知识"]},{"title":"维生素","url":"%2F2019%2F%E7%BB%B4%E7%94%9F%E7%B4%A0.html","content":"\n## 维生素分类\n\n### 维生素A\n\n> 长期用眼。\n\n维生素A缺乏，会带来眼睛干涩，夜间视力下降等问题。\n\n![维生素A](http://cdn.mydearest.cn/blog/images/VA.jpg)\n\n---\n<!--more-->\n\n### 维生素C\n\n> 果蔬没吃够的\n\n![维生素A](http://cdn.mydearest.cn/blog/images/VC.jpg)\n\n### 维生素D\n\n> 太阳晒的少，影响钙吸收\n\n### 维生素B\n\nB类的维生素有很多种。\n\n#### 硫胺素(维生素B1)\n\n运动越多，消耗能量（主要是碳水化合物）越多，硫胺素需要也越多。随着进食量增加，硫胺素摄入可能也会增加，**所以一般不必额外补充。**\n\n#### 核黄素（维生素B2）\n\n核黄素跟蛋白质、脂肪、碳水化合物的能量产生都有关系。我国目前是成年男性1.4毫克/天，女性1.2毫克/天。运动人群，增加到推荐量的1-2倍足矣。食物补充的话，平时可以多吃肉、蛋和奶制品。花椰菜、芦笋、菠菜这类绿色蔬菜核黄素含量也比较高。**这些东西吃的少的话，可以考虑补充剂。**\n\n#### 烟酸（维生素B3）\n\n烟酸跟蛋白质、碳水化合物、脂肪的能量产生都有关。含烟酸比较丰富的食物有肉类、谷类、豆类食物。因为色氨酸在体内能转化成烟酸，动物蛋白摄入比较多的人，**烟酸一般都不会缺乏**。所以，常吃较多肉的人，即便是运动人群，也基本不用额外补充烟酸。\n\n#### 维生素B6\n\n这种维生素主要跟糖原和蛋白质代谢有关。体内储存的糖原想变成葡萄糖，氨基酸想转换利用，都需要维生素B6，所以这东西跟运动关系密切。\n\n维生素B6跟别的B族维生素不一样，这玩意有毒性。但一般都要达到药物剂量才会中毒。比如治疗经期按综合症、哮喘有时会用到B6。维生素B6的最高耐受上限是100毫克/天。低于这个剂量一般没有太大问题。\n\n比较安全的补充方式还是食物，肉、蔬菜、坚果、香蕉、全谷物食品里含B6都很丰富。比如100克鸡胸肉里就有大约0.6毫克维生素B6。所以，这些东西吃的比较多的话，一般不用吃补充剂额外补充。\n\n#### 橙子、橘子、柚子、青柠、西柚、柠檬、芦柑的关系。\n\n橙子是橘子和柚子杂交来的，橘子和橙子杂交成了芦柑，柚子和橙子又杂交成了青柠，橙子和青柠杂交了柠檬，橙子和柚子杂交成了西柚。","tags":["杂谈"],"categories":["杂谈"]},{"title":"vuex学习笔记","url":"%2F2019%2Fvuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","content":"\n## vuex\n数据驱动模板（管理共享状态）\n核心store仓库（响应式的状态存储）\n提交mutation才能修改内部状态 记录每次改变保存状态快照\n\n```js\nconst store = new Vuex.Store({\n    state:{\n        count:0\n    },\n    mutations: {\n        increase(state){\n            state.count++;\n        }\n    },\n    // 开启严格模式\n    strict: process.env.NODE_ENV !== 'production'\n    // 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n})\n\nstore.commit('increase');\nstore.state.count;\n```\n\n不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。\n\n---\n<!--more-->\n\n### state（单一状态树）\n\n用一个对象包含所有的应用层级状态\n\n- 从store实例中读取状态\n```js\n// 计算属性\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n- 从根组件注入实例\n```js\nconst app = new Vue({\n  el: '#app',\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n// 读取\nthis.$store.state.count\n```\n\n- 多个属性使用mapState()辅助函数\n```js\ncomputed: mapState({\n    count: state => state.count,\n    name: state=> state.name\n})\n// 如果属性与state子节点名称相同 传入字符串数组\n// 映射 this.count 为 store.state.count\nmapState(['count'])\n```\n\n### getter对state数据的派生操作（共享数据的共享函数）\n```js\nconst store = new Vuex.Store({\n    state:{\n        todos: [\n            { id: 1, text: '...', done: true },\n            { id: 2, text: '...', done: false }\n        ]\n    },\n    getters: {\n        doneTodos: state => {\n            return state.todos.filter(todo => todo.done)\n        }\n        // 接收getter参数\n        doneTodosCount: (state, getters) => {\n            return getters.doneTodos.length\n        }\n        // 方法\n        getTodoById: (state) => (id) => {\n            return state.todos.find(todo => todo.id === id)\n        }\n    }\n})\n// 访问\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n```\n- mapGetters()辅助函数\n```js\ncomputed: {\n    // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n        'doneTodosCount',\n        'anotherGetter',\n        // ...\n    ])\n}\nmapGetters({\n    // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n    doneCount: 'doneTodosCount'\n})\n```\n\n### mutation\n提交mutation\n```js\nstore.commit(\"increase\")\n// 传参\nstore.commit('increase', 10)\n// 最好还是规范传payload对象\nstore.commit('increase', {\n    amount:10\n})\n// 对象风格提交\nstore.commit({\n  type: 'increase',\n  amount: 10\n})\n```\n1.最好提前在你的 store 中初始化好所有所需属性。\n\n2.当需要在对象上添加新属性时，你应该\n\n•使用 Vue.set(obj, 'newProp', 123), 或者\n\n•以新对象替换老对象。\n```js\nstate.obj = { ...state.obj, newProp: 123 }\n```\n\n- 常量替代事件类型\n```js\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n```js\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n**mutation必须是同步函数**\n一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n\n#### 组件中提交mutation\n1. \n```js\nthis.$store.commit('xxx')\n```\n\n2. mapMutations 辅助函数\n```js\nmethods: {\n    ...mapMutations([\n      'increase', // 将 `this.increase()` 映射为 `this.$store.commit('increase')`\n\n      // `mapMutations` 也支持载荷：\n      'increaseBy' // 将 `this.increaseBy(amount)` 映射为 `this.$store.commit('increaseBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increase' // 将 `this.add()` 映射为 `this.$store.commit('increase')`\n    })\n}\n```\n\n### action\n```js\nstore.commit('increment')\n// 任何由 \"increment\" 导致的状态变更都应该在此刻完成。\n```\n\nAction 类似于 mutation，不同在于：\n•Action 提交的是 mutation，而不是直接变更状态。\n•Action 可以包含任意异步操作。\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increase (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increase (context) {\n      context.commit('increase')\n    },\n    increaseOr({commit}) {\n      commit('increase')\n    },\n    increaseAsync ({ commit }) {\n        // 支持异步操作\n        setTimeout(() => {\n        commit('increment')\n        }, 1000)\n    }\n  }\n})\n```\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。\n\n- 触发action\n```js\nstore.dispatch('increase')\n```\n- 支持同样的载荷方式和对象方式分发\n```js\n// 以载荷形式分发\nstore.dispatch('increaseAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'increaseAsync',\n  amount: 10\n})\n```\n\n```js\n// 购物车操作实例\nactions: {\n  checkout ({ commit, state }, products) {\n    // 把当前购物车的物品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发出结账请求，然后乐观地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接受一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () => commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n```\n\n#### 组件中分发action\n在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increase', // 将 `this.increase()` 映射为 `this.$store.dispatch('increase')`\n\n      // `mapActions` 也支持载荷：\n      'increaseBy' // 将 `this.increaseBy(amount)` 映射为 `this.$store.dispatch('increaseBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increase' // 将 `this.add()` 映射为 `this.$store.dispatch('increase')`\n    })\n  }\n}\n```\n\n#### action组合嵌套\nstore.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise\n```js\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  },\n   actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n采用async await\n\n```js\n// getData() 和 getOtherData() 返回的是 Promise\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n\n### module切分模块\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n- 模块内部的action\n```js\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  },\n   getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n- 命名空间\n```js\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n- 在带命名空间的模块内访问全局内容（Global Assets）\n```js\nmodules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n- 在带命名空间的模块注册全局 action\n若需要在带命名空间的模块注册全局 action，可添加 root: true，并将这个 action 的定义放在函数 handler 中。\n```js\n{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch('someAction')\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> 'someAction'\n        }\n      }\n    }\n  }\n}\n```\n\n- 带命名空间的绑定函数\n```js\ncomputed: {\n  ...mapState({\n    a: state => state.some.nested.module.a,\n    b: state => state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    'some/nested/module/foo', // -> this['some/nested/module/foo']()\n    'some/nested/module/bar' // -> this['some/nested/module/bar']()\n  ])\n}\n```\n\n简化\n```js\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n\n也可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数\n```js\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }\n}\n```\n\n## 定义插件\n```js\nconst myPlugin = store => {\n    // 传入store初始化时调用\n    store.subscribe((mutation, state)=>{\n        // 每次mutation之后调用\n        // mutation 的格式为 {type, payload}\n    })\n}\n```\n\n## 表单处理\n因为提交mutation才能修改状态，所以v-model不适合绑定vuex里的state，不符合vuex的思想。\n```html\n<input v-model=\"obj.message\">\n```\n假设这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。\n\n1. 不采用v-model\n所以需要input绑定value，然后调用input或者change提交mutation修改状态\n```html\n<input :value=\"message\" @input=\"updateMessage\">\n```\n```js\ncomputed: {\n    ...mapState({\n        message: state => state.obj.message\n    })\n},\nmethod: {\n    updateMessage(e){\n        this.$store.commit(\"updateMessage\", e.target.value)\n    }\n}\n```\n\n2. 采用v-model\n```js\n// ...\ncomputed: {\n  message: {\n    get () {\n      return this.$store.state.obj.message\n    },\n    set (value) {\n      this.$store.commit('updateMessage', value)\n    }\n  }\n}\n```","tags":["vue"],"categories":["知识"]},{"title":"macvscode更新失败：Permissiondenied解决办法","url":"%2F2019%2Fmacvscode%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9APermissiondenied%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html","content":"\n## 场景 -- mac vscode不能安装更新\n> Could not create temporary directory: Permission denied\n\n## 原因分析\nmac下`/Users/username/Library/Caches/`用户文件不一样，root和username\n\n导致\n\n> drwxr-xr-x   6 username  staff   204B Jan 17 20:33 com.microsoft.VSCode\n> drwxr--r--   2 root    staff    68B Dec 17 13:51 com.microsoft.VSCode.ShipIt\n\n## 解决方案\n```\n// 1. 关闭vscode\n\n// 2. 这一步是需要输入密码的\nsudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/ \n\n// 3. 这一步是不需要输入密码的, 如果不进行第一步，第二步会报错\nsudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/*\n\n// 4. 更新xattr\nxattr -dr com.apple.quarantine /Applications/Visual\\ Studio\\ Code.app\n```\n\n## 重新安装更新 完成😁\n\n## Mac版本下的Chrome，双击html文件打不开\n原因其实是因为在Mac OS系统下，在Finder(访达)中做任何操作，文件都会不可避免的被附加上一个特有的拓展属性(extend attributes)，可以通过终端命令ls -l查看，这些文件通常都会有@作为标记，因此，由于产品的原型是由Axure来制作的，然后导出了tar的压缩包，因此我们解压之后，通常都不能直接在浏览器打开！\n\n怎么解决这种问题呢？\n\n我们可以清除掉这个属性(extend attributes)！\n\n1. 可以针对单个文件做清除操作（filename就是要文件名，例如：index.html）\n```js\nxattr -c filename\n```\n\n2. 也可以针对整个目录做清除操作（directory就是目录名，例如：content）\n```js\nxattr -rc directory\n```\n","tags":["工具"],"categories":["工具"]},{"title":"borderRadius百分比50和100究竟有什么区别","url":"%2F2019%2FborderRadius%E7%99%BE%E5%88%86%E6%AF%9450%E5%92%8C100%E7%A9%B6%E7%AB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html","content":"\n\nborder-radius的值是百分比的话，就相当于盒子的宽度和高度的百分比。我们知道在一个正方形内做一个面积最大的圆形，这个圆的半径就为正方形边长的一半。所\n\n以border-radius为50%时，则会形成圆。那么可能有人就会问，border-radius为100%时，对应圆的半径长度不就是正方形的宽高么，这种情况下，为什么还是会\n\n形成一个和值为50%一样的圆形呢？\n\n---\n<!--more-->\n\n　　其实这是W3C对于[重合曲线](https://www.w3.org/TR/css-backgrounds-3/#corner-overlap)有这样的规范：如果两个相邻角的半径和超过了对应的\n\n盒子的边的长度，那么浏览器要重新计算保证它们不会重合。下面我们假定一个宽\n\n高为100px的正方形A。此时设置border-top-left-radius=100%；则正方形A会变成一个半径为100px的四分之一圆弧。 \n\n![radius1](http://cdn.mydearest.cn/blog/images/radius1.png)\n\n　　然后我们再给border-top-right-radius=100%。此时相邻的角的半径已经超过了对应的盒子的边的长度。浏览器需要重新计算。重新计算的规则是同时缩放两\n\n个圆角的半径知道他们刚好符合这个方形。\n\n\n　　建议使用border-radius = 50% 来避免浏览器不必要的计算。值得注意的是在涉及到与圆角相关动画的情况下，值为50%和100%，在动画效果上会有不同。\n\n## 示例代码\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>动画效果差异</title>\n</head>\n<style>\ndiv{\n  width: 100px;\n  height: 100px;\n  margin-bottom: 10px;\n  \n  transition: border-radius 3s;\n\n}\n.half{\n  border-radius: 50%;\n  background: #000;\n}\n.full{\n  border-radius: 100%;\n  background: #f00;\n}\n\n.box1:hover div{\n  border-radius: 0;\n}\n.wrap{\n  width:100px;\n  height: 250px;\n  border: 1px solid red;\n  cursor: pointer;\n}\n\n.box2 .half{\n    border-radius: 0;\n    background: #000;\n}\n\n.box2 .full{\n    border-radius: 0;\n    background: #f00;\n}\n.box2:hover .half{\n  border-radius: 50%;\n}\n.box2:hover .full{\n  border-radius:100%\n}\n</style>\n<body>\n  <div class='wrap box1'>\n    <div class=\"half\"></div>\n    <div class=\"full\"></div>\n  </div>\n  \n  <div class='wrap box2'>\n    <div class=\"half\"></div>\n    <div class=\"full\"></div>\n  </div>\n  <p>将鼠标移到红框内</p>\n</body>\n</html>\n```","tags":["知识"],"categories":["CSS"]},{"title":"JS函数基础","url":"%2F2019%2FJS%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80.html","content":"\n## 函数的定义\n函数其实就是一个封装一段代码段的**对象**，那函数名其实仅是用来引用函数对象的一个普通变量\n\n写代码的时候我们避免不了要重复用一些代码，一直重复写很耗时，而且不美观也不利于维护，因此函数的出现就是来让代码重用，便于维护。\n\n一段代码，可能被反复使用，可以定义为函数，然后调用函数来使用这段代码。\n\n在JavaScript中函数就是对象。函数不同于其他对象的决定性特点是，函数存在一个被称为[[Call]]的内部属性。内部属性无法通过代码访问而是\n\n定义了代码执行时的行为。ECMAScript为JavaScript的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。\n\n[[Call]]属性是函数独有的，表明该对象可以被执行。由于仅函数拥有该属性，ECMAScript定义了typeof操作符对任何具有[[Call]]属性的对\n\n象返回 `[object Function]`\n\n---\n<!--more-->\n\n## 函数的创建\n**function 声明**\n\n```js\nfunction 函数名(参数列表) {\n  函数体;\n  return 返回值;\n}\n```\n\n**直接量声明**\n\n```js\nvar 函数名 = function(参数列表) {\n  函数体;\n  return 返回值;\n};\n```\n\n**用 new 创建**\n\n因为 Function 是内置类型，本身有一个 Function 的构造函数，是内置类型，所以是可以 `new` 的\n\n```js\nvar 函数名 = new Function(\"参数名1\",\"参数名2\",...,\"函数体; return 返回值\")\n```\n\n这里注意，参数和函数体都要用引号引起来，但是一般函数的创建都不会这样创建，以前面的两种为主，那其实前面两种的创建是存在一定的差别的，下面会提到\n\n## 函数的参数\n函数执行时必须的数据变量，它分为显示参数(Parameters)与隐式参数(Arguments)\n\n### 显示参数\n```js\nfunction fun(name, id) {\n  //函数体\n}\n```\n\n这种直接传进来的 name 和 id 就是显示参数，也就是你能看到的。其实函数传递的参数就相当于在函数体内又声明了一个局部变量\n\n```js\nvar i = 10;\nfunction fun(i) {\n  i++;\n  console.log(i);\n}\nfun(i);\n```\n\n上面的代码，就相当于下面的代码\n\n```js\nvar i = 10;\nfunction fun() {\n  var i = 10; //这个值就是传进来的参数的值\n  i++;\n  console.log(i);\n}\nfun(i); //在此处传入i\n```\n\n### 隐式参数\n每个 JavaScript 函数内部都有一个对象 `arguments` 对象,其实是一个类数组的对象,它会自动接受所有传入函数的参数值。\n\n```js\nfunction func(          ) {\n  //arguments[          ]\n}\n```\n\n值得一说的是,`arguments` 有下标有长度，可以通过下标来获得传入的参数，比如 `arguments[0]` 就是第一个参数, `length` 就可以遍历这个类数组对象，但是，毕竟它不是数组，所以不能进行一些数组特有的操作，比如 `sort`\n\n### 函数重载\n强类型语言对重载的定义：函数名相同，参数不同，或者是参数类型不同都可以叫做函数的重载。\n\n但在js中因为 arguments 的存在，JavaScript的函数根本就不存在所谓的签名，所以重载在JavaScript中实际是不存在的。\n```js\n// 模拟函数重载\nfunction abc(){\n    if (arguments.length ===1){\n        //A\n    }\n    if(arguments.length ===2){\n        //B\n    }\n}\n\nabc(11);\nabc(11,22);\n```\n\n## 声明提前\n在开始执行程序前,js 引擎会首先查找 `var` 声明的变量和 `function` 声明的函数，将其提前到当前作用域的顶部集中创建，而将赋值操作保留在原地,这里特别说一下,未用 `var` 声明的变量不会声明提前.\n\n```js\nconsole.log(a); //a is not defined\na = 10;\n```\n\n```js\nconsole.log(a); //undefined\nvar a = 10;\nconsole.log(a); //10\n```\n\n但是在它下面声明并赋值变量 `a`,因为声明提前,其实代码会变成下面这个样子\n\n```js\nvar a;\nconsole.log(a);\na = 10;\nconsole.log(a);\n```\n\n这样看，一切都变得很合理。。\n\n函数也是一样\n\n```js\nfunction fun() {\n  console.log(1);\n}\nfun(); //2\nfunction fun() {\n  console.log(2);\n}\nfun(); //2\n```\n\n控制台会输出两个 2,因为 function 声明的函数也会声明提前,代码其实是下面这个样子\n\n```js\nfunction fun() {\n  console.log(1);\n}\nfunction fun() {\n  console.log(2);\n}\nfun(); //2\nfun(); //2\n```\n\n第二次声明因为方法名字一样，后者覆盖了前者，所以再调用的时候就会调用最后这个\n\n但是声明提前会增加程序解读的难度，因此我们在写程序时，尽量避免声明提前所带来的危害\n\n### 声明提前的解决方法\n那我们既然知道会有声明提前这种操作，就在变量和函数的声明时都放在当前作用域的顶部。\n\n在 ES6 中 可以用 let 代替 var,不过要求在当前作用域中 let 变量之前不允许出现声明的变量\n\n也可以用直接量声明变量的方法\n\n```js\nvar fun = function() {\n  console.log(1);\n};\nfun(); //1\nvar fun = function() {\n  console.log(2);\n};\nfun(); //2\n```\n\n这种当然也会声明提前，那我们看一下声明提前后的代码\n\n```js\nvar fun;\nvar fun;\nfun = function() {\n  console.log(1);\n};\nfun(); //1\nfun = function() {\n  console.log(2);\n};\nfun(); //2\n```\n\n声明提前但是赋值还是留在原地，所以虽然有声明提前，但是并不会改变我们原本想要的结果。也就解决了声明提前带来的危害。\n\n## 匿名函数\n函数创建时没有指定函数名\n\n匿名函数使用后自动释放,会节约内存,它会划分临时作用域，避免全局变量污染全局。\n\n### 用处\n**callback**\n\n将一个函数作为参数传入另一个函数内，被其它函数调用\n\n举个栗子🌰\n\n```js\narr.sort(function(a, b) {\n  return a - b;\n});\n```\n\n```js\nstr.replace(/reg/g, function(kw,$1,$2,...){return 替换值})\n```\n\n#### 自调\n定义函数后自己调用自己，调用结束后，立刻释放，不占内存\n\n举个例子🌰\n\n```js\n(function(参数列表) {\n  函数体;\n  return 返回值;\n})(参数值列表);\n```\n\n会定义一个临时的作用域，减少使用全局变量，避免全局污染。\n\n## 重载\n相同函数名，不同参数列表的多个函数。在调用时，根据传入参数的不同，自动选择匹配的函数执行。\n\n这样可以减少 api 的数量，减轻调用者的负担。\n\n听起来很诱人，但是 js 语法不支持重载，原因是 js 不允许多个同名函数同时存在，后声明的函数会覆盖前面声明的。(哇。js 不支持你在这里说什么，神经病啊).\n\n既然说重载，那肯定是可以通过某些方法实现的。这个方法就是利用 `arguments`\n\n```js\nfunction test() {\n  if (arguments.length == 0) {\n    //不传值的操作\n  } else if (arguments.length == 1) {\n    //传一个值进行的操作\n  } else {\n    //....等等\n  }\n}\n```\n\n其实也不是真正意义上的重载，因为并没有创建同名的多个函数，但是实现的效果是和重载差不多的。\n\n## 常规函数\n\n- 命名函数\n- 匿名函数\n- 对象方法\n- 对象方法简写(ES 6)\n- IIFE(立即执行函数)\n\n## 箭头函数\n- 命名箭头函数\n- 匿名箭头函数\n- 对象方法\n- IIFE 箭头函数\n","tags":["深入理解"],"categories":["JS"]},{"title":"NodeJSHttp加载静态资源","url":"%2F2019%2FNodeJSHttp%E5%8A%A0%E8%BD%BD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90.html","content":"\n问题场景：浏览器向后台发送请求后，后台返回一个html界面。但是在浏览器中没有加载js、css等静态资源，查找原因后发现是Content-Type的原因。浏览器不知道css、js等文件的文件格式，无法成功加载静态文件。所以，需要设置正确的文件格式。\n\n---\n<!--more-->\n\n## 搭建简单的本地服务\n```js\nvar http = require('http');//引入http模块\n\n//开启服务，监听8888端口\n//端口号最好为6000以上\nvar server = http.createServer(function(req,res){\n    /*\n        req用来接受客户端数据\n        res用来向客户端发送服务器数据\n    */\n\n    console.log('有客户端连接');//创建连接成功显示在后台\n\n    //一参是http请求状态，200连接成功\n    //连接成功后向客户端写入头信息\n    res.writeHeader(200,{\n        'content-type' : 'text/html;charset=\"utf-8\"'\n    });\n\n    res.write('这是正文部分');//显示给客户端\n    res.end();\n\n}).listen(8888);\n\nconsole.log('服务器开启成功');\n```\n\n## 访问本地站点\n```js\nvar http = require('http');\nvar fs = require('fs');//引入文件读取模块\n\nvar documentRoot = 'E:/PhpProject/html5/websocket/www';\n//需要访问的文件的存放目录\n\nvar server= http.createServer(function(req,res){\n\n    var url = req.url; \n    //客户端输入的url，例如如果输入localhost:8888/index.html\n    //那么这里的url == /index.html \n\n    var file = documentRoot + url;\n    console.log(url);\n    //E:/PhpProject/html5/websocket/www/index.html \n\n\n    fs.readFile( file , function(err,data){\n    /*\n        一参为文件路径\n        二参为回调函数\n            回调函数的一参为读取错误返回的信息，返回空就没有错误\n            二参为读取成功返回的文本内容\n    */\n        if(err){\n            res.writeHeader(404,{\n                'content-type' : 'text/html;charset=\"utf-8\"'\n            });\n            res.write('<h1>404错误</h1><p>你要找的页面不存在</p>');\n            res.end();\n        }else{\n            res.writeHeader(200,{\n                'content-type' : 'text/html;charset=\"utf-8\"'\n            });\n            res.write(data);//将index.html显示在客户端\n            res.end();\n\n        }\n\n    });\n\n\n\n}).listen(8888);\n\nconsole.log('服务器开启成功');\n```\n\n## 无法加载静态文件\n\n### 解决方案一\n- 手动设置Content-Type\n```js\nvar http = require('http');\nvar fs = require('fs');//引入文件读取模块\n\nvar documentRoot = './dist';\n//需要访问的文件的存放目录\n\nhttp.createServer(function(req,res){\n\n    var url = req.url; \n    //客户端输入的url，例如如果输入localhost:8888/index.html\n    //那么这里的url == /index.html \n\n    var file = documentRoot + url;\n    console.log(file);\n\n    fs.readFile(file , function(err,data){\n    /*\n        一参为文件路径\n        二参为回调函数\n            回调函数的一参为读取错误返回的信息，返回空就没有错误\n            二参为读取成功返回的文本内容\n    */\n        if(err){\n            res.writeHeader(404,{\n                'content-type' : 'text/html;charset=\"utf-8\"'\n            });\n            res.write('<h1>404错误</h1><p>你要找的页面不存在</p>');\n            res.end();\n        }else{\n            var type = file.substr(file.lastIndexOf(\".\")+1,file.length)\n            res.writeHeader(200,{'Content-type':\"text/\"+type+';charset=\"utf-8\"'});\t//在这里设置文件类型，告诉浏览器解析方式\n            // 根据后缀名判断文件类型不太准确 可以使用mime模块 mime.getType(filePath)\n            res.write(data);//将index.html显示在客户端\n            res.end();\n        }\n    });\n}).listen(8888);\n\nconsole.log('服务器开启成功');\n\n\n// // 手动设置content-type\n// http.createServer(function(req,res){\n// \tvar path = req.url;\t\n// \tconsole.log(\"path: \"+path)\n// \tif(path == \"/\"){\n// \t\tpath = \"/index.html\";\n// \t}\n// \tsendFile(res,path);\n// }).listen(8888)\n\n// function sendFile(res,path){\n//   var path = process.cwd()+'/dist'+path;\n// \tfs.readFile(path,function(err,stdout,stderr){\n// \t\tif(!err){\n// \t\t\tvar data = stdout;\n// \t\t\tvar type = path.substr(path.lastIndexOf(\".\")+1,path.length)\n// \t\t\tres.writeHead(200,{'Content-type':\"text/\"+type+';charset=\"utf-8\"'});\t//在这里设置文件类型，告诉浏览器解析方式\n// \t\t\tres.write(data);\n// \t\t}\n// \t\tres.end();\n//   })\n// }\n```\n\n### 解决方案二\n\n- 使用mime模块，npm install mime.\n- mime.getType(filePath)","tags":["NodeJS"],"categories":["Node"]},{"title":"switch的块级作用域","url":"%2F2019%2Fswitch%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F.html","content":"\nES6 或 TS 引入了块级作用域,通过let和const、class等可以定义块级作用域里的变量，块级作用域内的变量不存在变量提升，且存在`暂时性死区`(在代码块内，使用let或const声明变量前该变量都是不可改变的)。常见的if语句，for循环的循环体内都可以定义块级变量。那么switch语句中的块级作用域是什么呢？ 先给出结论：\n\n`switch语句中的块级作用域，在整个switch语句中，而不是对于每一个case生成一个独立的块级作用域。`\n\n---\n<!--more-->\n\n举个栗子🌰\n```javascript\nlet number = 1;\nswitch(number){\n  case 1:\n    let name = 'cosyer';\n  default:\n    console.log(name)\n}\n// cosyer\n```\n\n```javascript\nlet number = 1;\nswitch(number){\n  case 1:\n    let name = 'cosyer';\n    break;\n  case 2:\n    let name = 'yu';\n    break;\n  default:\n   console.log(name);\n}\n// Uncaught SyntaxError: Identifier 'name' has already been declared\n```\n\n## 可能存在的问题\n```javascript\nlet number = 1;\nswitch(number){\n    case 1 : name = 'cosyer'; break;\n}\n// name虽然没有声明，但是给name赋值相当于给全局的window对象复制，也就是window.name = 'cosyer'。\n```\n\n```javascript\nlet number = 2;\nswitch(number){\n  case 1:\n    let name = 'cosyer';\n    break;\n  case 2:\n    name = 'yu';\n    break;\n}\n// Uncaught ReferenceError: name is not defined\n```\n\n这里虽然case里面定义的块级虽然不会存在变量提升，但是会存在暂时性锁区,也就是说如果let name = 'cosyer' 没有执行，也就是name定义的过程没有执行，那么name在整个块级作用域内都是不可用的，都是undefined。\n\n所以尽量不要在case里定义块级变量。\n","tags":["深入理解"],"categories":["JS"]},{"title":"深入理解instanceof","url":"%2F2019%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3instanceof.html","content":"\n在JS中，大家通常用`typeof`来判断基本类型，`instanceof`来判断引用类型。\n\n## typeof\n> typeof一般只能返回如下几个结果：number,boolean,string,function,object,undefined字符串\n\n> 对于Array,null等特殊对象使用typeof一律返回object，而函数返回function这正是typeof的局限性。\n\n> 在判断除Object类型的对象(基本类型)时比较方便。\n\n\n## instanceof\n> object instanceof constructor\n\n> instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n\n> 换种说法就是左侧的对象是否是右侧对象的实例。\n\n## 相关练习\n```javascript\n'123' instanceof String // true\nlet str = new String('123')\nstr instanceof String // true\n```\n\n---\n<!--more-->\n\n```javascript\n// 都是Object的实例 true\nconsole.log({} instanceof Object)\nconsole.log([] instanceof Array)\nconsole.log([] instanceof Object)\nconsole.log(function() {} instanceof Function)\nconsole.log(function() {} instanceof Object)\n```\n\n```javascript\nfunction Foo(){} \nfunction BFoo(){} \nFoo.prototype = new BFoo();\nlet foo = new Foo();\nconsole.log(foo instanceof Foo); // true\nconsole.log(foo instanceof BFoo); // true  \n```\n\n```javascript\nconsole.log(String instanceof String); // flase\nconsole.log(String instanceof Object);\nconsole.log(String instanceof Function);\nconsole.log(Object instanceof Object); \nconsole.log(Function instanceof Function); \nconsole.log(Function instanceof Object);\n\nfunction Foo(){} \nfunction BFoo(){} \nFoo.prototype = new BFoo();\nconsole.log(Foo instanceof Function);\nconsole.log(Foo instanceof Foo);\n```\n\n## instanceof实现\n```javascript\nfunction instance_of(L, R) {//L 表示左边的object，R 表示右边的constructor\n const R_P = R.prototype;// 取 R 的显式原型\n L = L.__proto__;// 取 L 的隐式原型,并且可能会顺着原型链重新赋值\n while (true) { \n   if (L === null) \n     return false; \n   if (R_P === L)// 这里重点：严格比较 true \n     return true; \n   L = L.__proto__; \n } \n}\n```\n\n## 重点解析\n![原型链](https://user-images.githubusercontent.com/25027560/37870377-2bc8211a-3007-11e8-92a0-04fa96aabf13.png)\n\n- \\_\\_proto\\_\\_ 属性，指向了创建该对象的构造函数的原型\n\n- 所有JS对象都有 \\_\\_proto\\_\\_ 属性，除了Object.prototype.\\_\\_proto\\_\\_ === null\n\n- 注意Object(),它是由function生成的，所以它的__proto__属性指向了function的构造器Function的原型Function.prototype\n\n- 注意构造器Function,它是唯一一个prototype和__proto__指向相同的对象\n\n- 一般来说，我们日常自行创建的构造器Foo的__proto__属性指向function的构造器Function的原型Function.prototype，但是构造器的原型对象Foo.prototype的__proto__属性是直接指向Object.prototype对象的","tags":["深入理解"],"categories":["JS"]},{"title":"深入理解JS的继承","url":"%2F2019%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E7%9A%84%E7%BB%A7%E6%89%BF.html","content":"\n{% fi https://user-images.githubusercontent.com/25027560/38763933-ac0fdb2a-3fd8-11e8-8510-5e8a2444f49a.png, Summary, Summary %}\n\n---\n<!--more-->\n\n## 总览\n![c5925056-aa27-4b97-9f5d-2ec786ea5125](https://user-images.githubusercontent.com/25027560/38763933-ac0fdb2a-3fd8-11e8-8510-5e8a2444f49a.png)\n\n## 一、借助构造函数\n```js\nfunction Parent1() {\n  this.name = 'parent1'\n}\nfunction Child1() {\n  // 将父类的执行上下文指向子类，父类执行时的实例属性都会指向子类\n  Parent1.call(this);// apply\n  this.type = 'child1'\n}\n```\n\n#### 缺点\n子类没有继承父类的原型方法\n只继承了父类构造函数中的属性和方法\n\n```js\nParent1.prototype.method = (arg) =console.log(arg);\nconsole.log(new Child1().method); // undefined\n```\n\n## 二、借助原型链\n```js\nfunction Parent2() {\n  this.name = 'parent2';\n  this.arr = [1, 2, 3];\n  this.method = (arg) =console.log(arg)\n}\nfunction Child2() {\n  this.type = 'child2'\n}\nChild2.prototype = new Parent2();\n```\n\n原型图如下\n![f9311957-d401-4bc0-961b-65f3f49d65ea](https://user-images.githubusercontent.com/25027560/38763935-b449916e-3fd8-11e8-8b76-e12f58c20d27.png)\n\n#### 缺点\n引用类型的属性被所有实例共享，实例之间会互相影响\n\n```js\nlet c21 = new Child2();\nlet c22 = new Child2();\n\nc21.arr.push(4);\nconsole.log(c21.arr, c22.arr);\n// 注意，下面是直接给实例添加method属性\n// 只是修改了method指针，没有修改原型链上的method方法\n// 只有修改引用对象才是真正的修改\nc21.method = 'c21';\nconsole.log(Parent2);\nconsole.log(c21, c22);\n```\n\n![c79f3ffe-030d-4753-9f32-361a2dffb9d2](https://user-images.githubusercontent.com/25027560/38763937-bad54c58-3fd8-11e8-9248-1f6b2954daf9.png)\n\n## 三、组合（构造+原型链）\n```js\nfunction Parent3() {\n  this.name = 'parent3';\n  this.arr = [1, 2, 3]\n}\nfunction Child3() {\n  Parent3.call(this);\n  this.type = 'child3'\n}\nChild3.prototype = new Parent3();\n```\n\n#### 优点\n每个实例不会再互相影响\n\n#### 缺点\n实例化时，父类被构造了两次，这没有必要\ncall一次，new一次\n\n## 四、组合优化一\n```js\nfunction Parent4() {\n  this.name = 'parent4';\n  this.arr = [1, 2, 3]\n}\nfunction Child4() {\n  Parent4.call(this);\n  this.type = 'child4'\n}\nChild4.prototype = Parent4.prototype;\n```\n\n![3dcc9c3e-5e1d-45bc-bcb5-72aaea635cc2](https://user-images.githubusercontent.com/25027560/38763939-c318a5fe-3fd8-11e8-9581-9e04e57976a4.png)\n\n#### 缺点\n无法判断实例的构造函数是父类还是子类\n\n```js\nlet c41 = new Child4();\nlet c42 = new Child4();\nconsole.log(c41 instanceof Child4, c41 instanceof Parent4);\n// true true\n```\n\n但其实，构造函数就是父类本身\n\n```js\nconsole.log(c41.constructor); // Parent4\n```\n\n很难得才通过`Parent4.call(this)`改变了构造函数的指向，现在又改回去了？天……不想看下去了行不行，兄dei，坚持一会就是胜利，别打瞌睡\n\n`Child4.prototype = Parent4.prototype`只是把`Child4`的`prototype`属性指针指向了`Parent4.prototype`这个引用对象而已，实际上`Parent4.prototype.constructor = Parent4`\n![af779508-30f5-43ea-8af8-ff25a308ccf9](https://user-images.githubusercontent.com/25027560/38763942-cdc97b40-3fd8-11e8-8f45-c7bdb95f8f5f.png)\n\n## 五、组合优化二\n```js\nfunction Parent5() {\n  this.name = 'parent5';\n  this.arr = [1, 2, 3]\n}\nfunction Child5() {\n  Parent5.call(this);\n  this.type = 'child5'\n}\n// 组成原型链\nChild5.prototype = Object.create(Parent5.prototype);\n```\n\n但是，这时候，实例对象的`constructor`依然是`Parent5`\n\n![f611911f-9fc1-4ff8-8da6-eb7874eeb335](https://user-images.githubusercontent.com/25027560/38763943-d3d9703a-3fd8-11e8-92d4-d161a335c80c.png)\n\n所以需要重新指定实例对象的构造器\n\n```js\nChild5.prototype.constructor = Child5;\n```\n\n```js\nlet c51 = new Child5();\nlet c52 = new Parent5();\nconsole.log(c51 instanceof Child5, c51 instanceof Parent5);\nconsole.log(c52 instanceof Child5, c52 instanceof Parent5);\nconsole.log(c51.constructor, c52.constructor);\n// true true\n// false true\n// Child5 Parent5\n```\n\n## 相关链接\n[js创建对象实现继承](https://mydearest.cn/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF.html)","tags":["深入理解"],"categories":["JS"]},{"title":"深入理解JS的类型、值和类型转换","url":"%2F2019%2FECMAScript%202016%E3%80%812017%E3%80%812018%20%E6%96%B0%E7%89%B9%E6%80%A7%20.html","content":"\n![image](https://user-images.githubusercontent.com/25027560/38468332-c0336d1c-3b76-11e8-93b5-94f73acab1c6.png)\n\n---\n<!--more-->\n\n## 一、ECMAScript 2016\n### 1、Array.prototype.includes\n[Array.prototype.includes() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)\n\n```js\nconst arr = [1, 2, 3, NaN];\n\nif (arr.indexOf(3) >= 0) {\n  console.log(true)\n}\n// true\n\nif (arr.includes(3)) {\n  console.log(true)\n}\n// true\n\narr.indexOf(NaN)\n// -1  无法识别NaN\narr.includes(NaN);\n// true   可以识别NaN\n```\n\n### 2、指数（幂）运算符 **\n```js\nMath.pow(2, 3)\n// 8\n\n2 ** 3\n// 8\n```\n\n## 二、ECMAScript 2017\n### 1、Object.values()\n[Object.values() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values)\n\n```js\nconst obj = { foo: \"bar\", baz: 42 };\nconsole.log(Object.values(obj)); // ['bar', 42]\n```\n\n### 2、Object.entries()\n[Object.entries() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n\n```js\nconst obj = { foo: 'bar', baz: 42 };\nconsole.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n```\n\n### 3、字符串填充 String padding\n[String.prototype.padStart() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart)\n[String.prototype.padEnd() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd)\n\n```js\n'abc'.padStart(10);         // \"       abc\"\n'abc'.padStart(10, \"foo\");  // \"foofoofabc\"\n'abc'.padStart(6,\"123465\"); // \"123abc\"\n'abc'.padStart(8, \"0\");     // \"00000abc\"\n'abc'.padStart(1);          // \"abc\"\n\n'abc'.padEnd(10);          // \"abc       \"\n'abc'.padEnd(10, \"foo\");   // \"abcfoofoof\"\n'abc'.padEnd(6, \"123456\"); // \"abc123\"\n'abc'.padEnd(1);           // \"abc\"\n```\n\n注意，Emojis和双字节字符会占据两位\n\n```js\n'heart'.padStart(10, \"❤️\"); // '❤️❤️❤heart'\n```\n\n### 4、Object.getOwnPropertyDescriptors\n[Object.getOwnPropertyDescriptor() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)\n\n```js\nObject.getOwnPropertyDescriptor(obj, prop)\n```\n\n`Object.getOwnPropertyDescriptor() `方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n\n### 5、函数参数结尾逗号\n```js\nfunction fn(a, b,) {}\n// 注意，参数b后面多了个逗号，不会报语法错误\n```\n\n### 6、Async/Await\n[async function - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)\n\n## 三、ECMAScript 2018\n### 1、共享内存与原子操作\n\n即使有event loop的“伪多线程”和Service Worker的强力增援，但依然掩盖不了JS是单线程的事实。\n\n共享内存与原子操作，给JS带来了多线程的功能，允许开发人员自行管理内存来开发高性能高并发的程序。\n\n直到目前为止，我们只能通过`postMessage`在JS主线程和web worker之间通信，传输数据。\n\n### 2、非转义序列的模板字符串\n[非转义序列的模板字符串 | esnext | es6 es7 es2017 es2018 es2019](http://esnext.justjavac.com/proposal/template-literal-revision.html)\n\n### 3、对象展开运算符\n```js\nlet { firstName, age, ...rest } = {\n  firstName: 'a',\n  age: 18,\n  a: 1,\n  b: 2\n};\n\nfirstName; // 'a',\nage; // 18\nrest;\n// 重点看这里 { a: 1, b: 2 }\n```\n\n### 4、Promise.prototype.finally()\n\n### 5、异步迭代器\n提供了`for-await-of`，异步迭代，等待每个promise被resolve再执行下一个\n\n```js\nconst promises = [\n  new Promise(resolve =resolve(1)),\n  new Promise(resolve =resolve(2)),\n  new Promise(resolve =resolve(3))\n];\n```\n\n```js\n// old\nasync function test1() {\n  for (const obj of promises) {\n    console.log(obj);\n  }\n}\ntest1(); // \n// Promise {<resolved>: 1}\n// Promise {<resolved>: 2}\n// Promise {<resolved>: 3}\n```\n\n```js\n// new\nasync function test2() {\n  for await (const obj of promises) {\n    console.log(obj);\n  }\n}\ntest2();\n// 1, 2, 3\n```\n\n### 6、正则表达式相关\n\n* `dotAll` 模式，使 . 可以匹配任意字符\n* 命名捕获组，可以理解为增加一个引用\n\n```js\nconst regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\nconst matchers = regex.exec('2015-01-02');\nmatchers[0];    // 2015-01-02\nmatchers[1];    // 2015\nmatchers[2];    // 01\nmatchers[3];    // 02\n```\n\n* 反向断言 Lookbehind Assertions\n* Unicode转义 Unicode Property Escapes","tags":["深入理解"],"categories":["JS"]},{"title":"深入理解JS的类型、值和类型转换","url":"%2F2019%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html","content":"\n## 一、七种内置类型和常见引用类型\n![精简](https://user-images.githubusercontent.com/25027560/37508449-123fc606-292e-11e8-9cf8-9667338b9ac4.png)\n\n![复杂](https://user-images.githubusercontent.com/25027560/37508456-1c2c0648-292e-11e8-94d7-541f20942869.png)\n\n---\n<!--more-->\n \n## 二、特殊的`null`\n用`typeof`来检查上述七种类型时，返回的是对应的类型字符串值\n \n```js\ntypeof null === 'ogject' // true\n```\n \n`null`是唯一一个用`typeof`检测会返回`object`的**基本类型值**（注意‘基本’两字）\n \n不同的对象在底层都表示为二进制\n在JavaScript中二进制前三位为0的话都会被判断为object类型\nnull的二进制表示全是0，自然前三位也是0\n所以 typeof null === “object”\n \n## 三、引用类型的子类型：typeof [引用类型] === what ?\n上面的图中虽然列出了七种引用类型，但是\n`typeof ‘引用类型’ === ‘object’ `一定成立吗？\n \n不，还有一种情况：`typeof ‘某些引用类型’ === ‘function’`\n\n```js\ntypeof Function; // 'function'\ntypeof new Function(); // 'function'\ntypeof function() {}; // 'function'\n\ntypeof Array; // 'function'\ntypeof Array(); // 'object'\ntypeof new Array(); // 'object'\ntypeof []; // 'object'\n\ntypeof Boolean; // \"function\"\ntypeof Boolean(); // \"boolean\"\ntypeof new Boolean(); // \"object\"\n\ntypeof Math; // 'object'\ntypeof Math(); // Math is not a function\ntypeof new Math(); // Math is not a constructor\n```\n\n### 1、引用类型中的函数\n先看前三句，原来typeof除了能判断`基本类型`和`object`之外，还能判断`function`类型，函数也属于对象\n\n### 2、引用类型的子类型\n拿`Array`举例子\n\n```js\ntypeof Array; // 'function'\ntypeof Array(); // 'object'\ntypeof new Array(); // 'object'\ntypeof []; // 'object'\n```\n\n`Array`是个构造函数，所以直接打印出function\n但构造出来的`Array()`却又是另一回事了，构造出来的结果是个数组，自然属于引用类型，所以也就打印出了`‘object’`\n\n构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的\n\n### 3、引用类型中的基本包装类型\n```js\ntypeof Boolean; // \"function\"\ntypeof Boolean(); // \"boolean\"\ntypeof new Boolean(); // \"object\"\n```\n\n`Boolean`是个构造函数，第一句没问题\n`Boolean()`直接执行，得出了布尔值，所以得到了`‘boolean’`\n\n而new出来的是个Boolean对象，具体来说就是：`通过构造函数创建出来的是封装了基本类型值的封装对象`\n\n这里用`String`来举个例子吧，看到了吗，一个封装对象\n![封装对象](https://user-images.githubusercontent.com/25027560/37508489-350e6e80-292e-11e8-81f2-3124d28d219e.png)\n\n但是，不推荐使用这种封装对象，举个例子\n\n```js\nvar a = new Boolean(false);\nif (!a) {\n  console.log('Oops'); // false\n}\n```\n\na是个对象，对象永远是真。\n\n### 4、Math到底是什么？\nMath和Global（浏览器中替代为window）都是内置的对象，并不是引用类型的一种\n\n```js\ntypeof Math; // 'object'\ntypeof Math(); // Math is not a function\ntypeof new Math(); // Math is not a constructor\n```\n\n既不是函数，也不是构造器。\n\n## 四、typeof的安全防范机制\n首先，我们需要知道`underfined`和`undeclared`的区别\n未定义与未声明\n\n但是，对于typeof来说，这两者都一样，返回的都是underfined\n\n```js\nvar a;\ntypeof a; // 'underfined'\ntypeof b; // 'underfined'\n```\n\n很明显，我们知道b就是undeclared（未声明的），但在typeof看来都是一样\n\n这个特性，可以拿来做些什么呢？\n\n举个简单的例子，在程序中使用全局变量 DEBUG 作为“调试模式”的开关。在输出调试信 息到控制台之前，我们会检查 DEBUG 变量是否已被声明。顶层的全局变量声明 var DEBUG = true 只在 debug.js 文件中才有，而该文件只在开发和测试时才被加载到浏览器，在生产环 境中不予加载。\n\n问题是如何在程序中检查全局变量 DEBUG 才不会出现 ReferenceError 错误。这时 typeof 的 安全防范机制就成了我们的好帮手:\n\n```js\n// 这样会抛出错误\nif (DEBUG) {\n  console.log('Debugging is starting');\n}\n// 这样是安全的\nif (typeof DEBUG !== 'undefined') {\n  console.log('Debugging is starting');\n}\n```\n\n这不仅对用户定义的变量(比如 DEBUG)有用，对内建的 API 也有帮助:\n\n```js\nif (typeof atob === \"undefined\") {\n         atob = function() { /*..*/ };\n}\n```\n\n## 五、值\n这一part引用自[一、内存空间详解 · Sample GitBook](https://yangbo5207.github.io/wutongluo/ji-chu-jin-jie-xi-lie/yi-3001-nei-cun-kong-jian-xiang-jie.html)\n\nJS的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JS的基础类型都保存在变量对象中\n\n严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。\n\n但引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。\n\n在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。\n\n这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。\n\n![3719a7f3-3915-4719-93d8-7629fa5b47bb](https://user-images.githubusercontent.com/25027560/37508497-409cd7fa-292e-11e8-8bc4-a62effd0f3c8.png)\n\n\n而为什么基础数据类型存在栈中，而引用数据类型存在堆中呢?\n\n- 堆比栈大，栈比堆速度快。\n- 基础数据类型比较稳定，而且相对来说占用的内存小。\n- 引用数据类型大小是动态的，而且是无限的。\n- 堆内存是无序存储，可以根据引用直接获取。\n\n## 六、强制类型转换\n《you don’t know JS》中 第一部分第4章\n\n类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时(runtime)。\n\n然而在 JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”(implicit coercion)和“显式强制类型转换”(explicit coercion)来区分。\n\n### 1、抽象值操作\n介绍显式和隐式强制类型转换之前，我们需要先掌握字符串、数字和布尔值之间类型转换的基本规则\n\n1️⃣**ToString**\ntoString() 可以被显式调用，或者在需要字符串化时自动调用\n\nnull 转换为 \"null\"，undefined 转换为 \"undefined\"，true 转换为 \"true\"。\n数字的字符串化则遵循通用规则\n极小和极大的 数字使用指数形式:\n\n```js\n// 1.07 连续乘以七个 1000\nvar a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;\n// 七个1000一共21位数字 \na.toString(); // \"1.07e21\"\n```\n\n数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 \",\" 连接起 来\n\n```js\nvar a = [1,2,3];\n a.toString(); // \"1,2,3\"\n```\n\n2️⃣ **ToNumber**\n其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。\n处理失败 时返回 NaN(处理数字常量失败时会产生语法错误)\n\n3️⃣ **ToBoolean**\n先看什么是假值\n\n```\n• undefined\n• null\n• false\n• +0、-0 和 NaN\n• \"\"\n```\n假值的布尔强制类型转换结果为 false。\n从逻辑上说，假值列表以外的都应该是真值(truth)\n\n```js\nvar a = new Boolean(false);\nvar b = new Number(0);\nvar c = new String('');\n\nvar d1 = Boolean( a && b && c );\nvar d2 = a && b && c;\n```\n\n![63754230-e3da-4363-a04d-cccca7030a15](https://user-images.githubusercontent.com/25027560/37508500-49f02fd2-292e-11e8-929b-168ea4309baf.png)\n\n如果假值对象并非封装了假值的对象，那它究竟是什么?\n值得注意的是，虽然 JavaScript 代码中会出现假值对象，但它实际上并不属于 JavaScript 语言的范畴。\n浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来(exotic) 值，这些就是“假值对象”。\n假值对象看起来和普通对象并无二致(都有属性，等等)，但将它们强制类型转换为布尔 值时结果为 false。\n\n**真值就是假值列表之外的值**\n\n```js\nvar a = 'false';\nvar b = '0';\nvar c = \"''\";\nvar d1 = Boolean(a && b && c);\nvar d2 = a && b && c\n```\n\n![985c49a4-061f-42fe-978c-83f7724d8867](https://user-images.githubusercontent.com/25027560/37508506-4e686bd8-292e-11e8-881b-81d56ac71281.png)\n\n\n```js\nvar a = \"0\";\nvar b = [];\nvar c = {};\nvar d = \"\";\nvar e = 0;\nvar f = null;\nvar g;\nBoolean( a ); // true  特别注意这个，字符串0和空字符串不一样\nBoolean( b ); // true\nBoolean( c ); // true\nBoolean( d ); // false  和第一个比，空字符串是false\nBoolean( e ); // false\nBoolean( f ); // false\nBoolean( g ); // false\n```\n\n### 2、显式类型转换\n\n```js\n// 字符串转换\nvar a = 42;\nvar b = String(a);\n// 数字转换\nvar c = '3.14';\nvar d = Number(c);\n// 布尔值转换\nvar e = [];\nvar f = Boolean(e)\n```\n\n### 3、隐式强制类型转换\n1️⃣字符串和数字之间的隐式转换\n\n```js\nvar a = '42';\nvar b = '0';\nvar c = 42;\nvar d = 0;\na + b; // \"420\" 这个地方，注意一下\nc + d; // 42\n```\n\n```js\nconsole.log([] + {}); // [object object]\nconsole.log({} + []); // ?这会是多少呢？\n```\n\n《you don’t know JS 》中5.1.3章节是这样说的\n\n还有一个坑常被提到(涉及强制类型转换，参见第 4 章)\n[] + {}; // \"[object Object]\"\n{} + []; // 0\n表面上看 + 运算符根据第一个操作数([] 或 {})的不同会产生不同的结果，实则不然。 第一行代码中，{} 出现在 + 运算符表达式中，因此它被当作一个值(空对象)来处理。第\n4 章讲过 [] 会被强制类型转换为 \"\"，而 {} 会被强制类型转换为 \"[object Object]\"。\n但在第二行代码中，{} 被当作一个独立的空代码块(不执行任何操作)。代码块结尾不需 要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换(参见第 4 章) 为 0。\n\n但目前的chrome浏览器控制台是这样的\n![034d7fa4-b144-4028-a346-0a52a3ab7faa](https://user-images.githubusercontent.com/25027560/37508514-5698c8fc-292e-11e8-9220-52136c53d5c4.png)\n\n\n{} 其实应该当成一个代码块，而不是一个 Object，当你在console.log使用的时候，{} 被当成了一个 Object\n![8c597cc9-d2e2-4a51-ad8c-dd1a25ac27db](https://user-images.githubusercontent.com/25027560/37509112-ef5b653e-2930-11e8-8456-824fd66271da.png)\n\n2️⃣ 隐式强制类型转换为布尔值\n下面的情况会发生 布尔值隐式强制类型转换。\n\n* (1)if (..)语句中的条件判断表达式。\n* (2)for ( .. ; .. ; .. )语句中的条件判断表达式(第二个)。\n* (3) while (..) 和 do..while(..) 循环中的条件判断表达式。\n* (4)? :中的条件判断表达式。\n* (5) 逻辑运算符 ||(逻辑或)和 &&(逻辑与)左边的操作数(作为条件判断表达式)。\n\n3️⃣ || 与 &&\n就一句话，理解了就万岁，称之为“操作数选择器”\n\n```js\na || b;\n// 大致相当于(roughly equivalent to): a ? a : b;\na && b;\n// 大致相当于(roughly equivalent to): a ? b : a;\n```\n\n### 4、== 与 ===\n- 常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”\n- 正确的解释是:“== 允许在相等比较中进行强制类型转换，而 === 不允许。","tags":["深入理解"],"categories":["JS"]},{"title":"React Refs揭密","url":"%2FReact%20Refs%E5%92%8CDOM%E6%8F%AD%E5%AF%86.html","content":"\n## 什么是Ref\nReact的官方介绍是这样的：\n\nIn the typical React dataflow, props are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.\n\n其中提到了这几个概念：\n\n在典型的React数据流理念中，父组件跟子组件的交互都是通过传递属性(properties)实现的。如果父组件需要修改子组件，只需要将新的属性传递给子组件，由子组件来实现具体的绘制逻辑。\n \n在特殊的情况下，如果你需要命令式(imperatively)的修改子组件，React也提供了应急的处理办法--Ref。\n\nRef 既支持修改DOM元素，也支持修改自定义的组件。\n\n---\n<!-- more -->\n\n## 什么是声明式编程(Declarative Programming)\n值得一提的是当中声明式编程(Declarative Programming)和命令式编程(Imperative Programming)的区别。声明式编程的特点是只描述要实现的结果，而不关心如何一步一步实现的，而命令式编程则相反，必须每个步骤都写清楚。我们可以根据语义直观的理解代码的功能是：针对数组的每一个元素，将它的值打印出来。不必关心实现其的细节。而命令式编程必须将每行代码读懂，然后再整合起来理解总体实现的功能。\n\nReact有2个基石设计理念：一个是声明式编程，一个是函数式编程。函数式编程以后有机会再展开讲。声明式编程的特点体现在2方面：\n\n组件定义的时候，所有的实现逻辑都封装在组件的内部，通过state管理，对外只暴露属性。\n\n组件使用的时候，组件调用者通过传入不同属性的值来达到展现不同内容的效果。一切效果都是事先定义好的，至于效果是怎么实现的，组件调用者不需要关心。\n\n因此，在使用React的时候，一般很少需要用到Ref。那么，Ref的使用场景又是什么？\n\n## Ref使用场景\nReact官方文档是这么说的：\n\nThere are a few good use cases for refs: Managing focus, text selection, or media playback.Triggering imperative animations.Integrating with third-party DOM libraries. Avoid using refs for anything that can be done declaratively.\n\n简单理解就是，控制一些DOM原生的效果，如输入框的聚焦效果和选中效果等；触发一些命令式的动画；集成第三方的DOM库。最后还补了一句：如果要实现的功能可以通过声明式的方式实现，就不要借助Ref。\n\n通常我们会利用 render 方法得到一个 App 组件的实例，然后就可以对它做一些操作。但在组件内，JSX 是不会返回一个组件的实例的，它只是一个ReactElement，只是告诉你，React被挂载的组件应该什么样：\n\n```js\nconst myApp = <App />\n```\n\nrefs就是由此而生，它是React组件中非常特殊的props， 可以附加到任何一个组件上，从字面意思上看，refs即reference，组件被调用时会创建一个该组件的实例，而refd就会指向这个实例。\n\n## Ref用法\n如果作用在原生的DOM元素上，通过Ref获取的是DOM元素，可以直接操作DOM的API：\n\n```js\nclass CustomTextInput extends React.Component {  \n    constructor(props) {    \n        super(props);        \n         this.focusTextInput = this.focusTextInput.bind(this);  \n    } \n    focusTextInput() {    \n        if(this.myTextInput !== null) {         \n             this.textInput.current.focus();    \n        }  \n    }  \n    render() {    \n         return (      \n             <div>        \n                 <input type=\"text\" ref={(ref) => this.myTextInput = ref} />        \n                 <input type=\"button\" value=\"Focus the text input\" onClick={this.focusTextInput}/>      \n             </div>    \n \n         );  \n     } \n }\n ```\n \n 如果作用在自定义组件，Ref获取的是组件的实例，可以直接操作组件内的任意方法：\n \n ```js\n class AutoFocusTextInput extends React.Component {  \n    constructor(props) {    \n        super(props);    \n         this.textInput = React.createRef();  \n    }  \n    componentDidMount() {    \n        this.textInput.current.focusTextInput();  \n    }  \n    render() {    \n        return (      \n            <CustomTextInput ref={this.textInput} />    \n        );  \n    } \n}\n```\n \n## Ref总结\n为了防止内存泄漏，当卸载一个组件时，组件里所有的refs就会变成null。\n\n值得注意的是，`findDOMNode` 和 `refs` 都无法用于无状态组件中。因为，无状态组件挂载时只是方法调用，并没有创建实例。\n\n对于 React 组件来讲，refs 会指向一个组件类实例，所以可以调用该类定义的任何方法。如果需要访问该组件的真实 DOM ，可以用 ReactDOM 。 findDOMNode来找到 DOM 节点，但并不推荐这样做，因为这大部分情况下都打破了封装性，而且通常都能用更清晰的方法在React中构建代码。","tags":["react"],"categories":["JS"]},{"title":"flutter入门","url":"%2Fflutter%E5%85%A5%E9%97%A8.html","content":"\n## 什么是flutter\n> Flutter is Google’s mobile UI framework for crafting high-quality \n> native interfaces on iOS and Android in record time. Flutter works \n> with existing code, is used by developers and organizations around \n> the world,and is free and open source.\n\n## 环境安装\n\n### 下载SDK\nhttps://flutter.io/docs/development/tools/sdk/archive?tab=macos#macos\n或者\ngit clone -b beta https://github.com/flutter/flutter.git\n\n### 镜像\n添加环境变量 .bash_profile\n```bash\nexport ANDROID_HOME=~/Library/Android/sdk\nexport PATH=${PATH}:${ANDROID_HOME}/tools\nexport PATH=${PATH}:${ANDROID_HOME}/platform-tools\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\nexport PATH=/Users/chenyu/treasure/flutter/flutter/bin:$PATH\n```\n\n### 运行`flutter doctor`查看是否需要安装其它依赖项来完成安装：\n\n该命令检查您的环境并在终端窗口中显示报告。Dart SDK已经在捆绑在Flutter里了，没有必要单独安装Dart。 仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务（以粗体显示）\n\n## 创建项目\n1. 在AndroidStudio安装Dart插件。启动studio，搜索flutter，自动安装Dart插件，完成后重启studio。 \n\n2. Android Studio - File - New -New Flutter Project\n\n### 文件入口\n项目路径下的lib文件夹下的main.dart文件\n\n```java\nimport 'package:flutter/material.dart'; //导包\nvoid main() => runApp(new MyApp());\nclass MyApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialAp\n}\n```","tags":["flutter"],"categories":["JS"]},{"title":"如何用js实现JSON.parse()","url":"%2F%E5%A6%82%E4%BD%95%E7%94%A8js%E5%AE%9E%E7%8E%B0JSON.parse().html","content":"\n## eval\n```javascript\nvar json = '{\"a\":\"1\", \"b\":2}';\nvar obj = eval(\"(\" + json + \")\");  // obj 就是 json 反序列化之后得到的对象\n```\n> 为什么要加括号呢？\n因为js中{}通常是表示一个语句块，eval只会计算语句块内的值进行返回。加上括号就变成一个整体的表达式。\n\n```javascript\nconsole.log( eval('{}') );      // undefind\nconsole.log( eval('({})') );    // Object {}\n```\n\n> eval作用域问题\n```javascript\nvar s = 1;\nfunction a() {\n    eval('var s=2');\n    console.log(s);\n}\na();                // 2\nconsole.log(s);     // 1\n```\n在局部环境使用eval便会创建局部变量。可以显示指定eval调用者来改变上下文环境。\n\n```javascript\nvar s = 'global';\nfunction a() {\n    eval('var s = \"local\"');\n    console.log(s);                 // local\n    console.log(eval('s'));         // local\n    console.log(window.eval('s'));  // global\n}\n```\n\n### 对参数json进行校验防止xss漏洞\n```javascript\nvar rx_one = /^[\\],:{}\\s]*$/;\nvar rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n\nif (\n    rx_one.test(\n        json\n            .replace(rx_two, \"@\")\n            .replace(rx_three, \"]\")\n            .replace(rx_four, \"\")\n    )\n) {\n    var obj = eval(\"(\" +json + \")\");\n}\n```\n\n## 递归手动扫描每个字符\n\n## new Function 函数声明的传参形式\n```javascript\nvar add = new Function('a, b', 'return a+b;');\nconsole.log( add(2, 3) );    // 5\n```\n\n```javascript\nvar jsonStr = '{ \"age\": 20, \"name\": \"jack\" }',\n    json = (new Function('return ' + jsonStr))();\n```\n\n## 插入script\n> 模拟jsonP的方式拼接字符串然后以callBack的方式返回。","tags":["前端"],"categories":["JS"]},{"title":"Sass、Less和Stylus区别","url":"%2Fsass%E3%80%81less%E5%92%8Cstylus%E5%8C%BA%E5%88%AB.html","content":"\n在前端界，有三大 CSS 预处理器，分别是 SASS(SCSS), Less, Stylus。\n本文便总结下 Sass、Less CSS、Stylus这三个预处理器的区别和各自的基本语法。\n\n> 我永远喜欢Stylus :>\n\n## 什么是CSS预处理器\n\nCSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让CSS 更见简洁，适应性更强，代码更直观等诸多好处。\n\n## 基本语法比较\n\n### Sass和Less\n首先 Sass 和 Less 都使用的是标准的 CSS 语法，因此如果可以很方便的将已有的 CSS 代码转为预处理器代码，默认 Sass 使用 .scss 扩展名，而 Less 使用 .Less 扩展名。\n```css\n/* style.scss or style.Less */\nh1 {\n  color: #0982C1;\n}\n```\n另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 \"Sass\"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式。\n```css\n/* style.Sass */\nh1\n  color: #0982c1\n```\n\n而 Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名。可以随意地书写。\n```css\n/* style.styl */\nh1 {\n  color: #0982C1;\n}\n/* 省略花括号 */\nh1\n  color: #0982C1;\n/* 省略花括号和分号 */\nh1\n  color #0982C1\n```\n\n---\n<!--more-->\n\n### 变量声明\n1. Sass\n> Sass变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。\n2. Less\n>  Less变量都是用@开头的。\n3. Stylus\n>  Stylus对变量是没有任何约束，可以是以$开头，或者任何的字符，而且与变量之间可以用冒号，空格隔开。\n\n### 嵌套\n```css\nsection {\n  margin: 10px;\n  nav {\n    height: 25px;\n    a {\n      color: #0982C1;\n      &:hover {\n        text-decoration: underline;\n      }\n    }\n  }\n} \n/* 使用“&”符号来引用父选择器。 */\n```\n\n### 运算符\n```css\nbody {\n  margin: (14px/2);\n  top: 50px + 100px;\n  right: 80 * 10%;\n}\n```\n\n### 颜色函数\n- Sass\n```css\nlighten($color, 10%); /* 返回的颜色在$color基础上变亮10% */\ndarken($color, 10%);  /* 返回的颜色在$color基础上变暗10% */\nsaturate($color, 10%);   /* 返回的颜色在$color基础上饱和度增加10% */\ndesaturate($color, 10%); /* 返回的颜色在$color基础上饱和度减少10% */\ngrayscale($color);  /* 返回$color的灰度色*/\ncomplement($color); /* returns complement color of $color */\ninvert($color);     /* 返回$color的反相色 */\nmix($color1, $color2, 50%); /* mix $color1 with $color2 with a weight of 50% */ \n```\n\n- Less\n```css\nlighten(@color, 10%); /* 返回的颜色在@color基础上变亮10% */\ndarken(@color, 10%);  /* 返回的颜色在@color基础上变暗10%*/\nsaturate(@color, 10%);   /* 返回的颜色在@color基础上饱和度增加10% */\ndesaturate(@color, 10%); /* 返回的颜色在@color基础上饱和度降低10%*/\nspin(@color, 10);  /* 返回的颜色在@color基础上色调增加10 */\nspin(@color, -10); /* 返回的颜色在@color基础上色调减少10 */\nmix(@color1, @color2); /* 返回的颜色是@color1和@color2两者的混合色 */  \n```\n\n- Stylus\n```css\nlighten(color, 10%); /* 返回的颜色在'color'基础上变亮10% */\ndarken(color, 10%);  /* 返回的颜色在'color'基础上变暗10% */\nsaturate(color, 10%);   /* 返回的颜色在'color'基础上饱和度增加10% */\ndesaturate(color, 10%); /* 返回的颜色在'color'基础上饱和度降低10% */  \n```\n\n### css预处理器处理属性前缀\n```css\n @mixin border-radius($values) {\n  -webkit-border-radius: $values;\n     -moz-border-radius: $values;\n          border-radius: $values;\n}\ndiv {\n  @include border-radius(10px);\n} \n```\n\n### 导入 (Import)\n很多 CSS 开发者对导入的做法都不太感冒，因为它需要多次的 HTTP 请求。但是在 CSS 预处理器中的导入操作则不同，它只是在语义上包含了不同的文件，但最终结果是一个单一的 CSS 文件，如果你是通过 @ import “file.css”; 导入 CSS 文件，那效果跟普通的 CSS 导入一样。\n```css\n/* file.{type} */\nbody {\n  background: #EEE;\n}\n```\n\n```css\n@import \"reset.css\";\n@import \"file.{type}\";\np {\n  background: #0982C1;\n} \n```\n\n- 转译出的css\n```css\n@import \"reset.css\";\nbody {\n  background: #EEE;\n}\np {\n  background: #0982C1;\n}  \n```\n\n### 混合（Mixins）\nMixins是预处器中的函数。当某段CSS样式经常要用到多个元素中，这样就需要重复的写多次。Mixins是一个公认的选择器，还可以在Mixins中定义变量或者是默认参数。\n- Sass @mixin声明 @include调用\n```css\n@mixin error($borderWidth: 2px) {\n  border: $borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  @include error(); //这里调用默认 border: 2px solid #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  @include error(5px); //这里调用 border:5px solid #F00;\n}\n```\n\n- Less\n```css\n.error(@borderWidth: 2px) {\n  border: @borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  .error(); //这里调用默认 border: 2px solid #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  .error(5px); //这里调用 border:5px solid #F00;\n}\n```\n\n- Stylus 像函数一样\n```css\nerror(borderWidth= 2px) {\n  border: borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  error(); \n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  error(5px); \n}\n```\n\n- example Sass3d文本\n```css\n@mixin text3d($color) {\n  color: $color;\n  text-shadow: 1px 1px 0px darken($color, 5%),\n               2px 2px 0px darken($color, 10%),\n               3px 3px 0px darken($color, 15%),\n               4px 4px 0px darken($color, 20%),\n               4px 4px 2px #000;\n}\n\nh1 {\n  font-size: 32pt;\n  @include text3d(#0982c1);\n}\n```\n\n### 继承（Inheritance）\n在多个元素应用相同的样式时，我们在CSS通常都是这样写：\n```css\np,\nul,\nol {\n  /* 样式写在这 */\n} \n```\n\n- Sass和Stylus @extend\n```css\n.block {\n  margin: 10px 5px;\n  padding: 2px;\n}\np {\n  @extend .block; /* 继承.block所有样式 */\n  border: 1px solid #EEE;\n}\n```\n\n- Less\nLESS支持的继承和Sass与Stylus不一样,他不是在选择器上继承，而是将Mixins中的样式嵌套到每个选择器里面。这种方法的缺点就是在每个选择器中会有重复的样式产生。\n```css\n .block {\n  margin: 10px 5px;\n  padding: 2px;\n}\np {\n  .block; /* 继承 '.block'中的样式 */\n  border: 1px solid #EEE;\n}\n```\n\n### if语句\n- Sass\n```css\n.mixin (@color) when (lightness(@color) > 30%) {\n    background-color: black;\n}\n.mixin (@color) when (lightness(@color) =<; 30%) {\n    background-color: white;\n}\n```\n\n- Less\n```css\n@if lightness($color) > 30% {\n    background-color: black;\n}\n\n@else {\n    background-color: white;\n}\n```\n\n- Stylus\n```css\nif lightness(color) > 30%\n    background-color black\nelse\n    background-color white\n```\n### loop\n- Sass\n```css\n@for $i from 1px to 3px {\n    .border-#{i} {\n        border: $i solid blue;\n    }\n}\n```\n\n- Less\n```css\n.loop(@counter) when (@counter > 0){\n    .loop((@counter - 1));\n\n    .border-@{counter} {\n        border: 1px * @counter solid blue;\n    }\n}\n```\n\n- Stylus\n```css\nfor num in (1..3)\n    .border-{num}\n        border 1px * num solid blue\n```\n\n### 作用域\n- Sass\nSass中不存在什么全局变量.\n```css\n$color: black;\n.scoped {\n  $bg: blue;\n  $color: white;\n  color: $color; /*白色*/\n  background-color:$bg;\n}\n.unscoped {\n  color:$color;/*白色*/\n}\t\n```\n\n- Less\nLESS中的作用域和其他程序语言中的作用域非常的相同，他首先会查找局部定义的变量，如果没有找到，会像冒泡一样，一级一级往下查找，直到根为止。\n```css\n@color: black;\n.scoped {\n  @bg: blue;\n  @color: white;\n  color: @color; /*白色*/\n  background-color:@bg;\n}\n.unscoped {\n  color:@color; /*黑色*/\n}\n```\n\n- Stylus\nStylus虽然起步比较晚，但其作用域的特性和LESS一样，可以支持全局变量和局变量。会向上冒泡查找，直到根为止。\n\n## 总结\nLess 从语言特性的设计到功能的健壮程度和另外两者相比都有一些缺陷，但用 Less 可以满足大多数场景的需求。\n但相比另外两者，基于 Less 开发类库会复杂得多，实现的代码会比较脏，能实现的功能也会受到 DSL 的制约。\n比 Stylus 语义更清晰、比 Sass 更接近 CSS 语法，使得刚刚转用 CSS 预编译的开发者能够更平滑地进行切换。\nSass 在三者之中历史最久，也吸收了其他两者的一些优点。\n从功能上来说 Sass 大而全，语义明晰但是代码很容易显得累赘。\n主项目基于 Ruby 可能也是一部分人不选择它的理由（Less 开始也是基于 Ruby 开发，后来逐渐转到 Less.js 项目中）。\nSass 有一个「事实标准」库——Compass，于是对于很多开发者而言省去了选择类库的烦恼，对于提升开发效率也有不小的帮助。\nStylus 的语法非常灵活，很多语义都是根据上下文隐含的。\n基于 Stylus 可以写出非常简洁的代码，但对使用团队的开发素养要求也更高，更需要有良好的开发规范或约定。\n总的来说，三种预处理器百分之七八十的功能是类似的。Less 适合帮助团队更快地上手预处理代码的开发，而 Sass 和 Stylus 的差异更在于口味。","tags":["Stylus"],"categories":["CSS"]},{"title":"angular7详解","url":"%2Fangular7%E8%AF%A6%E8%A7%A3.html","content":"\n## 开始准备\n1. 安装nodejs\n```\nnpm -v\n```\n\n2. 安装@angular/cli\n```\nnpm i -g @angular/cli\n```\n\n3. CLI命令建立项目\n```\nng new ng7demo\n```\n选择是否加入路由模块以及哪种css预处理器\n\n> 可ctrl+c取消自动安装node_modules，手动进入项目npm install\n> node-sass安装不上可切换淘宝镜像库或者用cnpm安装\n1. npm config set registry https://registry.npm.taobao.org \n   npm install\n\nor \n\n2. npm install -g cnpm \n   cnpm install \n\n4. 启动项目\n```javascript\nng serve --open // 自动打开浏览器 http://localhost:4200/\n```\n---\n<!--more-->\n\n## 语法\n### 生成组件\n```\n// 标签app-article 如果不想要或者自定义前缀可在angular.json里修改prefix属性\nng g c article\n// 可添加目录\nng g s ./serveices/eventBus\n// \n```\n### 组件引用\n```\n// 标签方式引用\n<app-article></app-article>\n// 属性方式引用\n<div app-article></div>\n// 类方式引用\n<div class=\"app-article\"></div>\n```\n\n```\n// @Component装饰器标识这是一个组件\n@Component({\n  //selector: 'app-article',\n  //selector: '[app-article]', //属性方式\n    selector: '.app-article',//类方式\n  templateUrl: './article.component.html',\n  styleUrls: ['./article.component.css']\n})\n```\n\n### 插值表达式\n将业务逻辑中的数据通过插值表达式显示在模板文件，即html页面上，或者将html页面上的事件传输到业务逻辑。\n\n```\n<p>标题是{{title}}</p>\n```\n### 属性绑定\n```\n<img [src]=\"imgSrc\" />\n<input value=\"value\"\n```\n\n### 插值运算 加减乘除/字符串拼接/三元/方法调用\n```\n{{5+3}},{{5-3}},{{5*3}},{{5/3}},{{ \"a\" + \"b\"}},{{true?1:0}}\n```\n### 事件绑定\n```\n<button (click)=\"showModal('click')\"><button>\n// 传递事件参数\n<input type=\"text\" (keyup) = \"updateContent($event)\"/>\n// 双向绑定 视图和数据，只要一方发生变化，另一方跟着变化。\n// 不需要在代码中手动更新视图，简化开发，增加代码内聚性，代码可读性更强。\n<input type=\"text\" [(ngModel)]=\"title\"/>\n// 为了ngModel能够解析需要引入import {FormsModule} from \"@angular/forms\";\n```\n\n### 模板指令\n#### 判断指令\n```\n<img *ngIf=\"imgShow;else #p1\"/>\n<p #p1></p>\n```\n#### 样式指令\n```\n<p [ngClass]=\"{bg:true}\">这段内容应用的是类样式。</p>\n<p [ngStyle]=\"{backgroundColor:pink}\">本段内容样式是内联样式。</p>\n```\n#### 循环指令\n```\n<ul>\n    <li *ngFor=\"let race of raceList; let i = index\">\n    {{ race.name }}-{{ i + 1 }}\n    </li>\n</ul>\n```\n\n### 管道符\n```\n{{currentTime | date: \"yyyy-MM-dd HH:mm:ss\" }}\n```\n### 父子组件通信\n```\n// 输入\n<child title=\"我的子组件\"></child>\n@Input\npublic title:string =\"\"\n// 输出\n<child title=\"我的子组件\" #child (follow)=\"getFollow($event)\"></child>\n@Output()\npublic follow = new EventEmitter();\nthis.follow.emit(\"子组件传来的数据\");\n```\n### localsStorage\n\n### 服务总线\n1. 注册服务\n```\nng g s ./services/eventBus\nimport { Injectable } from \"@angular/core\";\nimport { Observable, Subject } from \"rxjs\";\n// 服务总线 组件间分享数据\n@Injectable({\n  providedIn: \"root\"\n})\nexport class EventBusService {\n  public eventBus: Subject<string> = new Subject();\n  constructor() {}\n}\n```\n\n2. 组件内发射数据\n```javascript\nthis.eventBusService.eventBus.next(\"child组件发送的数据\");\n```\n\n3. 组件接收数据\n```javascript\nthis.eventBusService.eventBus.subscribe(arg => {\n    console.log(`接收到事件${arg}`);\n});\n```\n\n### 标签变量引用\n```\n<child title=\"我的子组件\" #child (follow)=\"getFollow($event)\"></child>\n<button (click)=\"child.sayHello()\">子组件说话</button>\n```\n\n### 组件注册\n```\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n// import部分是模块以及装饰器的引入。\n// declarations部分是声明模块的内部成员。\n// imports部分是导入其它模块。\n// providers指定应用程序根级别需要使用的service。\n// bootstrap是app启动的根组件。\n// export控制将那些内部成员暴露给外部使用。\n```\n\n### 路由导航\n```\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { ChildComponent } from \"./child/child.component\";\nimport { BrotherComponent } from \"./brother/brother.component\";\n\nconst routes: Routes = [{\n  path: '',\n  component: ChildComponent\n},\n{\n  path: 'brother',\n  component: BrotherComponent\n}];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n``` \n\n```\n<!--RouterOutlet 相当于一个占位符,在Angular中根据路由状态动态插入视图。-->\n<a [routerLink]=\"['/']\">child</a><br/>\n<a [routerLink]=\"['/brother']\">brother</a>\n<router-outlet></router-outlet>\n```\n### http服务\n```\n// app.module.ts\nimport { HttpModule } from '@angular/http';\nimport { HttpClientModule } from '@angular/common/http';\n// services\nimport { Headers } from '@angular/http';\nimport { HttpClient, HttpResponse } from '@angular/common/http';\n\nthis.httpClient.request(UserService.METHOD_POST, url, options).subscribe((data)=>{});\n``` \n\n## ng7的新特性\n```\n// angular.json\n\"budgets\": [\n    {\n        \"type\": \"initial\",\n        \"maximumWarning\": \"2mb\",\n        \"maximumError\": \"5mb\"\n    }\n]\n// 这个配置适用于打包文件限制 ng build --prod \n// 打包生成生产环境时如果包大于2MB,那么CLI工具会提示waning,如果大于5MB,中断打包。\n```\n\n## npm i 和 npm install的小区别\n1、用npm i 安装的模块无法用npm uninstall卸载，需要用npm uninstall i命令\n\n2、npm i 会帮助检测与当前node版本最匹配的npm包 版本号，并匹配出来相互依赖的npm包应该提升的版本号\n\n3、部分npm包在当前node版本下无法使用，必须使用建议版本\n\n4、安装报错时intall肯定会出现npm-debug.log 文件，npm i不一定\n\n## npm install 的执行过程\n1. 发出npm install命令\n2. 查询 node_modules 目录之中是否已经存在指定模块\n3. 若存在，不再重新安装\n4. 若不存在npm 向 registry 查询模块压缩包的网址下载压缩包，存放在根目录下的.npm目录里\n5. 解压压缩包到当前项目的 node_modules 目录\n","tags":["angular"],"categories":["Ng"]},{"title":"大漠穷秋angular7讲座","url":"%2F%E5%A4%A7%E6%BC%A0%E7%A9%B7%E7%A7%8Bangular7%E8%AE%B2%E5%BA%A7.html","content":"h5 132合法标签\n大而全的angular\nemmm一上午要讲基础--还都是基本例子基本都见过\n\n### 编译器\n集成开发环境@angular/cli\n### 模板引擎\n\n## 组件库\n- datagrid\n- tree z-tree\n- datepicker\n- formvalid\nng2-admin \n比较接地气\n- JHipster\n- nicefish\n\n- 生成组件\n> ng g c User\n\n```javascript\nnpm install -g @angular/cli\n```\n--- \n<!--more-->\n\n我的看法(好用程度)\nstylus>less>sass\n\n* 人类的本质就是复读机\n* 学习本就是一个不断抄袭、模仿、联系、创新的过程。\n* 就这么个意思还是学习了语法绑定，自己说服自己。会语法基本就能做东西，深入才是重点。\n大佬自己都说angular慢0.0，基本都会涵盖demo的内容实现业务开发。\n\n##  第一天感受\n大佬上午讲了js的发展历史，下午讲了ng的基础语法、环境搭建等特性。比较基础的demo示例，比较低端，以前就做过。有点小失望。\n\n优化记录\n1. index.js 2.4M\n2. 七牛云的图片域名被回收了\n\n## qs.stringify和JSON.stringify\n```javascript\nvar a = {name:'hehe',age:10};\n qs.stringify(a)\n// 'name=hehe&age=10'\nJSON.stringify(a)\n// '{\"name\":\"hehe\",\"age\":10}'\n```\nwp php建站 主题模板 响应式插件 资讯门户站\n加载慢，angular这种大而全的框架很不错，但是我永远喜欢react.jpg😁","tags":["讲座"],"categories":["Ng"]},{"title":"css高度坍塌和判断横竖屏","url":"%2Fcss%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C%E5%92%8C%E5%88%A4%E6%96%AD%E6%A8%AA%E7%AB%96%E5%B1%8F.html","content":"\n{% centerquote %} \n 1.01^365=37.8\n{% endcenterquote %}\n\n两个盒子，一个下边距20px，一个上边距50px，最后为两个盒子之间的距离为多少 50px\n解决:根据W3C的标准，在页面中元素都一个隐含的属性叫做Block FormattingContext\n简称BFC，该属性可以设置打开或者关闭，默认是关闭的。\n\n---\n<!--more-->\n### css高度坍塌\n\nIFC（inline Formatting Contexts)--内联格式化上下文,IFC的高度由其包含行内元素中最高的实际高度计算而来的（不受竖直方向上的padding/margin影响）\n\nBFC--块级格式化上下文\n\n- 触发条件\n  - float不为none\n  - overflow不为visible\n  - display为table-cell，table-caption，inline-block\n  - position为absolute，fixed\n  - fieldset元素\n- 功能\n  - 自我独立，内部元素不会影响外部元素\n  - 会包含浮动元素\n  - 同一个BFC的margin重叠\n\n#### 当开启元素的BFC以后，元素将会具有如下的特性：\n- 属于同一个 BFC 的两个相邻 Box 垂直排列\n- 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n- BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外)\n- BFC 的区域不会与 float 的元素区域重叠\n- 计算 BFC 的高度时，浮动子元素也参与计算\n- 文字层不会被浮动层覆盖，环绕于周围\n\n#### 应用\n- 父元素高度塌陷\n- 阻止margin重叠\n- 可以包含浮动元素 —— 清除内部元素浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中)\n- 自适应两栏布局\n- 可以阻止元素被浮动元素覆盖\n\n#### 如何开启元素的BFC\n1. 设置元素浮动(不推荐)\n- 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题\n2. 设置元素绝对定位(不推荐)\n3. 设置元素为inline-block(不推荐)\n- 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式\n4. 将元素的overflow设置为一个非visible的值（aotu hidden）\n推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。\noverflow: hidden;\n\n但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。\n在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，该属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的：直接将元素的zoom设置为1即可。\n\n> zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍\n> zoom:1表示不放大元素，但是通过该样式可以开启hasLayout\n> zoom这个样式，只在IE中支持，其他浏览器都不支持。\n\n### 设备旋转监听\n- 事件\n```javascript\n// Listen for orientation changes\nwindow.addEventListener(\"orientationchange\", function() {\n    // Announce the new orientation number\n    alert(window.orientation);\n\n}, false);\n```\n\n- 媒体查询\n```html\n<!-- link元素中的CSS媒体查询 -->\n<link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" />\n```\n\n```css\n/* 样式表中的CSS媒体查询 */\n@media all and (orientation: portrait) {\n  body div {background: red;} \n\n}\n@media (min-width: 700px) and (orientation: landscape) { \n  body div {background: blue; } \n}\n```\n\n- resize方法\n可以用resize事件来判断。用innerWidth ， innerHeight，可以检索得到屏幕大小。依据宽和高的大小比较判断，宽小于高为竖屏，宽大与高就是横屏。\n```javascript\n(function(){\n    var updateOrientation = function(){\n        var orientation = (window.innerWidth > window.innerHeight) ? 'landscape' : 'portrait';\n    };\n\n    var init = function(){\n\n        updateOrientation();\n        \n        //监听resize事件\n        window.addEventListener('resize',updateOrientation,false);\n    };\n\n    window.addEventListener('DOMContentLoaded',init,false);\n})();\n```\n\n### 层叠上下文\n元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。\n\n- 触发条件\n  - 根层叠上下文(html)\n    - position\n    - css3属性\n    - flex\n    - transform\n    - opacity\n    - filter\n    - will-change\n    - -webkit-overflow-scrolling\n\n- 层叠等级：层叠上下文在z轴上的排序\n  - 在同一层叠上下文中，层叠等级才有意义\n  - z-index的优先级最高\n\n![z-index](http://cdn.mydearest.cn/blog/images/z-index.png)\n\n### 居中布局\n\n\n#### 水平居中\n\n行内元素: text-align: center\n块级元素: margin: 0 auto\nabsolute + transform\nflex + justify-content: center\n\n#### 垂直居中\n\nline-height: height\nabsolute + transform\nflex + align-items: center\ntable\n\n#### 水平垂直居中\n\nabsolute + transform\nflex + justify-content + align-items\n","tags":["布局"],"categories":["知识"]},{"title":"使用命令行激活windows10专业版","url":"%2F%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BF%80%E6%B4%BBwindows10%E4%B8%93%E4%B8%9A%E7%89%88.html","content":"\n以管理员的身份运行cmd\n\n1. 先卸载密钥\n```bash\nslmgr.vbs /upk\n```\n- 此时弹出窗口显未“已成功卸载了产品密钥”。\n\n2. 安装密钥\n```bash\nslmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX\n```\n- 弹出窗口提示：“成功的安装了产品密钥”。\n\n3. 设置计算机名\n```bash\nslmgr /skms cosyer的个人电脑\n```\n- 弹出窗口提示：“密钥管理服务计算机名成功的设置为cosyer的个人电脑”。\n\n---\n<!-- more -->\n\n4. 激活密钥\n```bash\nslmgr /ato\n```\n- 此时将弹出窗口提示：“成功的激活了产品”。\n\n如果第4步未能成功地激活，则重复执行第3步、第4步，且将第3步的语句修改为以下几个之一，需要一个一个进行尝试。\n\n```bash\n“slmgr /skms 110.noip.me”\n“slmgr /skms kms.lotro.cc”\n“slmgr /skms mhd.kmdns.net”\n“slmgr /skms xykz.f3322.org”\n“slmgr /skms 106.186.25.239”\n“slmgr /skms 3rss.vicp.net:20439”\n“slmgr /skms 45.78.3.223”\n“slmgr /skms kms.chinancce.com”\n“slmgr /skms kms.didichuxing.com”\n“slmgr /skms skms.ddns.net”\n“slmgr /skms franklv.ddns.net”\n“slmgr /skms 192.168.2.8”\n```","tags":["windows10激活"],"categories":["知识"]},{"title":"helloPHP","url":"%2FhelloPHP.html","content":"\n1年以前我就浅学过PHP，用`thinkPHP`框架开发起来确实比较轻松快捷流水化。最近闲来无事，再次回顾学习下这个世界上最好的语言。\n\n## 简介\nPHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\n\n## 语法\nPHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。\n\nPHP 脚本可以放在文档中的任何位置。\n\nPHP 脚本以 <?php 开始，以 ?> 结束。很多语言的语法都相类似。\n\n```php\n<!DOCTYPE html> \n<html> \n<body> \n<?php \necho \"Hello World!\";\n// 单行注释\n/*\n多行注释\n*/\n?> \n</body> \n</html>\n```\n\n---\n<!-- more -->\n\n### 变量\n- 变量以 $ 符号开始，后面跟着变量的名称\n\n- 变量名必须以字母或者下划线字符开始\n\n- 变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）\n\n- 变量名不能包含空格\n\n- 变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\n> 同js一样PHP也是弱类型脚本语言不需要声明变量的数据类型\n\n### 作用域\n1. local 局部\n2. global 全局\n3. static 静态\n4. parameter 参数\n\n```php\n<?php \n$x=5; // 全局变量 \n$z=5;\nfunction myTest() \n{ \n    $y=10; // 局部变量 \n    global $x,$z; // 函数内部访问全局变量需要加global关键字\n    $z=$x+$z;\n    // 一样的效果$GLOBALS['z']=$GLOBALS['x']+$GLOBALS['z'];\n}  \n\nmyTest(); \necho \"<p>测试函数外变量:<p>\"; \necho \"变量 x 为: $x\"; \necho \"<br>\"; \necho \"变量 y 为: $y\"; \necho $z; // 10\n?>\n```\n\n当一个函数完成时，它的所有变量通常都会被删除。所以当需要时可以声明静态变量\n\n```php\n<?php\nfunction myTest($y)\n{\n    static $x=0;\n    echo $x,$y; // 参数变量\n    $x++;\n}\n \nmyTest(1);\nmyTest(2);\nmyTest(3);\n?>\n```\n\n### 输出echo和print\necho 和 print 区别:\n- echo - 可以输出一个或多个字符串\n- print - 只允许输出一个字符串，返回值总为 1\n> echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。\n\n### 语句加分号\n\n### 数据类型\n1. String（字符串）\n\n```php\n<?php \n$txt1=\"Hello\"; \n$txt2=\"World\"; \necho $txt1 . \" \" . $txt2;  // \"Hello world\"\necho strlen(\"Hello World!\"); // 返回长度\necho strpos(\"Hello World!\",\"World\"); // 返回索引和js indexOf很像\n?>\n```\n\n2. Integer（整型）\n3. Float（浮点型）\n4. Boolean（布尔型）\n5. Array（数组）\n```php\n<?php\n$cars=array(\"Volvo\",\"BMW\",\"Toyota\");\necho count($cars);\n?>\n// 数组遍历\n<?php\n$cars=array(\"Volvo\",\"BMW\",\"Toyota\");\n$arrlength=count($cars);\n \nfor($x=0;$x<$arrlength;$x++)\n{\n    echo $cars[$x];\n    echo \"<br>\";\n}\n?>\n// 关联数组 object？\n<?php\n$age=array(\"Peter\"=>\"35\",\"Ben\"=>\"37\",\"Joe\"=>\"43\");\necho \"Peter is \" . $age['Peter'] . \" years old.\";\n?>\n// 遍历关联数组\n<?php\n$age=array(\"Peter\"=>\"35\",\"Ben\"=>\"37\",\"Joe\"=>\"43\");\n \nforeach($age as $x=>$x_value)\n{\n    echo \"Key=\" . $x . \", Value=\" . $x_value;\n    echo \"<br>\";\n}\n?>\n```\n数组排序函数\n- sort() - 对数组进行升序排列\n- rsort() - 对数组进行降序排列\n- asort() - 根据关联数组的值，对数组进行升序排列\n- ksort() - 根据关联数组的键，对数组进行升序排列\n- arsort() - 根据关联数组的值，对数组进行降序排列\n- krsort() - 根据关联数组的键，对数组进行降序排列\n\n6. Object（对象）\n使用class关键字声明类对象。类是可以包含属性和方法的结构。\n\n```php\n<?php\nclass Car\n{\n  var $color;\n  function __construct($color=\"green\") {\n    $this->color = $color;\n  }\n  function what_color() {\n    return $this->color;\n  }\n}\n?>\n```\n\n7. NULL（空值）\n> PHP var_dump() 函数返回变量的数据类型和值：\n### 常量的声明\ndefine()函数 \n> define(\"slogan\", \"hello\");\n该函数有三个参数:\n- name：必选参数，常量名称，即标志符。\n- value：必选参数，常量的值。\n- case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。\n\n### if...elseif....else 语句\n```php\n<?php\n$t=date(\"H\");\nif ($t<\"10\")\n{\n    echo \"Have a good morning!\";\n}\nelseif ($t<\"20\")\n{\n    echo \"Have a good day!\";\n}\nelse\n{\n    echo \"Have a good night!\";\n}\n?>\n```\n\n### 超级全局变量\n- $GLOBALS(超级全局变量组)\n- $_SERVER(包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组)\n- $_REQUEST(用于收集HTML表单提交的数据)\n- $_POST(用于收集HTML表单提交的数据,method设置为post)\n- $_GET(用于收集HTML表单提交的数据,method设置为get,也可以收集URL中发送的数据)\n- $_FILES\n- $_ENV\n- $_COOKIE\n- $_SESSION\n\n```php\n<?php\n$x=array(\"one\",\"two\",\"three\");\nforeach ($x as $value)\n{\n    echo $value . \"<br>\";\n}\n?>\n```\n\n### 魔术常量(预定义常量)\n- __LINE__(当前行号)\n- __FILE__(文件的完整路径和文件名)\n- __DIR__(文件所在目录)\n- __FUNCTION__(函数内部返回函数名)\n- __CLASS__(类内部返回类名)\n- __TRAIT__(Trait 名包括其被声明的作用区域)\n从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。\n其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。\n\n```php\n<?php\nclass Base {\n    public function sayHello() {\n        echo 'Hello ';\n    }\n}\n \ntrait SayWorld {\n    public function sayHello() {\n        parent::sayHello();\n        echo 'World!';\n    }\n}\n \nclass MyHelloWorld extends Base {\n    use SayWorld;\n}\n \n$o = new MyHelloWorld();\n$o->sayHello(); // Hello World\n?>\n```\n\n- __METHOD__(返回方法定义时的名称)\n- __NAMESPACE__(当前的命名空间名称)\n1. 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。\n2. 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。\n\n### php获取下拉菜单的数据\n```php\n<?php\n$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';\nif($q) {\n        if($q =='BAIDU') {\n                echo '百度<br>http://www.baidu.com';\n        } else if($q =='GOOGLE') {\n                echo 'Google 搜索<br>http://www.google.com';\n        } else if($q =='TAOBAO') {\n                echo '淘宝<br>http://www.taobao.com';\n        }\n} else {\n?>\n<form action=\"\" method=\"get\"> \n    <select name=\"q\">\n    <option value=\"\">选择一个站点:</option>\n    <option value=\"BAIDU\">Runoob</option>\n    <option value=\"GOOGLE\">Google</option>\n    <option value=\"TAOBAO\">Taobao</option>\n    </select>\n    <input type=\"submit\" value=\"提交\">\n    </form>\n<?php\n}\n?>\n```\n\n### 获取当前时间\n```php\n<?php\n//设置默认当前时区\ndate_default_timezone_set('PRC');\necho date('Y-m-d H:i:s',time());\n?>\n```\n\n### 文件引入\n> include 和 require 的区别\n- require 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件；\n- include 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。\n- require 引入的文件有错误时，执行会中断，并返回一个致命错误；\n- include 引入的文件有错误时，会继续执行，并返回一个警告。\n\n### 打开文件\n```php\n$file = fopen(\"test.txt\",\"r\");\n\n// 读取文件每一行，直到文件结尾\nwhile(!feof($file))\n{\n    echo fgets($file). \"<br>\";\n    //  逐个字符echo fgetc($file);\n}\n\nfclose($file);\n```\n\n### 文件上传\n```html\n<form action=\"upload_file.php\" method=\"post\" enctype=\"multipart/form-data\">\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n```\n\n```php\n<?php\nheader(\"Content-Type: text/html;charset=utf-8\");\n// 允许上传的图片后缀\n$allowedExts = array(\"gif\", \"jpeg\", \"jpg\", \"png\", \"PNG\");\n$temp = explode(\".\", $_FILES[\"file\"][\"name\"]);\necho $_FILES[\"file\"][\"size\"];\n$extension = end($temp);     // 获取文件后缀名\nif ((($_FILES[\"file\"][\"type\"] == \"image/gif\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/jpeg\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/jpg\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/pjpeg\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/x-png\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/png\"))\n&& ($_FILES[\"file\"][\"size\"] < 204800)   // 小于 200 kb\n&& in_array($extension, $allowedExts))\n{\n    if ($_FILES[\"file\"][\"error\"] > 0)\n    {\n        echo \"错误：: \" . $_FILES[\"file\"][\"error\"] . \"<br>\";\n    }\n    else\n    {\n        echo \"上传文件名: \" . $_FILES[\"file\"][\"name\"] . \"<br>\";\n        echo \"文件类型: \" . $_FILES[\"file\"][\"type\"] . \"<br>\";\n        echo \"文件大小: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" kB<br>\";\n        echo \"文件临时存储的位置: \" . $_FILES[\"file\"][\"tmp_name\"] . \"<br>\";\n        \n        // 判断当期目录下的 upload 目录是否存在该文件\n        // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777\n        if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"]))\n        {\n            echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在。 \";\n        }\n        else\n        {\n            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下\n            move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]);\n            echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"];\n        }\n    }\n}\nelse\n{\n    echo \"非法的文件格式\";\n}\n?>\n```\n\n### 设置cookie(必须写在html之前)\n```php\nsetcookie(\"user\", \"cosyer\", time()+3600); // 1小时后过期\necho $_COOKIE[\"user\"]; // (isset($_COOKIE[\"user\"])判断是否设置了cookie\n// 删除setcookie(\"user\", \"\", time()-3600);设置成过去的时点\n```\n\n### 存储session\n```php\nsession_start();\n// 存储 session 数据\n$_SESSION['views']=1;\n// 释放 session 数据\n// unset($_SESSION['views']);\n// 清空所有数据\n// session_destroy();\n```\n\n### php发送email\n```php\n<?php\nif (isset($_REQUEST['email'])) { // 如果接收到邮箱参数则发送邮件\n    // 发送邮件\n    $email = $_REQUEST['email'] ;\n    $subject = $_REQUEST['subject'] ;\n    $message = $_REQUEST['message'] ;\n    mail(\"someone@example.com\", $subject,\n    $message, \"From:\" . $email);\n    echo \"邮件发送成功\";\n} else { // 如果没有邮箱参数则显示表单\n    echo \"<form method='post' action='mailform.php'>\n    Email: <input name='email' type='text'><br>\n    Subject: <input name='subject' type='text'><br>\n    Message:<br>\n    <textarea name='message' rows='15' cols='40'>\n    </textarea><br>\n    <input type='submit'>\n    </form>\";\n}\n?>\n```\n\n### 错误处理\n> die(\"文件不存在\");\n### 异常处理 同 try catch new Exception()","tags":["PHP"],"categories":["PHP"]},{"title":"chrome插件扩展程序开发指南","url":"%2Fchrome%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.html","content":"\n### 什么是chrome extensions\nChrome Extensions，中文名叫 “Chrome浏览器扩展程序”。引用官方文档的描述，翻译一下就是 “可以修改和增强浏览器功能的 H5 小程序”。\n它的入口在浏览器窗口的右上角，地址栏的最右边\n\n---\n<!-- more -->\n\n### 入门\n#### manifest.json\nmanifest.json 是整个插件扩展程序中最重要的一个描述文件，这个 json 格式的文件包含了你整个扩展程序的一些重要描述，比如 “扩展程序名称”、“扩展程序图标”、“权限申请” 等。\n\n```json\n{\n  // Required\n  \"manifest_version\": 2, // manifest 版本号，这里都写 2 就好了，从 Google Chrome 18 开始，就开始升级到 2 版本了\n  \"name\": \"My Extension\",\n  \"version\": \"1.0.0\", // 扩展程序版本，这个是自定义的，建议参考 semver 规范(http://semver.org/)\n\n  // Recommended\n  \"default_locale\": \"zh\", // 默认语言，具体可以看 i18n 文档(https://developer.chrome.com/extensions/i18n)\n  \"description\": \"A plain text description\", // 项目描述\n  \"icons\": { // icon，不同的位置支持不同大小的 icon，具体看文档(https://developer.chrome.com/extensions/manifest/icons)\n    \"128\": \"icons/icon_128.png\",\n    \"48\": \"icons/icon_48.png\",\n    \"16\": \"icons/icon_16.png\"\n  },\n\n  // Pick one (or none)\n  \"browser_action\": { // 多数都是使用这个，插件扩展程序针对的是浏览器行为（图标是在地址栏外面）\n    \"default_icon\": \"icons/24.png\", // 最佳大小为19*19，地址栏上的插件扩展程序的 icon（一般作为主入口）\n    \"default_popup\": \"popup.html\", // 点击插件扩展程序 icon 后弹出来的窗口的主页面 html\n    \"default_title\": \"extentsions demo\" // 当鼠标放到扩展程序图标上时显示的文字\n  },\n  \"page_action\": { // 插件扩展程序针对的是页面行为（图标是在地址栏里面的）\n    ...\n  },\n\n  // Optional\n  \"author\": ...,\n  \"automation\": ...,\n  \"background\": {\n    // Recommended\n    \"persistent\": false\n  },\n  \"background\": {\n    \"scripts\": [\"eventPage.js\"],\n    \"persistent\": false\n  },\n  \"chrome_settings_overrides\": {...},\n  \"chrome_ui_overrides\": {\n    \"bookmarks_ui\": {\n      \"remove_bookmark_shortcut\": true,\n      \"remove_button\": true\n    }\n  },\n  \"chrome_url_overrides\": {...},\n  \"commands\": {...},\n  \"content_capabilities\": ...,\n  \"content_scripts\": [{...}],\n  \"content_security_policy\": \"policyString\",\n  \"converted_from_user_script\": ...,\n  \"current_locale\": ...,\n  \"declarative_net_request\": ...,\n  \"devtools_page\": \"devtools.html\",\n  \"event_rules\": [{...}],\n  \"externally_connectable\": {\n    \"matches\": [\"*://*.example.com/*\"]\n  },\n  \"file_browser_handlers\": [...],\n  \"file_system_provider_capabilities\": {\n    \"configurable\": true,\n    \"multiple_mounts\": true,\n    \"source\": \"network\"\n  },\n  \"homepage_url\": \"http://path/to/homepage\",\n  \"import\": [{\"id\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"}],\n  \"incognito\": \"spanning, split, or not_allowed\",\n  \"input_components\": ...,\n  \"key\": \"publicKey\",\n  \"minimum_chrome_version\": \"versionString\",\n  \"nacl_modules\": [...],\n  \"oauth2\": ...,\n  \"offline_enabled\": true,\n  \"omnibox\": {\n    \"keyword\": \"aString\"\n  },\n  \"optional_permissions\": [\"tabs\"],\n  \"options_page\": \"options.html\",\n  \"options_ui\": {\n    \"chrome_style\": true,\n    \"page\": \"options.html\"\n  },\n  \"permissions\": [\"tabs\"],\n  \"platforms\": ...,\n  \"plugins\": [...],\n  \"requirements\": {...},\n  \"sandbox\": [...],\n  \"short_name\": \"Short Name\",\n  \"signature\": ...,\n  \"spellcheck\": ...,\n  \"storage\": {\n    \"managed_schema\": \"schema.json\"\n  },\n  \"system_indicator\": ...,\n  \"tts_engine\": {...},\n  \"update_url\": \"http://path/to/updateInfo.xml\",\n  \"version_name\": \"aString\",\n  \"web_accessible_resources\": [...]\n}\n```\n\n#### 学做一个demo\n1. manifestjson(该文本文件需要用UTF8字符集保存)\n```json\n{\n  \"name\": \"第一个Chrome插件\",\n  \"manifest_version\": 2,\n  \"version\": \"1.0\",\n  \"description\": \"我的第一个Chrome插件，还不错吧\",\n  \"browser_action\": {\n    \"default_icon\": \"1.png\"\n  },\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://www.baidu.com/\"],\n      \"js\": [\"test.js\"]\n    }\n  ]\n}\n```\n\n2. test.js\n```javascript\nalert(\"Hello World\");\ndocument.body.style.backgroundColor=\"gray\";\n```\ncontent_scripts是运行在打开页面的脚本，可以拿到整个页面的DOM对象，所以可以利用该脚本对页面进行操作。\n\n3. 添加图片1.png\n\n4. 打开chrome，打开菜单，找到扩展程序选项更多工具>扩展程序路径下。点击加载已解压的扩展程序，添加文件夹就OK啦！\n\n\n### 常用api \n- bookmarks: 书签管理接口，可以对浏览器的书签进行增删改查等管理\n- tabs: 标签管理接口，可以对浏览器的标签进行增删改查等管理\n- contextMenus: 右键菜单管理\n- cookies: 浏览器 cookie 的管理\n- notifications: 消息通知\n- desktopCapture: 可针对 “窗口” 或者 ”标签“ 的截图接口\n- i18n: 国际化（多语言支持）\n\n### 程序发布和分享\n打包扩展程序，第一次打包只需要设置根目录，打包完成后会生成.crx和.pem密钥文件(版本的迭代需要此文件，否则则会生成新的程序文件)，将.crx文件发给其他人拖入扩展程序页面即可安装。\n\n### 发布到chrome商店\n当一切准备就绪，就可以准备发布上线了，Chrome 有个官方的插件扩展程序市场，还自带了发布和更新等一体化管理的流程，非常方便。\n传送门：[Chrome商店dashboard](https://chrome.google.com/webstore/developer/dashboard)\n\n注意，上传的是 zip 而不是生成的 crx 文件，具体参考：[https://developer.chrome.com/webstore/publish](https://developer.chrome.com/webstore/publish)\n\n### 常见问题\n1. 引入外部 js 时报 Refused to load the script 的问题\n```javascript\n<script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"></script>\n```\n解决方案：修改 content_security_policy，把对应的域名加上去即可，比如以上的问题可以解决：\n\n```json\n{\n    \"content_security_policy\": \"https://code.jquery.com\"\n}\n```\n> 以上表示允许 https://code.jquery.com 域名下的外部 js 的引入。\n2. Chrome 插件扩展程序是开源的方式安装的，可以去安装目录通过扩展程序 ID 来找到源码。\n正常情况下，Chrome 插件扩展程序的默认安装目录如下：\n\n- Windows XP：C:\\Documents and Settings\\用户名\\Local Settings\\Application Data\\Google\\Chrome\\User Data\\Default\\Extensions\n- Windows7：C:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions\n- Mac：~/Library/Application Support/Google/Chrome/Default/Extensions\n- Ubuntu：~/.config/google-chrome/Default/Extensions\n如果在这些不同操作系统中的默认安装位置没找到插件，那么还有一种方法可以查询到。\n\n地址栏访问 chrome:version\n找到 “个人资料路径”，该路径下的 extensions 文件夹就是 Chrome 插件扩展程序的安装路径了\n安装路径下的插件扩展程序，是以 ID 为目录区分的\n地址栏访问 chrome://extensions/，可以查看每个插件扩展程序的 ID\n\n### 高级教程-chrome插件合集\n[项目地址](https://github.com/cosyer/chrome-extensions)\n\n### 参考资料\n[官方文档](https://developer.chrome.com/extensions/overview)","tags":["整理"],"categories":["知识"]},{"title":"webapck4零配置了解一下","url":"%2Fwebpack4%E9%9B%B6%E9%85%8D%E7%BD%AE%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B.html","content":"\nwebpack4 最主要的卖点便是零配置，要想成为一位webpack配置工程师怎么能不开始了解呢？话不多说，让我们开始体验 webpack 4 的一些特性。\n\n### entry 和 output\n1. 创建空目录，初始化配置\n```bash\nmkdir webpack4-quickstart\ncd  webpack4-quickstart\nnpm init -xyz\n```\n\n2. 安装相关依赖\n```bash\nnpm i webpack --save-dev\nnpm i webpack-cli --save-dev\n```\n\n- webpack： 即 webpack 核心库。它提供了很多 API, 通过 Node.js 脚本中 require('webpack') 的方式来使用 webpack。\n- webpack-cli：是 webpack 的命令行工具。webpack 4 之前命令行工具是集成在 webpack 包中的，4.0 开始 webpack 包本身不再集成 cli。\n\n3. package.json添加构建命令\n```javascript\n\"scripts\":{\n    \"build\":\"webpack\"\n}\n```\n---\n<!-- more -->\n\n- 如果直接开始运行`npm run build`会因为缺少指定的默认目录的文件导致抛出错误\n- 添加入口文件 \n```javascript\n// ./src/index.js\nconsole.log(\"hello world\")\n```\n- 再执行`npm run build`，则默认生成了'./dist/main.js'文件\n\n### development和production模式\n在webpack 4 以前，拥有2份配置文件是webpack项目常见的情况，一个常规的项目配置可能是这样的：\n\n> 一份开发环境的配置，用来配置 dev server 和其他的一些东西\n> 一份生产环境的配置，配置一些 UglifyJSPlugin、sourcemaps 等等\n但是在webpack 4中，我们可以通过设置命令行参数production和development来区分环境：\n\n```json\n\"scripts\": {\n  \"dev\": \"webpack --mode development\",\n  \"build\": \"webpack --mode production\"\n}\n```\n\n分别执行`npm run dev`和`npm run build`会发现第二种执行的代码被压缩了。\n\n> Development mode 则是在速度上进行了优化，只不过不会提供压缩功能。\n> Production mode 可以实现各种优化，包括 代码压缩、tree-shaking...\n\n### 脚本中覆盖默认的入口和出口\n```json\n\"scripts\": {\n  \"dev\": \"webpack --mode development ./entry/index.js --output ./output/main.js\",\n  \"build\": \"webpack --mode production ./entry/index.js --output ./output/main.js\"\n}\n```\n\n### babel插件配置es6->es5\n\n1. 插件依赖\n> babel-core\n> babel-loader\n> babel-preset-env 编译 ES6 -> ES5 \n```javascript\nnpm i babel-core babel-loader babel-preset-env --save-dev\n```\n\n2. 通过`./babelrc`来配置相关插件\n```json\n{\n    \"presets\":[\n        \"env\"\n    ]\n}\n```\n\n3. 2种方式来配置`babel-loader`\n> webpack.config.js配置\n```javascript\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\"\n        }\n      }\n    ]\n  }\n};\n```\n> 脚本命令配置 --module-bind\n```json\n\"scripts\": {\n    \"dev\": \"webpack --mode development --module-bind js=babel-loader\",\n    \"build\": \"webpack --mode production --module-bind js=babel-loader\"\n  }\n```\n\n### 最小化js文件\n> config.optimization.minimize(true)\n\n### 图片资源压缩\n```js\nconfig.module\n  .rule('images')\n  .use('image-webpack-loader')\n  .loader('image-webpack-loader')\n  .options({\n    bypassOnDebug: true\n  })\n  .end()\n```\n\n这里只是简单的介绍，想要详细的了解webpack4的新特性请访问[github地址](https://github.com/cosyer/webpack4)。\n","tags":["整理"],"categories":["知识"]},{"title":"实现前端路由","url":"%2F%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.html","content":"\n现代的前端框架react/vue/angular都有路由router的概念，通过手写实现可以帮助我们更好地了解它的工作原理。它们都推荐单页面应用 SPA 开发模式，在路由切换时替换 DOM Tree 中最小修改的部分 DOM，来减少原先因为多页应用的页面跳转带来的巨量性能损耗。它们都有自己的典型路由解决方案，@angular/router、react-router、vue-router等。\n\n一般来说，这些路由插件总是提供两种不同方式的路由方式： Hash 和 History，有时也会提供非浏览器环境下的路由方式 Abstract(支持所有 JavaScript 运行\n环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式)。\n\n### 实现路由的2种方式\n1. hash模式 状态保存需要另行传递\n2. history模式 原生提供了自定义状态传递的能力\n\n### 缺点\nhash: 地址栏会多出一个#号，对url造成影响，在某些场景下如微信支付有坑。\nhistory: 兼容性差，直接访问报404，需要服务器做处理。\n\n### 基本原理\n- hash 主要原理是通过监听 # 后的 URL 路径标识符的更改而触发的浏览器 hashchange 事件(当 location.hash 发生改变时，将触发这个事件)\n\n> 注意： Hash 方法是利用了相当于页面锚点的功能，所以与原来的通过锚点定位来进行页面滚动定位的方式冲突，导致定位到错误的路由路径，因此需要采用别的办法。\n\n- history 则基于 pushState 和 popState replaceState\n\nHash 模式是使用 URL 的 Hash 来模拟一个完整的 URL，因此当 URL 改变的时候页面并不会重载。History 模式则会直接改变 URL，所以在路由跳转的时候会丢失一些地址信息(只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求)，在刷新或直接访问路由地址的时候会匹配不到静态资源。因此需要在服务器上配置一些信息，让服务器增加一个覆盖所有情况的候选资源。\n\n> history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 \n404 错误。\n\n---\n<!--more-->\n\n- 服务器配置\n1. Nginx方式\n采用Nginx方案需要先将所有资源打包生成到对应的目录，比如dist，然后做如下配置：\n```js\nserver {\n\tserver_name react.thinktxt.com;\n\tlisten 80;\n\n\troot /Users/txBoy/WEB-Project/React-Demo/dist;\n\tindex index.html;\n\tlocation / {\n    // $uri 是 nginx 的变量，就是当前这次请求的路径\n    // try_files 会尝试在这个路径下寻找资源，如果找不到，会继续朝下一个寻找\n    // $uri/ 的意思是在路径目录下寻找 index.html 或 index.htm\n    // 最后都找不到的话，返回 index.html\n    \ttry_files $uri $uri/ /index.html;\n  }\n}\n```\n\n2. 通过修改webpack-dev-server运行方式\n这个解决方法很简单，直接在运行时加入参数“–history-api-fallback”就可以了\n\n3. Node服务端配置\n\n```js\n// express\n//配置任何请求都转到index.html，而index.html会根据React-Router规则去匹配任何一个route\napp.get('*', function (request, response){\n  response.sendFile(path.resolve(__dirname, 'dist', 'index.html'))\n})\n\n// koa\nimport xtpl from 'koa-xtpl';\napp.use(xtpl({\n\troot: path.resolve(__dirname, '../dist'),\n\textname: 'html',\n\tcommands: {}\n}));\n```\n由于koa的这种方式端口与webpack-dev-server（8080）必须不同，所以还需要配合Nginx代理。例如：\n```js\nserver {\n\tserver_name react.thinktxt.com;\n\tlisten 80;\n\n\tlocation / {\n\t\tproxy_pass http://localhost:8081;\n\t}\n}\n\nserver {\n\tserver_name static.react.thinktxt.com;\n\tlisten 80;\n\n\tlocation / {\n\t\tproxy_pass http://localhost:8080;\n\t}\n}\n```\n\n既然我们的Nginx代理用了真实域名，自然别忘了修改一下host，如下：\n```js\n127.0.0.1 react.thinktxt.com\n127.0.0.1 static.react.thinktxt.com\n```\n\n### hash模式\n```javascript\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n  <style>\n    body {\n      margin: 0;\n      padding: 0;\n    }\n\n    #login, #index {\n      width: 100%;\n      height: 100%;\n      display: none;\n    }\n\n    #login {\n      background: #f5f5f5;\n      display: block;\n    }\n\n    #index {\n      background: #aaddff;\n    }\n  </style>\n</head>\n<body>\n\n<!--登录页-->\n<div id=\"login\" class=\"component\">\n  <input type=\"button\" onclick=\"hashPush('index?id=1')\" value=\"登陆\">\n</div>\n\n<!--首页-->\n<div id=\"index\" class=\"component\">\n  <input type=\"button\" onclick=\"hashPush('login?key=2',{data:'params data'})\" value=\"退出登陆\">\n</div>\n\n</body>\n<script>\n  // 全局变量\n  var params = {}\n\n  // 页面跳转\n  function hashPush(url, param) {\n    location.hash = \"#\" + url\n\n    // 解析url\n    let questionIndex = url.indexOf(\"?\")\n    let path = url\n    if (questionIndex >= 0) {\n      path = url.substr(0, questionIndex)\n    }\n\n    if (param) {\n      // path路由作为key标识内容传参 存储路由\n      params[path] = param \n    }\n  }\n\n  // 监听hash的变动\n  window.addEventListener('hashchange', function (e) {\n    // let newURL = event.newURL; // hash 改变后的新 url\n    // let oldURL = event.oldURL; // hash 改变前的旧 url\n    let url = location.hash.slice(1) || \"index\"\n    // 解析url\n    let questionIndex = url.indexOf(\"?\")\n    let path, query\n    if (questionIndex >= 0) {\n      // 获取当前变化的路由名\n      path = url.substr(0, questionIndex)\n      // 获取url上的传参\n      let queryString = url.substr(questionIndex + 1)\n      let queryArray = queryString.split(\"&\")\n      let queryObject = {}\n      queryArray.map(str => {\n        let equalIndex = str.indexOf(\"=\")\n        if (equalIndex > 0) {\n          let key = str.substr(0, equalIndex)\n          let value = str.substr(equalIndex + 1)\n          queryObject[key] = value\n        }\n      })\n      query = queryObject\n    } else {\n      path = url\n      query = {}\n    }\n\n    console.log('接收到url传递的参数', query)\n    console.log('直接用params传递的参数', params[path])\n    setVisible(path)\n  })\n\n  // 显示跟路由地址对应的内容，隐藏其他内容\n  function setVisible(url) {\n    let components = Array.from(document.body.querySelectorAll(\".component\"))\n    components.map(item => {\n      if (item.id === url) {\n        // console.log('显示',item.id)\n        item.style.display = 'block'\n      } else {\n        // console.log('隐藏',item.id)\n        item.style.display = 'none'\n      }\n    })\n  }\n</script>\n</html>\n```\n\n### history模式(需要服务器环境)\n```javascript\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n  <style>\n    body {\n      margin: 0;\n      padding: 0;\n    }\n\n    #login, #index {\n      width: 100%;\n      height: 100%;\n      display: none;\n    }\n\n    #login {\n      background: #f5f5f5;\n      display: block;\n    }\n\n    #index {\n      background: #aaddff;\n    }\n  </style>\n</head>\n<body>\n\n<!--登录页-->\n<div id=\"login\" class=\"component\">\n  <input type=\"button\" onclick=\"historyPush('index')\" value=\"登陆\">\n</div>\n\n<!--首页-->\n<div id=\"index\" class=\"component\">\n  <input type=\"button\" onclick=\"historyPush('login',{data:'params data'})\" value=\"退出登陆\">\n</div>\n\n</body>\n<script>\n  // 全局变量\n  var params = {}\n\n  // 页面跳转\n  function historyPush(url, param) {\n    history.pushState(param, '我是页面标题', url)\n    if (param) {\n      params[url] = param\n    }\n  }\n\n  // 监听前进后退\n  window.addEventListener('popstate', function (e) {\n    // e.state 就是pushState 的时候，传的第一个参数\n    let url = state.target.location.pathName\n    console.log('接收到传递的参数', e.state)\n    console.log('直接用params传递的参数', params[path])\n    setVisible(path)\n  })\n\n  // 显示跟路由地址对应的内容，隐藏其他内容\n  function setVisible(url) {\n    let components = Array.from(document.body.querySelectorAll(\".component\"))\n    components.map(item => {\n      if (item.id === url) {\n        // console.log('显示',item.id)\n        item.style.display = 'block'\n      } else {\n        // console.log('隐藏',item.id)\n        item.style.display = 'none'\n      }\n\n    })\n  }\n</script>\n</html>\n```\n\n## 参考资料\n- [前端路由跳转基本原理](https://juejin.im/post/5c52da9ee51d45221f242804)\n","tags":["整理"],"categories":["知识"]},{"title":"js函数柯里化","url":"%2Fjs%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html","content":"\n### 函数柯里化定义\n\n函数柯里化（function currying）又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数后，\n\n该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包里被保存起来。待到函数真正需要求值的时候，之前传入的参数都会被一次性用于求值。\n\n把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。\n\n顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。\n\n```javascript\nfunction add(x,y){\n    return x + y;\n}\n// 函数只传入一个参数的时候实现加法\nfunction curry(x){\n    return function(y){\n        return x + y;\n    }\n}\nvar add2 = curry(1);\nadd2(1) // 2 即curry(1)(1)\n```\n\n--- \n<!-- more -->\n\n### 函数柯里化实践\n\n```javascript\n// 通过以上简单介绍我们大概了解了，函数柯里化基本是在做这么一件事情：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。用公式表示就是我们要做的事情其实是\n\nfn(a,b,c,d)=>fn(a)(b)(c)(d)；\n\nfn(a,b,c,d)=>fn(a，b)(c)(d)；\n\nfn(a,b,c,d)=>fn(a)(b，c，d)；\n\n......\n\n// 再或者这样：\n\nfn(a,b,c,d)=>fn(a)(b)(c)(d)()；\n\nfn(a,b,c,d)=>fn(a)；fn(b)；fn(c)；fn(d)；fn()；\n```\n\n> 通用的函数柯里化版本\n\n```javascript\n// 这里需要传入长度\nfunction curry(fn, length, ary) {\n    length = length || fn.length;\n    ary = ary || [];//记录所有传入的参数\n    var slice = Array.prototype.slice;\n    return function () {\n        if (arguments.length < length) {\n            Array.prototype.push.apply(ary, slice.call(arguments));//每次把参数合并到ary数组中\n            return curry(fn, length - arguments.length, ary)//把还需传参的长度和已有参数数组传入curry，递归调用\n        } else {\n            return fn.apply(this, ary.concat(slice.call(arguments))); //调用求职函数，记得把此次传入的参数合并到ary数组再计算\n        }\n    };\n}\n\nlet total = function () {\n        let total = 0;\n        [].slice.call(arguments).forEach(item => {\n            total += item;\n        });\n        return total;\n    };\n let fn = curry(total, 4);\n fn(1)(2)(3)(4);//10\n fn(1,2)(3)(4);//10\n```\n\n```javascript\n// 这里是无参数时开始计算所有的cost\nvar currying = function(fn){\n    var args = [];\n    \n    return function(){\n        if(arguments.length === 0){\n            return fn.apply(this, args);\n        }else{\n            [].push.apply(args, arguments);\n            return arguments.callee;\n        }\n    }\n};\nvar cost = (function(){\n    var money = 0;\n    \n    return function(){\n        for(var i = 0, l = arguments.length; i < l; i++){\n            money += arguments[i];\n        }\n        return money;\n    }\n}());\n\nvar cost = currying(cost);//转化为currying函数\n\ncost(100);//未真正求值\ncost(200);//未真正求值\ncost(300);//未真正求值\n\nconsole.log(cost());//求值并输出：600  \n```\n\n```javascript\n// 和toString().valueOf()时计算和是一样的道理\nfunction add(num){\n    var _add = function(args){\n        num+=args;\n        return arguments.callee;\n    }\n    // (function foo(args){num+=args return foo;})\n    var _add =(function foo(args){num+=args; return foo;})\n    _add.toString = _add.valueOf = function(){\n        return num;\n    }\n    return _add;\n}\n```\n\n### 为了减少函数传参，同时将一些固定参数私有化\n```javascript\nfunction curry(fn, args) {\n  // 获取函数需要的参数长度\n  let length = fn.length;\n\n  args = args || [];\n\n  return function() {\n    let subArgs = args.slice(0);\n\n    // 拼接得到现有的所有参数\n    for (let i = 0; i < arguments.length; i++) {\n      subArgs.push(arguments[i]);\n    }\n\n    // 判断参数的长度是否已经满足函数所需参数的长度\n    if (subArgs.length >= length) {\n      // 如果满足，执行函数\n      return fn.apply(this, subArgs);\n    } else {\n      // 如果不满足，递归返回科里化的函数，等待参数的传入\n      return curry.call(this, fn, subArgs);\n    }\n  };\n}\n```\n\n```js\n// es6实现\nfunction curry(fn, ...args) {\n  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);\n}\n```\n\n### 函数柯里化的优点\n1. 延迟计算 \n可以传递需要的参数，等到何时想要结果，再一并计算。\n\n2. 参数复用 \n有些参数相同，只需要传递一遍即可，不需要每次都传，太繁琐。\n","tags":["整理"],"categories":["知识"]},{"title":"为什么react和immutable成为了好基友","url":"%2F%E4%B8%BA%E4%BB%80%E4%B9%88react%E5%92%8Cimmutable%E6%88%90%E4%B8%BA%E4%BA%86%E5%A5%BD%E5%9F%BA%E5%8F%8B.html","content":"\n工作中，React社区推崇搭配一起使用Immutable，就像咖啡牛奶伴侣一样。众所周知React的性能优化我们可以优化组件的嵌套层级，\n\n避免不必要的重绘，以及shouldComponentUpdate来判别组件是否会因为当前属性(props)和状态(state)变化而导致组件输出变化。\n\n一提到React，大家第一时间就想到的虚拟DOM(Virtual DOM)和伴随其带来的高性能（在虚拟dom上进行节点的更改最后在反映到真实dom上）。\n\n但是React提供的是声明式的API(declarative API),好的一方面是让我们编写程序更加方便，但另一方面，却使得我们不太了解内部细节。\n\n--- \n<!-- more -->\n\n### 一致化处理(Reconciliation)\nReact采用的是虚拟DOM，每次属性(props)和状态(state)发生变化的时候，render函数返回不同的元素树，\n\nReact会检测当前返回的元素树和上次渲染的元素树之前的差异，然后找出何如高效的更新UI。即render就执行diff差异再进行重绘。\n\n### shouldComponentUpdate\n默认的shouldComponentUpdate会在props和state发生变化时返回true,表示组件会重新渲染，从而调用render函数。\n\n当然了在首次渲染的时候和使用forceUpdate的时候，是不会经过shouldComponentUpdate判断。\n\n合理地编写shouldComponentUpdate函数，从而能避免不必要的一致化处理，使得性能可以极大提高。。我们可以通过\n\n继承React.PureComponent或者通过引入PureRenderMixin模块来达到目的。但是这也存在一个问题:\n\n```javascript\n// 子组件继承PureComponent只会进行浅比较\nclass ListOfWords extends React.PureComponent {\n  render() {\n    return <div>{this.props.words.join(',')}</div>;\n  }\n}\n\nclass WordAdder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      words: ['marklar'] // 复杂类型\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // 当触发点击页面并没有进行重新渲染\n    const words = this.state.words;\n    words.push('marklar');\n    this.setState({words: words});\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick} />\n        <ListOfWords words={this.state.words} />\n      </div>\n    );\n  }\n}\n```\n> 共享的可变状态是万恶之源\n\nJavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。\n\n如 foo={a: 1}; bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了 2。\n\n虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。\n\n为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。\n\nImmutable 可以很好地解决这些问题。\n\n\n### Immutable Data\n\nImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。\n\nImmutable 实现的原理是 Persistent Data Structure（持久化数据结构），\n\n也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，\n\nImmutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。\n\n> Map：键值对集合，对应于 Object，ES6 也有专门的 Map 对象\n\n> List：有序可重复的列表，对应于 Array\n\n> Set：无序且不可重复的列表\n\n比较两个Immutable对象是否相同，只需要使用===就可以轻松判别。因此如果React传入的数据是Immutable Data,那么React就能高效地比较前后属性的变化，从而决定shouldComponentUpdate的返回值。\n\n```javascript\n// 原来的写法\nlet foo = {a: {b: 1}};\nlet bar = foo;\nbar.a.b = 2;\nconsole.log(foo.a.b);  // 打印 2\nconsole.log(foo === bar);  //  打印 true\n\n// 使用 immutable.js 后\nimport Immutable from 'immutable';\nfoo = Immutable.fromJS({a: {b: 1}});\nbar = foo.setIn(['a', 'b'], 2);   // 使用 setIn 赋值\nconsole.log(foo.getIn(['a', 'b']));  // 使用 getIn 取值，打印 1\nconsole.log(foo === bar);  //  打印 false\n\n// 使用  seamless-immutable.js 后\nimport SImmutable from 'seamless-immutable';\nfoo = SImmutable({a: {b: 1}})\nbar = foo.merge({a: { b: 2}})   // 使用 merge 赋值\nconsole.log(foo.a.b);  // 像原生 Object 一样取值，打印 1\nconsole.log(foo === bar);  //  打印 false\n```\n\n#### Immutable-advantage\n1. Immutable 降低了 Mutable 带来的复杂度\n```javascript\nfunction touchAndLog(touchFn) {\n  let data = { key: 'value' };\n  touchFn(data);\n  console.log(data.key);\n}\n```\n在不了解touchFn函数的代码的情况下，不知道是否对data进行了修改。而如果data为Immutable对象一切都简单了，会打印value。\n\n2. 节省内存\nImmutable.js 使用了 Structure Sharing （结构共享）会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。\n\n```javascript\nimport { Map } from 'immutable';\nlet a = Map({\n  select: 'users',\n  filter: Map({ name: 'Cam' })\n})\nlet b = a.set('select', 'people');\n\na === b; // false\na.get('filter') === b.get('filter'); // true\n// 上面 a 和 b 共享了没有变化的 filter 节点。\n```\n\n3. Undo/Redo，Copy/Paste，时间旅行等功能\n\n4. 并发安全\n\n5. 函数式编程\n\n#### Immutable-disadvantage\n1. 需要熟悉新的api\n\n2. 引入新的库有大小\n\n3. 思维的变化\nImmutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get('key')而不是 map.key，array.get(0) 而不是 array[0]。\n\n下面给出一些办法来避免类似问题发生：\n\n> 使用 Flow 或 TypeScript 这类有静态类型检查的工具\n> 约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头。\n> 使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用。\n\n另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值。\n\n#### 两个Immutable对象的比较\n1. === 全等比较内存地址性能最好\n\n2. Immutable.is() 进行值比较\n\nImmutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。\n\n由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。\n\n```javascript\nlet a = Immutable.Map({a：1})\nlet b = Immutable.Map({a：1})\na === b // false \nImmutable.is(a,b) // true \n// Object.defineProperty() // IE9\n```\n#### 与 Object.freeze、const 区别\nObject.freeze 和 ES6 中新加入的 const 都可以达到防止对象被篡改的功能，但它们是 shallowCopy 的。对象层级一深就要特殊处理了。怪不得常量const复杂类型就不行了，直接回答浅拷贝。\n\n\n#### react中使用\n```javascript\nimport { is } from 'immutable';\n\nshouldComponentUpdate: (nextProps = {}, nextState = {}) => {\n  const thisProps = this.props || {}, thisState = this.state || {};\n  // 不清楚层级 直接比较两个对象\n  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||\n      Object.keys(thisState).length !== Object.keys(nextState).length) {\n      return true;\n  }\n\n  for (const key in nextProps) {\n    if (!is(thisProps[key], nextProps[key])) {\n      return true;\n    }\n  }\n\n  for (const key in nextState) {\n    if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) {\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n```javascript\nfunction diff(obj1,obj2){\n    var o1 = obj1 instanceof Object;\n    var o2 = obj2 instanceof Object;\n    if(!o1 || !o2){/*  判断不是对象  */\n        return obj1 === obj2;\n    }\n\n    if(Object.keys(obj1).length !== Object.keys(obj2).length){\n        return false;\n        //Object.keys() 返回一个由对象的自身可枚举属性(key值)组成的数组,例如：数组返回下表：let arr = [\"a\", \"b\", \"c\"];console.log(Object.keys(arr))->0,1,2;\n        //即Object.keys只适用于可枚举的属性，而Object.getOwnPropertyNames返回对象自动的全部属性名称。\n    }\n\n    for(var attr in obj1){\n        var t1 = obj1[attr] instanceof Object;\n        var t2 = obj2[attr] instanceof Object;\n        if(t1 && t2){\n            return diff(obj1[attr],obj2[attr]);\n        }else if(obj1[attr] !== obj2[attr]){\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n```javascript\nimport '_' from 'lodash';\n\nconst Component = React.createClass({\n  getInitialState() {\n    return {\n      data: { times: 0 }\n    }\n  },\n  handleAdd() {\n    let data = _.cloneDeep(this.state.data);\n    data.times = data.times + 1;\n    this.setState({ data: data });\n    // 如果上面不做 cloneDeep，下面打印的结果会是已经加 1 后的值。let data = this.state.data 指向同一内存地址\n    console.log(this.state.data.times);\n  }\n}\n\n使用 Immutable 后：\n\n  getInitialState() {\n    return {\n      data: Map({ times: 0 })\n    }\n  },\n  handleAdd() {\n    this.setState({ data: this.state.data.update('times', v => v + 1) });\n    // 这时的 times 并不会改变\n    console.log(this.state.data.get('times'));\n  }\n上面的 handleAdd 可以简写成：\n\n  handleAdd() {\n    this.setState(({data}) => ({\n      data: data.update('times', v => v + 1) })\n    });\n  }\n```\n\n#### 常用api\n```javascript\n// 声明\nImmutable.Map({a:1})\nImmutable.Map([1,2])\n\n// 原生js转换为immutable data\nImmutable.fromJS({a:1}) // immutable的 map\n\nImmutable.fromJS([1,2]) // immutable的 list\n\n// 从immutableData 回到 JavaScript 对象\nimmutableData.toJS()\n\n// 判断两个immutable数据是否一致\nImmutable.is(immutableA, immutableB)\n\n// 判断是不是map或List\nImmutable.Map.isMap(x)\n\nImmutable.List.isList(x)\n\n// 对象合并(注意是同个类型)\nimmutableMaB = immutableMapA.merge(immutableMaC)\n\n// Map的增删改查\nimmutableData.get('a') // {a:1} 得到1。\n\nimmutableData.getIn(['a', 'b']) // {a:{b:2}} 得到2。访问深层次的key\n\n// 增和改(注意不会改变原来的值，返回新的值原有的基础上扩展出分支)\nimmutableData.set('a', 2) // {a:1} 得到1。\n\nimmutableData.setIn(['a', 'b'], 3)\n\nimmutableData.update('a',function(x){return x+1})\n\nimmutableData.updateIn(['a', 'b'],function(x){return x+1})\n\n// 删\nimmutableData.delete('a')\n\nimmutableData.deleteIn(['a', 'b'])\n\n// List的增删查改如同Map，不过参数变为数字索引。比如immutableList.set(1, 2)\n```\n\n当然还有现在火热的immer.js，unstated了解一下@_@\n\n[参考文章](https://www.cnblogs.com/3body/p/6224010.html)","tags":["react"],"categories":["JS"]},{"title":"\\[1,2,3\\]是JSON吗？","url":"%2F%5B1%2C2%2C3%5D%E6%98%AFJSON%E5%90%97%EF%BC%9F.html","content":"\nA: “这个接口我传个 JSON 给你，格式是这样的 '[1, 2, 3]'”\n\nB: “等下，这不是数组吗，JSON 应该有键啊，类似这样才行'{ \"key\": [1, 2, 3] }'”\n\nA: “不，这就是 JSON 格式的数据”\n\nB: “啊，是吗？”\n你是否也有这样的疑惑？ wappalyzer chrome网页分析插件\n\n--- \n<!-- more -->\n\n## 什么是JSON\n\n**JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。**\n\n它仅仅是一种格式，就好比厨师脑中的食谱，这道菜有什么材料。而从原材料变成成品给顾客食用，这个过程食谱并没有实际参与，只是一个指导作用。\n\n所以JSON也是不存在于我们的程序中，不存在任何地方，只是一个思维，存在我们脑海里。\n\n这个思维，就是JSON这种格式应该包含哪些元素。\n\n- “名称/值”对的集合\n- 值的有序列表\n\n> 所以\"[1,2,3]\"是符合JSON格式的数据结构的\n\n> 但不能说[1, 2, 3]是一个JSON，它在javascript中可以被转换为数组，也可以在其他语言中被转换为数组（如果有这种类型）。而之所以只有这两种，是因为大部分现代计算机语言都支持。\n那[1, 2, undefined, 3]符合JSON格式吗？\n> “既然结构要是计算机语言都支持的，那结构中的值也需要吧，而undefined是javascript独有的，其他语言并没有，所以不符合JSON格式。”\n\n合法的JSON值有以下6种\n- string\n- number\n- boolean\n- null\n- object\n- array\n\n```javascript\n{\n    \"person\": {\n        \"name\": \"cosyer\",\n        \"age\": 18,\n        \"skills\": [\"javascript\", \"html\", \"css\"]\n    },\n    \"happy\": true\n}\n```\n\n## JS中的JSON\n在JavaScript中，如果在请求接口时要传递数据，我们往往会说“传一个JSON”，从上面已经知道JSON只是一个格式，那我们传递的到底是什么？\n\n```javascript\n// 一个简单的 post 请求\nconst body = {\n    name: 'cosyer',\n    age: 18\n};\n\nfetch('https://easy-mock.com/mock/5a1d30028e6ddb24964c2d91/business/api/login', {\n    method: 'POST',\n    body,\n})\n    .then((res) => res.json())\n    .then((data) => {\n        console.log(data);\n    });\n```\n\n> 但实际上并没有将参数传递过去，即Headers中并不存在Request Payload，需要将body使用JSON.stringify()方法转换为一个字符串后，才能成功传递。\nbody:JSON.stringify(body) or '{\"name\": 'cosyer',\"age\": 18}'\n\n但两者还是有区别的\n\n```javascript\nconst body = {\n    name: 'cosyer',\n    skills: undefined,\n};\nconsole.log(JSON.stringify(body)); // {\"name\":\"cosyer\"}\n```\n\n```javascript\nconst body = {\n    name: 'cosyer',\n    skills: [undefined],\n};\nconsole.log(JSON.stringify(body)); // {\"name\":\"cosyer\",\"skills\":[null]}。\n```\n\n### JSON.parse\n> JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。\n> 可以用来判断某个字符串是否符合JSON格式\n\n### 和XML的区别\n- 数据体积方面\nJSON相对于XML来讲，数据的体积小，传递的速度更快些。\n- 数据交互方面\nJSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互\n- 数据描述方面\nJSON对数据的描述性比XML较差\n- 传输速度方面\nJSON的速度要远远快于XML\n\n## 总结\n\nJSON是日常开发中最常使用的，但仅限于“会用”，实际上JSON的用途已经不局限在“数据交换”，NoSQL、配置文件也有JSON的身影，深入了解是有必要的，毕竟看起来这么“简单”。","tags":["知识"],"categories":["知识"]},{"title":"java -jar与nohup","url":"%2Fjava%20-jar%E4%B8%8Enohup.html","content":"\njava程序员，经常会遇到这样一个问题，打个jar包，测试或者上线生产，于是乎面临的选择来了，java –jar or nohup？\n下面我来扒一扒：\n\n## java -jar a.jar &\n直接启动jar文件，在当前会话进程中开启一个子进程来运行程序，这个子进程会随着会话进程的结束而结束。\n\n这种情况适合短时间测试用。\n\n## nohup java -jar a.jar &\nhangup ：(挂断)，终端退出时会发送 hangup 信号来通知其关闭所有子进程。\n\nnohup ：(不挂断，忽略挂断信号)。\n\nnohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上\"&\"来将命令同时放入后台运行，也可用\">filename2>&1\"来更改缺省的重定向文件名。\n\n这种情况适合在生产环境长时间运行。\n\n## nodejs应用在linux上运行\n\n### 使用场景\n\n- forever管理多个站点，每个站点访问量不大，不需要监控。\n- supervisor是开发环境用。\n- nodemon 是开发环境使用，修改自动重启。\n- pm2 网站访问量比较大,需要完整的监控界面。\n\n1. forever\n```javascript\nnpm install -g forever\nforever start index.js -o out.log -e err.log\nforever list \nforever stop index.js [id]\nforever stopall\nforever restartall\n```\n\n2. supervisor 热部署\n```javascript\nnpm install -g supervisor\nsupervisor app.js // 文件有改动会立即重启node模块\n```\n\n3. nodemon\n```javascript\nnpm install -g nodemon\nnodemon app.js\n```\n\n4. nohup\n```javascript\nnohup node index.js &\nnohup node index.js > myLog.log 2>&1 &\n```\n\nnohup问题:\n\n但是有时候在这一步会有问题，当把终端关闭后，进程会自动被关闭，查看nohup.out可以看到在关闭终端瞬间服务自动关闭。\n有个操作终端时的细节：当shell中提示了nohup成功后还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；\n而我是每次在nohup执行成功后直接点关闭程序按钮关闭终端。所以这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown。\n\n5. 高大上的pm2\n\n特性：\n- 内建负载均衡（使用Node cluster 集群模块）\n- 后台运行\n- 0秒停机重载，维护升级的时候不需要停机\n- 具有Ubuntu和CentOS 的启动脚本\n- 停止不稳定的进程（避免无限循环）\n- 控制台检测\n- 提供 HTTP API\n- 远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )\n\n使用：\n\n```javascript\nnpm install -g pm2\npm2 start app.js -o out.log -e err.log\npm2 stop app.js\npm2 restart app.js\npm2 list\npm2 descibe [id]\npm2 monit // 查看cpu和内存使用\npm2 logs // 实时集中log处理\npm2 web // 浏览器查看\n```","tags":["Java"],"categories":["知识"]},{"title":"实现双向绑定","url":"%2F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.html","content":"\n主流的双向绑定方法\n1.发布-订阅模式\n通过使用 get 和 set 的方式获取数据然后更新数据，其原理就是监听页面中某个具体元素的事件，然后将其最新的值手动 set 到 数据中，同时订阅 model 层的改变，然后触发页面的渲染更新\n\n2.脏检测\n通过对比数据是否有变更，来决定是否更新视图。最简单的可以通过定时轮询去检测数据的变动。Angular 只有在指定事件触发时进入脏检测：\n\n- DOM事件，比如用户输入文本点击按钮等（ng-click）\n- XHR响应事件\n浏览器 Location 变更\n- Timer事件\n- 执行 $digest() 或 $apply();\n\n脏检查的主要原理是在将数据绑定到 View 的时候，就在监听器列表（scope 作用域中的监听队列 watchList）中插入一条监听器，当触发 UI 事件或者 Ajax 请求时，就会触发脏检查（$digest cycle), 在 $digest 流程中，将遍历每个数据变量的 watcher，比较它的新旧值。当新旧值不同时，触发 listener 函数，执行相关的更新逻辑。这个过程将会一直重复，直到所有数据指令的新旧值都相同为止。\n\n脏检查虽然可以达到实现双向绑定，但是当页面中绑定的 watcher 过多时，就会引发性能问题。所以 angular 在进行 $digest 检测时，会限制循环检查的次数最少2次，最多10次，防止无效的检查。\n\n3.数据劫持\n通过 ES5 的 Object.defineProperty() 来劫持数据属性的 getter 和 setter， 在数据变动时触发订阅者（watcher），从而触发相应的监听回调更新视图。\n\n- Observer 对数据的所有属性进行监听其 getter 和 setter\n- Compile 是一个指令解析器，对 MVVM 实例的所有元素指令进行解析，并渲染成 model 中的绑定数据，当数据进行更新时，也能替换为更新后的值。\n- Watcher 作为 Compile 和 Observer 的桥梁，能够订阅数据属性的更新，然后执行相应的监听回调\n- Deps 用于存放监听器数组，主要用来保存 Watcher\n- Updater 执行更新操作，针对不同的指令进行不同的更新操作，如 v-model, v-class, v-html 等类型的指令。\n- MVVM 作为入口函数，整合以上所有的功能。\n\n![vue-mvvm](http://cdn.mydearest.cn/blog/images/vue-mvvm.png)\n\nObserver 劫持了所有数据属性的 getter 和 setter，当数据发生改变时，就会通知 deps 中所有 watcher 的更新操作，进而触发页面的重新渲染，这是修改 Model 层从而引发 View 层的重新渲染。\n在 Compile 中监听可输入元素的事件，然后将新值更新到 model 的数据中，这是修改 View 层触发的 Model 层的修改。\n\n- 用户名或者邮箱跟github没有关联上， github认为不是你提交的， 不统计。\n- fork 的项目， 不统计\n- 没有在版本库的master【默认分支】上提交\n\n[解读](https://github.com/SunShinewyf/issue-blog/issues/46)\n\n---\n<!--more-->\n\n## defineProperty实现\n\n目前支持双向绑定的Vue中的实现就是这种方法。但是这种方法不太好的地方就是对于数组之类的对象，类似修改数组的length，直接用索引设置元素如items[0] = {}，以及数组的push，pop等变异方法是无法触发setter的。针对这些，vue中的实现是在Object和Array的原型添加了定制方法来处理这些特殊操作，可以实现上述要求。\n\n```js\n/**\n  * bind\n  * @param {object} target \n  * @param {object} dom \n  * @param {object} map \n  */\nconst bind = (target, dom, map) =>\n  Object.keys(map || target).forEach(key =>\n    Object.defineProperty(target, key, {\n      set(value) {\n        const domKey = map ? map[key] : key\n        dom[domKey] = value\n      },\n      get() {\n        const domKey = map ? map[key] : key\n        return dom[domKey]\n      }\n    }))\nwindow._alternate = {}\n\nconst p = document.getElementById('p')\n\nbind(_alternate, p, {\n  'value': 'innerHTML'\n})\n```\n\n## proxy实现\n\n怎么理解reflect\nreflect 是es6新增的一个全局对象。顾名思义，反射，类似于Java里面的反射机制。在Java里面，反射是个很头疼的概念。简单理解为：通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。对于Java来说，程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。\n\n```js\n/**\n  * bind\n  * @param {object} model \n  * @param {object} map \n  */\nconst bind = (model, map) => new Proxy(map || model, {\n  get(_, key) {\n    const mkey = map ? map[key] : key\n    return Reflect.get(model, mkey)\n  },\n  set(_, key, value) {\n    const mkey = map ? map[key] : key\n    return Reflect.set(model, mkey, value)\n  }\n})\n\nwindow.__alternate = bind(document.getElementById('p'), {\n  'value': 'innerHTML'\n})\n```\n\n## mvvm\n[MVVM](https://github.com/cosyer/MVVM)\n\n### mvvm\n```js\nfunction MVVM(options) {\n  this.$el = options.el;\n  this.$data = options.data;\n  this.$method = options.method;\n  if (this.$el) {\n    // 对所有数据进行劫持\n    new Observer(this.$data);\n    // 将数据直接代理到实例中，无需通过vm.$data来操作\n    this.proxyData(this.$data);\n    new Compile(this.$el, this);\n  }\n}\n\nMVVM.prototype = {\n  proxyData: function (data) {\n    Object.keys(data).forEach((key) => {\n      Object.defineProperty(this, key, {\n        get() {\n          return data[key];\n        },\n        set(newValue) {\n          data[key] = newValue;\n        },\n      });\n    });\n  },\n};\n```\n\n### observer\n```js\nfunction Observer(data) {\n  this.data = data;\n  this.observe(this.data);\n}\n\nObserver.prototype = {\n  /**\n   * @param {data} 要监听的数据对象\n   */\n  observe: function (data) {\n    if (!data || typeof data !== \"object\") return;\n    // 为每一个属性设置数据监听\n    Object.keys(data).forEach((key) => {\n      this.defineReactive(data, key, data[key]);\n      this.observe(data[key]); // 深度递归劫持属性\n    });\n  },\n\n  /**\n   * @param {data} 要监听的数据对象\n   * @param {key} 要监听的对象属性key值\n   * @param {value} 要监听的对象属性值\n   */\n  defineReactive: function (data, key, value) {\n    let dep = new Dep();\n    let self = this;\n\n    // 如果是该属性值是对象类型，则遍历\n    Object.defineProperty(data, key, {\n      enumerable: true,\n      configurable: false,\n      get: () => {\n        // 由于需要在闭包内添加watcher，所有需要 Dep 定义一个全局 target 属性，暂存 watcher ，添加完移除\n        if (Dep.target) {\n          // 如果为true，则说明是实例化 watcher 引起的，所以需要添加进消息订阅器中\n          dep.depend();\n        }\n        return value;\n      },\n      set: (newVal) => {\n        if (newVal === value) return;\n        value = newVal;\n        // 对新值进行监听\n        self.observe(newVal);\n        // 通知所有订阅者\n        dep.notify();\n      },\n    });\n  },\n};\n```\n\n### watcher\n```js\n/**\n *\n * @param {*vm} 双向绑定实例\n * @param {*expOrFn} 是表达式还是function\n * @param {*cb} 执行更新时的回调函数\n */\nfunction Watcher(vm, expr, cb) {\n  this.depIds = {}; // 存储deps订阅的依赖\n  this.vm = vm; // component 实例\n  this.cb = cb; // 更新数据时的回调函数\n  this.expr = expr; // 表达式还是function\n  this.value = this.get(vm, expr); // 在实例化的时候获取老值\n}\n\nWatcher.prototype = {\n  // 暴露给 Dep 类的方法，用于在订阅的数据更新时触发\n  update: function () {\n    const newValue = this.get(this.vm, this.expr); // 获取到的新值\n    const oldValue = this.value; // 获取到的旧值\n    if (newValue !== oldValue) {\n      // 判断新旧值是否相等，不相等就执行回调\n      this.value = newValue;\n      this.cb(newValue);\n    }\n  },\n\n  addDep: function (dep) {\n    // 检查depIds对象是否存在某个实例，避免去查找原型链上的属性\n    if (!this.depIds.hasOwnProperty(dep.id)) {\n      dep.addSub(this); // 在 dep 存储 watcher 监听器\n      this.depIds[dep.id] = dep; // 在 watcher 存储订阅者 dep\n    }\n  },\n\n  // 获取data中的值，可能出现 hello.a.b的情况\n  getVal: function (vm, expr) {\n    expr = expr.split(\".\");\n    return expr.reduce((prev, next) => {\n      return prev[next];\n    }, vm.$data);\n  },\n\n  // 获取值\n  get: function (vm, expr) {\n    Dep.target = this;\n    const val = this.getVal(vm, expr);\n    Dep.target = null;\n    return val;\n  },\n};\n```\n\n### dep\n```js\n// 订阅事件的唯一标识\nlet uid = 0;\n\n// 订阅类\nfunction Dep() {\n  this.id = uid++;\n  this.subs = [];\n}\n\nDep.prototype = {\n  addSub: function (sub) {\n    if (this.subs.indexOf(sub) === -1) {\n      // 避免重复添加\n      this.subs.push(sub);\n    }\n  },\n\n  removeSub: function (sub) {\n    const index = this.subs.indexOf(sub);\n    if (index > -1) {\n      this.subs.splice(index, 1);\n    }\n  },\n\n  depend: function () {\n    Dep.target.addDep(this); //执行 watcher 的 addDep 方法\n  },\n\n  notify: function () {\n    this.subs.forEach((sub) => {\n      sub.update(); // 执行 watcher 的 update 方法\n    });\n  },\n};\n\n// Dep 类的全局属性 target，是一个 Watch 实例\nDep.target = null;\n```\n\n### compile\n```js\nfunction Compile(el, vm) {\n  this.el = this.isElementNode(el) ? el : document.querySelector(el);\n  this.vm = vm;\n  if (this.el) {\n    // 将真实DOM移入内存 fragment 中\n    let fragment = this.node2Fragment(this.el);\n    this.compile(fragment);\n    //将编译后的 fragment 再次转化为 DOM 塞回到页面中\n    this.el.appendChild(fragment);\n  }\n}\n\nCompile.prototype = {\n  // 将 DOM 转化为 fragment\n  node2Fragment: function (el) {\n    let fragment = document.createDocumentFragment();\n    // 每次获取DOM节点树中的第一个元素，直到移除完毕为止\n    while (el.firstChild) {\n      fragment.appendChild(el.firstChild);\n    }\n    // 返回一个文档碎片容器，存储DOM树的所有节点\n    return fragment;\n  },\n  // 是否是DOM节点元素\n  isElementNode(node) {\n    return node.nodeType === 1;\n  },\n  //编译函数\n  compile: function (fragment) {\n    let childNodes = fragment.childNodes;\n    Array.from(childNodes).forEach((node) => {\n      // 是否是元素节点\n      if (this.isElementNode(node)) {\n        this.compileElement(node);\n        this.compile(node);\n      } else {\n        // 是否是文本节点\n        this.compileText(node);\n      }\n    });\n  },\n\n  //判断是否是指令\n  isDirective: function (name) {\n    // 不能使用 indexOf 的方式，因为可能出现 v-model-v-model,必须以 v- 开头\n    return name.startsWith(\"v-\");\n  },\n\n  // 是否是事件指令\n  isEventDirective: function (dir) {\n    return dir.startsWith(\"on\");\n  },\n\n  //编译节点元素\n  compileElement: function (node) {\n    // 带v-model v-text\n    let attrs = node.attributes; // 取出当前节点的属性\n    Array.from(attrs).forEach((attr) => {\n      let attrName = attr.name;\n      if (this.isDirective(attrName)) {\n        // 取到指令对应的值放到节点中\n        let expr = attr.value;\n        const attrArr = attrName.split(\"-\");\n        // 说明此时不是 v-model 的这种形式，而是 v-model-v-model\n        if (attrArr.length !== 2) {\n          return;\n        }\n        let type = attrArr[1]; // 获取指令是哪种类型，比如v-model,v-text\n        // 如果是事件指令\n        if (this.isEventDirective(type)) {\n          CompileUtil.eventHandler(node, this.vm, expr, type);\n        } else {\n          // 调用对应的编译方法 编译哪个节点,用数据替换掉表达式\n          CompileUtil[type](node, this.vm, expr);\n        }\n      }\n    });\n  },\n\n  // 编译文本元素\n  compileText: function (node) {\n    let expr = node.textContent; // 取文本中的内容 todo:和 innerHTML 的区别\n    let reg = /\\{\\{([^}]+)\\}\\}/g; // 不能直接检测 {{}} 这种情况，还要考虑这种情况 {{a}} {{b}} {{c}}\n    if (reg.test(expr)) {\n      // 调用编译文本的方法 编译哪个节点,用数据替换掉表达式\n      CompileUtil[\"text\"](node, this.vm, expr);\n    }\n  },\n};\n\n// 指令处理集合\nvar CompileUtil = {\n  // 文本处理\n  text: function (node, vm, expr) {\n    let updateFn = Updater[\"textUpdater\"];\n    let value = this.getTextVal(vm, expr);\n    expr.replace(/\\{\\{([^}]+)\\}\\}/g, (...arguments) => {\n      // 实例化观察者，添加到发布订阅的数组中\n      new Watcher(vm, arguments[1], (newValue) => {\n        // 传入每次的表达式，比如出现 {{a}} {{b}}, 就要分别取获取表达式 a,b 的值,\n        // 如果直接传入 newValue,则后一个值会覆盖前一个值\n        updateFn && updateFn(node, this.getTextVal(vm, expr));\n      });\n    });\n    updateFn && updateFn(node, value);\n  },\n  // html指令处理\n  html: function (node, vm, expr) {\n    let updateFn = Updater[\"htmlUpdater\"];\n    // 更新渲染\n    new Watcher(vm, expr, (newValue) => {\n      updateFn && updateFn(node, newValue);\n    });\n    // 初始化渲染\n    updateFn && updateFn(node, this.getVal(vm, expr));\n  },\n\n  // class 指令处理\n  class: function (node, vm, expr) {\n    let updateFn = Updater[\"classUpdater\"];\n    // 更新渲染\n    new Watcher(vm, expr, (newValue) => {\n      updateFn && updateFn(node, newValue);\n    });\n    // 初始化渲染\n    updateFn && updateFn(node, this.getVal(vm, expr));\n  },\n\n  // model指令处理\n  model: function (node, vm, expr) {\n    let updateFn = Updater[\"modelUpdater\"];\n    new Watcher(vm, expr, (newValue) => {\n      updateFn && updateFn(node, newValue);\n    });\n    // 监听输入框的input事件，并将值回填到数据中\n    node.addEventListener(\"input\", (e) => {\n      let newValue = e.target.value;\n      this.setVal(vm, expr, newValue);\n    });\n    updateFn && updateFn(node, this.getVal(vm, expr));\n  },\n\n  // 事件指令处理\n  eventHandler: function (node, vm, expr, type) {\n    // todo\n    let eventType = type.split(\":\")[1],\n      fn = vm.$method[expr];\n    if (eventType && fn) {\n      node.addEventListener(eventType, fn.bind(vm), false);\n    }\n  },\n\n  // 获取文本的值\n  getTextVal: function (vm, expr) {\n    return expr.replace(/\\{\\{([^}]+)\\}\\}/g, (...arguments) => {\n      //argument[1] 就是 {{hello}} 里面的 hello 值\n      return this.getVal(vm, arguments[1]);\n    });\n  },\n  // 获取值\n  getVal: function (vm, expr) {\n    expr = expr.split(\".\"); //将 hello.a.b 转化为数组,调用reduce获取最里面的值\n    return expr.reduce((prev, next) => {\n      return prev[next];\n    }, vm.$data);\n  },\n  // 设置值\n  setVal: function (vm, expr, value) {\n    expr = expr.split(\".\");\n    // 将新值回填到数据中，并且回填到最后一个值，如:hello.a.b，就需要把值回填到b中\n    return expr.reduce((prev, next, index) => {\n      if (index === expr.length - 1) {\n        return (prev[next] = value);\n      }\n      return prev[next];\n    }, vm.$data);\n  },\n};\n\n// 更新数据处理集合\nvar Updater = {\n  // 文本更新\n  textUpdater: function (node, value) {\n    node.textContent = typeof value === \"undefined\" ? \"\" : value;\n  },\n  // html 更新\n  htmlUpdater: function (node, value) {\n    node.innerHTML = typeof value === \"undefined\" ? \"\" : value;\n  },\n  // class 更新\n  classUpdater: function (node, value) {\n    let className = node.className;\n    className = className.replace(value, \"\").replace(/\\s$/, \"\");\n    var space = className && String(value) ? \" \" : \"\";\n    node.className = className + space + value;\n  },\n  // model 更新\n  modelUpdater: function (node, value) {\n    node.value = typeof value === \"undefined\" ? \"\" : value;\n  },\n};\n```\n","tags":["整理"],"categories":["JS"]},{"title":"深浅拷贝","url":"%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D.html","content":"\n## 深浅拷贝概念\n\n深拷贝和浅拷贝只针对象 Object, Array 这样的复杂对象（引用类型）的。\n\n复制引用（引用类型）的拷贝方法称之为浅拷贝，创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果\n\n属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\n\n深拷贝就是指完全的拷贝一个对象，将原对象的各个属性递归复制下来。这样即使嵌套了对象，两者也相互分离。\n\n## 浅拷贝 对基本类型拷贝值，引用类型拷贝引用\n### Object.assign()\n### 扩展运算符...\n\n```javascript\nvar shallowCopy = function(obj) {\n    if (typeof obj !== 'object') return;      // 只拷贝对象\n    var newObj = obj instanceof Array ? [] : {};     // 根据obj的类型判断是新建一个数组还是对象\n    for (var key in obj) {      // 遍历obj，并且判断是obj的属性才拷贝\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = obj[key];\n        }\n    }\n    return newObj;\n}\n\nfunction shallowCopy2(source) {\n  if (source === null || typeof source !== 'object') return source;\n  const copy = Array.isArray(source) ? [] : {};\n\n  Object.keys(source).forEach(key => {\n    copy[key] = source[key];\n  });\n  return copy;\n}\n\nvar obj = { a:1, arr: [2,3] };\nvar shallowObj = shallowCopy(obj);\nshallowObj.arr[1] = 5;\nconsole.log(obj.arr[1])  // 5 互相影响 指向了同一块内存地址\nshallowObj.a = 5;\nconsole.log(obj.a) // 1 \n```\n\n## 深拷贝(将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。)\n### JSON.parse(JSON.stringify(a)): 性能最快\n具有循环引用的对象时，报错\n当值为函数、undefined、或symbol时，无法拷贝\n\n### 递归复制\n```javascript\n// 不考虑循环引用\nvar deepCopy = function(obj) {\n    if (typeof obj !== 'object') return;\n    var newObj = obj instanceof Array ? [] : {};\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];\n        }\n    }\n    return newObj;\n}\n\nvar obj = { a:1, arr: [2,3] };\nvar shallowObj = shallowCopy(obj);\nshallowObj.arr[1] = 5;\nconsole.log(obj.arr[1])  // 3 没有影响 重新拷贝了新数据\nshallowObj.a = 5;\nconsole.log(obj.a) // 1 \n```\n\n```js\n// 不考虑循环引用\nconst clone = function(data){\n    if(typeof data !== 'object'){\n        return data;\n    }\n    let keys = Object.keys(data);\n    let result = Array.isArray(data) ? [] : {};\n    keys.forEach(key=>{\n        if(typeof data[key] === 'object'){\n            result[key] = clone(data[key]);\n        }else{\n            result[key] = data[key];\n        }\n    })\n    return result;\n}\n```\n\n```js\n// 考虑循环引用 只考虑了普通的 object和 array两种数据类型\nconst clone = function(data){\n    let map = new WeakMap(); // 这里用WeakMap弱引用，会自动回收，不需要手动处理置为null\n    function dp(obj){\n        if(typeof obj !== 'object'){\n            return obj;\n        }\n        let o = map.get(obj);\n        if(o){\n            return o;\n        }\n        let result = Array.isArray(obj) ? [] : {};\n        map.set(obj, result);\n        let keys = Object.keys(obj);\n        keys.forEach(key=>{\n            if(typeof obj[key] === 'object'){\n                result[key] = dp(obj[key]);\n            }else{\n                result[key] = obj[key];\n            }\n        })\n        return result;\n    }\n    return dp(data);\n}\n```\n\n```js\n// 终极版\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\nconst argsTag = '[object Arguments]';\n\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst numberTag = '[object Number]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst errorTag = '[object Error]';\nconst regexpTag = '[object RegExp]';\nconst funcTag = '[object Function]';\n\nconst deepTag = [mapTag, setTag, arrayTag, objectTag, argsTag];\n\n\nfunction forEach(array, iteratee) {\n    let index = -1;\n    const length = array.length;\n    while (++index < length) {\n        iteratee(array[index], index);\n    }\n    return array;\n}\n\nfunction isObject(target) {\n    const type = typeof target;\n    return target !== null && (type === 'object' || type === 'function');\n}\n\nfunction getType(target) {\n    return Object.prototype.toString.call(target);\n}\n\nfunction getInit(target) {\n    const Ctor = target.constructor;\n    return new Ctor();\n}\n\nfunction cloneSymbol(targe) {\n    return Object(Symbol.prototype.valueOf.call(targe));\n}\n\nfunction cloneReg(targe) {\n    const reFlags = /\\w*$/;\n    const result = new targe.constructor(targe.source, reFlags.exec(targe));\n    result.lastIndex = targe.lastIndex;\n    return result;\n}\n\nfunction cloneFunction(func) {\n    const bodyReg = /(?<={)(.|\\n)+(?=})/m;\n    const paramReg = /(?<=\\().+(?=\\)\\s+{)/;\n    const funcString = func.toString();\n    if (func.prototype) {\n        const param = paramReg.exec(funcString);\n        const body = bodyReg.exec(funcString);\n        if (body) {\n            if (param) {\n                const paramArr = param[0].split(',');\n                return new Function(...paramArr, body[0]);\n            } else {\n                return new Function(body[0]);\n            }\n        } else {\n            return null;\n        }\n    } else {\n        return eval(funcString);\n    }\n}\n\nfunction cloneOtherType(targe, type) {\n    const Ctor = targe.constructor;\n    switch (type) {\n        case boolTag:\n        case numberTag:\n        case stringTag:\n        case errorTag:\n        case dateTag:\n            return new Ctor(targe);\n        case regexpTag:\n            return cloneReg(targe);\n        case symbolTag:\n            return cloneSymbol(targe);\n        case funcTag:\n            return cloneFunction(targe);\n        default:\n            return null;\n    }\n}\n\nfunction clone(target, map = new WeakMap()) {\n\n    // 克隆原始类型\n    if (!isObject(target)) {\n        return target;\n    }\n\n    // 初始化\n    const type = getType(target);\n    let cloneTarget;\n    if (deepTag.includes(type)) {\n        cloneTarget = getInit(target, type);\n    } else {\n        return cloneOtherType(target, type);\n    }\n\n    // 防止循环引用\n    if (map.get(target)) {\n        return map.get(target);\n    }\n    map.set(target, cloneTarget);\n\n    // 克隆set\n    if (type === setTag) {\n        target.forEach(value => {\n            cloneTarget.add(clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆map\n    if (type === mapTag) {\n        target.forEach((value, key) => {\n            cloneTarget.set(key, clone(value, map));\n        });\n        return cloneTarget;\n    }\n\n    // 克隆对象和数组\n    const keys = type === arrayTag ? undefined : Object.keys(target);\n    forEach(keys || target, (value, key) => {\n        if (keys) {\n            key = value;\n        }\n        cloneTarget[key] = clone(target[key], map);\n    });\n\n    return cloneTarget;\n}\n\nmodule.exports = {\n    clone\n};\n```\n\n尽管使用深拷贝会完全的克隆一个新对象，不会产生副作用，但是深拷贝因为使用递归，性能会不如浅拷贝，在开发中，还是要根据实际情况进行选择。\n","tags":["整理"],"categories":["知识"]},{"title":"js判断数据类型","url":"%2Fjs%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html","content":"\n## typeof\n> typeof一般只能返回如下几个结果：number,boolean,string,function,object,undefined字符串\n\n> 对于Array,null等特殊对象使用typeof一律返回object，这正是typeof的局限性。\n\n> typeof表示是对某个变量类型的检测，基本数据类型除了null都能正常的显示为对应的类型，引用类型除了函数会显示为'function'，其它都显示为object。\n\n```javascript\nvar fn = new Function ('a', 'b', 'return a + b')\n\ntypeof fn // function\n```\n\n## instanceof \n> instanceof适用于检测对象，它是基于原型链运作的。\n\n> instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。换种说法就是如果左侧的对象是右侧对象的实例， 则表达式返回true, 否则返回false 。\n\n> instanceof对基本数据类型检测不起作用，因为基本数据类型没有原型链。可以准确的判断复杂数据类型。\n\n```javascript\n[1, 2, 3] instanceof Array // true \n/abc/ instanceof RegExp // true \n({}) instanceof Object // true \n(function(){}) instanceof Function // true\n\n// 基于constructor \na.constructor === Array; \n// 基于Object.prototype.isPrototypeOf \nArray.prototype.isPrototypeOf(a); \n// 4.基于getPrototypeOf \nObject.getPrototypeOf(a) === Array.prototype; \n```\n\n## Object.prototype.toString.call\n\n可以检测各种数据类型，推荐使用。\n\n```javascript\nObject.prototype.toString.call([]); // => [object Array] \nObject.prototype.toString.call({}); // => [object Object] \nObject.prototype.toString.call(''); // => [object String] \nObject.prototype.toString.call(new Date()); // => [object Date] \nObject.prototype.toString.call(1); // => [object Number] \nObject.prototype.toString.call(function () {}); // => [object Function] \nObject.prototype.toString.call(/test/i); // => [object RegExp] \nObject.prototype.toString.call(true); // => [object Boolean] \nObject.prototype.toString.call(null); // => [object Null] \nObject.prototype.toString.call(); // => [object Undefined]\n```\n\n```javascript\nlet isType = type => obj => {\n  return Object.prototype.toString.call( obj ) === '[object ' + type + ']';\n}\n \nvar isString = isType( 'String' ); \nvar isArray = isType( 'Array' ); \nvar isNumber = isType( 'Number' );\n\nconsole.log( isArray( [ 1, 2, 3 ] ) ); //true\n```\n\n## constructor\nconstructor也不是保险的，因为constructor属性是可以被修改的，会导致检测出的结果不正确。\n\n```js\nconsole.log([].constructor === Array)   // true\nfunction a() {}\nconsole.log(a.constructor === Function)   // true\nconsole.log(12.constructor === Number)  // true\nconsole.log('22'.constructor === String)  // true\nconsole.log([] .constructor ===  Array)   // true\nconsole.log({a: 1}.constructor ===  Object) // true\nconsole.log(true.constructor === Boolean) // true\nconsole.log(json.constructor === Object) // true\nconsole.log((new Date()).constructor === Date)   // true\nconsole.log(reg.constructor ===  RegExp) //true\nconsole.log(error.constructor === Error) // true\n```\n","tags":["整理"],"categories":["知识"]},{"title":"js创建对象实现继承","url":"%2Fjs%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF.html","content":"\n今天10月31日，万圣节前夜。希望ff的病早点好，身体健康。\n\n## 创建对象(字面量、构造函数、create方法、调用函数返回对象)\n```javascript\nvar obj = {} // 字面量 \nvar obj = new Object() // 很少见，性能低 没有形参时可省略()\nvar obj = Object.create(null) // 以xx为原型创建对象\nvar obj = Object.assign({})   // 复制到目标对象\n// Object.assign()还可以去除多余的参数覆盖\nObject.assign({ a: 1, b: 2 }, { b: 3, c: 3 })\nconst newObj = { ...{ a: 1, b: 2 }, ...{ b: 3, c: 3 } }\n// {a: 1, b: 3, c: 3}\n// Object() ==> {}\n```\n\n---\n<!--more-->\n\n### 复制一个对象\n```javascript\nvar obj = { a: 1 };\nvar copy = Object.assign({}, obj);\nconsole.log(copy); // { a: 1 }\n```\n\n### 浅拷贝\n\nObject.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。\n\n```javascript\nlet obj1 = { a: 0 , b: { c: 0}};\nlet obj2 = Object.assign({}, obj1);\nconsole.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}\n\nobj1.a = 1;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}\nconsole.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}\n\nobj2.a = 2;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}\nconsole.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}\n\nobj2.b.c = 3;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}\nconsole.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}\n\n// Deep Clone\nobj1 = { a: 0 , b: { c: 0}};\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 4;\nobj1.b.c = 4;\nconsole.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}\n```\n\n### 合并对象\n```javascript\nvar o1 = { a: 1 };\nvar o2 = { b: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。\n```\n\n### 合并相同属性的对象\n```javascript\nvar o1 = { a: 1, b: 1, c: 1 };\nvar o2 = { b: 2, c: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign({}, o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\n```\n\n### 创建对象模式(6种)\n#### 工厂模式\n\n在一个函数内创建一个空对象，给空对象添加属性和属性值，return这个对象。然后调用这个函数并传入参数来使用。\n\n```javascript\nfunction createPerson(name, age, job){ \n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.sayName = function(){ alert(this.name); }; \n    return o;\n}\nvar person1 = createPerson(\"cosyer\", 23); \nconsole.log(person1.name) //cosyer\nconsole.log(person1.sayName()) //cosyer\n```\n优点：解决了创建多个相似对象的问题\n缺点：没有解决对象识别的问题（即怎样知道一个对象的类型）\n\n#### 构造函数模式\n\n创建一个构造函数，然后用new 创建构造函数的实例。\n\n```javascript\nfunction Person(name, age, job){\n    this.name = name; \n    this.age = age; \n    this.sayName = function(){ \n        console.log(this.name); \n    }; \n}\n\nvar person1 = new Person(\"cosyer\", 22); \nconsole.log(person1.name) //cosyer\nconsole.log(person1.sayName()) //cosyer\n```\n\n优点：\n\n1. 子类型构造函数中可向超类型构造函数传递参数。\n2. 方法都在构造函数中定义，对于属性值是引用类型的就可通过在每个实例上重新创建一遍，避免所有实例的该属性值指向同一堆内存地址，一个改其他也跟着改。\n原始 复杂(引用) \n缺点：\n对于一些可共用的属性方法（比如这边的this.sayName）没必要都在每个实例上重新创建一遍，占用内存。(无法复用)\n\n\n- 对象字面量vs构造函数创建对象对比\n\n字面量的优势：\n\n1. 代码量更少，更易读；\n\n2. 可以强调对象就是一个简单的可变的散列表，而不必一定派生自某个类；\n\n3. 对象字面量运行速度更快，因为它们可以在解析的时候被优化：它们不需要作用域解析(scope resolution)；因为存在我们创建了一个同名的构造函数Object()的可能，当我们调用Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到了名为Object()的函数就执行，如果没找到，就继续顺着作用域链往上照，直到找到全局Object()构造函数为止；\n\n4. Object()构造函数可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另外一个对象实例，而这往往不是你想要的。\n\n#### 原型模式\n\n创建一个函数，给函数原型对象赋值。利用函数的prototype属性指向函数的原型对象，从而在原型对象添加所有实例可共享的属性和方法。\n\n```javascript\nfunction Person(){ }\nPerson.prototype.name = \"cosyer\"; \nPerson.prototype.age = 23; \nPerson.prototype.sayName = function(){\n     console.log(this.name); \n};\nvar person1 = new Person();\nconsole.log(person1.name) //cosyer\nconsole.log(person1.sayName()) //cosyer\n```\n优点：\n可以让所有对象实例共享它所包含的属性和方法(复用性)。\n缺点：\n\n1. 在创建子类型的实例时，不能向超类型的构造函数中传递参数。\n2. 如果包含引用类型值的属性，那一个实例改了这个属性（引用类型值），其他实例也跟着改变。\n\n#### 组合模式\n\n构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。简单来说就是属性值是引用类型的就用构造函数模式，方法和属性能共享的就用原型模式，取精去糟。\n\n```javascript\nfunction Person(name, age){ //构造函数模式\n    this.name = name; \n    this.age = age; \n    this.friends = [\"aa\", \"bb\"]; \n}\nPerson.prototype = {  //原型模式\n    constructor : Person, \n    sayName : function(){ \n        console.log(this.name); \n    }\n}\nPerson.prototype.hobby = {exercise:\"ball\"}; //原型模式\n\nvar person1 = new Person(\"cosyer\", 23);\nvar person2 = new Person(\"cuby\", 27)\nperson1.friends.push(\"cc\");   \nconsole.log(person1.friends);   //\"aa,bb,cc\"\nconsole.log(person2.friends);   //\"aa,bb\"\nperson1.sayName = function(){console.log(this.age)};\nperson1.sayName();  //22\nperson2.sayName();  //cuby\nperson1.hobby.exercise = \"running\";\nconsole.log(person1.hobby);  //{exercise: \"running\"}\nconsole.log(person2.hobby); //{exercise: \"running\"}\n```\n\n#### 动态原型模式\n```javascript\nfunction Person(name, age){ //构造函数模式\n    this.name = name; \n    this.age = age; \n    this.friends = [\"aa\", \"bb\"]; \n    if(typeof Person.prototype.hobby !== 'object'){\n        // 只写入1次\n        Person.prototype.hobby = {exercise:\"ball\"};  \n    }\n}\n```\n\n#### 寄生构造函数模式\n\n## 继承方式(9种)\n### 构造函数继承(复制父类的实例属性给子类)\n```javascript\nfunction SuperType(){ \n    this.colors = [\"red\", \"blue\", \"green\"]; \n}\nfunction SubType(){ //继承了 SuperType \n    SuperType.call(this); \n}\n\nvar instance1 = new SubType(); \ninstance1.colors.push(\"black\"); \nconsole.log(instance1.colors); //\"red,blue,green,black\"\nvar instance2 = new SubType(); \nconsole.log(instance2.colors); //\"red,blue,green\"\n```\n优点：\n1. 简单，易于实现\n2. 父类新增原型方法、原型属性，子类都能访问到\n缺点：\n1. 无法实现多继承，因为原型一次只能被一个实例更改\n2. 来自原型对象的所有属性被所有实例共享（上诉例子中的color属性）\n3. 创建子类实例时，无法向父构造函数传参\n\n### 原型链继承(将父类的实例作为子类的原型)\n```javascript\nfunction SuperType(){ \n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType(){};\nSubType.prototype = new SuperType();\n\nvar instance1 = new SubType();\nvar instance2 = new SubType(); \nconsole.log(instance1.colors); //[\"red\", \"blue\", \"green\"]\nconsole.log(instance2.colors);//[\"red\", \"blue\", \"green\"]\n\ninstance1.colors.push(\"black\"); \nconsole.log(instance1.colors);//[\"red\", \"blue\", \"green\", \"black\"]\nconsole.log(instance2.colors);//[\"red\", \"blue\", \"green\", \"black\"]\n```\n优点：\n1. 简单，易于实现\n2. 父类新增原型方法、原型属性，子类都能访问到\n缺点：\n1. 无法实现多继承，因为原型一次只能被一个实例更改\n2. 来自原型对象的所有属性被所有实例共享（上诉例子中的color属性）\n3. 创建子类实例时，无法向父构造函数传参\n\n### 组合继承(将原型链和借用构造函数的技术组合到一块。使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承)\n```javascript\nfunction SuperType(name){  //父类（构造函数）\n    this.name = name;\n}\n\nSuperType.prototype.sayName = function(){  //父类的原型添加一个方法\n    console.log(this.name);\n}\n\nfunction SubType(name, age){  //借用构造函数来实现对实例属性的继承 \n    SuperType.call(this, name);    //继承实例属性 这边继承this.name = name;\n    this.age = age;     //自己的属性\n}\n\nSubType.prototype = new SuperType();    //使用原型链实现对原型属性和方法的继承  这边是继承\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function(){ \n    alert(this.age); \n};\nvar instance1 = new SubType(\"cosyer\", 23);\nconsole.log(instance1.age)   //23\nconsole.log(instance1.name)  //cosyer\ninstance1.sayName(); //cosyer\ninstance1.sayAge(); //23\n```\n优点：\n1. 弥补了构造继承的缺点，现在既可以继承实例的属性和方法，也可以继承原型的属性和方法\n2. 既是子类的实例，也是父类的实例\n3. 可以向父类传递参数\n4. 函数可以复用\n缺点：\n1. 调用了两次父类构造函数，生成了两份实例\n2. constructor指向问题\n\n### 实例继承(为父类实例添加新特征，作为子类实例返回)\n```js\nfunction Son(name) {\n    let f=new Father('传给父类的参数')\n    f.name=name||'son'\n    return f\n}\n\nlet s = new Son(\"son\"); //或者直接调用子类构造函数 let s = Son(\"son\");\nconsole.log(s.name); // son\ns.sayAge(); // 18\ns.sayName(); // son\nconsole.log(s.age); // 18\nconsole.log(s instanceof Father); // true\nconsole.log(s instanceof Son); // false\nconsole.log(s.constructor === Father); // true\nconsole.log(s.constructor === Son); // false=\n```\n优点：\n1. 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果\n缺点：\n1. 实例是父类的实例，不是子类的实例\n2. 不支持多继承\n\n### 拷贝继承(对父类实例中的的方法与属性拷贝给子类的原型)\n```js\nfunction Son(name) {\n    let f = new Father(\"传给父类的参数\");\n    for (let k in f) {\n    Son.prototype[k] = f[k];\n    }\n    Son.prototype.name = name;\n}\n\nlet s = new Son(\"son\");\nconsole.log(s.name); // son\ns.sayAge(); // 18\ns.sayName(); // son\nconsole.log(s.age); // 18\nconsole.log(s instanceof Father); // false\nconsole.log(s instanceof Son); // true\nconsole.log(s.constructor === Father); // false\nconsole.log(s.constructor === Son); // true\n```\n优点：\n1. 支持多继承\n缺点：\n1. 效率低，性能差，占用内存高（因为需要拷贝父类属性）\n2. 无法获取父类不可枚举的方法（不可枚举的方法，不能使用for-in访问到)\n\n### 寄生组合继承(通过寄生方式，砍掉父类的实例属性，避免了组合继承二次执行父类构造函数的缺点)\n```js\nfunction Son(name) {\n    Father.call(this);\n    this.name = name || \"son\";\n}\n\n// 方法一  自己动手创建一个中间类\n// (function() {\n//   let NoneFun = function() {};\n//   NoneFun.prototype = Father.prototype;\n//   Son.prototype = new NoneFun();\n//   Son.prototype.constructor = Son;\n// })();\n\n// 方法二  直接借用Object.create()方法\nSon.prototype = Object.create(Father.prototype);\n// 修复构造函数指向\nSon.prototype.constructor = Son;\n\nlet s = new Son(\"son\");\nconsole.log(s.name); // son\ns.sayAge(); // 18\ns.sayName(); // son\nconsole.log(s.age); // 18\nconsole.log(s instanceof Father); // true\nconsole.log(s instanceof Son); // true\nconsole.log(s.constructor === Father); // false\nconsole.log(s.constructor === Son); // true\n```\n优点：\n1. 比较完美（js实现继承首选方式）\n缺点：\n1.实现起来较为复杂（可通过Object.create简化）\n\n```js\nfunction Person(obj) {\n    this.name = obj.name\n    this.age = obj.age\n}\nPerson.prototype.add = function(value){\n    console.log(value)\n}\nvar p1 = new Person({name:\"番茄\", age: 18})\n\nfunction Person1(obj) {\n    Person.call(this, obj)\n    this.sex = obj.sex\n}\n// 这一步是继承的关键\nPerson1.prototype = Object.create(Person.prototype)\nPerson1.prototype.play = function(value){\n    console.log(value)\n}\nvar p2 = new Person1({name:\"鸡蛋\", age: 118, sex: \"男\"})\n```\n\n### es6 class继承(使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super) \n```js\nclass Son extends Father {\n    constructor(name) {\n    super(name);\n    this.name = name || \"son\";\n    }\n}\n\nlet s = new Son(\"son\");\nconsole.log(s.name); // son\ns.sayAge(); // 18\ns.sayName(); // son\nconsole.log(s.age); // 18\nconsole.log(s instanceof Father); // true\nconsole.log(s instanceof Son); // true\nconsole.log(s.constructor === Father); // false\nconsole.log(s.constructor === Son); // true\n```\n\n### 原型式继承\n利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。\n```js\nfunction object(obj){\n  function F(){}\n  F.prototype = obj;\n  return new F();\n}\n```\n缺点：\n- 原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。\n- 无法传递参数\n\n### 寄生式继承\n核心：在原型式继承的基础上，增强对象，返回构造函数。\n```js\nfunction createAnother(original){\n  var clone = object(original); // 通过调用 object() 函数创建一个新对象\n  clone.sayHi = function(){  // 以某种方式来增强对象\n    alert(\"hi\");\n  };\n  return clone; // 返回这个对象\n}\n```\n缺点（同原型式继承）\n\n## ES5/ES6 的继承除了写法以外还有什么区别\n- ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。\n```js\nfunction Super() {}\nfunction Sub() {}\n\nSub.prototype = new Super();\nSub.prototype.constructor = Sub;\n\nvar sub = new Sub();\n\nSub.__proto__ === Function.prototype;\n```\n\n- ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。\n```js\nclass A extends B{}\nA.__proto__ === B;  //继承属性\nA.prototype.__proto__ == B.prototype;//继承方法\n```\n\n`Happy Halloween!`\n","tags":["整理"],"categories":["知识"]},{"title":"实现jsonp","url":"%2F%E5%AE%9E%E7%8E%B0jsonp.html","content":"\n作为常用的跨域解决方案，怎么能不用原生实现一下呢！\n\njsonp跨域其实也是JavaScript设计模式中的一种代理模式。\n在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。\n一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信。补充一点，JSONP不使用XMLHttpRequest对象加载资源，不属于真正意义上的AJAX。\n\n```javascript\n// 实现目标\nJSONP(url, {\n  data: {\n    key1: value1\n  },\n  callback: function (data) {\n    // data 是服务端返回的数据\n  }\n})\n```\n\n--- \n<!-- more -->\n\n- 带参数\n```javascript\nconst JSONP = (url, jsonpObj) => {\n  // 属性名 \n  let cbName = \"cb\" + JSONP.count++\n  // 回调函数 \n  let cbQuery = \"JSONP.\" + cbName\n  let paramsToQuery = obj => {\n    let query = '?'\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        query += `${k}=${obj[k]}&`\n      }      \n    }\n    return query\n  }\n  JSONP[cbName] = data => {\n    try {\n      jsonpObj.callback(data)\n    } finally {\n      delete JSONP[cbName]\n      document.body.removeChild(script)\n    }   \n  }\n  let queryStr = paramsToQuery(jsonpObj.data) + 'callback=' + cbQuery\n  let script = document.createElement('script')\n  script.src = url + encodeURIComponent(queryStr)\n  document.body.appendChild(script)\n}\nJSONP.count = 0\n```\n\n- easy模式\n```js\nfunction jsonp(url, jsonpCallback, success) {\n  const script = document.createElement('script')\n  script.src = url\n  script.async = true\n  script.type = 'text/javascript'\n  window[jsonpCallback] = function(data) {\n    success && success(data)\n  }\n  document.body.appendChild(script)\n}\n```\n\n- 简单的不传参数的jsonp实现\n```js\nconst jsonp = url => {\n  new Promise((resolve, reject) => {\n    // 创建标签\n    const script = document.createElement('script')\n    // 设置回调名\n    const callbackId = `jsonp_${Date.now()}`\n    // 拼接url\n    script.src = url.includes('?') ? `${url}&callback=${callbackId}` : `${url}?callback=${callbackId}`\n\n    // 设置读取返回结果的回调函数, 必须设置在window上\n    window[callbackId] = result => {\n      // 释放内存\n      delete window[callbackId]\n      // 移除标签\n      document.body.removeChild(script)\n      // 结果\n      result ? resolve(result) : reject('404')\n    }\n\n    script.addEventListener('error', () => reject('script create fail'))\n    // 发出请求\n    document.body.appendChild(script)\n}\n\njsonp('').then(console.log)\n```\n\n## 服务端实现jsonp\n- express\n```js\n/* 服务端相关操作，以express为例 */\nlet express = require('express')\nlet app = express()\nconst port = '3000'\napp.get('/',function(req,res){\n  let {a,b,callback} = req.query\n  console.log(a)\n  console.log(b)\n  // 注意，返回给script标签，浏览器直接把这部分字符串执行\n  res.send(`${callback}('数据包')`)\n})\napp;listen(port)\n```\n\n和CORS相比，JSONP 最大的优势在于兼容性好，IE 10以下低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。\n","tags":["知识"],"categories":["知识"]},{"title":"高逼格的JS代码","url":"%2F%E9%AB%98%E9%80%BC%E6%A0%BC%E7%9A%84JS%E4%BB%A3%E7%A0%81.html","content":"\n黑科技JS代码整理 是不是很void 666\n\n### 一行代码实现评级\n```javascript\n\"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate);定义一个变量rate是1到5的值\n```\n\n### SB、NB、Hello World\n```javascript\n(!(~+[])+{})[--[~+\"\"][+[]]*[~+[]] + ~~!+[]]+({}+[])[[~!+[]]*~+[]]\n\n([][[]]+[])[+!![]]+([]+{})[!+[]+!![]]\n\n([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[+[]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()([][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+{})[+[]])[+[]]+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+([]+{})[+!![]]+(!![]+[])[+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()([][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+{})[+[]])[+[]]+(!+[]+!![]+[])+(+!![]+[]))\n```\n\n### 错误处理的正确方法\n```javascript\ntry {\n    something\n} catch (e) {\n    window.location.href =\n        \"http://stackoverflow.com/search?q=[js]+\" +\n        e.message;\n}\n// 百度版\ntry {\n    something\n} catch (e) {\n    window.location.href =\n        \"https://www.baidu.com/s?wd=\" +\n        e.message;\n}\n```\n\n--- \n\n<!-- more -->\n\n### 标记区域的范围\n```javascript\n[].forEach.call($$(\"*\"),function(a){\n    a.style.outline=\"1px solid #\"+(~~(Math.random()*(1<<24))).toString(16)\n})\n// 等价于\nArray.prototype.forEach.call(document.querySelectorAll('*'), \ndom => dom.style.outline = `1px solid #${parseInt(Math.random() * \nMath.pow(2,24)).toString(16)}`)\n\n$$('*').map(x => x.style.border = '1px solid')\n// 删除括号内容replace(/\\((.+?)\\)$/g,'')\n```\n\n### 获取随机字符串\n```javascript\nMath.random().toString(16).substring(2)  // 0e7a48ca4bec3\nMath.random().toString(36).substring(2)  // s2ue8xvgu7a\n```\n\n### 这样的判断你能做对吗\n```javascript\n(10)[\"toString\"]() === \"10\" // true\n\nconsole.log(10..toString());//10\nconsole.log(10.toString());//SyntaxError: Unexpected token ILLEGAL\n// 在JavaScript中，数字后面的\".\"操作符是的意义是不确定。因为它既可能是一个浮点数的标志，又可能是取一个对象的属性的运算符。但是JavaScript的解释器把他当做了浮点数的标志\n// 等价于 \nconsole.log((10.).toString());\nconsole.log((10.)toString())\n```\n\n### 匿名函数自执行方法\n```javascript\n( function() {}() );\n( function() {} )();\n[ function() {}() ];\n\n~ function() {}();\n! function() {}();\n+ function() {}();\n- function() {}();\n\ndelete function() {}();\ntypeof function() {}();\nvoid function() {}();\nnew function() {}();\nnew function() {};\n\nvar f = function() {}();\n\n1, function() {}();\n1 ^ function() {}();\n1 > function() {}();\n```\n\n### 终于到 void 666\n```javascript\n// 以下都是undefined\nvar a; \nvar a = undefined \nvoid 0\nvoid 666\nvoid(0)\nvoid (0)\n```\n\n### 金额格式化\n```javascript\n// api\n(156589822366).toLocaleString() // \"156,589,822,366\"\n\n// 正则就完事了\nvar test1 = '1234567890'\nvar format = test1.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\nconsole.log(format) // 1,234,567,890\n\n// 非正则\n function formatCash(str) {\n       return str.split('').reverse().reduce((prev, next, index) => {\n            return ((index % 3) ? next : (next + ',')) + prev\n       })\n}\nconsole.log(formatCash('1234567890')) // 1,234,567,890\n```\n\n### 逗号运算符\n```javascript\nvar a = 0;\nvar b = (a++,99);\n// a 1 b 99\n```\n\n### 交换两个数的值\n```javascript\n// 加减运算 缺点也很明显，整型数据溢出，对于32位字符最大表示数字是2147483647，如果是2147483645和2147483646交换就失败了。\nvar a=1,b=2;\na += b;\nb = a - b;\na -= b;\n\n// 第三个临时变量\nvar a=1,b=2;\nvar temp = a;\na = b;\nb= temp;\n\n// 位运算\nlet a=3,b=4;\na^=b;\nb^=a;\na^=b;\n\n// es6\nlet a = 1, b = 2;\n[a, b] = [b, a];\n```\n\n### JSON数据的深拷贝\n```javascript\nvar a = {\n    a: 1,\n    b: { c: 1, d: 2 }\n}\nvar b=JSON.parse(JSON.stringify(a))\n// Number parseInt parseFloat\n```\n局限性：\n- 会忽略 undefined\n- 不能序列化函数，会被忽略\n- 不能解决循环引用的对象\n\n### 长度为6值为8的数组\n```javascript\nArray(6).fill(8)\n```\n\n### 脚本永不报错\n```javascript\nwindow.onerror = function(m, f, l){ return true }\n```\n\n### 生活常识\n36.3℃～37.2℃(口腔)、36.1℃～37℃(腋窝)\n\n60～100次/分\n\n1500ml\n\n2500大卡\n\n90mmHg<收缩压<140mmHg、60mmHg<舒张压<90mmHg\n\n## 使用Boolean过滤数组中的假值\n双否运算符(~~)\n```js\nconst compact = arr => arr.filter(Boolean)\ncompact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]) // // [ 1, 2, 3, 'a', 's', 34 ] \n```\n\n## 惰性载入函数\n```js\njsfunction foo(){\n    if(a !== b){\n        console.log('aaa')\n    }else{\n        console.log('bbb')\n    }\n}\n \n// 优化后\nfunction foo(){\n    if(a != b){\n        foo = function(){\n            console.log('aaa')\n        }\n    }else{\n        foo = function(){\n            console.log('bbb')\n        }\n    }\n    return foo();\n}\n```\n那么第一次运行之后就会覆写这个方法，下一次再运行的时候就不会执行判断了。当然现在只有一个判断，如果判断很多，分支比较复杂，那么节约的资源还是可观的。\n\n## 字符串比较时间大小\n```js\nvar a = \"2014-08-08\";\nvar b = \"2014-09-09\";\n \nconsole.log(a>b, a<b); // false true\nconsole.log(\"21:00\"<\"09:10\");  // false\nconsole.log(\"21:00\"<\"9:10\");   // true   时间形式注意补0\n```\n字符串比较大小是按照字符串从左到右每个字符的charCode来的，但所以特别要注意时间形式注意补0\n\n```js\n// 方法1\nvar a = [1,2,3]\na.join = a.toString = a.shift\na == 1 && a == 2 && a == 3 // true 隐式类型转换\n\n// 方法2\nvar a = {\n    num: 0,\n    valueOf(){\n        this.num++;\n        return this.num;\n    }\n}\n'选择'>'努力' // true\n```\n\n## 数字补0操作\n```js\nconst addZero1 = (num, len = 2) => (`0${num}`).slice(-len)\nconst addZero2 = (num, len = 2) => (`${num}`).padStart(len, '0')\naddZero1(3) // 03\n \naddZero2(32,4)  // 0032\n```\n\n## es6的八进制表示\n```js\n035            // 8进制29      原来的方式\n0o35            // 8进制29     es6的方式\n```\n\n## Math.round实现的精确保留指定位数的函数(toFixed不完善)\n```js\nconst round = (n, decimals = 0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`)\nround(1.345, 2)                 // 1.35\nround(1.345, 1)                 // 1.3\n\n// 不太完善 round(1.2,2) 为1.2没有补0\nfunction addZ(num,len=2){ \n    num=num.toString() \n    if(!num.includes('.')) num=num+'.' \n    if(!Object.is(Number(num),NaN)){ \n        num= Number(num).toFixed(len)    \n    } \n    else if(num.includes(',')){ \n        if(!Object.is(Number(num.replace(/,/g,'')),NaN)){ \n        len=num.indexOf('.')+Number(len)+1 \n        num= num.length<len? num.padEnd(len,'0'):num; \n        } \n    } \n    return num \n}\n\nfunction keepDecimal (num, len=2) {\n    let result = parseFloat(num)\n    result = Math.round(num * 10**len) / (10**len)\n    return result\n}\n```\n\n## 统计相同项(reduce)\n```js\nvar str = a.split('').reduce((p,k)=>(p[k]++||(p[k]=1),p),{})\n\n\njsvar cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'];\nvar carsObj = cars.reduce(function (obj, name) {\n  obj[name] = obj[name] ? ++obj[name] : 1;\n  return obj;\n}, {});\ncarsObj; // => { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 }\n```\n\n```js\n// 数组相同项的次数\nconst countOccurrences = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);\ncountOccurrences([1, 1, 2, 1, 2, 3], 1); // 3\n```\n\n## 两个数值的交换\n```js\nvar temp = a; a = b; b = temp            \nb = [a, a = b][0]                     \na = a + b; b = a - b; a = a - b \n// es6 解构赋值\nlet x = 1;\nlet y = 2;\n[x, y] = [y, x];\n```\n\n## 多判断\n```js\nif ( foo === 'bar' || foo === 'foobar' || foo === 'foo' )\n{\n//...\n}\n\n就可以写成：\nif ( foo in { 'bar':'', 'foobar':'', 'foo':'' } )\n{\n//...\n}\n```\n\n## shell压缩解压\n```shell\ntar -zcvf newfilename.tar.gz filename\ntar -zxvf newfilename.tar.gz\n```\n\n## banana\n```js\n('b'+'a'+ +'a'+'a').toLowerCase()\n// banana\n```\n","tags":["整理"],"categories":["JS"]},{"title":"babel的.babelrc配置","url":"%2Fbabel%E7%9A%84.babelrc%E9%85%8D%E7%BD%AE.html","content":"\n> Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。Babel 内部所使用的语法解析器是 Babylon\n\n一个基本的.babelrc配置:\n\n```javascript\n{\n  \"presets\": [\n    \"env\",\n    \"stage-0\"\n  ],\n  \"plugins\": [\"transform-runtime\"]\n}\n```\n\n--- \n<!-- more -->\n\n### presets env\n\npresets 是babel的一个预设，使用的时候需要安装对应的插件，对应babel-preset-xxx，例如下面的配置，需要npm install babel-preset-env\n\n> 每年每个 preset 只编译当年批准的内容。 而 babel-preset-env 相当于 es2015 ，es2016 ，es2017 及最新版本。\n\n```javascript\n{\n  \"presets\": [\"env\"]\n}\n```\n\n### presets stage\nstage 代表着ES提案的各个阶段，一共有5个阶段，存在依赖关系。也就是说stage-1是包括stage-0的，以此类推：\n- Stage 0 - 稻草人: 只是一个想法，可能是 babel 插件。\n- Stage 1 - 提案: 初步尝试。\n- Stage 2 - 初稿: 完成初步规范。\n- Stage 3 - 候选: 完成规范和浏览器初步实现。\n- Stage 4 - 完成: 将被添加到下一年度发布。\n\n### plugins\npresets，是plugins的预设，起到方便设置的作用。如果不采用presets，可以使用plugins\n```javascript\n{\n  \"plugins\": [\"transform-es2015-arrow-functions\"] // 也可以预设babel-preset-es2015\n}\n``` \n\n### 自定义预设和插件\n3种方式设置都ok\n\n```javascript\n\"plugins\": [\"babel-plugin-myPlugin\"]\n\"plugins\": [\"myPlugin\"]\n\"plugins\": [\"./node_modules/asdf/plugin\"]。\n// presets同理。\n```\n\n### plugins/presets排序\n- plugins 会运行在 presets 之前。\n- plugins 会从第一个开始顺序执行。\n- presets 的顺序则刚好相反(从最后一个逆序执行)。\n\n### babel-polyfill\n`babel`本身只提供预发的转换，当我们使用一些箭头函数这样的新的语法，其实在babel看来，更像是一种语法糖。\n但是babel不能转义一些ES6、ES7...的新的全局属性，例如 Promise 、新的原生方法如 String.padStart (left-pad) 等。\n这个时候我们就需要使用babel-polyfill。","tags":["整理"],"categories":["知识"]},{"title":"实现trim的3种方法","url":"%2F%E5%AE%9E%E7%8E%B0trim%E7%9A%843%E7%A7%8D%E6%96%B9%E6%B3%95.html","content":"\ntrim 方法 (字串) (JavaScript) 移除字串前后的空白字元以及行结束字元。\n- 用法\nstring.trim()\n\n1. 递归截取(不推荐)\n```javascript\nfunction trim(str){\n// 加入类型判断 \nif(str[0]===' '||str[str.length-1]===' '){\n    if(str[0]===' '){\n      str=str.substring(1,str.length)\n    }\n    if(str[str.length-1]===' '){\n      str=str.substring(0,str.length-1)\n    }\n    trim(str)\n  }else{\n    console.log(str)\n    return str\n  }\n}\n```\n\n2. 2次遍历记录不为空格的索引，最后截取\n```javascript\nfunction trim(str) {\n    let start, end // 开始和结束为止 遍历记录不为空格的索引\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] !== ' ') {\n            start = i\n            break\n        }\n    }\n    for (let i = str.length - 1; i > 0; i--) {\n        if (str[i] !== ' ') {\n            end = i\n            break\n        }\n    }\n    return str.substring(start, end + 1)\n}\n```\n\n3. 正则替换\n```javascript\nfunction trim(str) {\n    return str.replace(/(^\\s*)|(\\s*$)/g, \"\")\n}\n\n// 1. value.toString()\n// 2. String('123213') \n// 3. '' + value\n```","tags":["整理"],"categories":["知识"]},{"title":"正则总结","url":"%2F%E6%AD%A3%E5%88%99%E6%80%BB%E7%BB%93.html","content":"\n正则表达式脱离语言，和数据结构与算法一样，作为程序员的软技能。目前存在的问题：不受重视\n优点：\n\n- 显著的提升代码质量\n- 灵活多变\n- 强大的数据校验支持\n\n```javascript\nvar regex1 = /cosyer/g;\nvar regex2 = new RegExp('cosyer', 'g');\nvar regex3 = new RegExp(/cosyer/, 'g');\nvar regex4 = new RegExp(/cosyer/g);\n```\n\n其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。 正则表达式的匹配模式支持下列 3 个标志。\n\n- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；\n- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；\n- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。\n\n新增的修饰符：\n\n- u: Unicode模式。用来处理Unicode大于\t\\uFFFF的单个字符（超过\\uFFFF会被程序员解析为两个字符）\n- y: 粘连模式。和g一样作为全局匹配，区别是g的下一次匹配不要求位置，但是y下一次匹配要求紧跟这这次匹配项之后\n- s: dotAll模式。正则表达式中点(.)作为匹配（除换行符\\n，回车符\\r，行分隔符，段分隔符）任意单个字符，支持点(.)真正匹配所有单个字符\n\n## 两种使用方式\n```js\nvar a1 = /\\+d/g; // 字面形式\nvar a2 = new RegExp('\\\\+d','g') // 构造函数\n```\n\n在JavaScript中建议使用字面形式的正则表达式，因为不需要担心字符串中的转义字符。比如上面示例代码中字面形式使用\\d而构造函数使用的是\\\\d；\n\n```javascript\nvar text = \"aaa \"; \nvar pattern1 = /\\s$/; //匹配字符串末尾的空格 \npattern1.exec(text);\n```\n---\n<!-- more -->\n\n正则定义了很多特殊意义的字符，有名词，量词，谓词等\n\n## 简单字符\n没有特殊意义的字符都是简单字符，简单字符就代表自身，绝大部分字符都是简单字符，举个例子。\n\n```javascript\n/abc/ // 匹配 abc\n/123/ // 匹配 123\n/-_-/ // 匹配 -_-\n```\n## 转义字符\n\\是转义字符，其后面的字符会代表不同的意思，转义字符主要有三个作用：\n\n1. 是为了匹配不方便显示的特殊字符，比如换行，tab符号等\n\n2. 正则中预先定义了一些代表特殊意义的字符，比如\\w等\n\n3. 在正则中某些字符有特殊含义(比如下面说到的)，转义字符可以让其显示自身的含义\n\n|常用转义字符|意义|\n|:---|:---|\n|\\n\t|匹配换行符 （newline）|\n|\\r\t|匹配回车符 （return）|\n|\\t\t|匹配制表符，也就是tab键|\n|\\v\t|匹配垂直制表符|\n|\\x20\t|20是2位16进制数字，代表对应的字符|\n|\\u002B\t|002B是4位16进制数字，代表对应的字符|\n|\\u002B\t|002B是4位16进制数字，代表对应的字符|\n|\\w\t|匹配任何一个字母或者数字或者下划线 单子字符 (word)|\n|\\W\t|匹配任何一个字母或者数字或者下划线以外的字符 非单子字符|\n|\\s\t|匹配空白字符，如空格，tab等 （space）|\n|\\S\t|匹配非空白字符|\n|\\d\t|匹配数字字符，0~9 （digit）\n|\\D\t|匹配非数字字符|\n|\\b\t|匹配单词的边界 (boundary)|\n|\\B\t|匹配非单词边界|\n|\\ |匹配\\本身|\n\n## 字符集合\n```javascript\n// 有时我们需要匹配一类字符，字符集可以实现这个功能，字符集的语法用[]分隔，下面的代码能够匹配a或b或c\n[abc]\n\n// 如果要表示字符很多，可以使用-表示一个范围内的字符，下面两个功能相同\n[0123456789]\n[0-9]\n\n// 在前面添加^，可表示非的意思，下面的代码能够匹配abc之外的任意字符\n[^abc]\n```\n其实正则还内置了一些字符集，在上面的转义字符有提到，下面给出内置字符集对应的自定义字符集\n\n```javascript\n// 匹配除了换行符（\\n）以外的任意一个字符 = [^\\n]\n\\w = [0-9a-zA-Z_]\n\\W = [^0-9a-zA-Z_]\n\\s = [ \\t\\n\\v]\n\\S = [^ \\t\\n\\v]\n\\d = [0-9]\n\\D = [^0-9]\n```\n\n## 量词\n如果需要匹配多次某个字符，正则也提供了量词的功能，正则中的量词有多个，如?、+、*、{n}、{m,n}、{m,}\n\n{n}匹配n次，比如a{2}，匹配aa\n\n{m, n}匹配m-n次，优先匹配n次，比如a{1,3}，可以匹配aaa、aa、a\n\n{m,}匹配m-∞次，优先匹配∞次，比如a{1,}，可以匹配aaaa...\n\n?匹配0次或1次，优先匹配1次，相当于{0,1}\n\n+匹配1-n次，优先匹配n次，相当于{1,}\n\n*匹配0-n次，优先匹配n次，相当于{0,}\n\n正则默认和人心一样是贪婪的，也就是常说的贪婪模式，凡是表示范围的量词，都优先匹配上限而不是下限\n\n```javascript\n// a{1, 3} 匹配字符串'aaa'的话，会匹配aaa而不是a\nvar text = \"aaa\"; \nvar pattern1 = /a{1,3}/;\npattern1.exec(text); //[\"aaa\", index: 0, input: \"aaa\"] // index input为属性\n```\n\n有时候这不是我们想要的结果，可以在量词后面加上?，就可以开启非贪婪模式\n\n```javascript\nvar text = \"aaa\"; \nvar pattern1 = /a{1,3}?/;\npattern1.exec(text); //[\"a\", index: 0, input: \"aaa\"]\n```\n\n## 字符边界\n^在[]外表示匹配开头的意思\n^abc // 可以匹配abc，但是不能匹配aabc\n\n$表示匹配结尾的意思\nabc$ // 可以匹配abc，但是不能匹配abcc\n上面提到的\\b表示单词的边界\n\n\\b表示匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。\nabc\\b // 可以匹配 abc ，但是不能匹配 abcc；\n/\\bm/匹配“moon”中得‘m’；\n/oo\\b/并不匹配\"moon\"中得'oo'，因为'oo'被一个“字”字符'n'紧跟着。\n/oon\\b/匹配\"moon\"中得'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。\n/\\w\\b\\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。\n\n## 选择表达式\n有时我们想匹配x或者y，如果x和y是单个字符，可以使用字符集，[abc]可以匹配a或b或c，如果x和y是多个字符，字符集就无能为力了，此时就要用到分组\n\n正则中用|来表示分组，a|b表示匹配a或者b的意思\n\n```javascript\n123|456|789 // 匹配 123 或 456 或 789\n```\n\n## 分组与引用\n分组是正则中非常强大的一个功能，可以让上面提到的量词作用于一组字符，而非单个字符，分组的语法是圆括号包裹(xxx)\n\n```javascript\n(abc){2} // 匹配abcabc\n```\n分组不能放在[]中，分组中还可以使用选择表达式\n```javascript\n(123|456){2} // 匹配 123123、456456、123456、456123\n```\n\n和分组相关的概念还有一个捕获分组和非捕获分组，分组默认都是捕获的，在分组的(后面添加?:可以让分组变为非捕获分组，非捕获分组可以提高性能和简化逻辑\n\n```javascript\n'123'.match(/(?:123)/) // 返回 ['123']\n'123'.match(/(123)/)  // 返回 ['123', '123']\n// 和分组相关的另一个概念是引用，比如在匹配html标签时，通常希望<xxx></xxx>后面的xxx能够和前面保持一致\n```\n\n引用的语法是\\数字，数字代表引用前面第几个捕获分组，注意非捕获分组不能被引用\n\n```javascript\n<([a-z]+)><\\/\\1> // 可以匹配 `<span></span>` 或 `<div></div>`等\n```\n\n## 预搜索\n\n如果你想匹配xxx前不能是yyy，或者xxx后不能是yyy，那就要用到预搜索\n\njs只支持正向预搜索，也就是xxx后面必须是yyy，或者xxx后面不能是yyy\n\n```javascript\n1(?=2) // 可以匹配12，不能匹配22\n1(?!2) // 可有匹配22，不能匹配12\n```\n\n## 修饰符\n默认正则是区分大小写，这可能并不是我们想要的，正则提供了修饰符的功能，修复的语法如下\n\n```javascript\n/xxx/gi // 最后面的g和i就是两个修饰符\n```\ng正则遇到第一个匹配的字符就会结束，加上全局修复符，可以让其匹配到结束\n\ni正则默认是区分大小写的，i可以忽略大小写\n\nm正则默认情况下，^和$只能匹配字符串的开始和结尾，m修饰符可以让^和$匹配行首和行尾，不理解就看例子\n\n```javascript\n/jing$/ // 能够匹配 'yanhaijing，不能匹配 'yanhaijing\\n'\n/jing$/m // 能够匹配 'yanhaijing， 能够匹配 'yanhaijing\\n'\n\n/^jing/ // 能够匹配 'jing'，不能匹配 '\\njing'\n/^jing/m // 能够匹配 'jing'，能够匹配 '\\njing'\n```\n\n## js使用正则表达式的方法\n正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法\n\n|方法|描述|\n|:---|:---|\n|exec\t|一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。|\n|test\t|一个在字符串中测试是否匹配的RegExp方法，它返回true或false。|\n|match\t|一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。|\n|search\t|一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。|\n|replace\t|一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。|\n|split\t|一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。|\n\n\n当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。如果匹配失败，那么exec方法返回null（也就是false）。\n\n```javascript\nvar text = \"cat, bat, sat, fat\"; var pattern1 = /.at/;\n\nvar matches = pattern1.exec(text);\nconsole.log(matches) //[\"cat\", index: 0, input: \"cat, bat, sat, fat\"]\n```\n\n## 匹配规则\n### 关键字匹配\n常用的匹配方式，通常是通过匹配关键词来实现定位\n\n示例1：正则设定手机号格式\n```js\nvar regex = /^(086-)?1[345789]\\d{9}$/;\nregex.test('15512341234'); // true\n```\n\n示例2：正则将时间格式转换：年/月/日（yyyy/mm/dd）\n```js\nvar date = new Date();\nvar time = date.toISOString();\nvar regex = /^(\\d{4})-(\\d{2})-(\\d{2})(.+)$/;\ntime.replace(regex, '$1/$2/$3'); // \"2019/08/23\"\n```\n\n### 位置匹配\n常用的位置匹配就是^（匹配字符串开头）和$（匹配字符串结尾）。\n另外还有\\b（匹配一个单词边界），\\B（匹配非单词边界）\n\n示例1：把字符串中所有单词的首字母大写\n```js\nvar regex = /\\b[a-z]/g;\nvar str = 'i am cosyer who is a web developers';\nstr.replace(regex, word => word.toUpperCase()); // \"I Am Cosyer Who Is A Web Developers\"\n```\n\n示例2：把字符串中所有每超过3个字符的单词就增加一个短横（-）\n```js\nvar regex = /[a-zA-Z]{3}\\B/g;\nvar str = 'i am cosyer who is a web developers';\nstr.replace(regex, word => word + '-'); // \"i am cos-yer who is a web dev-elo-per-s\"\n```\n\n## 高级用法\n### 贪婪匹配\n\n- 贪婪匹配：趋向于最大长度匹配。（默认）\n- 非贪婪匹配：匹配到结果就好。\n\n示例1：贪婪匹配获取数字\n```js\n'123456789'.match(/\\d+/)[0]; // \"123456789\"\n```\n\n示例2：非贪婪匹配获取数字\n```js\n'123456789'.match(/\\d+?/)[0]; // \"1\"\n```\n\n### 懒惰匹配\n上文中的非贪婪匹配就用到了惰性匹配，其特点就是在其他重复量词后面加上限定符（?）\n惰性匹配的特点：\n\n- 重复量词后面添加限定符（?）\n- 惰性匹配会尽可能少的匹配字符，同时必须满足整个匹配模式。\n\n示例1：非惰性匹配和惰性匹配\n```js\n'123412341234'.match(/1(\\d+)4/)[0]; // \"123412341234\"\n'123412341234'.match(/1(\\d+?)4/)[0]; // \"1234\"\n```\n\n### 先行断言/先行否定断言\n先行断言：x只有在y前面才匹配，必须写成/x(?=y)/的形式。\n先行否定断言：x只有不在y前面才匹配，必须写成/x(?!y)/的形式。\n匹配的结果是x，如通过match方法匹配项会返回x。\n\n示例1：先行断言和先行否定断言的用法\n```js\n/cosyer(?=2019)/.test('cosyer2019'); // true\n/cosyer(?=2019)/.test('cosyer-2019'); // false\n\n/cosyer(?!2019)/.test('cosyer2019'); // false\n/cosyer(?!2019)/.test('cosyer-2019'); // true\n```\n我们可以发现，这里同时包含了关键词匹配和位置匹配，属于正则的高级匹配。\n接下来我们可以看看怎么处理业务中的问题。\n\n示例2：通过正则把数字 1234567890 转换成美元 $1,234,567,890\n```js\nvar str = '1234567890';\nvar regex = /(?!^)(?=(\\d{3})+$)/g;\nstr.replace(regex, ',').replace(/^/, '$'); // \"$1,234,567,890\"\n```\n\n### 后行断言/后行否定断言\n后行断言和先行断言正好相反。\n\n后行断言：x只有在y后面才匹配，必须写成/(?<=y)x/的形式。\n后行否定断言：x只有不再y后面才匹配，必须写成/(?<!y)x/的形式。\n匹配的结果是x，如通过match方法匹配项会返回x。\n\n示例1：后行断言和后行否定断言的用法\n```js\n/(?<=2019)cosyer/.test('2019cosyer'); // true\n/(?<=2019)cosyer/.test('2019-cosyer'); // false\n\n/(?<!2019)cosyer/.test('2019cosyer'); // false\n/(?<!2019)cosyer/.test('2019-cosyer'); // true\n```\n示例2：通过正则把美元 $123,456,789,000 变成美元 $1234,5678,9000\n试着通过先行断言+先行否定断言来处理\n```js\nvar str = '$123,456,789,000';\nvar regex = /(?!^)(?=(\\d{4})+$)/g;\nstr.replace(/,/g, '').replace(regex, ','); // \"$,1234,5678,9000\"\n```\n由于第一个字符是$而不是数字，在这里先行否定断言判断字符串初始无效，所以在$和数字中间出现了逗号分隔符。\n同时也不能把(?!^)改成(?!$)，因为匹配到1234，56789，000的时候前面的字符也不是$而是1，所以仍然会在开头添加一个逗号（,）。\n```js\nvar str = '$123,456,789,000';\nvar regex = /(?!\\$)(?=(\\d{4})+$)/g;\nstr.replace(/,/g, '').replace(regex, ','); // \"$,1234,5678,9000\"\n```\n我们发现，我们只需要排除一种情况，就是$后面跟着逗号的情况。\n这个时候满足后行断言匹配项（x）在美元符号$后面。\n试着通过后行否定断言代替先行否定断言。\n```js\nvar str = '$123,456,789,000';\nvar regex = /(?<!\\$)(?=(\\d{4})+$)/g;\nstr.replace(/,/g, '').replace(regex, ','); // \"$1234,5678,9000\"\n```","tags":["redux"],"categories":["JS"]},{"title":"动手实现redux","url":"%2F%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0redux.html","content":"\n概念：\n- 一个app只有一个store，一个store管理着一个全局state含有以下方法\n  - getState: 获取 state；\n  - dispatch: 触发 action, 更新 state；\n  - subscribe: 订阅数据变更，注册监听器；\n- createStore 传入reducer，返回getState, dispatch, subscribe\n- action是一个至少有type这个键的对象，可以写一个creactAction 函数去return生成action对象\n- createStore.dispatch(action) 根据action这个对象去更新state\n- dispatch是一个函数，内部又将执行reducer函数\n- reducer也是一个函数，传入state,action, 输出一个新的state . (switch case return…)\n  - 遵守数据不可变，不要去直接修改 state，而是返回出一个 新对象；\n  - 默认情况下需要 返回原数据，避免数据被清空；\n  - 最好设置 初始值，便于应用的初始化及数据稳定；\n\n![redux](http://cdn.mydearest.cn/blog/images/redux.png)\n\n---\n<!-- more -->\n\n```html\n<div id = 'title'></div>\n<input type=\"button\" id = \"changeTheme\" value=\"变成蓝色主题\">\n```\n\n```javascript\n// 实现createStore 传入reducer\nfunction createStore(reducer){\n    // 存储数据\n    let state = null\n    // 订阅列表\n    const listenerList=[]\n    // 增加订阅\n    const subscribe=(listener)=>listenerList.push(listener)\n    // 返回state\n    const getState=()=>state \n    // dispatch\n    const dispatch=(action)=>{\n      // 新的state\n      state=reducer(state,action)\n      // 遍历执行\n      listenerList.forEach(item)=>item()\n    }\n    // 初始化state\n    dispatch({})\n    return {getState,subscribe,dispatch}\n}\n\n// 实现reducer\nfunction reducer(state,action){\n  if(!state){\n    return {\n      title:'红色',\n      color:'red'\n    }\n  }\n  switch(action.type){\n    case 'UPDATE_TITLE':\n    return {...state,title:action.title}\n    case 'UPDATE_COLOR':\n    return {...state,color:action.color}\n    default:return state\n  }\n}\n\n// 传入reducer生成store\nconst store = createStore(reducer)\n\n// 渲染代码\nfunction renderDom(state){\n  const titleDOM = document.getElementById('title');\n  titleDOM.innerHTML = state.title;\n  titleDOM.style.color = state.color;\n}\n\n// 监听数据变化重新渲染页面\nstore.subscribe(() => renderDom(store.getState()));// 让每次dispatch时都会执行传入的这个函数，渲染页面\n\n// 首次渲染页面\nrenderDom(store.getState());\n\n// createAction\n// const MAIN_PAGE_TYPE = 'mainPage'\n// export function getMainPage({ name }) {\n//   return {\n//     type: MAIN_PAGE_TYPE,\n//     payload: {\n//       name\n//     }\n//   }\n// }\n\n// action\nconst updateThemeName = () => ({\n  type: 'UPDATE_TITLE',\n  title: '蓝色'\n});\nconst updateThemeColor = () => ({\n  type: 'UPDATE_COLOR',\n  color: 'blue'\n});\n\n// 绑定事件\ndocument.getElementById('changeTheme').onclick = () => {\n  store.dispatch(updateThemeName());\n  store.dispatch(updateThemeColor());\n};\n```\n\n## 实现`bindActionCreator`\n```js\n// 将actionCreator转化成dispatch形式\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function() {\n    return dispatch(actionCreator.apply(this, arguments))\n  }\n}\n\n// 参数actionCreators是一个对象或者函数，dispatch即store.dispatch\n\nexport default function bindActionCreators(actionCreators, dispatch) {\n  // 如果传入是函数，直接返回一个包裹dispatch的函数\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n  // 传入参数不符合规范情况\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, instead received ${\n        actionCreators === null ? 'null' : typeof actionCreators\n      }. ` +\n        `Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?`\n    )\n  }\n  // 传入参数是Object的情况，遍历对象，根据相应的key，生成包裹dispatch的函数\n  const keys = Object.keys(actionCreators)\n  const boundActionCreators = {}\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    const actionCreator = actionCreators[key]\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  // 返回每个value都是包裹dispatch函数的对象\n  return boundActionCreators\n}\n```\n","tags":["redux"],"categories":["JS"]},{"title":"人一生必须要去的3个地方","url":"%2F%E4%BA%BA%E4%B8%80%E7%94%9F%E5%BF%85%E9%A1%BB%E5%8E%BB%E7%9A%843%E4%B8%AA%E5%9C%B0%E6%96%B9.html","content":"\n通常有人说一个人一生最好经常去三个地方看看，人生感悟会提高一个档次，人生观，价值观乃至世界观，都会有一个质的飞跃。这三个地方就是：托儿所、殡仪馆、监狱。 常去托儿所，看到天真烂漫、童真无邪、活泼可爱的孩子们，会更加的体会到生命的重要和可爱，从而更加珍惜生命，热爱生活，激发出更多积极向上的人生志向。 常去殡仪馆，看到撒手人寰逝去的人们，会感受到，人赤条条来，赤条条去，人为财死，鸟为食亡，是多么的狭隘和自私，心胸会豁然开朗，，不会在为鸡毛蒜皮的小事斤斤计较，退一步海阔天空，让三分心平气和。会更加的领会人生的价值所在，让人生更具异彩。 常去监狱，看到无论是过去高官还是贫民百姓，进到监狱没有了姓名，只有号码，一律囚服，进出报告，极大的限制了人身自由，天高任鸟飞，海阔凭鱼跃的现实已经成为梦中的理想。自古就有人犯王法身无主，因此也就会更加的洁身自好，以人为镜，严于律己。守法度者为幸福，世上本没有绝对的自由，遵守了，习惯了，适应了也就自由了。\n\n---\n<!--more-->\n\n中国的人实在是太多了，人均资源少，而且分配不均，旱死的旱死涝死的涝死。小时候奶奶经常说我爸生下来多么瘦小，为了生存还去卖过血。我爸也是从无到有的打拼。我是努力了，但我拼命努力了么？没有！！！是需要有那种不成功便成仁的决心和坚持到底的毅力。是的，我自己什么都将可以牺牲的！要想得到什么必须付出同等的代价。新中国成立解放了人民，同样也诞生了新的剥削阶级。文革各个组织间的利益冲突。中国还是那个中国，似曾相识的中央集权，人民当家做主恩恩，当好韭菜，接收被剥削收割的命运。\n\n自古以来的人情社会，不送礼办不成事，贪污落马的大老虎们一批接一批。拉帮结派、结党营私、官官相护。\n\n- 退休年龄将来目标是65岁退休，现在国人平均寿命接近75岁，10年能拿回多少退休金？- 养老个人部分退休可以逐年领回，但只算本金，按本国多年通货膨胀率测算，退休时相当于多少实际购买力？\n- 社保里有些险种可能多数人用不到，比如失业险，多交了很多人也没得益，算下这种会占多少？\n- 最后，要看是公司单独给员工交满额还是全社会所有公司都交满额。这也有关系？是的，公司是盈利组织，多支付了成本就要想办法收回来。\n\n近些年的社保制度，要知道以前的公寓都是不交养老保险的。现在他们推向还能拿到不菲的养老金。是谁的缴纳的呢？这样的庞氏骗局能持续多久呢？\n\n妈妈的胃结石、奶奶的甲亢、爷爷的骨刺。身体健康最重要，讨厌医院里消毒水和中药的味道。这里的氛围代凯莱达。以前一老以为自己有绝症重病，什么后脑勺的突起，坐摩托车时的心悸，不敢去做刺激性的娱乐项目，以前去方特都只是去坐坐旋转木马，有心脏病。这就是我的极限吗？！\n\n科室真的好赚钱，医生好闲。\n\n努力努力，不想当韭菜了。保护好自己的家人，努力地活下去！！！\n\n一点精神都没有~早知道去苏宁了，果然还是想啥都干外包公司只能温饱，发财是没有希望的。只能去互联网公司。\n不是什么病真是太好了，但是要考公务员。可能会离很远。我为了离得近选择了外包公司，处于鄙视链下，学习受限。接私活。可能去sn这种大公司镀个金也是个好选择吧！大平台之间跳转的重要性。\n\n一天到晚没什么精神，让人好担心。10.3一起煮饭吃了。对菜价什么的也有了大概的了解，生活的丰富多彩。2年不到15k，大城市的高薪真是个诱惑，家里还和我说买车位emmm。\n\nangularjs写的好难受，一个 controller 文件大几千行看的脑胀==。现在经济下行，南京这边没什么的好公司啊。hw桌面云用起来也不太爽，基本有问题一个拉一个最后一堆人定位问题，国际化的多个局点特性也很麻烦，全是业务层面和环境部署。\n\nemmm又得搞讲座，混不过去啊，人多紧张忘词。又不好把问题全贴PPT上，尴尬。全是语法内容其实也没什么好讲的😂搞得Switch都落灰了。\n\n996珍惜时间充分利用时间，不做无效劳动。\n\n在高中的时候身边尚且都是与自己家境相差不大的人，到了大学就彻底显露出阶级差距，家境好的不仅精通外语，而且兴趣广泛，相比之下我们就只会死读书。我们这些底层爬出的年轻人去参加学生会参加招新，竞争不过别人流利的口才，去文艺部又没有傲人的才艺，一时间难免觉得自己一无是处。\n\n1. revenage/respect/insult/limit edu/compare\n2. protect family/stress\n3. enjoy life/interest/enthusiastic\n4. fk fair/breakthrough\n5. strong/advance giant\n6. death\n7. house/physical beauty desire 豪宅、智能家居\n8. science\n\n1. remember packet/jokes\n2. 情绪管理/神经衰弱\n3. 不分场合 dependency=>excuse\n4. selfish 手臂 hug\n5. tourism house\n6. naive 独立思考\n7. 道德绑架 key\n8. lazy/累 做不到的话就别说\n9. 双方父母支持\n10. seisei的身材\n\n1. 不去做的话永远也做不到。\n2. 要想得到什么，必须付出同等的代价。\n3. 我的钻头可是突破天际的钻头啊！\n4. 学习就是不断重复与抄袭的一个过程。\n\n1. eat drink\n2. enjoy nature\n3. work\n4. games\n5. 痒\n6. sleep break\n7. pull and push\n8. wc\n9. 马杀鸡spa\n10. Bath feet\n11. think animate\n12. neck bones\n13. 采耳\n形容词： 白富美、白瘦幼、黑长直、青春qc、肤白貌美\n\n- 马斯洛需求层次理论其基本内容是将人的需求从低到高依次分为生理需求、安全需求、社交需求、尊重需求和自我实现需求五种需求。\n\n- 马太效应是指强者愈强、弱者愈弱的现象。\n\n- 墨菲定律：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。\n\n- 囚徒困境：两个共谋犯罪的人被关入监狱，不能互相沟通情况。如果两个人都不揭发对方，则由于证据不确定，每个人都坐牢一年；若一人揭发，而另一人沉默，则揭发者因为立功而立即获释，沉默者因不合作而入狱十年；若互相揭发，则因证据确凿，二者都判刑八年。由于囚徒无法信任对方，因此倾向于互相揭发，而不是同守沉默。(两个人平分或独占100w)\n\n- 丛林法则是自然界里生物学方面的物竞天择、优胜劣汰、弱肉强食的规律法则。\n\n- 世界五大健康水果\n\n1. 苹果；苹果含有丰富的糖类、有机酸、纤维素、维生素、矿物质、多酚及黄酮类营养物质，降低血脂，降血压，预防癌症。苹果在古希腊神话中，是智慧的象征。\n\n2. 杏；杏中含有丰富的β胡罗卜素，能很好地帮助人摄取维生素A；但不宜多食，一次以3-5枚即可。\n\n3. 香蕉；古印度和波斯民间认为，金色的香蕉果实乃是“上苍赐予人类的保健佳果”。传说佛教始祖释迦牟尼由于吃了香蕉而获得智慧，香蕉因此被誉为“智慧之果”。香蕉含有多种微量元素和维生素，能帮助肌肉松\n弛，使人身心愉悦 ，并具有一定的减肥功效。\n\n4. 黑莓；同等重量黑莓中纤维物质的含量是其他水果的3倍多，毫无疑问对心脏健康有帮助；防衰老，提高免疫力，具有促进脑代谢，降压，降血脂和抗心律失常的作用。\n\n5. 蓝莓；蓝莓是种特别的水果，多吃蓝莓可du减少尿路感染的几率；拥有抗氧化的功能，dao可以减低癌症发生的机会。\n\n活着，即使怎么样也要活着，为自己活着，自残就自残，没人关心只是他们不理解，也不愿意了解。那些什么都不知道的人凭什么劝你为别人活？凭什么觉得自残只是想证明什么？可笑！一个人遇到无论如何都无法解决又不能对抗的痛苦，那他除了找一个能够发泄的途径还能干什么？只是不要做让自己后悔的事，后悔的事情很难挽回。我不知道死能不能让我解脱，但我一定会后悔。凭什么活的这么痛苦了，还要去死呢？那之前的痛苦还有意义吗？甘心吗？我不甘心。一生最美好的，对我来说，就是死的时候，还能发自内心的微笑着去死。现在呢？难道就带着脑子里那些折磨人的东西，结束这一生？总之，不要做让自己后悔的事，即便满身伤痛，也请微笑着活到最后吧！(◦˙▽˙◦)\n\n如果你选择认可且接纳学历的鄙视链，并在生活中处处势利攀比，从心里渴望获得人上人的虚荣，那么你遇到的每一个人都会让你在自大和自卑中反复、徘徊，继而撕裂你的自我认同和自我尊严。长此以往，你确实就完了。\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"toFixed方法注意点","url":"%2FtoFixed%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9.html","content":"\n### 遇到的问题:\n\njs的浮点数运算不准确，(a + b).toFixed(2)能解决一部分问题，但并不完美。\n\n```javascript\n0.1 + 0.2 //0.30000000000000004\n(0.1 + 0.2).toFixed(2) // 0.30\n0.815 + 0.1 // 0.9149999999999999\n(0.815 + 0.1).toFixed(2) // 0.91，错误！期望0.92\n// toFixed并不是我们通常理解的“四舍五入”，而是“四舍六入五留双”\n// 简单来说就是：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为奇应舍去，五前为偶要进一。\n(0.225).toFixed(2) // 0.23\n(0.235).toFixed(2) // 0.23，错误！期望0.24\n```\n---\n<!-- more -->\n\n### 解决方案\n\n网络上有很多种解决方案，可以修正toFixed方法，也可以重新定义四则运算。重新定义四则运算，最为规范，但使用麻烦，故我最终选择了修正toFixed。\n声明：源码来源于网络，本文只是添加了注释和分析。\n\n```javascript\n// 直接替换原型链上的方法，方便使用\nNumber.prototype.toFixed = function (n) {\n  // n为期望保留的位数，超过限定，报错！\n  if (n > 20 || n < 0) {\n    throw new RangeError('toFixed() digits argument must be between 0 and 20');\n  }\n  // 获取数字\n  const number = this;\n  // 如果是NaN,或者数字过大，直接返回'NaN'或者类似'1e+21'的科学计数法字符串\n  if (isNaN(number) || number >= Math.pow(10, 21)) {\n    return number.toString();\n  }\n  // 默认保留整数\n  if (typeof (n) == 'undefined' || n == 0) {\n    return (Math.round(number)).toString();\n  }\n\n  // 先获取字符串\n  let result = number.toString();\n  // 获取小数部分\n  const arr = result.split('.');\n\n  // 整数的情况，直接在后面加上对应个数的0即可\n  if (arr.length < 2) {\n    result += '.';\n    for (let i = 0; i < n; i += 1) {\n      result += '0';\n    }\n    return result;\n  }\n\n  // 整数和小数\n  const integer = arr[0];\n  const decimal = arr[1];\n  // 如果已经符合要求位数，直接返回\n  if (decimal.length == n) {\n      return result;\n  }\n  // 如果小于指定的位数，补上\n  if (decimal.length < n) {\n    for (let i = 0; i < n - decimal.length; i += 1) {\n      result += '0';\n    }\n    return result;\n  }\n  // 如果到这里还没结束，说明原有小数位多于指定的n位\n  // 先直接截取对应的位数\n  result = integer + '.' + decimal.substr(0, n);\n  // 获取后面的一位\n let last = decimal.substr(n, 1);\n if (/^\\d(9){5,}[89]$/.test(decimal.substr(n))) {\n    last += last + 1;\n  }\n  // 大于等于5统一进一位\n  if (parseInt(last, 10) >= 5) {\n    // 转换倍数，转换为整数后，再进行四舍五入\n    const x = Math.pow(10, n);\n    // 进一位后，转化还原为小数\n    result = (Math.round((parseFloat(result) * x)) + 1) / x;\n    // 再确认一遍\n    result = result.toFixed(n);\n  }\n\n  return result;\n};\n```","tags":["知识"],"categories":["JS"]},{"title":"js判断浏览器类型和访问来源","url":"%2Fjs%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%BF%E9%97%AE%E6%9D%A5%E6%BA%90.html","content":"\n`userAgent` 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。\n\n一般来讲，它是在 `navigator.appCodeName` 的值之后加上斜线和 `navigator.appVersion` 的值构成的。\n\n例如：Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322)。\n\n注：用户代理头：user-agent header。\n\n--- \n<!-- more -->\n\n## 判断浏览器类型\n```javascript\n//判断当前浏览类型 \n function BrowserType() \n { \n   var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 \n   var isOpera = userAgent.indexOf(\"Opera\") > -1; //判断是否Opera浏览器 \n   var isIE = userAgent.indexOf(\"compatible\") > -1 && userAgent.indexOf(\"MSIE\") > -1 && !isOpera; //判断是否IE浏览器 \n   var isEdge = userAgent.indexOf(\"Windows NT 6.1; Trident/7.0;\") > -1 && !isIE; //判断是否IE的Edge浏览器 \n   var isFF = userAgent.indexOf(\"Firefox\") > -1; //判断是否Firefox浏览器 \n   var isSafari = userAgent.indexOf(\"Safari\") > -1 && userAgent.indexOf(\"Chrome\") == -1; //判断是否Safari浏览器 \n   var isChrome = userAgent.indexOf(\"Chrome\") > -1 && userAgent.indexOf(\"Safari\") > -1; //判断Chrome浏览器 \n \n   if (isIE)  \n   { \n      var reIE = new RegExp(\"MSIE (\\\\d+\\\\.\\\\d+);\"); \n      reIE.test(userAgent); \n      var fIEVersion = parseFloat(RegExp[\"$1\"]); \n      if(fIEVersion == 7) \n      { return \"IE7\";} \n      else if(fIEVersion == 8) \n      { return \"IE8\";} \n      else if(fIEVersion == 9) \n      { return \"IE9\";} \n      else if(fIEVersion == 10) \n      { return \"IE10\";} \n      else if(fIEVersion == 11) \n      { return \"IE11\";} \n      else \n      { return \"0\"}//IE版本过低 \n    }//isIE end \n     \n    if (isFF) { return \"FF\";} \n    if (isOpera) { return \"Opera\";} \n    if (isSafari) { return \"Safari\";} \n    if (isChrome) { return \"Chrome\";} \n    if (isEdge) { return \"Edge\";} \n  }\n```\n\n## 判断浏览器访问来源\n### 方法1\n```javascript\nwindow.location.href = /Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent) ? \"https://www.baidu.com/\" :  \"http://news.baidu.com/\";\n```\n\n### 方法2\n```javascript\nfunction IsPC() {\n    var userAgentInfo = navigator.userAgent;\n    var Agents = [\"Android\", \"iPhone\",\n                \"SymbianOS\", \"Windows Phone\",\n                \"iPad\", \"iPod\"];\n    var flag = true;\n    for (var v = 0; v < Agents.length; v++) {\n        if (userAgentInfo.indexOf(Agents[v]) > 0) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}\n```\n\n### 方法3\n```javascript\nfunction browserRedirect() {\n    var sUserAgent = navigator.userAgent.toLowerCase();\n    var bIsIpad = sUserAgent.match(/ipad/i) == \"ipad\";\n    var bIsIphoneOs = sUserAgent.match(/iphone os/i) == \"iphone os\";\n    var bIsMidp = sUserAgent.match(/midp/i) == \"midp\";\n    var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == \"rv:1.2.3.4\";\n    var bIsUc = sUserAgent.match(/ucweb/i) == \"ucweb\";\n    var bIsAndroid = sUserAgent.match(/android/i) == \"android\";\n    var bIsCE = sUserAgent.match(/windows ce/i) == \"windows ce\";\n    var bIsWM = sUserAgent.match(/windows mobile/i) == \"windows mobile\";\n    if (!(bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) ){\n        window.location.href=B页面;\n    }\n}\nbrowserRedirect();\n```","tags":["知识"],"categories":["JS"]},{"title":"实现网页顶部加载条loading","url":"%2F%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E9%A1%B6%E9%83%A8%E5%8A%A0%E8%BD%BD%E6%9D%A1loading.html","content":"\n### 为什么要加loading的效果\n\n一款好的产品，都需要有一个漂亮的loading界面。lodaing界面不仅能给用户带来良好的体验，而且有效的消除了程序加载等待过程中的枯躁感。loading进度条更是对当前加载进度的一个良好反馈。从0%-100%的加载进度可以有效的告知用户还有多久即可打开页面。带有进度条的loading界面在程序中并不罕见，但是在web中呢？到目前为止浏览器并没有提供有效的浏览器对象来反馈页面的加载进度，所以无法直接、便捷的获得页面加载进度的反馈。\n\n---\n<!-- more -->\n\n### jquery实现\n```html\n<div id=\"progress\"> \n   <span></span> \n</div> \n```\n\n```css\nbody{ \n      margin:0; \n  } \n  #progress { \n      position:fixed; \n      height: 2px; \n      background:#6bc30d; \n      transition:opacity 500ms linear \n  } \n  #progress.done { \n      opacity:0 \n  } \n  #progress span { \n      position:absolute; \n      height:2px; \n      -webkit-box-shadow:#6bc30d 1px 0 6px 1px; \n      -webkit-border-radius:100%; \n      opacity:1; \n      width:150px; \n      right:-10px; \n      -webkit-animation:pulse 2s ease-out 0s infinite; \n  } \n \n  @-webkit-keyframes pulse { \n      30% { \n          opacity:.6 \n      } \n      60% { \n          opacity:0; \n      } \n      100% { \n          opacity:.6 \n      } \n} \n```\n\n```javascript\n$({property: 0}).animate({property: 100}, { \n    duration: 2000, \n    step: function() { \n        var percentage = Math.round(this.property); \n \n        $('#progress').css('width',  percentage+\"%\"); \n \n         if(percentage == 100) { \n                $(\"#progress\").addClass(\"done\");//完成，隐藏进度条 \n            } \n    } \n}); \n```\n\n### tip\n- 这种方法简单明了，但兼容性不是太好。主流的浏览器肯定没有问题，但如果考虑IE兼容性的，就不要用此方法了。\n- duration是设置时间的。默认是2秒。换算代码：2000=2秒\n- 请引入jquery库文件。否则程序不会运行\n\n","tags":["知识"],"categories":["JS"]},{"title":"Sass学习笔记","url":"%2Fsass.html","content":"\n### 简介\nSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。\n\n---\n<!--more-->\n\n### 导入\n```javascript\n@import \"reset.css\"; // css\n@import \"index\"; // sass\n```\n\n### 变量\n```javascript\n// 普通变量\n$fontSize:16px;\n\n// 默认变量\n$baseLineHeight: 1.5 !default;\n\n// 覆盖默认变量，需要写在 !default 前面\n$baseLineHeight: 1.7;\n$baseLineHeight: 1.5 !default;\n\n// 一维 list\n$px: (5px 10px 20px 30px);\n\n// 二维 list\n$px: (5px 10px)\n     (20px 30px);\n// 或者\n$pxs: 5px 10px, 20px 30px;\n\n// Map 类似对象\n$heading: (\n    h1: 2em,\n    h2: 1.5em,\n    h3: 1.2em\n);\n```\n\n### 插值\n插值使用 #{}\n\n```javascript\n// Variables\n$mySelector: banner;\n\n// .banner\n.#{mySelector} {\n    font-weight: bold;\n    line-height: 40px;\n    margin: 0 auto;\n}\n```\n\n### 跳出嵌套\n@at-root (without: rule| all | media)\n\n```javascript\n// 跳出普通的嵌套\n.demo {\n    animation: motion 3s infinite;\n\n    @at-root {\n        @keyframes motion {\n          ...\n        }\n    }\n}\n\n// 跳出 media 嵌套\n@media print {\n    .parent2{\n        color:#f00;\n\n        @at-root (without: media) {\n            .child2 {\n                width:200px;\n            }\n        }\n    }\n}\n```\n\n### 混合(mixin)\n使用 @mixin 声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。\n@mixin 通过 @include 来调用。\n混合器中不仅可以包含属性，也可以包含 css 规则，包含选择器和选择器中的属性，也可以使用 & 上下文。\n\n为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示\n\n```javascript\n// 无参数\n@mixin block {\n    display: block;\n}\n\n// css 规则，注意上下文\n@mixin no-bullets {\n    list-style: none;\n    li {\n        list-style-image: none;\n        list-style-type: none;\n        margin-left: 0px;\n    }\n}\n\n// 带参数\n@mixin opacity($opacity: 50) {\n    opacity: $opacity / 100;\n    filter: alpha(opacity=$opacity);\n}\n\n// 多个参数\n@mixin horizontal-line($border: 1px dashed #ccc, $padding: 10px){\n    border-bottom: $border;\n    padding-top: $padding;\n    padding-bottom: $padding;\n}\n\n@include horizontal-line($padding: 15px);\n\n// 多组值参数\n@mixin box-shadow($shadow...) {\n    -webkit-box-shadow:$shadow;\n    box-shadow:$shadow;\n}\n\n@include box-shadow(\n    0 2px 2px rgba(0, 0, 0, 0.3),\n    0 3px 3px rgba(0, 0, 0, 0.2)\n);\n```\n\n#### @Content\n@content 它可以使 @mixin 接受一整块样式，接受的样式从 @content 开始。\n\n```javascript\n@mixin max-screen($res) {\n    @media only screen and ( max-width: $res ) {\n        @content; // body { color: red }\n    }\n}\n\n@include max-screen(480px) {\n    body { color: red } // 这里就i @content 引用的内容\n}\n```\n\n## 继承\n选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend，后面紧跟需要继承的选择器。\n继承可以继承默认的元素属性，比如让一个div继承a，那么这 div 看起来就好像 a 一样。\n\n```javascript\n// 继承现有的标签，或类\nh1{\n    border: 4px solid #ff9aa9;\n}\n.speaker{\n    @extend h1;\n    border-width: 2px;\n}\n```\n\n## 占位选择器%\n可以定义占位选择器 %，如果不调用则不会有任何多余的 css 代码。\n\n```javascript\n%block {\n    display: block;\n}\n\n.box {\n    @extend %block;\n}\n```\n\n## 函数\nsass定义了很多函数可供使用，当然你也可以自己定义函数，以@fuction开始。\n\n使用最多的是颜色函数：\n颜色函数中又以 lighten 减淡和 darken 加深为最，\n其调用方法为 lighten($color, $amount) 和 darken($color, $amount)\n它们的第一个参数都是颜色值，第二个参数都是百分比。\n\n```javascript\n@function pxToRem($px) {\n    @return $px / $baseFontSize * 1rem;\n}\nbody {\n    color: lighten($gray, 10%); // 直接使用\n}\ndiv {\n    font-size: pxToRem(16px);\n    color: darken($gray, 10%);\n}\n```\n\n## @if判断\n@if 可一个条件单独使用，也可以和 @else 结合多条件使用\n\n```javascript\n$big: false;\np {\n    @if $big == false {\n        margin: 10px;\n    }\n    @else {\n        margin: 10px auto;\n    }\n}\n```\n\n## 三目判断\n语法为：if($condition, $if_true, $if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值。\n\n```javascript\n$min: 20;\np {\n    color: if($min > 10, red, blue); // blue\n}\n```\n\n## for循环\nfor 循环有两种形式，分别为：@for $var from [start] through [end] 和 @for $var from [start] to [end]。\n关键字through表示包括end这个数，而to则不包括end这个数。\n\n```javascript\n@for $i from 1 through 3 {\n    .item-#{$i} { width: 2em * $i; }\n}\n```\n\n## @each 循环\n语法为：@each $var in [list or map]\n\n```javascript\n$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);\n@each $header, $size in $headings {\n    #{$header} {\n        font-size: $size;\n    }\n}\n```\n","tags":["Sass"],"categories":["CSS"]},{"title":"如何练就超强的学习能力","url":"%2F%E5%A6%82%E4%BD%95%E7%BB%83%E5%B0%B1%E8%B6%85%E5%BC%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B.html","content":"\n### 学习开始前的准备\n\n心态我认为世界上没有“困难”的内容，只有“简单但是不完整”的内容。爱因斯坦说：“如果你不能让一个五岁小孩理解你的概念，那就意味着你对这个概念不够了解。”这句话的含义很丰富。首先，为什么一个五岁小孩具备可以理解所有概念的能力？因为所有概念本质上都是一个逻辑链条，一环接一环。只要把每一个环节的逻辑理解了，那你对这个概念本身就理解透了。这个逻辑链条上的每一环都不困难，所以一个五岁小孩都能理解。理解一个概念最困难的地方在于填补一个断裂的逻辑链条。很多时候，教科书里会说：“因为A，所以C。” 然而那个概念其实是“因为A，所以B，所以C。”在这个时候我们就会头大：看不懂A和C之间的联系啊，难道是因为A所以D所以C？还是因为A所以E所以C？困难就是在这个过程中出现的。我们都曾有过这个经历：自己苦苦思索了许久的难题，在别人一两句话的点拨下就豁然开朗。这种经历的本质就是对方告诉了你：“A和C之间缺失的那个部分是B。”从A到B到C的逻辑不难，难的是修补A和C之间断裂的逻辑链条。因此，我再次重复：世界上没有“困难”的内容，只有“简单但是不完整”的内容。当你在学习上感到气馁时，记住上面这句话，它将会给你继续探索的信心和勇气。\n\n---\n<!-- more -->\n\n### 痴迷（obsession）\n\n“痴迷”是我用过的最有效的方法。当我学到一个新概念时，如果我不能马上理解它，我就会一整天反复在脑中思索这个概念：走路时、吃饭时、坐车时都在思考。其实就是把别人看手机的时间拿来思考概念了。但是“痴迷”和常见的“利用碎片时间”有一个根本性的不同。利用碎片时间是被动的，是“因为我有这些时间，所以我要利用好它”；而痴迷是主动的，是“我对这个内容很好奇，所以我要弄懂它。”换句话说，利用碎片时间的重点在于“利用时间”，而痴迷的重点在于“你很好奇”。当你用“痴迷”的方法想通一个概念时，你就会把这个概念记得特别牢固，因为1）你花了很多时间反复思考它，这本身就是一个记忆的过程；2）你对这个概念会有自己的理解，知其然并知其所以然，而不是单纯把教科书背了下来。“知其然并知其所以然”意味着当你对这个概念的记忆变得模糊时，你脑里将有更多关于这个概念的内容来“提示”你将其记起来。\n\n### 有效率的学习策略\n\n当你遇到一道数学难题时，你会怎么做？查答案？自己苦苦思索？开始玩手机逃避？我的做法是在有答案的情况下先查答案，不浪费时间在解题过程上，而是把时间都花在理解概念上。这样才可以把时间的效用最大化，因为难题都是树的叶子，而题目考察的概念是树的主干。一棵树只有一个主干，但是可以有茫茫多的叶子。如果你每个难题都自己思索的话，你大概率得学到猴年马月了。因此，应对难题最好的方法不是硬刚，而是找答案。","tags":["杂谈"],"categories":["杂谈"]},{"title":"选择","url":"%2F%E9%80%89%E6%8B%A9.html","content":"\n{% centerquote %} \n没有方向的船，任何方向都是逆风。\n{% endcenterquote %} \n\n{% centerquote %} \n拼命活下去，发现更大的世界。\n{% endcenterquote %} \n\n选择比努力更加重要。在中国这个有着特殊国情的国家里，个人的位置是很难找准定位的。混的差了，被人鄙夷。混的好了招人记恨。人就是喜欢互相比较，每个人的学习产出比是不一样的。不满足于现状，总想着明天一定比今天的自己强。\n\n--- \n<!--more-->\n\n每个人的格局和所谓的幸福度都是不一样的，nj1年10k看上去已经不错了，比上不足比下有余。有很多老家的年轻人拿着微薄的薪水过着随遇而安的生活，而有自尊心希望受到别人的肯定，努力地活下去。去外包就去外包吧，钱给足也是可以的。福利待遇有不错。就是估计要上sn和tn的黑名单了，发了offer都不去。。。也有需要重新租房等一系列问题。就是技术单一，工作环境差，内网环境。不管怎样都不能懈怠，不会这么一直干下去。但是福利待遇还是不错的，不断充实自己的技能。存量与增量\n\n风味人间真好看，流口水=3=\n2018.11.20又让我想起了revenge，生活是需要`passion`，`enthusastic`，`motion`,`stress`。\n\n制定计划，时间管理。做一个好看的todoList。区别于其他人，自主思考、甄别是非的能力。\n\n`成功男士` --- 自身的强大\n- 教育\n- 私活\n- 店面\n- 营养师\n- 理财","tags":["杂谈"],"categories":["杂谈"]},{"title":"console控制台优化","url":"%2Fconsole%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.html","content":"\n熟悉前端的不会对console和alert陌生，两者在调试的时候可谓是法宝级别的工具，但是关于console，其实远远不止于console.log这一个简单的命令，它能做的事情有很多，那么让我们来一起了解一下，它有哪些冷门功能吧。\n\n---\n<!--more-->\n### 显示信息的命令\n```javascript\nconsole.log('hello world');\nconsole.info('信息');\nconsole.debug('调试');\nconsole.error('错误');\nconsole.warn('警告');\n```\n\n### 占位符\n​ console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）\n\n```javascript\nconsole.log(\"%d年%d月%d日\",2016,11,11);\n```\n\n### 信息分组\n```javascript\nconsole.group(\"第一组信息\");\nconsole.log(\"第一组第一条:何问起(http://hovertree.com)\");\nconsole.log(\"第一组第二条:柯乐义(http://keleyi.com)\");\nconsole.groupEnd();\nconsole.group(\"第二组信息\");\nconsole.log(\"第二组第一条:HoverClock 一个jQuery时钟插件\");\nconsole.log(\"第二组第二条:欢迎使用\");\nconsole.groupEnd();\n```\n\n### 对象信息\n```javascript\nvar obj={\n    id:1,\n    name:123\n}\nconsole.dir(obj)\n```\n\n### 显示网页节点\n```javascript\nconsole.dirxml()用来显示网页的某个节点（node）所包含的html/xml代码\nvar info = document.getElementById('info');\nconsole.dirxml(info);\n```\n\n### 判断变量是否为真\n​console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。\n\n```javascript\nconsole.assert(1 == 1); \nconsole.assert(1 == 2); // Assertion failed: console.assert\n```\n\n### 追踪函数的调用踪迹\n```javascript\nfunction add(a,b){\nconsole.trace();\nreturn a+b;\n}\nvar x = add3(1,1);\nfunction add3(a,b){return add2(a,b);}\nfunction add2(a,b){return add1(a,b);}\nfunction add1(a,b){return add(a,b);}\n// add add1 add2 add3\n```\n\n### 计时功能\nconsole.time()和console.timeEnd()，用来显示代码的运行时间。\n\n```javascript\nconsole.time(\"控制台计时器一\");\nfor(var i=0;i<10000;i++){\nfor(var j=0;j<1000;j++){}\n}\nconsole.timeEnd(\"控制台计时器一\");\n```","tags":["优化"],"categories":["知识"]},{"title":"前端性能优化","url":"%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html","content":"\n前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。\n---\n<!--more-->\n\n![optimize](http://cdn.mydearest.cn/blog/images/optimize.png)\n\n## 页面的内容\n1. 通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。\n\n2. 通过 DNS 缓存等机制来减少 DNS 的查询次数。\n\n3. 通过设置缓存策略，对常用不变的资源进行缓存。\n\n4. 使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。\n\n5. 通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。组件路由按需加载。\n\n6. 不管对于CSR或者SSR，都建议配合使用Service worker，来控制资源的调配及骨架屏秒开的体验。\n\n## 服务器\n1. 使用 CDN 服务，来提高用户对于资源请求时的响应速度。\n\n2. 服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。\n\n3. 尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie\n\n## CSS 和 JavaScript\n1. 把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。\n\n2. 避免使用 @import 标签。\n\n3. 尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。\n\n4. 通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。\n\n## 资源合并压缩 减少HTTP请求\n### 尽量合并和压缩html css和js文件 借助前端工具 例如 webpack gulp grunt...\n### 开启gzip压缩\n\n## 图片优化\n### 雪碧图 图片压缩 svg base64\n\n## 懒加载 / 预加载\n### 懒加载：图片进入可视区域之后请求图片资源 对于电商等图片很多，页面很长的业务场景适用 并发加载的资源过多会阻塞 js 的加载，影响网站的正常使用\n### 预加载：图片等静态资源在使用之前的提前请求 资源使用到时能从缓存中加载，提升用户体验\n\n## 浏览器存储\n### localStorage：大小为 5M 左右仅在客户端使用，不和服务端进行通信 浏览器本地缓存方案\n### indexedDB：用于客户端存储大量结构化数据 为应用创建离线版本\n\n## 浏览器缓存\n### 强缓存：\n\n- expires：\n缓存过期时间，用来指定资源到期的时间，是服务器端的绝对时间\n告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求\n\n- cache-control：max-age = xxx\n声明该资源在加载后的xxx秒内都直接使用缓存 使用的是相对时间 即加载文件本机的时间\n\n如果在Cache-Control响应头设置了 \"max-age\" 或者 \"s-max-age\" 指令，那么 Expires 头会被忽略。\n\n\n### 协商缓存：\n\n> 触发条件\n\n> Cache-Control 的值为 no-cache （不强缓存）\n> max-age 过期了 （强缓存，但总有过期的时候）\n\n- Last-Modified / If-Modified-Since\n\nLast-Modified ------- response header\nIf-Modified-Since ------- request header\n缺点：某些服务端不能获取精确的修改时间；文件修改时间改了，但文件内容却没有变\n\n- Etag / If-None-Match\n\n文件内容的 hash 值\netag ------- response header\nif-none-match ------- request header\n\n## CDN 内容分发网络\njsdelivr/PicGo\n\n## 前端错误监控以及上报\n- 前端错误分类：\n\n1. 即时运行错误：代码错误\n2. 资源加载错误\n3. 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性，并且服务器添加Access-Control-Allow-Origin\n\n- 即时运行错误捕获\n（1）try ....catch\n（2) window.onerror 或者 window.addEventListener 记住事件捕获阶段获得，不是冒泡阶段\n\n\n- 资源加载错误\n（1）object.onerror，如img.onerror\n（2）performance.getEntries （getEntries api返回一个资源加载完成数组，假设为img，再查询页面中一共有多少个img，二者的差就是没有加载上的资源）\n（3）Error事件捕获\n\n4. 错误如何上报\n- ajax\n- image的src上报\n```js\n(new Image()).src = '错误上报的请求地址'\n```\n\n一般来说都是采用image对象的方式上报错误的；使用图片发送get请求，上报信息，由于浏览器对图片有缓存，同样的请求，图片只会发送一次，避免重复上\n报。\n","tags":["性能优化"],"categories":["JS"]},{"title":"classNames在react上的应用","url":"%2FclassNames%E5%9C%A8react%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8.html","content":"\n### 前言\n\n在 Vue 里有一个动态的 class 语法，很好的根据条件动态设置 class。例如：\n\n```javascript\n<div class=\"button\" :class=\"{ active: show }\"></div>\n```\n就是当 show 为 true 时，此标签被赋予 active 样式。\n\n在 React 要实现这样功能，可能会这样做：\n\n```javascript\n<div className={`button ${show ? 'active' : ''}`}></div>\n```\n注意到，这里只有一个属性判断，如果有多个时会显得非常麻烦，那么现在使用 [ClassNames](https://github.com/JedWatson/classnames) 这个库来解决这个问题。\n\n---\n<!-- more -->\n\n### 基本使用\n`ClassNames` 是一个高性能、简便的用户根据条件动态设置 `className` 的 `Javascript` 库。\n\n它的使用非常简单，来看看下面的几种使用方式。（自己也可以开发一个类似的库，不过没必要再造轮子）\n\n```javascript\nimport classNames from 'classnames';\n\nclassNames('foo', 'bar');                   // => 'foo bar'\nclassNames('foo', { bar: true });           // => 'foo bar'\nclassNames({ 'foo-bar': true });            // => 'foo-bar'\nclassNames({ 'foo-bar': false });           // => ''\nclassNames({ foo: true }, { bar: true });   // => 'foo bar'\nclassNames({ foo: true, bar: true });       // => 'foo bar'\n\n// 多级嵌套，多参数\nclassNames('foo', { bar: true, duck: false }, 'baz', { quux: true });\n// => 'foo bar baz quux'\n\n// !! 为 false 的将被忽略\nclassNames(null, false, 'bar', undefined, 0, 1, { baz: null }, '');\n// => 'bar 1'\n```\n\n### 动态属性名\n在 ES6 下，可以使用模板语法，来设置跟强大的动态 `className`。\n\n```javascript\nconst buttonType = 'primary';\nclassNames({ [`btn-${buttonType}`]: true });\n```\n\n### 去重功能dedupe\n使用 dedupe 版本的 classNames 可以正确地对类进行重复数据删除，并确保在后面的参数中指定的错误类从结果集中排除。dedupe 会慢（约5倍），因此它是作为选择提供的（在默认是不会去重的）。\n\n```javascript\nimport classNames from 'classnames/dedupe';\n\nclassNames('foo', 'foo', 'bar');                // => 'foo bar'\nclassNames('foo', { foo: false, bar: true });   // => 'bar'\n```\n### 映射bind\n如果您使用 css-modules 或类似的方法来抽象类“名称”以及 className 实际输出到 DOM 的真实值，那么要使用 bind 版本。\n\n```javascript\nimport classNames from 'classnames/bind';\n// 映射关系\nconst styles = {\n    foo: 'abc',\n    bar: 'def',\n    baz: 'xyz'\n};\n\nconst cx = classNames.bind(styles);\nconst className = cx('foo', ['bar'], { baz: true });  //（1） => \"abc def xyz\"\n// const className = cx('abc', ['def'], { xyz: true }); （2）\n```\n这里什么意思呢？实际上就是把 foo 与 abc 产生映射，也就是说 （1） 和 （2） 两条语句是等效的，好处就像是定义一些常量一样。\n\n### 在React上使用\n如antd上的源码，prefix定义class\n\n```javascript\nconst prefixCls = 'alter';\n\nconst classs = classNames(prefixCls, {\n    [`${prefixCls}-${type}`]: true,\n    [`${prefixCls}-close`]: !this.state.closing,\n    [`${prefixCls}-with-description`]: !!description,\n    [`${prefixCls}-no-icon`]: !showIcon,\n    [`${prefixCls}-banner`]: !!banner,\n}, className);\n```\n\n### 参考资料\n- https://github.com/JedWatson/classnames\n- https://www.npmjs.com/package/classcat","tags":["react"],"categories":["JS"]},{"title":"generator生成器","url":"%2Fes6generator.html","content":"\n生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字，有意思的是函数会在每个yield后暂停。\n\n这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。\n\n--- \n<!-- more -->\n\nOK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。\n\n- function 关键字与函数名之间有一个星号；\n- 函数体内部使用 yield表达式，定义不同的内部状态；\n- next 指针移向下一个状态\n\n```javascript\n// 生成器 最大的特点是可以交出函数的执行权\nfunction *createGenerator(){\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\n// 迭代器\nlet iterator=createGenerator()\nconsole.log(iterator.next().value) // 1\nconsole.log(iterator.next().value) // 2\nconsole.log(iterator.next().value) // 3\n```\n\n```js\nfunction *foo(x) {\n  let y = 2 * (yield (x + 1))\n  let z = yield (y / 3)\n  return (x + y + z)\n}\nlet it = foo(5)\nconsole.log(it.next())   // => {value: 6, done: false}\nconsole.log(it.next(12)) // => {value: 8, done: false}\nconsole.log(it.next(13)) // => {value: 42, done: true}\n```\n1. 首先 Generator 函数调用时它会返回一个迭代器\n2. 当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6\n3. 当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 \nyield 等于 2 * 12 / 3 = 8\n4. 当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42\n\n那生成器和迭代器又有什么用处呢？\n\n围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。\n\n生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。\n\n那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的：\n\n```javascript\nfunction run(taskDef){\n  // 创建迭代器，让它在别处可用\n  let task=taskDef();\n\n  // 启动任务\n  let result=task.next();\n\n  // 递归使用函数来保持对next()的调用\n  function step(){\n      // 如果还有更多要做的\n      if(!result.done){\n        result=task.next();\n        step();\n      }\n  }\n\n  // 开始处理过程\n  step();\n}\n```\n生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。可以不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 \n`yield` 来等待异步操作结束。\n\nes6引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n```javascript\nfunction timeout(ms){\n  return new Promise((resolve)=>{\n      setTimeout(resolve,ms)\n  });\n}\n\nasync function asyncPrint(value,ms){\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world',50)\n```\n\n一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\nasync函数对 Generator 函数的改进，体现在以下四点：\n- 内置执行器\n- 更好的语义\n- 更广的适用性\n- 返回值是Promise\n\n## 可迭代对象的特点\n1. 知道如何每次访问集合中的一项，并跟踪该序列中的当前位置\n2. 提供而next方法，来返回序列中的下一项(value, done)\n3. 迭代器一旦被创建，可以反复调用next\n\n```js\nfunction makeIterator(array){\n    var nextIndex = 0;\n    return {\n       next: function(){\n           return nextIndex < array.length ?\n               {value: array[nextIndex++], done: false} :\n               {done: true};\n       }\n    };\n}\n// 使用 next 方法依次访问对象中的键值\nvar it = makeIterator(['step', 'by','step']);\nconsole.log(it.next().value); // 'step'\nconsole.log(it.next().value); // 'by'\nconsole.log(it.next().value); // 'step'\nconsole.log(it.next().value);  // undefined\nconsole.log(it.next().done); // true\n```\n","tags":["es6"],"categories":["JS"]},{"title":"移动端web问题总结（长期更新）","url":"%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html","content":"\n## meta基础知识\n### H5页面窗口自动调整到设备宽度，并禁止用户缩放页面\n```javascript\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```\n\n## ios竖屏拍照上传，图片被旋转问题\n```js\n// 1.通过第三方插件exif-js获取到图片的方向\n// 2.new一个FileReader对象，加载读取上传的图片\n// 3.在fileReader的onload函数中，得到的图片文件用一个Image对象接收\n// 4.在image的onload函数中，利用步骤1中获取到的方向orientation，通过canvas旋转校正，重新绘制一张新图\n// 注意iPhone有3个拍照方向需要处理，横屏拍摄，home键在左侧，竖屏拍摄，home建上下\n// 5.将绘制的新图转成Blob对象，添加到FormData对象中，然后进行校正后的上传操作\n// 代码有点杂，待整理后上传，网上应该是可以找到的\n```\n\n## ios：DOM元素固定一边，另一边滚动，滚动很卡的问题\n```js\n// (横向滚动用的多些)简单粗暴的办法，样式添加如下属性\n-webkit-overflow-scrolling: touch;\n```\n\n## 部分手机第三方输入法会将页面网上挤的问题\n```js\n// 特定需求页面，比如评论页面，输入框在顶部之类的\nconst interval = setInterval(function() {\n    document.body.scrollTop = 0;\n}, 100)\n// 注意关闭页面或者销毁组件的时候记得清空定时器\nclearInterval(interval);\n```\n\n## iPhoneX适配\n```\n// 1.viewport meta 标签增加属性viewport-fit=cover\n<meta name=\"viewport\" content=\"width=device-width, viewport-fit=cover, xxxx\">\n// 2.body元素增加样式\nbody {\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n// 3.如有fixed底部的元素，也增加上面样式\nxxx {\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n  background-color: #fff; // 记得添加background-color，不然会出现透明镂空的情况\n}\n```\n\n## 某些机型不支持video标签的poster属性，特别是安卓\n```js\n用图片元素 <img />来代替poster\n播放前显示<img />，隐藏 <video />\n播放后显示<video />，隐藏 <img />\n```\n\n## CSS透明度颜色设置问题\n```\nAndroid部分不支持 hex写法，推荐用rgba的写法\n#0000009c --> rgba(0, 0, 0, 0.61)\n```\n\n## flex对低版本的ios和Android的支持问题\n```js\n// 使用postcss的autoprefixer插件，自动添加浏览器内核前缀，\n// 并且增加更低浏览器版本的配置，自动添加flex老版本的属性和写法\nautoprefixer({\n    browsers: [\n        'iOS >= 6',     // 特殊处理支持低版本IOS\n        'Safari >= 6',  // 特殊处理支持低版本Safari\n    ],\n}),\n```\n\n## ios 页面回退到长列表出现灰色遮挡问题\n```\n方案1：对列表数据进行缓存，比如redux之类的用法。\n方案2：回退时，跳到页面顶部。\nconst timer = setTimeout(() => {\n    window.scrollTo(0, 1);\n    window.scrollTo(0, 0);\n}, 0);\n```\n\n## ios 日期转换NAN的问题\n```\n将日期字符串的格式符号替换成'/'。\n栗子：'yyyy-MM-dd'.replace(/-/g, '/')\n```\n\n## react未知错误异常，导致页面崩溃，空白\n```\nReact 16.x 增加了componentDidCatch() 生命周期方法\n捕获全局异常来进行页面的友好提示\n```\n\n## 移动端适配\n- 媒体查询\n- px2rem\n- flexible\n- flex\n- grid\n- 百分比\n","tags":["知识"],"categories":["知识"]},{"title":"react组件实现按需加载","url":"%2Freact%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD.html","content":"\n随着前端应用体积的扩大，资源加载的优化是我们必须要面对的问题，动态代码加载就是其中的一个方案，webpack 提供了符合 ECMAScript 提案 的 `import()` 语法 ，让我们来实现动态地加载模块（注：require.ensure 与 import() 均为 webpack 提供的代码动态加载方案，在 webpack 2.x  中，require.ensure 已被 import 取代）。\n\n## React.lazy 是什么\n在 React 16.6 版本中，新增了 React.lazy 函数，它能让你像渲染常规组件一样处理动态引入的组件，配合 webpack 的 Code Splitting ，只有当组件被加载，对应的资源才会导入 ，从而达到懒加载的效果。\n\n## 使用 React.lazy\n```js\n// 不使用 React.lazy\nimport OtherComponent from './OtherComponent';\n// 使用 React.lazy\nconst OtherComponent = React.lazy(() => import('./OtherComponent'))\n```\n\nReact.lazy 接受一个函数作为参数，这个函数需要调用 import() 。它需要返回一个  Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件。\n\n在控制台打印可以看到，React.lazy 方法返回的是一个 lazy 组件的对象，类型是 react.lazy，并且 lazy 组件具有 _status 属性，与 Promise 类似它具有 Pending、Resolved、Rejected 三个状态，分别代表组件的加载中、已加载、和加载失败三种状态。\n\n> 需要注意的一点是，React.lazy 需要配合 Suspense 组件一起使用，在 Suspense 组件中渲染 React.lazy 异步加载的组件。如果单独使用 React.lazy，React 会给出错误提示。其中在 Suspense 组件中，\nfallback 是一个必需的占位属性，如果没有这个属性的话也是会报错的。\n\n```js\n// 延迟加载回调 不需要加载效果设置为null maxDuration可以设置最大持续时间 最新版本中已移除了这个属性\nconst SuspenseComponent = (Component) => (props) => {\n  return (\n    <Suspense fallback={Math.random() >= 0.5 ? <Loading /> : <SkeletonView />}>\n      <Component {...props}></Component>\n    </Suspense>\n  );\n};\n...\n...\ncomponent: SuspenseComponent(OtherComponent),\n```\n\n---\n<!--more-->\n\n## Webpack 动态加载\n上面使用了 `import()` 语法，webpack 检测到这种语法会自动代码分割。使用这种动态导入语法代替以前的静态引入，可以让组件在渲染的时候，再去加载组件对应的资源。这个异步加载流程的实现机制是怎么样\n呢？\n\n```js\n__webpack_require__.e = function requireEnsure(chunkId) {\n    // installedChunks 是在外层代码中定义的对象，可以用来缓存了已加载 chunk\n  var installedChunkData = installedChunks[chunkId]\n    // 判断 installedChunkData 是否为 0：表示已加载 \n  if (installedChunkData === 0) {\n    return new Promise(function(resolve) {\n      resolve()\n    })\n  }\n  if (installedChunkData) {\n    return installedChunkData[2]\n  } \n  // 如果 chunk 还未加载，则构造对应的 Promsie 并缓存在 installedChunks 对象中\n  var promise = new Promise(function(resolve, reject) {\n    installedChunkData = installedChunks[chunkId] = [resolve, reject]\n  })\n  installedChunkData[2] = promise\n  // 构造 script 标签\n  var head = document.getElementsByTagName(\"head\")[0]\n  var script = document.createElement(\"script\")\n  script.type = \"text/javascript\"\n  script.charset = \"utf-8\"\n  script.async = true\n  script.timeout = 120000\n  if (__webpack_require__.nc) {\n    script.setAttribute(\"nonce\", __webpack_require__.nc)\n  }\n  script.src =\n    __webpack_require__.p +\n    \"static/js/\" +\n    ({ \"0\": \"alert\" }[chunkId] || chunkId) +\n    \".\" +\n    { \"0\": \"620d2495\" }[chunkId] +\n    \".chunk.js\"\n  var timeout = setTimeout(onScriptComplete, 120000)\n  script.onerror = script.onload = onScriptComplete\n  function onScriptComplete() {\n    script.onerror = script.onload = null\n    clearTimeout(timeout)\n    var chunk = installedChunks[chunkId]\n    // 如果 chunk !== 0 表示加载失败\n    if (chunk !== 0) {\n        // 返回错误信息\n      if (chunk) {\n        chunk[1](new Error(\"Loading chunk \" + chunkId + \" failed.\"))\n      }\n      // 将此 chunk 的加载状态重置为未加载状态\n      installedChunks[chunkId] = undefined\n    }\n  }\n  head.appendChild(script)\n    // 返回 fulfilled 的 Promise\n  return promise\n}\n```\n\n结合上面的代码来看，webpack 通过创建 script 标签来实现动态加载的，找出依赖对应的 chunk 信息，然后生成 script 标签来动态加载 chunk，每个 chunk 都有对应的状态：未加载 、 加载中、已加载 。\n\n\n## Suspense\nSuspense 内部主要通过捕获组件的状态去判断如何加载，上面我们提到 React.lazy 创建的动态加载组件具有 Pending、Resolved、Rejected 三种状态，当这个组件的状态为 Pending 时显示的是 Suspense \n中 fallback 的内容，只有状态变为 resolve 后才显示组件。\n\n\n## Error Boundaries 统一处理资源加载失败场景\n如果遇到网络问题或是组件内部错误，页面的动态资源可能会加载失败，为了优雅降级，可以使用 [Error Boundaries](https://react.docschina.org/docs/error-boundaries.html) 来解决这个问题。\nError Boundaries 是一种组件，如果你在组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 生命周期函数，它就会成为一个  Error Boundaries 的组件。\n\n```js\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n​\n  static getDerivedStateFromError(error) { \n      // 更新 state 使下一次渲染能够显示降级后的 UI\n      return { hasError: true };  \n  }\n  componentDidCatch(error, errorInfo) { \n      // 你同样可以将错误日志上报给服务器\n      logErrorToMyService(error, errorInfo);\n  }\n  render() {\n    if (this.state.hasError) { \n        // 你可以自定义降级后的 UI 并渲染      \n        return <h1>对不起，发生异常，请刷新页面重试</h1>;    \n    }\n    return this.props.children; \n  }\n}\n```\n你可以在 componentDidCatch  或者 getDerivedStateFromError 中打印错误日志并定义显示错误信息的条件，当捕获到 error 时便可以渲染备用的组件元素，不至于导致页面资源加载失败而出现空白。\n\n```js\n<ErrorBoundary>\n  <App />\n</ErrorBoundary>\n```\n\n> 需要注意的是：错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。\n\n## 总结\nReact.lazy()  和 React.Suspense 的提出为现代 React 应用的性能优化和工程化提供了便捷之路。 React.lazy 可以让我们像渲染常规组件一样处理动态引入的组件，结合 Suspense 可以更优雅地展现组件懒\n加载的过渡动画以及处理加载异常的场景。\n\n> 注意：React.lazy 和 Suspense 尚不可用于服务器端，如果需要服务端渲染，可遵从官方建议使用 [Loadable Components](https://github.com/gregberge/loadable-components)。loadable支持服务端\n懒加载，而且支持库的懒加载。\n\n[react koa2 ssr教程](https://github.com/cosyer/react-koa2-ssr)\n","tags":["react"],"categories":["JS"]},{"title":"css绘制几何图形","url":"%2Fcss%E7%BB%98%E5%88%B6%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2.html","content":"\nCSS能够生成各种形状。正方形和矩形很容易，因为它们是 web 的自然形状。添加宽度和高度，就得到了所需的精确大小的矩形。添加边框半径，你就可以把这个形状变成圆形，足够多的边框半径，你就可以把这些矩形变成圆形和椭圆形。\n\n我们还可以使用 CSS 伪元素中的 `::before` 和 `::after`，这为我们提供了向原始元素添加另外两个形状的可能性。通过巧妙地使用定位、转换和许多其他技巧，我们可以只用一个 HTML 元素在 CSS 中创建许多形状。\n\n虽然我们现在大都使用字体图标或者svg图片，似乎使用 CSS 来做图标意义不是很大，但怎么实现这些图标用到的一些技巧及思路是很值得我们学习。\n\n---\n<!--more-->\n\n### 圆\n```css\ndiv {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50px; \n/* 注意宽高相同圆角为一半 50%/100%都可以*/\n}\n```\n\n### 四个不同方向的半圆\n```css\n.top\n{\n  width: 100px;\n  height: 50px;\n  border-radius: 50px 50px 0 0;\n}\n.right {\n  width: 50px;\n  height: 100px;\n  border-radius: 0 50px 50px 0;\n}\n.bottom {\n  width: 100px;\n  height: 50px;\n  border-radius: 0 0 50px 50px;\n}\n.left {\n  width: 50px;\n  height: 100px;\n  border-radius: 50px 0 0 50px;\n}\n```\n\n--- \n<!-- more -->\n\n### 四分之一圆\n```css\n{\n  width:50px;\n  height:50px;\n  border-radius:50px 0 0 0;\n}\n```\n\n## 椭圆\n```css\n{\n  width: 150px;\n  height: 100px;\n  border-radius: 50%; \n}\n```\n\n### 菱形\n```css\n.quarter-ellipse{\n    width: 100px;\n    height: 50px;\n    background: pink;\n    transform: skew(-20deg);\n    text-align: center;\n    line-height: 50px;\n}\n```\n\n### 三角形\n```css\n/* 上三角 */\n#triangle-up {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid lightblue;\n}\n/* 下三角 */\n#triangle-down {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-top: 100px solid lightblue;\n}\n/* 左三角 */\n#triangle-left {\n    width: 0;\n    height: 0;\n    border-top: 50px solid transparent;\n    border-right: 100px solid lightblue;\n    border-bottom: 50px solid transparent;\n}\n/* 右三角 */\n#triangle-right {\n    width: 0;\n    height: 0;\n    border-top: 50px solid transparent;\n    border-left: 100px solid lightblue;\n    border-bottom: 50px solid transparent;\n}\n/* 左上角 */\n#triangle-topleft {\n    width: 0;\n    height: 0;\n    border-top: 100px solid lightblue;\n    border-right: 100px solid transparent;\n}\n/* 右上角 */\n#triangle-topright {\n    width: 0;\n    height: 0;\n    border-top: 100px solid lightblue;\n    border-left: 100px solid transparent; \n}\n/* 左下角 */\n#triangle-bottomleft {\n    width: 0;\n    height: 0;\n    border-bottom: 100px solid lightblue;\n    border-right: 100px solid transparent;\n}\n/* 右下角 */\n#triangle-bottomright {\n    width: 0;\n    height: 0;\n    border-bottom: 100px solid lightblue;\n    border-left: 100px solid transparent;\n}\n```\n\n### 箭头\n```css\n#curvedarrow {\n  position: relative;\n  width: 0;\n  height: 0;\n  border-top: 9px solid transparent;\n  border-right: 9px solid red;\n  transform: rotate(10deg);\n}\n#curvedarrow:after {\n  content: \"\";\n  position: absolute;\n  border: 0 solid transparent;\n  border-top: 3px solid red;\n  border-radius: 20px 0 0 0;\n  top: -12px;\n  left: -9px;\n  width: 12px;\n  height: 12px;\n  transform: rotate(45deg);\n}\n```\n\n### 梯形\n```css\n#trapezoid {\n  border-bottom: 100px solid red;\n  border-left: 25px solid transparent;\n  border-right: 25px solid transparent;\n  height: 0;\n  width: 100px;\n}\n```\n\n### 六角星\n```css\n#star-six {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid red;\n  position: relative;\n}\n#star-six:after {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 100px solid red;\n  position: absolute;\n  content: \"\";\n  top: 30px;\n  left: -50px;\n}\n```\n\n### 五角星\n```css\n#star-five {\n  margin: 50px 0;\n  position: relative;\n  display: block;\n  color: red;\n  width: 0px;\n  height: 0px;\n  border-right: 100px solid transparent;\n  border-bottom: 70px solid red;\n  border-left: 100px solid transparent;\n  transform: rotate(35deg);\n}\n#star-five:before {\n  border-bottom: 80px solid red;\n  border-left: 30px solid transparent;\n  border-right: 30px solid transparent;\n  position: absolute;\n  height: 0;\n  width: 0;\n  top: -45px;\n  left: -65px;\n  display: block;\n  content: '';\n  transform: rotate(-35deg);\n}\n#star-five:after {\n  position: absolute;\n  display: block;\n  color: red;\n  top: 3px;\n  left: -105px;\n  width: 0px;\n  height: 0px;\n  border-right: 100px solid transparent;\n  border-bottom: 70px solid red;\n  border-left: 100px solid transparent;\n  transform: rotate(-70deg);\n  content: '';\n}\n```\n\n### 五边形\n```css\n#pentagon {\n  position: relative;\n  width: 54px;\n  box-sizing: content-box;\n  border-width: 50px 18px 0;\n  border-style: solid;\n  border-color: red transparent;\n}\n#pentagon:before {\n  content: \"\";\n  position: absolute;\n  height: 0;\n  width: 0;\n  top: -85px;\n  left: -18px;\n  border-width: 0 45px 35px;\n  border-style: solid;\n  border-color: transparent transparent red;\n}\n```\n\n### 六边形\n```css\n#hexagon {\n  width: 100px;\n  height: 55px;\n  background: red;\n  position: relative;\n}\n#hexagon:before {\n  content: \"\";\n  position: absolute;\n  top: -25px;\n  left: 0;\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 25px solid red;\n}\n#hexagon:after {\n  content: \"\";\n  position: absolute;\n  bottom: -25px;\n  left: 0;\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 25px solid red;\n}\n```\n\n### 八边形\n```css\n#octagon {\n  width: 100px;\n  height: 100px;\n  background: red;\n  position: relative;\n}\n#octagon:before {\n  content: \"\";\n  width: 100px;\n  height: 0;\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-bottom: 29px solid red;\n  border-left: 29px solid #eee;\n  border-right: 29px solid #eee;\n}\n#octagon:after {\n  content: \"\";\n  width: 100px;\n  height: 0;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  border-top: 29px solid red;\n  border-left: 29px solid #eee;\n  border-right: 29px solid #eee;\n}\n```\n\n### 爱心💗\n```css\n#heart {\n  position: relative;\n  width: 100px;\n  height: 90px;\n}\n#heart:before,\n#heart:after {\n  position: absolute;\n  content: \"\";\n  left: 50px;\n  top: 0;\n  width: 50px;\n  height: 80px;\n  background: red;\n  border-radius: 50px 50px 0 0;\n  transform: rotate(-45deg);\n  transform-origin: 0 100%;\n}\n#heart:after {\n  left: 0;\n  transform: rotate(45deg);\n  transform-origin: 100% 100%;\n}\n```\n\n### 无穷大（莫比乌斯环）\n```css\n#infinity {\n  position: relative;\n  width: 212px;\n  height: 100px;\n  box-sizing: content-box;\n}\n#infinity:before,\n#infinity:after {\n  content: \"\";\n  box-sizing: content-box;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 60px;\n  height: 60px;\n  border: 20px solid red;\n  border-radius: 50px 50px 0 50px;\n  transform: rotate(-45deg);\n}\n#infinity:after {\n  left: auto;\n  right: 0;\n  border-radius: 50px 50px 50px 0;\n  transform: rotate(45deg);\n}\n```\n\n### 钻石\n```css\n#cut-diamond {\n  border-style: solid;\n  border-color: transparent transparent red transparent;\n  border-width: 0 25px 25px 25px;\n  height: 0;\n  width: 50px;\n  box-sizing: content-box;\n  position: relative;\n  margin: 20px 0 50px 0;\n}\n#cut-diamond:after {\n  content: \"\";\n  position: absolute;\n  top: 25px;\n  left: -25px;\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-color: red transparent transparent transparent;\n  border-width: 70px 50px 0 50px;\n}\n```\n\n### 吃豆人\n```css\n#pacman {\n  width: 0px;\n  height: 0px;\n  border-right: 60px solid transparent;\n  border-top: 60px solid red;\n  border-left: 60px solid red;\n  border-bottom: 60px solid red;\n  border-top-left-radius: 60px;\n  border-top-right-radius: 60px;\n  border-bottom-left-radius: 60px;\n  border-bottom-right-radius: 60px;\n}\n```\n\n### 对话泡泡\n```css\n#talkbubble {\n  width: 120px;\n  height: 80px;\n  background: red;\n  position: relative;\n  -moz-border-radius: 10px;\n  -webkit-border-radius: 10px;\n  border-radius: 10px;\n}\n#talkbubble:before {\n  content: \"\";\n  position: absolute;\n  right: 100%;\n  top: 26px;\n  width: 0;\n  height: 0;\n  border-top: 13px solid transparent;\n  border-right: 26px solid red;\n  border-bottom: 13px solid transparent;\n}\n```\n\n### 太极\n```css\n#yin-yang {\n  width: 96px;\n  box-sizing: content-box;\n  height: 48px;\n  background: #eee;\n  border-color: red;\n  border-style: solid;\n  border-width: 2px 2px 50px 2px;\n  border-radius: 100%;\n  position: relative;\n}\n#yin-yang:before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 0;\n  background: #eee;\n  border: 18px solid red;\n  border-radius: 100%;\n  width: 12px;\n  height: 12px;\n  box-sizing: content-box;\n}\n#yin-yang:after {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  background: red;\n  border: 18px solid #eee;\n  border-radius: 100%;\n  width: 12px;\n  height: 12px;\n  box-sizing: content-box;\n}  \n```\n\n### 放大镜\n```css\n#magnifying-glass {\n  font-size: 10em;\n  display: inline-block;\n  width: 0.4em;\n  box-sizing: content-box;\n  height: 0.4em;\n  border: 0.1em solid red;\n  position: relative;\n  border-radius: 0.35em;\n}\n#magnifying-glass:before {\n  content: \"\";\n  display: inline-block;\n  position: absolute;\n  right: -0.25em;\n  bottom: -0.1em;\n  border-width: 0;\n  background: red;\n  width: 0.35em;\n  height: 0.08em;\n  transform: rotate(45deg);\n}\n```\n\n### 月亮\n```css\n#moon {\n  width: 80px;\n  height: 80px;\n  border-radius: 50%;\n  box-shadow: 15px 15px 0 0 red;\n}  \n```\n\n### 虚线\n```css\n.dotted-line{\n    border: 1px dashed transparent;\n    background: linear-gradient(white,white) padding-box, repeating-linear-gradient(-45deg,#ccc 0, #ccc .25em,white 0,white .75em);\n}\n```\n\n## 气泡框\n使用绝对定位进行三角形覆盖，实现气泡框突出部分。\n```html\n<style>\n.bubble-tip {\n  width: 100px;\n  height: 30px;\n  line-height: 30px;\n  margin-left: 10px;\n  border: 1px solid #c5c5c5;\n  border-radius: 4px;\n  position: relative;\n  background-color: #fff;\n}\n.bubble-tip::before {\n  content: \"\";\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-width: 10px 10px 10px 0;\n  border-color: transparent #ffffff transparent transparent;\n  position: absolute;\n  top: 5px;\n  left: -10px;\n  z-index: 2;\n}\n.bubble-tip::after {\n  content: \"\";\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-width: 10px 10px 10px 0;\n  border-color: transparent #c5c5c5 transparent transparent;\n  position: absolute;\n  top: 5px;\n  left: -11px;\n  z-index: 1;\n}\n</style>\n<div class=\"bubble-tip\"></div>\n```\n\n## 卡券贴\n在CSS3当中，background添加了`background-size`属性，控制背景图片的大小，配合`background-position`属性，可以在一个背景下面展示多张图片。详见[background-MDN](https://developer.mozilla.org/zh-CN/docs/Web/CSS/background)。\n\nbackground-size: cover;使背景图像完全覆盖背景区域。也可以js获取图片宽高再比较一下，再决定往哪个方向居中。\n\n卡券贴的核心是使用透明白色径向渐变radial-gradient，分别让4张背景图中的左下角、右下角、右上角和左下角出现缺省，再利用drop-shadow实现元素阴影，从而达到效果。\n\nradial-gradient语法如下：\n```css\nradial-gradient(shape size at position, start-color, ..., last-color)\n```\n\n```html\n<style>\n.coupon{\n  width: 200px;\n  height: 80px;\n  background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right / 50% 40px no-repeat,\n    radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left / 50% 40px no-repeat,\n    radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right / 50% 40px no-repeat,\n    radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left / 50% 40px no-repeat;\n  filter: drop-shadow(3px 3px 3px #c5c5c5);\n}\n</style>\n\n<div class=\"coupon\"></div>\n```\n\n## 图片切角\n```css\nbackground: url(image.png);\n  mask:\n      linear-gradient(135deg, transparent 15px, #fff 0)\n      top left,\n      linear-gradient(-135deg, transparent 15px, #fff 0)\n      top right,\n      linear-gradient(-45deg, transparent 15px, #fff 0)\n      bottom right,\n      linear-gradient(45deg, transparent 15px, #fff 0)\n      bottom left;\n  mask-size: 50% 50%;\n  mask-repeat: no-repeat;\n```\n\n## 1px高的线条\n```html\n<div style=\"height:1px;overflow:hidden;background:red\"></div>\n```\n","tags":["布局"],"categories":["CSS"]},{"title":"Http请求概述","url":"%2Fhttp%E8%AF%B7%E6%B1%82%E6%A6%82%E8%BF%B0.html","content":"\n超文本传输协议（HTTP, HyperText Transfer Protocol）是一种无状态的协议，它位于OSI七层模型的传输层。HTTP客户端会根据需要构建合适的HTTP请求方法，而HTTP服务器会根据不同的HTTP请求方法做出不同的响应。\n\n--- \n<!-- more -->\n\n\n## HTTP 报文组成部分\n- 请求报文: 请求行 请求头 空行 请求体\n- 响应报文: 响应行 响应头 空行 响应体\n> 请求行里包括请求方法, url, http 版本; 响应行里包括状态码, http 版本, 状态说明;\n\n![http-request](http://cdn.mydearest.cn/blog/images/http-request.png)\n\n![http-response](http://cdn.mydearest.cn/blog/images/http-response,png)\n\n## HTTP版本\n在HTTP的发展过程中，出现了很多HTTP版本，其中的大部分协议都是向下兼容的。在进行HTTP请求时，客户端在请求时会告诉服务器它采用的协议版本号，而服务器则会在使用相同或者更早的协议版本进行响应。\n- HTTP/0.9\n这是HTTP最早大规模使用的版本，现已过时。在这个版本中 只有GET一种请求方法，在HTTP通讯也没有指定版本号，也不支持请求头信息。该版本不支持POST等方法，因此客户端向服务器传递信息的能力非常有限。HTTP/0.9的请求只有如下一行：\nGET www.baidu.com\n\n- HTTP/1.0\n这个版本是第一个在HTTP通讯中指定版本号的协议版本，HTTP/1.0至今仍被广泛采用，特别是在代理服务器中。该版本支持：GET、POST、HEAD三种HTTP请求方法。\n- HTTP/1.1\n\nHTTP/1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。\n\n- HTTP/2\n这个版本是最新发布的版本，于2015年5月做HTTP标准正式发布。HTTP/2通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。\n\n - 二进制流：http2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码\n - 数据压缩：使用HPACK算法对header的数据进行压缩\n - 多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中浏览器客户端在同一时间，针对同一域名下的请求有一定数量的限制，超过限制会发生阻塞。\n - 资源推送优先级(服务器端推送)-当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常\n 合适加载静态资源。\n\n![服务端推送](http://cdn.mydearest.cn/blog/images/http2-push.png)\n### nginx实现\n```\nserver {\n    listen 443 ssl http2;\n    ···//省略\n    location / {\n        ···//省略\n        http2_push /style.css;\n        http2_push /example.png;\n    }\n}\n```\n\n### 多路复用和持久连接的区别\n> 相当于你们家跟你叔叔家打电话：一个是你把跟你叔叔聊完后，不挂电话，你妈和你婶婶聊，你跟你堂兄弟姐妹聊。一个是你们家3口人和你叔叔家三口人同时一对一聊天。\n- 所谓持久连接，就是重用下之前的连接，明显连接一次只能一个请求/应答消息。\n- 多路复用（multiple access），就是多个http请求/应答使用一个连接。\n\n## HTTP请求方法\n\n### HTTP/1.1\n协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。\n\n#### GET\nGET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。\n\n#### HEAD\nHEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。\n\n#### POST\nPOST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被 包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。\n\n#### PUT\nPUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。\n\n#### DELETE\nDELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。\n\n#### CONNECT\nCONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。\n\n#### OPTIONS\nOPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用 * 来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。\n\n#### TRACE\nTRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。\n\n### HTTP/1.1之后增加的方法\n在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是PATCH 方法:\n\n#### PATCH\nPATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：\n1.PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。\n2.当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。\n\n### 请求头和响应头\n> header 有哪些字段\n1)请求(客户端->服务端[request]) \n    GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) \n    Accept: */*(客户端能接收的资源类型) \n    Accept-Language: en-us(客户端接收的语言类型) \n    Connection: Keep-Alive(维护客户端和服务端的连接关系) \n    Host: localhost:8080(连接的目标主机和端口号) \n    Referer: http://localhost/links.asp(告诉服务器我来自于哪里) \n    User-Agent: Mozilla/4.0(客户端版本号的名字) \n    Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) \n    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  \n    Cookie(客户端暂存服务端的信息) \n    Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)\n    content-type：请求/响应体文件里 MIME 类型。\n    content-length：请求/响应体长\n    origin：跨域请求时存在，请求来源\n    cache-control：强缓存控制，字段见 MDN\n    expires：强缓存控制，值为时间戳，标记缓存过期时间\n\n2)响应(服务端->客户端[response])\n    HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)\n    Location: http://www.baidu.com(服务端需要客户端访问的页面路径) \n    Server:apache tomcat(服务端的Web服务端名)\n    Content-Encoding: gzip(服务端能够发送压缩编码类型) \n    Content-Length: 80(服务端发送的压缩数据的长度) \n    Content-Language: zh-cn(服务端发送的语言类型) \n    Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)\n    Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)\n    Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)\n    Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)\n    Transfer-Encoding: chunked(分块传递数据到客户端）  \n    Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)\n    Expires: -1//3种(服务端禁止客户端缓存页面数据)\n    Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  \n    Pragma: no-cache(服务端禁止客户端缓存页面数据)   \n    Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  \n    Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)\n在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。\n\n## 状态码\n\n|   | 类别                          | 原因短语\n:---|:----------                   |:---------\n1XX | Informational（信息性状态码）   | 接收的请求正在处理\n2XX | Success（成功状态码）           | 请求正常处理完毕\n3XX | Redirection（重定向状态码）     | 需要进行附加操作以完成请求\n4XX | Client Error（客户端错误状态码） | 服务器无法处理请求\n5XX | Server Error（服务器错误状态码） | 服务器处理请求出错\n\n- 101: 需要切换协议(使用 Websocket 开始阶段是 http 协议, 中间切换到 WebSocket 协议, 此时返回的状态码是 101 表示后续协议还需切换)\n- 2XX\n  * 200 OK \n    <details>\n      <summary>成功处理</summary>\n      表示从客户端发来的请求在服务器端被正常处理了\n    </details>\n  * 204 No Content\n    <details>\n      <summary>成功处理，但无报文实体的主体返回</summary>\n      该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。\n    </details>\n  * 206 Partial Content\n    <details>\n      <summary>范围请求</summary>\n      该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n    </details>\n- 3XX\n  * 301 Moved Permanently\n    <details>\n      <summary>永久性重定向</summary>\n      该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。\n    </details>\n  * 302 Found\n    <details>\n      <summary>临时性重定向(可使用原有URI)</summary>\n      该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。\n    </details>\n  * 303 See Other\n    <details>\n      <summary>同302，但此处因采用GET\b方法</summary>\n      该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。\n    </details>\n  * 304 Not Modified\n    <details>\n      <summary>协商缓存(资源未修改可使用缓存)</summary>\n      该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。(附带条件的请求是指采用 GET方法的请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。)\n    </details>\n  * 307 Temporary Redirect\n    <details>\n      <summary>临时重定向</summary>\n      该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。\n    </details>\n- 4XX 客户端错误\n  * 400 Bad Request\n    <details>\n      <summary>报文中存在语法错误</summary>\n      该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。\n    </details>\n  * 401 Unauthorized\n    <details>\n      <summary>要求身份认证</summary>\n      该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\n    </details>\n  * 403 Forbidden\n    <details>\n      <summary>拒绝请求</summary>\n      该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。\n    </details>\n  * 404 Not Found\n    <details>\n      <summary>未找到请求的资源</summary>\n      该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。\n    </details>\n  * 415 Unsupported media type：不支持的媒体类型\n* 5XX\n  * 500 Internal Server Error\n    <details>\n      <summary>服务器端在执行请求时发生了错误</summary>\n      该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。\n    </details>\n  * 503 Service Unavailable\n    <details>\n      <summary>服务器暂时无响应</summary>\n      该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户端。\n    </details>\n\n## HTTP 事物时延\nDNS 解析、连接、传输、处理。\n\n## HTTP 连接\n管道化连接: 依赖于 Http/1.1 是持久连接的。\n\n## TCP三次握手\n客户端和服务端都需要知道各自可收发，因此需要三次握手(syn建立联机,ack确认联机)\n\n- 客户端发送 syn=1(同步序列编号)，ack=0标志的数据包给服务端，进入 syn_send 状态，等待确认\n- 服务端接收并确认 syn 包后发送 syn+ack(1,1) 包，进入 syn_recv 状态\n- 客户端接收 syn+ack 包后，发送syn=0，ack=1 包，双方进入 established 状态\n\n```js\n                  C                   S\n                          SYN=1\n                     ---------------> 确认自己可以接收\n                        SYN=1,ACK\n   确定s可收，自己可收 <--------------\n                            ACK\n                     ---------------> 确认C可收\n\n```\n\n## TCP四次挥手\n- 客户端 -- FIN --> 服务端， FIN—WAIT\n- 服务端 -- ACK --> 客户端， CLOSE-WAIT\n- 服务端 -- ACK,FIN --> 客户端， LAST-ACK\n- 客户端 -- ACK --> 服务端，CLOSED\n\n```\n1. 第一次挥手(FIN=1，seq=x)\n\n假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。\n\n发送完毕后，客户端进入 FIN_WAIT_1 状态。\n\n2. 第二次挥手(ACK=1，ACKnum=x+1)\n\n服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。\n\n发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。\n\n3. 第三次挥手(FIN=1，seq=y)\n\n服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。\n\n发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。\n\n4. 第四次挥手(ACK=1，ACKnum=y+1)\n\n客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。\n\n服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。\n\n客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。\n```\n\n## TCP和UDP的区别\n\n1. TCP是面向连接的，UDP是无连接的，即发送之前不需要先建立连接 \n\n2. TCP提供可靠的服务。也就是说，通过TCP连接传输数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。正因如此，TCP适合大数据量的交换 (为什么是可靠的：因为有ACK)\n\n3. TCP是面向字节流，UDP是面向报文，并且网络出现拥塞不会使发送速率降低（因此会出现丢包，实时的应用如ip电话和视频会议等）\n\n4. TCP是一对一，UDP支持一对一，一对多 \n\n5. TCP的首部较大为20字节，而UDP只有8字节 \n\n6. TCP是面向连接的可靠性传输，而UDP是不可靠的\n","tags":["http"],"categories":["知识"]},{"title":"获取浏览器url参数方法总结","url":"%2F%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html","content":" \n1. 正则(xxx?typeId=2)\n```javascript\nfunction getQueryString(name) {\n    var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');\n    var r = window.location.search.substr(1).match(reg);\n    if (r != null) {\n        // return unescape(r[2]); // 中文会乱码\n        return decodeURI(r[2]);\n    }\n    return null;\n}\ngetQueryString(\"typeId\") // \"2\"\n```\n\n---\n<!-- more -->\n\n2. split拆分\n```javascript\nfunction getQueryString() {\n    var url = location.search; //获取url中\"?\"符后的字串\n    var theRequest = new Object();\n    if (url.indexOf(\"?\") != -1) {\n        var str = url.substr(1);\n        strs = str.split(\"&\");\n        for(var i = 0; i < strs.length; i ++) {\n            theRequest[strs[i].split(\"=\")[0]] = decodeURI(strs[i].split(\"=\")[1]);\n        }\n    }\n    return theRequest;\n}\ngetQueryString(\"typeId\") // {typeId:\"2}\n```\n\n3. 正则获值 和1一样\n```javascript\nfunction getQueryString(name) {  \n    var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");  \n    var r = window.location.search.substr(1).match(reg);  //获取url中\"?\"符后的字符串并正则匹配\n    var context = \"\";  \n    if (r != null)  \n         context = r[2];  \n    reg = null;  \n    r = null;  \n    return context == null || context == \"\" || context == \"undefined\" ? \"\" : context;  \n}\n```\n\n4. 单参数获取(?1)获取？后面的数据\n```javascript\nvar url=window.location.href\nurl.substring(url.indexOf('?') + 1)\n// url.substr(url.indexOf('?') + 1)\n\nvar url=window.location.search\nurl.substring(1)\n// url.substr(1)\n```\n\n5. 获取所有参数的对象\n```js\nfunction getQueryStringObject() {\n    var reg = /([^?&=]+)=([^&]+)/g;\n    var q = {};\n    location.search.replace(reg, (m, k, v) => q[k] = v);\n    return q;\n}\n```\n\n6. URL对象-URLSearchParams\nURLSearchParams 构造函数不会解析完整 URL，但是如果字符串起始位置有 ? 的话会被去除。\n```js\nvar paramsString1 = \"http://example.com/search?query=123\";\nvar searchParams1 = new URLSearchParams(paramsString1);\n\nsearchParams1.has(\"query\"); // false \nsearchParams1.has(\"http://example.com/search?query\"); // true\n\nsearchParams1.get(\"query\"); // null\nsearchParams1.get(\"http://example.com/search?query\"); // \"123\" (equivalent to decodeURIComponent('%40'))\n\nvar paramsString2 = \"?query=value\";\nvar searchParams2 = new URLSearchParams(paramsString2);\nsearchParams2.has(\"query\"); // true \n\nvar url = new URL(\"http://example.com/search?query=%40\");\nvar searchParams3 = new URLSearchParams(url.search);\nsearchParams3.has(\"query\") // true\n\nlet param = new URLSearchParams()\nparam.append('username', 'admin')\nparam.append('pwd', 'admin')\n```\n","tags":["知识"],"categories":["知识"]},{"title":"单页应用优缺点分析","url":"%2Fspa.html","content":"\n单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。\n\n--- \n<!--more-->\n\n## 优点：\n1、分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；前后台分离开发模式。\n\n2、减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；\n\n3、同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；\n\n4. 服务器压力变小，后台不需要负责模板渲染，输出页面工作。ajax实现页面刷新，不需要重新加载整个页面。\n\n## 缺点：\n1、SEO难度大，由于所有的内容都是在一个页面中动态替换显示，现在可以通过Prerender等技术解决一部分；\n\n2、前进后退由路由管理，由于单页面应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有页面的切换需要自己建立堆栈管理；\n\n3、初次加载耗时多，为实现单页面web应用功能及显示效果，需要在加载页面的时候将js，css统一加载，部分页面按需加载；\n","tags":["知识"],"categories":["知识"]},{"title":"https加密通信流程解析","url":"%2Fhttps%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1.html","content":"\nhttps其实是有两部分组成：http + SSL / TLS加密数据包，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。\n\nhttps比http要占用更多的资源，http使用TCP 三次握手建立连接，客户端和服务器需要交换3个包，https除了 TCP 的三个包，还要加上 ssl握手需要的9个包，所以一共是12个包。\n\n> SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL最新的版本是3.0。TLS的全称是Transport Layer Security，即安全传输层协议，是建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。\n\nSSL/TLS = 非对称加密（如RSA、ECC） + 对称加密（如AES、DES） + 散列算法（如MD5）\n\n> 1.对数据加密 2.验证网站服务器身份\n---\n\n<!-- more -->\n\n## 流程解析\n\n### 客户端发起HTTPS请求\n\n用户在浏览器里输入一个https网址，然后连接到server的443端口。\n\n### 服务端的配置\n\n采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。\n\n### 传送证书\n\n这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。\n\n### 传送加密信息\n\n这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。\n\n### 服务端解密信息\n\n服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。\n\n### 传输加密后的信息\n\n这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。\n\n### 客户端解密信息\n\n客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。\n\n- GET / HEAD / OPTIONS方法           \n只从服务端获取资源 并不对服务器进行修改 因此相对安全。\n对于客户端来说是不安全的 请求参数会显示在URL中。 \n\n- TRACE方法（两端安全）\n用于诊断诊断服务器 仅记录路径信息 是安全的。\n\n- POST方法\n会影响服务器端的资源。\n\n## 说一下http和https\n> https的ssl加密是在传输层实现的。\n\n1. http 超文本传输协议，是一个客户端和服务端请求应答的标准。用于从www服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。\n\n2. 以安全为目标的http通道，简单讲就是http的安全版。即在http下加入ssl层，https的安全基础就是ssl，因此加密的详细内容就需要ssl。\n\n## 为什么要用HTTPS？\n因为HTTP在“裸奔”（明文传输，不安全）。\n- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全\n- 对网站服务器进行真实身份认证\n\n### http和https的区别？\n1. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议，需要CA证书。\n\n2. 链接方式不同，对应的默认端口也不同，http 80，http 443端口。\n\n3. http无状态，https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\n\n### https协议的工作原理(双向加密建立)\n客户端和服务端都有公钥和私钥。\n\n1. 客户端使用https url访问服务器，则要求web服务器建立ssl链接\n\n2. 服务端发送公钥\n\n3. 客户端发送'验证串+服务端公钥' && 客户端公钥\n\n4. 服务端使用私钥取得验证串与客户端公钥一起发送给客户端\n\n5. 客户端使用客户端私钥来获取验证串是否匹配\n\n### 协议解析\n多了一个 upgrade-insecure-requests 的字段。该字段让页面打开后的请求自动变为 https。\n\n### 缺点\n1. https握手阶段比较费时，会使页面加载时间延长，耗电增加\n\n2. https缓存不如http高效，会增加数据的开销\n\n3. ssl证书也需要花钱，功能越强大的证书费用越高\n\n4. ssl证书需要绑定IP，不能再同一个ip上绑定多个域名，Ipv4资源支持不了这样的消耗\n","tags":["http"],"categories":["知识"]},{"title":"网页埋点相关知识","url":"%2F%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF.html","content":"\n埋点的需求：一个网站上线,开发者除了保证网站功能正常,体验优好之外,还有一项重要的工作是数据收集,通过收集用户的行为数据可以帮助了解网站的功能是否满足用户的需求,导流方式是否有效,新功能上线后是否效果是否达到设计初衷,根据数据指引有效优化产品体验以及发现新的产品方向是产品经理的必备技能,而如何采集准确并且足够的网站数据则应该是开发者的责任.在大数据处理能力越来越强下,以及机器学习等依赖数据哺育的工具进化下,采集足够多的数据往往是网站向着良性方向进化的必备条件\n\n---\n<!-- more -->\n\n## 埋点方案\n- ajax\n- img(优势：不占用ajax请求，天然支持跨域，执行无阻塞。)\n- script\n\n## 常见工具\n\n网站的数据采集有很多现成的工具,如google Analytics, 百度统计, 友盟+等,往往通过在页面上接入js SDK代码。\n\n而在实际采集过程中,数据是如何传递过去的呢,,我们随便打开一个埋有百度统计的网站, 打开chrome的开发者工具,勾选Preserve log,\n可以发现在页面点击一个链接或者做一些其他操作,在Networking tab下可以看到hm.gif的网络请求, 这里由于统计的数据发送涉及到第三方网址,涉及跨域问题,而图片请求天然是跨域的,所以业界的通用做法是构造一个空的gif用于向第三方网站, 而真正需要统计的参数往往是通过url进行传递。\n\n## 数据采集(生成图片Url参数挂在?上)\n\n- 基本的发送函数，创建Img发送统计请求导数据采集后台。\n```javascript\nfunction sendUrl(url) {\n    let img = new Image();  // 创建一个img对象\n    let key = 'project_log_' // 为本次数据请求创建一个唯一id\n        + Math.floor(Math.random() * 2147483648).toString(36); \n \n    window[key] = img;   // 用一个数组维护img对象\n \n    img.onload = img.onerror = img.onabort = function () {\n        img.onload = img.onerror = img.onabort = null;  // 清除img元素\n        window[key] = null;\n        img = null;  \n    };\n    img.src = url;  // img对象赋值url后自动发送请求,无需插入到页面元素中去\n}\n```\n\n- 数据格式约定\n```javascript\n数据格式规则,如:1.gif?q=xxx&fr=xxx&refer=xxx&p=xxxx&xxxxx\nq表示页面搜索词; fr表示页面的上游页面时什么, refer是指从来源页面, p表示事件类型等;\n```\n\n## 访问时长的计算\n```javascript\nvar st = new Date().getTime();  // 在页面加载运行js时记录当前时间\n\n$(window).on('beforeunload', function () {\n    var et = new Date().getTime();\n    var stayTime = et - st;\n    \n}); // 在页面要unload触发'beforeunload'事件时进行时间差计算得到访问时长\n\n// 需要用户在页面有过任何操作才会出现提示。每次都是打开接着就关闭进行测试，所以以为没用\nwindow.onbeforeunload = function(){\n    return \"onbeforeunload is work\";\n}\n```\n\n## 关键指标\n### PV pageview\n\n传统意义上每次页面刷新代表着一次新的pv, 也就是每次统计js执行时都+1, 而现在页面很多都用到了ajax技术来进行无刷新获取展现页面来替代翻页,如瀑布流页面通过下来加载新的页面,这时候页面不重新刷新,因此可以在ajax请求接口处进行埋点进行pv累加;\n\n### 单项PV\n\n页面上部分元素有单独统计pv的需要,有些页面元素不是页面展现都展现,或者需要统计类似于某一广告的展现次数,这种需要需要在url里单独定义参数来标识;\n\n### 聚焦时间\n\n与访问时长不同,由于页面可以通过tab切换导致虽然页面没有unload但实际处于失去焦点状态, 因此需要订阅focusIn与focusOut两个事件,在focusIn时开始计时, 在focusOut时停止计时,在页面unload时将focus时间进行累加得到聚焦时间;\n\n","tags":["知识"],"categories":["知识"]},{"title":"export/export default/import的区别以及用法","url":"%2Fes6export.html","content":"\nES6模块主要有两个功能：export和import\n\nexport用于对外输出本模块（一个文件可以理解为一个模块）变量的接口\n\nimport用于在一个模块中加载另一个含有export接口的模块。\n\n也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。\n\n---\n<!-- more -->\n\n## export和import（一个导出一个导入）\n```javascript\n// a 文件 \nexport var name=\"cosyer\" // 导出单个变量\n\n// 引用a文件 \nimport {name} from './a'\nexport default {\n    data(){\n\n    },\n    howl:function (){\n    console.log(name) // cosyer\n    }\n}\n\n// 导出多个变量 \nlet name1='张三';\nlet name2='李四';\nexport {name1,name2}\n\n// 引用多个变量\nimport {name1,name2} from './a'\n\n// 导出函数\nfunction mini(num){\n    console.log(num)\n}\n\nexport {mini}\n\n// 引用函数\nimport {mini} from './a'\nexport default{\n    howl:function(){\n        mini(1) // 1\n    }\n}\n```\n\n## export和export default\n\n1. export与export default均可用于导出常量、函数、文件、模块等。\n\n2. 你可以在其它文件或模块中通过import + (常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用。\n\n3. 在一个文件或模块中，export、import可以有多个，export default仅有一个。\n\n```javascript\nexport name1;\nexport name2;\n```\n\n4. 通过export方式导出，在导入时要加{}，export default则不需要。\n\n其实很多时候export与export default可以实现同样的目的，但使用export default命令，为模块指定默认输出，这样就不需要知道加载模块的变量名。\n\n```javascript\nexport default name\nimport name from './a'\n```\n\n- 当用export default people导出时，就用 import people 导入（不带大括号）。\n- 一个文件里，有且只能有一个export default。但可以有多个export。\n- 当用export name 时，就用 import{name} 导入（记得带上大括号）。\n- 当一个文件里，既有一个export default people, 又有多个export name 或者 - export age时，导入就用 import people,{name,age}。\n- 当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用 import * as example。","tags":["es6"],"categories":["JS"]},{"title":"mobx -- 走进观察者模式","url":"%2Fmobx.html","content":"\n#### React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。\n#### React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。\n#### MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。\n#### redux缓存机制 时间回溯适用于撤销操作 操作状态\n\n1. 安装\n~~~\nnpm install --save mobx mobx-react\n~~~\n2. 核心概念\n- state(状态) \n状态是驱动应用的数据。\n- observable(value) && @observable \nObservable 值可以是JS基本数据类型、引用类型、普通对象、类实例、数组和映射。其修饰的state会暴露出来供观察者使用。\n- observer(观察者)\n被observer修饰的组件，将会根据组件内使用到的被observable修饰的state的变化而自动重新渲染。\n- action(动作)\n只有在 actions 中，才可以修改 Mobx 中 state 的值。\naction-->state-->view\n- computed \n计算值(computed values)是可以根据现有的状态或其它计算值衍生出的值。(可以看成公式)\ngetter：获得计算得到的新state并返回。\nsetter：不能用来直接改变计算属性的值，但是它们可以用来作\"逆向\"衍生。\n- autorun\n这通常是当你需要从反应式代码桥接到命令式代码的情况，例如打印日志、持久化或者更新UI的代码。\n- 如果你有一个函数应该自动运行，但不会产生一个新的值，请使用autorun。 其余情况都应该使用 computed。\n- reactions\nReactions 和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新 React 组件树以修补DOM、等等。 简而言之，reactions 在 响应式编程和命令式编程之间建立沟通的桥梁。\n\n~~~javascript\n// component\nimport {inject, observer} from \"mobx-react\";\n\n// 观察者 注入store添加到属性上\n@inject(\"store\") @observer\n\nthis.props.store.xxStore.num\nthis.props.store.xxStore.plus() // num+=1\nthis.props.store.xxStore.total\n\n// homeStore\n\n@observable num;\nconstrutor(){\n    this.name=''\n    this.items=[]\n}\n\n@computed get total() {\n    return this.items.length;\n }\n  \n@action plus=()=>{\n    this.num+=1\n}\n\nautorun((e)=>{})\n\nconst homeStore =new HomeStore()\nexport {homeStore}\n~~~\n\n~~~javascript\nswitch\nrouter render={(props)=><Item {...props}/>}\nrouter component={Index}\nreact-route-dom\nwithRouter\nLinking\n// Provider 传递stores\nPrivider store={stores}\ncreate-react-app react-scripts\n~~~\n基本就这两种方法:immutable/observable\nmobx: oop\nredux: 函数式\n\nssr:流模式、字符串\n\n[demo地址](https://github.com/cosyer/mobx-demo)\n\n","tags":["状态管理"],"categories":["JS"]},{"title":"主流浏览器的内核和渲染方式解读","url":"%2F%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E8%A7%A3%E8%AF%BB.html","content":"\n## 浏览器内核\n- Trident:IE，360，搜狗\n\n- Gecko：firefox\n\n- webkit:safari，旧版chrome\n\n- presto：旧版opera\n\n- blink(webkit的一个分支)：新版chrome，新版opera\n\n## 浏览器的渲染方式\n\n1. 构建DOM树\n浏览器请求到html代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求。（解码->令牌化->词法分析->dom树创建）\n\n2. 构建CSSOM\ncss文件加载完成，开始构建CSSOM（CSSOM只输出包含有样式的节点）\n\n3. 生成渲染树（Render Tree）\nCSSOM构建结束后，和DOM一起生成Render Tree\n\n4. 计算渲染树布局（Layout）\n有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义以及他们的从属关系。依照盒子模型，计算出每个节点在屏幕中的位置及尺寸。\n\n5. 将布局Paint绘制到屏幕上\n布局之后，浏览器知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置。所以接下来按照算出来的规则，通过显卡，把内容画在屏幕上。\n\n![render](http://cdn.mydearest.cn/blog/images/render.png)\n\nCSS阻塞渲染：由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染。CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在head中，仅仅是为了更快的解析CSS，保证更快的首次渲染。\nJS阻塞页面：JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在解析HTML时，一旦碰到script，就会立即停止HTML的解析，也阻塞了其后的CSS解析，整个解析进程必须等待JS的执行完成才能够继续。从性能角度上讲，将script放在页面底部，也就合情合理了。\n\n## 重绘（Repaint）：\n\n当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为repaint。\n\n- 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少。\n\n### 触发重绘\n\n1. DOM改动\n2. CSS改动\n\n## 重排（Reflow）：\n\nDOM结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为reflow。\n\n- 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。\n\n### 触发重排\n\n1. 当增加、删除、修改DOM节点时，会导致reflow或repaint\n2. 当移动DOM的位置，或是插入动画的时候\n3. 当修改CSS样式的时候\n4. 当Resize窗口的时候，或是滚动的时候\n5. 当修改网页的默认字体时\n\n## 最小化重绘和重排 \n1. 避免频繁使用 style，而是采用修改class的方式。\n\n2. 批量修改DOM：使用文档片段创建一个子树，然后再拷贝到文档中（document.fragment）使用createDocumentFragment进行批量的 DOM 操作。\n\n3. 缓存布局信息\n\n4. 对于 resize、scroll 等进行防抖/节流处理。\n","tags":["知识"],"categories":["知识"]},{"title":"flex布局","url":"%2Fflex.html","content":"\n芮 rui 四声\n\n浏览器前缀 -webkit/chrome、safari -moz/firefox -ms/ie -o/opera\n\n弹性伸缩flexbox布局 \n\n任何一个容器都可设为display:flex\n\n行内元素 display:inline-flex\n\nwebkit内核浏览器（Safari） display:-webkit-flex; display:flex\n\n设为flex布局以后，子元素的float、clear、vertical-align属性将失效。\n\n--- \n<!-- more -->\n## 容器的属性\n### flex-direction 决定主轴的方向\n\nflex-direction:row;  /*默认：从左到右*/\n\nflex-direction:row-reverse;  /*从右到左*/\n\nflex-direction:column;  /*从上到下*/\n\nflex-direction:column-reverse;  /*从下到上*/\n\n### flex-wrap:一条轴排列不下，如何换行\n\nflex-wrap:nowrap;  /*默认:不换行*/\n\nflex-wrap:wrap;  /*换行，第一行在上方*/\n\nflex-wrap:wrap-reverse;  /*换行，第一行在下方*/\n\n### flex-flow：上面两个的简写\nflex-flow:fiex-direction flex-wrap;  /*默认 row no-wrap*/\n\n### justify-content:主轴上的对齐方式\n\njustify-content:flex-start;  /*默认：左对齐*/\n\njustify-content:flex-end;  /*右对齐*/\n\njustify-content:center;  /*居中*/\n\njustify-content:space-between;  /*两端对齐，项目之间的间隔相同，边缘项目紧贴边框*/\n\njustify-content:space-around;  /*项目两侧的间隔相同，所以，项目之间的间隔比项目与边框的间隔大一倍*/\n\n### align-items:交叉轴上如何对齐\n\nalign-items:flex-start;  /*起点对齐*/\n\nalign-items:flex-end;  /*终点对齐*/\n\nalign-items:center;  /*中点对齐*/\n\nalign-items:baseline;  /*项目的第一行文字的基线对齐*/\n\nalign-items:stretch;  /*默认：项目未设高度或auto，占满整个容器高度*/\n\n### align-content：多根轴线的对齐方式，只有一根轴线时，不起作用。\n\naling-content:flex-start;  /*与交叉轴的起点对齐*/\n\naling-content:flex-end;  /*与交叉轴的终点对齐*/\n\naling-content:center;  /*与交叉轴的中点对齐*/\n\naling-content:space-between;  /*与交叉轴两端对齐，轴线之间的间隔平均分布。*/\n\naling-content:space-around;  /*每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍*/\n\naling-content:stretch;  /*默认：轴线占满整个交叉轴*/\n\n## 项目的属性\n\n### order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\norder:1;\n\norder:99;\n\norder:-1;   \n\n/*-1 1 99的顺序排列*/\n\n### flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n\nflex-grow: <number>; /* default 0 */\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。\n\n如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### flex-shrink:定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\nflex-shrink: <number>; /* default 1 */\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。\n\n如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### flex-basis:定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\nflex-basis: <length> | auto; /* default auto */\n\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n### flex: 1 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。分别对应的是 flex 元素的占位、缩放、容器宽高。\n\nflex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n\n### align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\nalign-self: auto | flex-start | flex-end | center | baseline | stretch;\n\n## react-native使用flex布局注意点\n\n- 样式对象需要驼峰式写法\n- React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。\n\n首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。\n\n## 扩展阅读：\n[w3cplus指南](http://www.w3cplus.com/css3/a-guide-to-flexbox-new.html)\n[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n[思维图](http://blog.csdn.net/magneto7/article/details/70854472)\n[可视化练习1](https://buptsteve.github.io/flex-playground/)\n[可视化练习2](https://react-medellin.github.io/flexbox-playground/)\n[可视化练习3](https://www.flexbox.aweutist.dev/showcase.html)\n[可视化练习4](https://vikram-rajput.github.io/flexbox-playground/)\n","tags":["布局"],"categories":["CSS"]},{"title":"前端工程化","url":"%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html","content":"\n前端的工程化、模块化、组件化。\n\n1. 广义的前端工程化\n\n前端工程是软件工程的一个子类，指的是将软件工程的方法和原理运用在前端开发中, 目的是实现高效开发，有效协同，质量可控。\n\n2. 狭义的前端工程化\n\n前端工程是指将开发阶段代码转变成生产环境的代码的一系列步骤。主要包括构建，分支管理，自动化测试，部署等。\n\n前端工程化的具体内容\n\n1. 代码规范：保证团队所有成员以同样的规范开发代码。\n\n2. 分支管理：不同的开发人员开发不同的功能或组件，按照统一的流程合并到主干。\n\n3. 模块管理：一方面，团队引用的模块应该是规范的；另一方面，必须保证这些模块可以正确的加入到最终编译好的包文件中。\n\n4. 自动化测试：为了保证和并进主干的代码达到质量标准，必须有测试，而且测试应该是自动化的，可以回归的。\n\n5. 构建：主干更新以后，自动将代码编译为最终的目标格式，并且准备好各种静态资源，\n\n6. 部署：将构建好的代码部署到生产环境。","tags":["知识"],"categories":["知识"]},{"title":"服务器推送技术","url":"%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF.html","content":"\n在做前端页面渲染时，经常会遇到有的组件需要跟随数据的变化而实时的变化，例如：一个线上报名系统，总人数有一定限制，所以要实时的展现已经报名的人数，应该怎么实现呢？最基本有如下3种方案：\n\n- Ajax轮询\n- Ajax长轮询(comet)\n- websocket长连接\n\n--- \n<!-- more -->\n\n## Ajax轮询\n\n### 优点\n实现简单，利用XHR,通过setInterval定时向后端发送请求。\n\n### 缺点\n会造成数据在一小段时间内不同步和大量无效的请求，增加后端处理压力.\n\n```javascript\nsetInterval(function() {\n    $.ajax({\n        url: 'https://www.baidu.com/',\n        success: function() {\n            //success code\n        }\n    });\n}, 3000);\n```\n\n## Ajax长轮询(comet)\n\n在Ajax轮询的基础上做的一点改进，在后端数据没有更新的时候不再返回空响应，而且后端一直保存连接，直到后端有数据变化，则相应请求并且关闭连接，前端收到数据，马上再次向后端发起请求，并处理刚刚收到的数据。\n\n通常的做法是，在服务器的程序中加入一个死循环，在循环中监测数据的变动。当发现新数据时，立即将其输出给浏览器并断开连接，浏览器在收到数据后，再次发起请求以进入下一个周期。\n\n```javascript\nfunction async() {\n    $.ajax({\n        url: 'http://api.3g.qq.com',\n        success: function() {\n            async();\n            //success code\n        }\n    });\n}\n```\n\n## websocket长连接\n\nWebSocket是html5中的协议，支持持久连接。http协议不支持持久连接，http1.0和http1.x都不支持持久性连接，http1.1中的keep-alive将多个http请求合并为1个。\n\nWebSocket通信协议包含两个部分，一是开放性HTTP握手连接协商连接参数，二是二进制消息分帧机制（接收消息的文本和二进制数据传输）。它是一个独立完善的协议，也可以在浏览器之外实现。\n\nHTTP的生命周期通过Request来界定，也就是Request一个response，那么在http1.0协议中这次请求就结束了；在http1.1中进行了改进，是有一个connection：keep-alive，也就是说在一个http连接里可以发送多个request，接收多个response。\n\nWebsocket是基于http协议的，或者说借用了http协议来完成部分握手，在握手阶段和http是相同的，请求头中多了两个属性：upgrade，connection\n```js\nUpgrade: websocket\nConnection: Upgrade\n```\n\n### HTTP升级协商\n\nWebSocket协议提供了很多强大的特性：基于消息的通信、自定义的二进制分帧层、子协议协商、可选的协议扩展，等等。即在交换数据之前，客户端必须与服务器协商适当的参数以建立连接。\n\n利用HTTP完成握手有几个好处。首先，让WebSockets与现有HTTP基础设施兼容：WebSocket服务器可以运行在80和443 端口上，这通常是对客户端唯一开放的端口。其次，让我们可以重用并扩展HTTP的Upgrade流，为其添加自定义的WebSocket首部，以完成协商。\n\n### 请求头信息\n\nConnection:Upgrade Sec-WebSocket-Key:eDCPPyPQZq7PiwRcx8SPog== Sec-WebSocket-Version:13 Upgrade:websocket \n\n### 响应头信息\n\nHTTP/1.1 101 Switching Protocols Connection:Upgrade Sec-WebSocket-Accept:/ZVAP3n6XuqDUoDp416PYUO+ZJc= Upgrade:websocket\n\n\n最后，前述握手完成后，如果握手成功，该连接就可以用作双向通信信道交换WebSocket消息。到此，客户端与服务器之间不会再发生HTTP通信，一切由WebSocket 协议接管。\n\n### 具体使用方法，本文采用node.js中的Socket.IO来进行说明：\n\n1. 服务端创建socket.io的实例\n\n```javascript\nvar app = require('express')(); \nvar http = require('http').Server(app); \nvar io = require('socket.io')(http);//创建实例 \n\napp.get('/', function(req, res){ res.sendfile('index.html'); });\n\nio.on('connection', function(socket){ \n    console.log('a user connected'); \n});// 监听前端连接 \n\nhttp.listen(3000, function(){ console.log('listening on *:3000'); });  \n```\n\n2. 数据传输\n\n```javascript\n// 前端客户端向后端发送数据：\nsocket.emit('chat message', $('#m').val()); \n\n// 后端接收数据：\n\nio.on('connection', function(socket){ \n    socket.on('chat message', function(msg){ \n    console.log('message: ' + msg); }); \n}); \n\n// 后端向前端发送数据：\n\nio.on('connection', function(socket){\n    socket.on('chat message', function(msg){ \n    io.emit('chat message', msg); }); \n}); \n\n// 前端接收数据：\nsocket.on('chat message', function(msg){ console.log(msg); });\n```\n","tags":["知识"],"categories":["知识"]},{"title":"函数的防抖和节流","url":"%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html","content":"\n场景：事件频繁被触发，频繁执行DOM操作、资源加载等重复行为，导致UI停顿甚至浏览器崩溃。如 input 实时搜索、scrollview 滚动更新。\n\n函数防抖和节流用于限制函数的执行。是优化高频率执行js代码的一种手段。\n\n---\n<!--more-->\n\n## 函数防抖\n\n函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。\n\n```javascript\nvar debounce = function(idle,action){\n  var last;\n  return function(){\n    var ctx = this,\n        args = arguments; // 存储参数\n    clearTimeout(last);\n    last = setTimeout(function(){\n      action.apply(ctx,args);\n    },idle);\n  }\n}\n\n// 返回函数连续调用时，空闲时间必须大于或等于idle，action才会执行。\n```\n\n### 实际例子\n\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n```javascript\nfunction debounce(fn, wait) {\n    var timeout = null;\n    return function() {\n        if(timeout !== null) \n                clearTimeout(timeout);\n        timeout = setTimeout(fn, wait);\n    }\n}\n// 处理函数\nfunction handle() {\n    console.log(Math.random()); \n}\n// 滚动事件\nwindow.addEventListener('scroll', debounce(handle, 1000));\n```\n\n当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。\n\n函数防抖适用于连续调用函数，但只在延时后调用一次。定时器存在则销毁，第一次一定会创建并调用函数。\n\n## 函数节流\n\n每隔某个时间去执行某函数，避免函数的过多执行。\n\n如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是说会先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。\n\n```javascript\nvar throttle = function(delay,action){\n  var last ;\n  return function(){\n    var cur = +new Date();  //返回毫秒数\n    if(cur - last > = delay){\n      action.apply(this,arguments);\n      last = cur;\n    }\n  }\n}\n```\n\n### 实际例子\n函数节流主要有两种实现方法：时间戳和定时器。\n\n```javascript\nvar throttle = function(func, delay) {\n    var prev = Date.now();\n    return function() {\n        var context = this;\n        var args = arguments;\n        var now = Date.now();\n        if (now - prev >= delay) {\n            func.apply(context, args);\n            prev = Date.now();\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    return function() {\n        var context = this;\n        var args = arguments;\n        if (!timer) {\n            timer = setTimeout(function() {\n                func.apply(context, args);\n                timer = null;\n            }, delay);\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n函数节流适用于间接性调用函数。定时器不存在则创建调用函数，定时销毁。","tags":["知识"],"categories":["JS"]},{"title":"在去上海前的一些想法","url":"%2Fbeforehz.html","content":"\n怯懦的我终于和领导提出了离职，从8月11号入职以来，jenkins打包管理、bugatti自动化部署等等惊艳到了在上家公司还是用手动发包javac的我，学到了更正规的软件开发流程体系和产品线的迭代，KA项目的定制化。从1月开始一直用RN做相关的微应用，期间虽然也做过小程序、mui的H5、antd的中后台系统，但大多数时间还是用RN写业务应用。经过几个应用的锻炼、改造，已经封出了一些较能应付业务需求的组件。复杂的集成调用框架那边都做了，其他部分做起来没有什么技术含量了。我知道已经毕业1年的我该做出些改变了。\n\n---\n<!-- more -->\n\n面对领导们的挽留，我也只能笑着婉拒。我想在大前端的道路上迈的更远，本来就没打算活很长的时间，在短暂还算充满干劲的人生中多做点自己感到快乐的事。说来也是好笑，来了南京这么久也没出去逛过，只对公司和公寓周边熟悉一些，真是符合我的作风啊o(*￣︶￣*)o。\n\n依稀还记得刚追被去南京发展是我的内心也是非常慌乱的，陌生的城市、环境和人不停地在劝退着我，投递的简历有了回复，我不断预演这面试的场景，竟可能多的将自己的优势展现出来。将近2个小时的长途客车旅途，我到了南京南站，摸着黑上了地铁到了软件大道。9点半又误打误撞地摸到了目的地，不好意思随便进入，随即打电话确认（有人来引下路多好）。等待的过程忐忑不安，人生第一次经历三轮面试，和技术聊真的开心啊O(∩_∩)O哈哈~面试完后立即又买了车票回了家汗~~\n\n自从工作以来就没请过假，没迟过到。自尊心强烈的我很在意别人对我的看法。去年买了房，房贷没什么压力。房子让父母住，我在工作的地方租房住，这是我的规划。不想去相亲，不想被各种绑架。\n\n作为熟练的api caller，高中之前的学习是多么快乐啊，是的，做题(除了语文)学习很快乐。新思维解题都是带来很多不同的思路，课堂上有选择地去学习自己喜欢的事物。虽然被老师骂的惨，但暗地里还是支持的。没压力地考上了重点高中，进城上高中了，才感觉到差距是巨大的。城里的小孩终究是不一样的，读过的书也好，培养的兴趣爱好也好，上过的兴趣班都远超过你。学的东西都是套路化的解题，枯燥乏味。渲染了xx的气氛，表达了xx什么的情感。各种烦心、倒霉的事也接踵而来，小小的幸福被扼杀。好奇心和脖子的扭，知道的越多，越觉得绝望。见过的所谓的'真实'，都是为了利益。永远不要去试探人性。现在看来都只是可笑的借口罢了，压力抑郁到自残。人与人之间最公平的就是时间了，每个人一天都是24小时，谁也不多，谁也不少。特别佩服那些活的独立、认真的人们。他们年轻、强大、充满个性，差距真的差到天差地别，是我前进的目标和憧憬的对象。我不会再迷茫了，毕竟~~~\n\n{% centerquote %} \n不去做的话永远也做不到。\n{% endcenterquote %} \n\ns(优势):互联网氛围、大牛、技术提升\nw(劣势):房租、10m2的地下室、消费、离家远、通勤时间、异地恋\no(机会):更高的待遇天花板、未来发展\nt(威胁):陌生的城市、重新整理技术体系、面试\n\n---\n\ns:门面做的不错、近10k（南京1年经验）、双休（有时间做自己项目学习、接外包）、雨花台区（离老婆近）\nw:不融资、官网low、没核心产品（说在招人明年做、说呆1年能到13-14 0^0？？？）、着急招人（目前人数较少？）、外包园、1-3年9-12k？？？常见都是10-15k。\n\n南京这边的工资待遇真的很低，感觉像命运一样，留了最后一张简历，偏偏扇贝又在这个时候叫我去面试。面试居然还提供饮品。这边催着入职，前面的还没消息，说到底还是自己太懦弱了，如果有联系或者果断点，就不会有这样的情况出现了。不去试一试怎么会知道呢，担当起自己的responsibility。\n\n2周前投的现在认识才提醒面试是不是太迟了；虽然很想去，技术氛围浓厚。大公司就会比较选人，不会立即给你答复。可这边的工作急着让你给答复。唉就这样形成了现在的处境。努力沉淀一点再跳槽到新公司吧！！！\n\n半杯水，懂了么。自身的强大很重要，more experience 成年人 卧薪尝胆\n\n办公环境、补贴、五险一金、工资、福利待遇、氛围、大公司镀金、自身的强大。选择比努力更重要，实力和机遇。看看别人的评分98，6周年dlun这种自研的能跟着一起成长。大格局，这样会越来越迷茫找不到自己的定位，半杯水的思想。真正的效率。\n\n3年了，还是在南京。。。\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"常见排序的JS实现","url":"%2Fsort.html","content":"\nhttps://github.com/damonare/Sorts 这位大兄弟♂总结的很好，快去看看吧！\n---\n<!-- more -->\n\n## 冒泡排序(两两比较)\n```js\nfunction bubleSort(arr) {\n    var len = arr.length;\n    for (let outer = len ; outer >= 2; outer--) {\n        for(let inner = 0; inner <=outer - 1; inner++) {\n            if(arr[inner] > arr[inner + 1]) {\n                [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]\n            }\n        }\n    }\n    return arr;\n}\n\n// 推荐\nfunction bubleSort(arr) {\n    var nLength = arr.length;\n\n    if (nLength < 2) {\n        return arr;\n    }\n\n    for (var i = nLength - 1; i > 0; --i) {\n        for (var j = 0; j < i; ++j) {\n            if (arr[j] > arr[j + 1]) {\n                var temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n## 选择排序(遍历自身以外的元素，最小的元素和自己调换位置)\n```js\n// 推荐\nfunction selectSort(arr) {\n    var len = arr.length;\n    for(let i = 0 ;i < len - 1; i++) {\n        for(let j = i ; j<len; j++) {\n            if(arr[j] < arr[i]) {\n                [arr[i],arr[j]] = [arr[j],arr[i]];\n            }\n        }\n    }\n    return arr\n}\n\nfunction selectSort(arr) {\n    var nLength = arr.length;\n    if (nLength < 2) {\n        return arr;\n    }\n    for (var i = 0; i < nLength; i++) {\n        var index = i;\n        for (var j = i + 1; j < nLength; j++) {\n            if (arr[j] < arr[index]) {\n                index = j;\n            }\n        }\n        if (i !== index) {\n            var temp = arr[i];\n            arr[i] = arr[index];\n            arr[index] = temp;\n        }\n    }\n    return arr;\n}\n```\n\n## 插入排序(将元素插入到已排序好的数组中)\n```js\nfunction insertSort(arr) {\n    for(let i = 1; i < arr.length; i++) {  \n        // 外循环从1开始，默认arr[0]是有序段\n        for(let j = i; j > 0; j--) {  \n            // j = i,将arr[j]依次插入有序段中\n            if(arr[j] < arr[j-1]) {\n                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];\n            } else {\n                break;\n            }\n        }\n    }\n    return arr;\n}\n\nfunction insertSort(arr) {\n    var nLength = arr.length;\n    if (nLength < 2) {\n        return arr;\n    }\n    for (var i = 1; i < nLength; ++i) {\n        var j = i,\n            value = arr[i];\n        while (j > 0 && arr[j - 1] > value) {\n            arr[j] = arr[j - 1];\n            --j;\n        }\n        if (j !== i) {\n            arr[j] = value;\n        }\n    }\n    return arr;\n}\n```\n\n### 快速排序\n- 选择基准值(base)，原数组长度减一(基准值)，使用 splice\n- 循环原数组，小的放左边(left数组)，大的放右边(right数组);\n- concat(left, base, right)\n- 递归继续排序 left 与 right\n\n```js\nfunction quickSort(arr) {\n    if(arr.length <= 1) {\n        return arr;  //递归出口\n    }\n    var left = [],\n        right = [],\n        current = arr.splice(0,1); \n    for(let i = 0; i < arr.length; i++) {\n        if(arr[i] < current) {\n            left.push(arr[i])  //放在左边\n        } else {\n            right.push(arr[i]) //放在右边\n        }\n    }\n    return quickSort(left).concat(current,quickSort(right));\n}\n\nfunction quickSort(arr) {\n    var nLength = arr.length,\n        pivotIndex = Math.floor(nLength / 2),\n        pivot = arr.splice(pivotIndex, 1)[0],\n        left = [],\n        right = [];\n    if (nLength < 2) {\n        return arr;\n    }\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return arguments.callee(left).concat([pivot], arguments.callee(right));\n}\n```\n\n### 希尔排序(不定步数的插入排序，插入排序)\n> 插冒归基稳定，快选堆希不稳定\n```js\nfunction shellSort(arr){\n    var nLength = arr.length;\n    if (nLength < 2) {\n        return arr;\n    }\n    for (var step = nLength >> 1; step > 0; step >>= 1) {\n        for (var i = 0; i < step; ++i) {\n            for (var j = i + step; j < nLength; j += step) {\n                var k = j,\n                    value = arr[j];\n                while (k >= step && arr[k - step] > value) {\n                    arr[k] = arr[k - step];\n                    k -= step;\n                }\n                arr[k] = value;\n            }\n        }\n    }\n    return arr;\n}\n```\n![sort](http://cdn.mydearest.cn/blog/images/sort.png)\n","tags":["排序"],"categories":["JS"]},{"title":"详解 Cookie、 LocalStorage 与 SessionStorage","url":"%2Fstorage.html","content":"\n## Cookie(属于文档对象模型DOM树根节点document)\n\nCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n## localStorage(属于浏览器对象模型BOM的对象window)\n\nlocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。\n\n缺点：\n1. 存储容量限制，大部分浏览器应该最多5M。\n2. 仅支持字符串，如果是存对象还需要将使用JSON.stringify和JSON.parse方法互相转换，有些啰嗦。\n3. 读取都是同步的。大多数情况下，还挺好使的。但如果存储数据比较大，例如一张重要图片base64格式存储了，读取可能会有可感知的延迟时间。\n\n## sessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n--- \n<!-- more -->\n\n## 三者的异同\n\n|特性|Cookie|localstorage|sessionstorage|\n|:---:|:---:|:---:|\n|生命周期|一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效|除非被清除，否则永久保存|仅在当前会话下有效，关闭页面或浏览器后被清除|\n|数据大小|4K|5M|5M|\n|与服务器端通信|每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题|仅在客户端（即浏览器）中保存，不参与和服务器的通信|同上|\n|易用性|需要自己封装，原生的Cookie接口不友好|可以封装来对Object和Array有更好的支持|同上|\n\n还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。\nIE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。\n\n## 安全性的考虑\n\n需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。\n\n## cookie用法\nJavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。\ndocument.cookie=\"username=John Doe\";\n\n您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：\ndocument.cookie=\"username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT\";\n\n您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。\ndocument.cookie=\"username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/\";\n\n```javascript\n// 设置cookie\nfunction setCookie(cname,cvalue,exdays)\n{\n  var d = new Date();\n  d.setTime(d.getTime()+(exdays*24*60*60*1000));\n  var expires = \"expires=\"+d.toGMTString();\n  document.cookie = cname + \"=\" + cvalue + \"; \" + expires;\n}\n\nfunction getCookie(name) {\n  var arr = document.cookie.replace(/\\s/g, \"\").split(\";\");\n  for (var i = 0; i < arr.length; i++) {\n    var tempArr = arr[i].split(\"=\");\n    if (tempArr[0] === name) {\n      return decodeURIComponent(tempArr[1]);\n    }\n  }\n  return \"\";\n}\n\n// 获取指定cookie\nfunction getCookie2(cname)\n{\n  var name = cname + \"=\";\n  var ca = document.cookie.split(';');\n  for(var i=0; i<ca.length; i++) \n  {\n    var c = ca[i].trim();\n    if (c.indexOf(name)==0) return c.substring(name.length,c.length);\n  }\n  return \"\";\n}\n\nfunction getCookie3(name) {\n  let v = window.document.cookie.match(\"(^|;) ?\" + name + \"=([^;]*)(;|$)\");\n  return v ? v[2] : null;\n}\n\nconst cookie = (n, v) => {\n  if (typeof v !== 'undefined') {\n    window.document.cookie = [n, '=', encodeURIComponent(v)].join('')\n  } else {\n    v = window.document.cookie.match(new RegExp(`(?:\\\\s|^)${n}\\\\=([^;]*)`))\n    return v ? decodeURIComponent(v[1]) : null\n  }\n}\n\n// 检测cookie函数\nfunction checkCookie()\n{\n  var username=getCookie(\"username\");\n  if (username!=\"\")\n  {\n    alert(\"Welcome again \" + username);\n  }\n  else \n  {\n    username = prompt(\"Please enter your name:\",\"\");\n    if (username!=\"\" && username!=null)\n    {\n      setCookie(\"username\",username,365);\n    }\n  }\n}\n```\n## localStorage和sessionStorage用法(存储数组、数字、对象等可以被序列化为字符串的内容)\nlocalStorage和sessionStorage类似(也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储)\n\nwindow.localStorage.key(1) // 读取索引为1的值\n```javascript\n    static setStorage(name, data) {\n        if (typeof data === 'object') {\n            window.localStorage.setItem(name, JSON.stringify(data))\n        } else if (typeof data === 'number' || typeof data === 'string' || typeof data === 'boolean') {\n            window.localStorage.setItem(name, data)\n        } else {\n            alert('该类型不能用于本地存储~')\n        }\n    }\n\n    /**\n     * 获取localstorage\n     */\n    static getStorage(name) {\n        let data = window.localStorage.getItem(name)\n        if (data) {\n            return JSON.parse(data)\n        } else {\n            return ''\n        }\n    }\n\n    /**\n     * 删除localstorage\n     */\n    static removeStorage(name) {\n        window.localStorage.removeItem(name)\n    }\n\n    /**\n     * 清空localstorage\n     */\n    static clearStorage() {\n        window.localStorage.clear()\n    }\n```\n\n## cookie 与 session 的区别\n- Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； \n\n- Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。\n\n## 规避localStorage缺点---localforage\n\nlocalforage的逻辑是这样的：优先使用IndexedDB存储数据，如果浏览器不支持，使用WebSQL，浏览器再不支持，使用localStorage。\n\nlocalforage的API名称和localStorage一样，但是，在同步还是异步上却不同，localforage是异步执行的，用法示意如下。\n```javascript\nlocalforage.getItem('key', function (err, value) {\n    // 如果err不是null，则出错。否则value就是我们想要的值\n});\n```","tags":["浏览器"],"categories":["JS"]},{"title":"面试题整理归纳","url":"%2Finterview.html","content":"\n## 字符串扩展的方法\n- includes()：返回布尔值，表示是否找到了参数字符串。数组也可以 a[1]=1 且能判断undefined\n```js\nvar a=[1,2,3]\na[4]=5 // [1, 2, 3, undefined × 1, 5] empty\n// a[3]=undefined [1, 2, 3, undefined, 5] \n\na.indexOf(undefined) // -1\na.includes(undefined) // true \n```\n- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n```js\n// polyfill\nif (String.prototype.startsWith) {\n  String.prototype.startsWith = function (search, index) {\n    return this.substr((!index || index < 0) ? 0 : index, search.length) === search;\n  }\n}\n```\n- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\nstr | index\n- repeat()：返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整(不四舍五入)。参数是负数或者Infinity，会报错。0/NaN返回空字符串,参数是字符串，则会先转换成数字，不传则为空字符串。\n- padStart()：头部补全。\n- padEnd()：尾部补全\n~~~\n'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n~~~\n如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。默认使用空格\n\n---\n<!-- more -->\n\n- 模板字符串（template string）是增强版的字符串，用反引号\\`标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\\`${表达式、变量}\\`\n- commonjs 服务器端 amd 浏览器端\n- const 必须赋值定义 let 在同一作用于无法重复命名 无法变量提升\n- split(字符串或者正则,设置长度) 字符串=>数组\n- substr(开始的索引//splice可以为负数-1则为字符串最后一个字符,length字符数)方法不同的是,substring(开始索引，结束索引+1)负的参数有区别\n只有单参数时到字符串结尾\nString exd=filePath.substring(filePath.lastIndexOf(\".\")+1,filePath.length)\n\n## 声明函数作用提升?声明变量和声明函数的提升有什么区别?\n\n(1) 变量声明提升：变量申明在进入执行上下文就完成了。\n只要变量在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；\n\n(2) 函数声明提升：执行代码之前会先读取函数声明，意味着可以把函数申明放在调用它的语句后面。\n只要函数在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；\n\n(3) 变量or函数声明：函数声明会覆盖变量声明，但不会覆盖变量赋值。\n同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。注意：如果在变量声明的同时初始化a，或是之后对a进行赋值，此时a的值变量的值。\n```javascript\neg: var a; var c = 1; a = 1; function a() { return true; } console.log(a);\n```\n\n## 如何判断数据类型？\ntypeof返回的类型都是字符串形式，可以判断function的类型；在判断除Object类型的对象时比较方便。\n判断已知对象类型的方法： instanceof，后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。\n```javascript\ntypeof null // object null instanceof Object // false\n\nvar str = 'abc';     \nconsole.log(typeof str++);         //number NaN\nconsole.log(typeof ('abc' + 1));   //string 'abc1'\n\nconsole.log(typeof new Date());    //object\nconsole.log(typeof Date());        //string\nconsole.log(typeof Date);          //function\n```\n\n### typeof原理\n- js在底层存储变量的时候，会在变量的机器码的低位1-3位存储类型信息\n - 对象 000开头\n - null 都为0\n - 浮点数 010\n - 字符串 100\n - 布尔 110\n - 整数 1\n - undefined -2^30\n \n## 异步编程？\n- 方法1：回调函数，优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。\n\n- 方法2：事件监听，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n- 方法3：事件发布/订阅，性质与“事件监听”类似，但是明显优于后者。\n\n- 方法4：Promises对象，是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。\n\n - generator\n - async/await\n\n## 事件流？事件捕获？事件冒泡？\n事件流：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。\n\n事件的传播分为3个阶段：\n1. 捕获阶段：事件从window对象自上而下向目标节点传播的阶段；\n2. 目标阶段：真正的目标节点正在处理事件的阶段；\n3. 冒泡阶段：事件从目标节点自下而上向window对象传播的阶段；\n\n事件捕获是不太具体的元素应该更早接受到事件，而最具体的节点应该最后接收到事件。他们的用意是在事件到达目标之前就捕获它。\n事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。\n\n> 并不是所有的事件都能冒泡\n- onblur\n- onfocus\n- onmouseenter\n- onmouseleave\n\n![boardcast](http://cdn.mydearest.cn/blog/images/boardcast.png)\n\n```html\n<nav id=\"root_b\">\n  <ul id=\"first_b\">\n    <li id=\"second_b\"><a id=\"target_b\" href=\"#\">冒泡</a></li>\n  </ul>\n</nav>\n<nav id=\"root_c\">\n  <ul id=\"first_c\">\n    <li id=\"second_c\"><a id=\"target_c\" href=\"#\">捕获</a></li>\n  </ul>\n</nav>\n```\n```js\n/**\n* listen\n* @param {string[]} ids \n* @param {boolean} isCatch \n*/\nconst listen = (ids, isCatch) => ids.forEach(id => document.getElementById(id).addEventListener('click', () => alert(id), isCatch))\n\n// BubbleEvent\nlisten(['root_b', 'first_b', 'second_b', 'target_b'], false)\n\n// CatchEvent\nlisten(['root_c', 'first_c', 'second_c', 'target_c'], true)\n```\n\n## 如何添加一个dom对象到body中?innerHTML、document.write和innerText区别?\nbody.appendChild(dom元素)；  \ninnerHTML:从对象的起始位置到终止位置的全部内容,包括Html标签。\ninnerText:从起始位置到终止位置的内容, 但它去除Html标签 \ndocument.write只能重绘整个页面\n\n## 简述ajax流程  \n1)客户端产生触发js的事件  \n2)创建XMLHttpRequest对象  \n```js \nvar client=null\nif(window.XMLHttpRequest){\n      client = new XMLHttpRequest();\n}else{\n      client = new ActiveXObject(\"Microsoft.XMLHTTP\");\n}\n```\n3)对XMLHttpRequest进行配置 \n```js   \nclient.open(\"GET\", url);\nclient.onreadystatechange = function(e) {\n    if (client.readyState !== 4) { // client状态\n      return;\n    }\n    if (client.status === 200) { // HTTP状态码\n      console.log('success', client.responseText);\n    } else {\n      console.warn('error');\n    }\n}; // 指定回调函数\nclient.responseType = \"json\";\nclient.setRequestHeader(\"Accept\", \"application/json;\");\nclient.setRequestHeader(\"Content-Type\", \"application/json;charset=utf-8\");\n```\n4)通过AJAX引擎发送异步请求 \n```javascript\n  client.send()\n```\n`promise 封装`\n```js\n/**\n  * @param {string} url\n  * @param {string} method\n  * @param {object} params\n  * @returns\n  */\nfunction request(url, method = 'GET', params = null) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.open(method, url)\n    xhr.addEventListener('readystatechange', () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          resolve(xhr.responseText)\n        } else {\n          reject({\n            code: xhr.status,\n            response: xhr.response\n          })\n        }\n      }\n    })\n    setTimeout(() => reject('timeout:1000'), 1000)\n    xhr.send(JSON.stringify(params))\n  })\n}\n```\n5)服务器端接收请求并且处理请求，返回html或者xml内容  \n6)XML调用一个callback()处理响应回来的内容  \n7)使用JS和DOM实现局部刷新\n\n## 自执行函数？用于什么场景？好处？  \n1、声明一个匿名函数  \n2、马上调用这个匿名函数。  \n作用：创建一个独立的作用域。  \n\n好处：防止变量弥散到全局，以免各种js库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理。\n\n场景：一般用于框架、插件等场景，设计私有变量和方法，封闭私有作用域。\n\n## 立即执行函数表达式(IIFE)\n### 使用匿名函数表达式\n```js\nvar a = 2;\n(function IIFE(){\n\tvar a = 3;\n\tconsole.log(a);//3\n})();\nconsole.log(a);//2\n```\n### 当作函数调用并传递参数进去\n```js\nvar a = 2;\n(function IIFE(global){\n\tvar a = 3;\n\tconsole.log(a);//3\n\tconsole.log(global.a);//2\n})(window);\nconsole.log(a);//2\n```\n### 解决undefined标识符默认值被错误覆盖\n```js\nundefined = true;\n(function IIFE(){\n\tvar a ;\n\tif(a === undefined){\n\t\tconsole.log('Undefined is safe here!');\n\t}\n})();\n```\n### 倒置代码运行顺序\n```js\nvar a = 2;\n(function IIFE(def){\n\tdef(window);\n})(function def(global){\n\tvar a = 3;\n\tconsole.log(a);//3\n\tconsole.log(global.a);//2\n});\n```\n\n```js\nvar i = 1;\nvar IFun = (function(){\n\tvar i = 1;\n\tconsole.log(i);\n\treturn function(){\n\t\ti++;\n\t\tconsole.log(i);\n}\n})();\nIFun();\nIFun();\n最终输出的结果为1，2，3，很多人会下意识的觉得结果会有4个值，但是运用了return 返回值以及自执行函数将函数返回给IFun变量，使得在第一次操作过程后，将返回函数直接赋给IFun。\n```\n\n### 作用\n1. 创建作用域，内部保存一些大量临时变量的代码防止命名冲突。\n2. 一些库的外层用这种形式包起来防止作用域污染。\n3. 运行一些只执行一次的代码\n\n## 回调函数？（传递地址，由非实现方调用）  \n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函\n数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\n\n## 什么是闭包?堆栈溢出有什么区别？ 内存泄漏? 那些操作会造成内存泄漏？怎么样防止内存泄漏？impression  \n闭包：就是能够读取其他函数内部变量的函数。一般是指内层函数。(子函数在外调用，子函数所在的父函数的作用域不会被释放。) \n\n堆栈溢出：就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。经常会在递归中发生。\n\n内存泄漏是指：用动态存储分配函数内存空间，在使用完毕后未释放，导致一直占据该内存单元。直到程序结束。指任何对象在您不再拥有或需要它之后仍然存在。\n\n造成内存泄漏：\nsetTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n防止内存泄漏：  \n1、不要动态绑定事件；      \n2、不要在动态添加，或者会被动态移除的dom上绑事件，用事件冒泡在父容器监听事件；  \n3、如果要违反上面的原则，必须提供destroy方法，保证移除dom后事件也被移除，这点可以参考Backbone的源代码，做的比较好；  \n4、单例化，少创建dom，少绑事件。\n\n原因：\n全局变量没有手动销毁，因为全局变量不会被回收\n闭包：闭包中的变量被全局对象引用，则闭包中的局部变量不能释放\n监听事件添加后，没有移除，会导致内存泄漏\n- 意外的全局变量无法被回收\n- 闭包\n- 定时器未删除被正确关闭\n- dom事件未清除\n- dom元素删除内存存在引用\n\n## html和xhtml有什么区别?\nHTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的标记语言。\n\n1.XHTML 元素必须被正确地嵌套。\n\n2.XHTML 元素必须被关闭。\n\n3.标签名必须用小写字母。\n\n4.空标签也必须被关闭。\n\n5.XHTML 文档必须拥有根元素。\n\n## 什么是构造函数？与普通函数有什么区别?\n构造函数：是一种特殊的方法(函数、对象)、主要用来创建对象时初始化对象，总与new运算符一起使用，创建对象的语句中构造函数的函数名必须与类名完全相同。\n\n与普通函数相比只能由new关键字调用，构造函数是类的标识。\n\n## 通过new创建一个对象的时候，函数内部有哪些改变？\n```javascript\nfunction Person(){}\nPerson.prototype.friend = [];\nPerson.prototype.age = 18;\n  var a = new Person();\n  a.friend[0] = '方涛'; // a.friend=['123'] 指向新对象 b.friend // []\n  a.age = 18;\n  var b = new Person();\n  b.friend // ['方涛'] \n  b.age   // 18\n```\n> 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。   \n> 2、属性和方法被加入到 this 引用的对象中。  \n> 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n\n`new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。`\n\n- 创建一个空对象：var obj = {}\n\n- 将空对象的__proto__指向构造函数的 prototype：obj.__proto__ = Person().prototype\n\n- 使用空对象作为上下文调用构造函数： Person.call(obj)\n\n```js\nfunction myNew (fn, ...args) {\n  let instance = Object.create(fn.prototype);\n  let result = fn.call(instance, ...args)\n  return typeof result === 'object' ? result : instance;\n}\n```\n\n## 事件委托的好处都有啥？说对了都给它=3=\n- 利用冒泡的原理，把事件加到父级上，触发执行效果  \n\n- 好处：新添加的元素还会有之前的事件；提高性能。\n\n## 节点类型?判断当前节点类型?\n- 元素节点 \n- 属性节点 \n- 文本节点 \n- 注释节点 \n- 文档节点\n\n通过nodeObject.nodeType判断节点类型：其中，nodeObject 为DOM节点（节点对象）。该属性返回以数字表示的节点类型，例如，元素节点返回 1，属性节点返回 2 。\n\n## 数组合并的方法？\n```js\n// 四种方法。\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\narr1 = arr1.concat(arr2);\nconsole.log(arr1); \n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\nArray.prototype.push.apply(arr1,arr2);\nconsole.log(arr1);\n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\nfor (var i=0; i < arr2.length; i++) {\narr1.push( arr2[i] );\n}\nconsole.log(arr1); \n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\n\narr1.push(...arr2)\n```\n\n## jquery和zepto有什么区别?\n- 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。\n\n- Dom操作的区别：添加id时jQuery不会生效而Zepto会生效。\n\n- zepto主要用在移动设备上，只支持较新的浏览器，好处是代码量比较小，性能也较好。\njquery主要是兼容性好，可以跑在各种pc，移动上，好处是兼容各种浏览器，缺点是代码量大，同时考虑兼容，性能也不够好。\n\n## $(function(){})和window.onload 和 $(document).ready(function(){})\n\n- window.onload:用于当页面的所有元素，包括外部引用文件，图片等都加载完毕时运行函数内的函数。load方法只能执行一次，如果在js文件里写了多个，只能执行最后一个。\n\n- $(document).ready(function(){})和$(function(){})都是用于当页面的标准DOM元素被解析成DOM树后就执行内部函数。这个函数是可以在js文件里多次编写的，对于多人共同编写的js就有很大的优势，因为所有行为函数都会执行到。而且$(document).ready()函数在HMTL结构加载完后就可以执行，不需要等大型文件加载或者不存在的连接等耗时工作完成才执行，效率高。\n\n## 简述下 this 和定义属性和方法的时候有什么区别?Prototype？\n\n- this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向。\n\n- prototype本质上还是一个JavaScript对象。 并且每个函数都有一个默认的prototype属性。\n\n- 在prototype上定义的属性方法为所有实例共享，所有实例皆引用到同一个对象，单一实例对原型上的属性进行修改，也会影响到所有其他实例。\n\n## ajax和jsonp的区别？\n- 相同点：都是请求一个url\n- 不同点：ajax的核心是通过XMLHttpRequest获取内容，jsonp只能get请求\n- jsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。\n\n## 常见的http协议状态码？\n```js\n1xx (临时响应)\n100: 继续(正在加载)\n101：切换协议  \n200：请求成功\n201：请求成功并且服务器创建了新的资源\n302：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。\n304：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。\n400：服务器不理解请求的语法。\n403：该状态表示服务器理解了本次请求但是拒绝执行该任务\n404：请求的资源（网页等）不存在\n405：方法不被允许\n500：内部服务器错误\n502：网关错误\n504：网关超时\n```\n\n## sessionStorage和localstroage与cookie之间有什么关联, cookie最大存放多少字节？\n三者共同点：都是保存在浏览器端，且同源的。\n\n区别:\n1、cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n\n### cookie的作用\n- 保存用户登录状态(存储sessionId来标识唯一用户)\n- 跟踪用户行为\n- 定制页面\n\n2、存储大小限制也不同，cookie数据不能超过4k，sessionStorage和localStorage 但比cookie大得多，可以达到5M\n\n3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n4、作用域不同，sessionStorage只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的( 即数据共享 )。\n\n\n## ajax的get与post区别？\n- get和post都是数据提交的方式。\n- get的数据是通过网址问号后边拼接的字符串进行传递的。post是通过一个HTTP包(request body)进行传递数据的。\n- get的传输量是有限制的，post是没有限制的。(实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度)\n- get的安全性可能没有post高，所以我们一般用get来获取数据，post一般用来修改数据。\n- get请求, 倒退按钮是无害的, post会重新发起请求\n- get会主动缓存, post不会\n- get请求只能进行url编码，而post请求支持多种编码\n- ***get产生一个TCP数据包，POST产生两个TCP数据包***\n- get比较快且有历史记录\n\nget就是将货品放在车顶，post放在车内。\n\n![get-post-diff](http://cdn.mydearest.cn/blog/images/get-post-diff.png)\n\n## GC机制？为什么闭包不会被回收变量和函数？\n- GC垃圾回收机制：将内存中不再使用的数据进行清理，释放出内存空间。\n\n引用类型是在没有引用之后, 通过 v8 的 GC 自动回收, 值类型如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 \n(new space) 切换的时候回收。\n\nv8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v\n8 引擎将内存分为了新生代和老生代。\n\n新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。\n\nV8 将内存分成 新生代空间 和 老生代空间。\n\n回收方法有两种：标记清除、计数引用\n\n老生代采用了标记清除法和标记压缩法。标记清除简单讲就是变量存储在内存中，当变量进入执行环境的时候，垃圾回收器会给它加上标记，这个变量离开执行环境，将其标记为“清除”，不可\n追踪，不被其他对象引用，或者是两个对象互相引用，不被第三个对象引用，然后由垃圾回收器收回，释放内存空间。。\n\n由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影\n响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。\n\n## 面向对象？\n万物皆对象，把一个对象抽象成类，具体上就是把一个对象的静态特征和动态特征抽象成属性（属性名、属性值）和方法，也就是把一类事物的算法和数据结构封装在一\n个类之中，程序就是多个对象和互相之间的通信组成的。\n\n面向对象具有封装性，继承性，多态性。\n封装：隐蔽了对象内部不需要暴露的细节，使得内部细节的变动跟外界脱离，只依靠接口进行通信。封装性降低了编程的复杂性。通过继承，使得新建一个类变得容易，一个类从派生类那里获得其非私有的方法和公用属性的繁琐工作交给了编译器。而继承和实现接口和运行时的类型绑定机制所产生的多态，使得不同的类所产生的对象能够对相同的消息作出不同的反应，极大地提高了代码的通用性。\n\n总之，面向对象的特性提高了大型程序的重用性和可维护性。\n\n## jsonp的原理和缺点？\n- 原理：使用script标签实现跨域访问，可在url中指定回调函数，获取JSON数据并在指定的回调函数中执行jquery实现jsop。\n- 缺点：只支持GET方式的jsonp实现，是一种脚本注入行为存在一定的安全隐患。如果返回的数据格式有问题或者返回失败了，并不会报错。\n\n## call和apply两者的区别和好处？\n- call和apply都是改变this指向的方法，区别在于call可以写多个参数，而apply只能写两个参数，第二个参数是一个数组，用于存放要传的参数。\n- 用call和apply实现更好的继承和扩展，更安全。\n\n## 压缩合并目的？http请求的优化方式？\n- Web性能优化最佳实践中最重要的一条是减少HTTP请求。而减少HTTP请求的最主要的方式就是，合并并压缩JavaScript和CSS文件。 \n\n- CSS Sprites（雪碧图、CSS精灵）：把全站的图标都放在一个图像文件中，然后用CSS的background-image和background-position属性定位来显示其中的一小部分。\n\n优点：\n1. 减少 HTTP 请求数，极大地提高页面加载速度\n2. 增加图片信息重复度，提高压缩比，减少图片大小\n3. 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现\n\n缺点：\n\n1. 图片合并麻烦\n2. 维护麻烦，修改一个图片可能需要重新布局整个图片，样式\n\n- 合并脚本和样式表; 图片地图：利用image map标签定义一个客户端图像映射，（图像映射指带有可点击区域的一幅图像）具体看：http://club.topsage.com/thread-2527479-1-1.html \n\n- 图片js/css等静态资源放在静态服务器或CDN服务器时，尽量采用不用的域名，这样能防止cookie不会互相污染，减少每次请求的往返数据。 \n\n- css替代图片, 缓存一些数据 \n\n- 少用location.reload()：使用location.reload() 会刷新页面，刷新页面时页面所有资源 (css，js，img等) 会重新请求服务器。建议使用location.href=\"当前页url\" 代替location.reload() ，使用location.href 浏览器会读取本地缓存资源。\n\n- 图片懒加载 \n\n\n## commonjs?requirejs?AMD|CMD|UMD?\n- CommonJS就是为JS的表现来制定规范，NodeJS是这种规范的实现，webpack 也是以CommonJS的形式来书写。因为js没有模块的功能，所以CommonJS应运而生。但它不能在浏览器中运行。 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)} \n\n- RequireJS 是一个JavaScript模块加载器。 RequireJS有两个主要方法(method): define()和require()。这两个方法基本上拥有相同的定义(declaration) 并且它们都知道如何加载的依赖关系，然后执行一个回调函数(callback function)。与require()不同的是， define()用来存储代码作为一个已命名的模块。 因此define()的回调函数需要有一个返回值作为这个模块定义。这些类似被定义的模块叫作AMD (Asynchronous Module Definition，异步模块定义)。 \n\n- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出 AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。 适用AMD规范适用define方法定义模块。\n\n- CMD是SeaJS 在推广过程中对模块定义的规范化产出\nAMD与CMD的区别：\n（1）对于于依赖的模块，AMD 是提前执行(requirejs2.0+可以延迟执行了)，CMD 是延迟执行。\n（2）AMD 推崇依赖前置，CMD 推崇依赖就近。\n（3）AMD 推崇复用接口，CMD 推崇单用接口。\n（4）书写规范的差异。\n\n- umd是AMD和CommonJS的糅合。\nAMD 浏览器第一的原则发展 异步加载模块。\nCommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD ( Universal Module Definition ), 希望解决跨平台的解决方案。UMD先判断是否支持Node.js的模块( exports )是否存在，存在则使用Node.js模块模式。\n\n### 差异\n1. `CommonJS 模块输出的是一个值的浅拷贝，ES6 模块输出的是值的引用。`也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 \nCommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那\n个模块里面去取值。\n\n2. `CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。`CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读\n取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n3. CommonJs导入的模块路径可以是一个表达式，因为它使用的是require()方法；而ES6 Modules只能是字符串。\n\n4. CommonJS this指向当前模块，ES6 Modules this指向undefined\n\n5. ES6 Modules中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname\n\n## js的几种继承方式？\n- 使用对象冒充实现继承\n- call、apply改变函数上下文实现继承\n- 原型链方式实现继承\n\n## js原型、原型链，有什么特点？\n在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性[[prototype]],我们通常称之为原型.原型的值可以是一个对象,也可以是null.如果它的值是一个对象,则这个对象也一定有自己的原型.这样就形成了一条线性的链,我们称之为原型链. \n\n访问一个对象的原型可以使用ES5中的Object.getPrototypeOf方法,或者ES6中的__proto__属性. 原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的。\n\n类的继承\n特点：基于原型链，既是父类的实例，也是子类的实例\n缺点：无法实现多继承\n\n构造继承、组合继承、实例继承和拷贝继承...\n\n## eval是做什么的？\n- 将把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。\n- 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');\n\n## null和undefined\n- null         表示一个对象是“没有值”的值，也就是值为“空”；\n- undefined     表示一个变量声明了没有初始化(赋值)；\n> Number(null)为0，而undefined为NaN\n\n## json的理解？\n- JSON（轻量级的数据交换格式），基于JS的子集，数据格式简单，易于读写，占用带宽小。\n```javascript\nJSON.parse() // 解析成JSON对象\n\nJSON.strinify() // 解析成JSON字符串\n```\n\n## script 引入方式：\n- html 静态<script>引入\n- js 动态插入<script>\n- <script defer>: 延迟加载，元素解析完成后执行\n- <script async>: 异步加载，但执行时会阻塞元素渲染只是它的加载过程不会阻塞\n\n## ajax（异步的js和xml）\n- ajax是指一种创建交互式网页应用的网页开发技术。通过后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n## 同异步的区别？\n- 同步(sync)：按顺序执行。\n- 异步(async)：不按顺序执行，可以跳过执行下面的代码。\n\n### 什么是异步\n当前一个任务被执行时，不会等待任务执行完成后就去执行下一个任务，等前一个任务执行完成后，将去执行其返回的回调函数，这是异步操作。\n\n### 为什么要异步\njs是单线程的，因此必须等前一个任务完成后，后一个任务才会被执行。因此当执行一段耗时的程序时，会影响整个程序的执行，异步的方法就是为了解决这个问题。\n\n## ajax的缺点？\n- 不支持浏览器的back按钮(事件由浏览器内核控制)\n- ajax暴露了与服务器的交互\n- 对搜索引擎的支持较弱\n- 破坏了程序的异常机制\n- 不容易调试\n\n## 跨域问题？\n### 同源策略\n同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键安全机制。\n\n- 协议不同\n- 端口不同\n- 域名不同\n- 常用解决方案：\n1. jsonp\n```html\n<script src=\"http://example.com/data.php?callback=do\"></script>\n```\n2. iframe\n3. window.name\n在一个窗口中，窗口载入的所有页面共享一个window.name，每个页面都对window.name具有读写权限，可以在window.name中设置想要的数据。\n4. window.postMessage\n```js\n// iframe通信\niframe.contentWindow.postMessage(msg);\nwindow.onmessage = function (e) {\n    e = e || event;\n    alert(e.data);\n}\n```\n5. document.domain\n将两个页面的document.domain设置成相同域名即可，js中设置，形如：\ndocument.domain = \"\";\n6. 服务器设置代理页面/响应header配置cors access-control-allow-origin\nCORS全称“ Cross-origin resource sharing ”（跨域资源共享），相比JSONP， CORS允许任何类型的请求 。\n\n> CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\n\n> 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨\n> 源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n\n> 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。\n\n7. nginx反向代理、nodejs反向代理\n- http-proxy-middleware 插件\n```js\nvar express = require('express');\nvar proxy = require('http-proxy-middleware');\n\nvar app = express();\n\napp.use('/cosyer', proxy({target: 'http://39.105.136.190:3000/', changeOrigin: true}));\napp.listen(3000);\n```\n\n- webpack-dev-server\n```js\ndevServer: {\n    port: 3000,\n    inline: true,\n    proxy: {\n        \"/cosyer\": {\n            target: \"http://39.105.136.190:3000/\",\n            changeOrigin: true  //必须配置为true，才能正确代理\n        }\n    }\n}\n```\nwebpack 的 devServer.proxy 就是使用了非常强大的 http-proxy-middleware 包来实现代理的，所以本质上是相通的。\n\n- nginx\n```js\nserver {\n  listen  80;\n  server_name  client.com;\n  location /api {\n    proxy_pass server.com;\n  }\n}\n```\n\n8. WebSocket\nWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。\n\n由于发出的WebSocket请求中有有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。\n\n正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。\n```js\nvar ws = new WebSocket('wss://echo.websocket.org');\nws.onopen = function (evt) {\n  console.log('Connection open ...');\n  ws.send('Hello WebSockets!');\n};\nws.onmessage = function (evt) {\n  console.log('Received Message: ', evt.data);\n  ws.close();\n};\nws.onclose = function (evt) {\n  console.log('Connection closed.');\n};\n```\n\n```\n前后端通信方式\nAjax 支持同源通信\nWebSocket 不受同源策略影响\nCORS 既支持同源通信也支持跨域通信\n```\n\n## 解决异步回调地狱有哪些方案？\n- promise\n- generator\n- async/await(优缺点)\n`async 和await` 相比直接使用 `Promise` 来说,优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性，导致性能的降低。\n\n## 图片的预加载和懒加载？\n- 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染，加快响应速度。\n- 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。\n\n两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n## mouseover和mouseenter的区别？\n- mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout\n\n- mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave\n\n- onmousedown 当元素上按下鼠标按钮时出发\n- onmousemove 当鼠标指针移动到元素上移动触发\n- onmouseover 当鼠标指针移动元素上时触发\n- onmouseout 当鼠标指针移出指定的对象时发生。\n- onmouseup 当在元素上释放鼠标按钮时触发\n- onmouseenter 事件在鼠标指针移动到元素上时触发。(不冒泡)\n- onmouseleave 事件在鼠标移除元素时触发。(不冒泡)\n\n## 改变函数内部this指针的指向函数（bind，apply，call的区别）？\n- 通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象(函数作用域)，第二个参数，apply是数组或者类数组对象arguments，而call则是arg1,arg2...这种形式。\n\n- 通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。\n\n## 说说前端中的事件流\nHTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。\n什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。\n\n事件捕获阶段\n处于目标阶段\n事件冒泡阶段\n\naddEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\nIE只支持事件冒泡。\n\n## 如何让事件先冒泡后执行？\n在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事\n件。\n\n## 什么是事件委托？（事件代理）\n简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的\n响应。\n\n捕获阶段的实际应用：可以在父元素层面阻止事件向子元素传播，也可以代替子元素执行某些操作。\n\n举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。\n\n好处：\n1. 减少内存消耗，提高性能(不需要为每一个子元素绑定事件)\n2. 动态绑定事件\n\n```html\n<ul id=\"proxy\">\n  <li><button id=\"1\">1</button></li>\n  <li><button id=\"2\">2</button></li>\n  <li><button id=\"3\">3</button></li>\n</ul>\n```\n\n```js\nfunction main() {\n  const proxy = document.getElementById('proxy')\n\n  proxy.addEventListener('click', event => {\n    const currentTarget = event.target\n    const id = currentTarget.id\n    switch (id) {\n      case '1':\n        alert(`proxy: ${1}`)\n        break;\n      case '2':\n        alert(`proxy: ${2}`)\n        break;\n      case '3':\n        alert(`proxy: ${3}`)\n        break;\n      default:\n        break;\n    }\n  })\n}\n```\n- event.target & event.currentTarget\n```js\n<div id=\"a\">\n    aaaa\n  <div id=\"b\">\n      bbbb\n    <div id=\"c\">\n        cccc\n      <div id=\"d\">\n          dddd\n      </div>\n    </div>\n  </div>\n</div>\n\n<script>\n    document.getElementById(\"a\").addEventListener(\"click\", function (e) {\n        console.log(\n            \"target:\" + e.target.id + \"&currentTarget:\" + e.currentTarget.id\n        );\n    });\n    document.getElementById(\"b\").addEventListener(\"click\", function (e) {\n        console.log(\n            \"target:\" + e.target.id + \"&currentTarget:\" + e.currentTarget.id\n        );\n    });\n    document.getElementById(\"c\").addEventListener(\"click\", function (e) {\n        console.log(\n            \"target:\" + e.target.id + \"&currentTarget:\" + e.currentTarget.id\n        );\n    });\n    document.getElementById(\"d\").addEventListener(\"click\", function (e) {\n        console.log(\n            \"target:\" + e.target.id + \"&currentTarget:\" + e.currentTarget.id\n        );\n    });\n</script>\n\n// 当我们点击最里层的元素d的时候，会依次输出:\n// target:d&currentTarget:d\n// target:d&currentTarget:c\n// target:d&currentTarget:b\n// target:d&currentTarget:a\n```\nevent.target始终是事件的真正发出者，而event.currentTarget始终是监听事件者。\n\n## 垂直居中\n1. margin:auto法\n```css\ndiv{\n    width:200px;\n    margin:0 auto;\n}\n/* 绝对定位居中 */\ndiv {\n    position: absolute;\n    width: 300px;\n    height: 300px;\n    margin: auto;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    background-color: pink;    /* 方便看效果 */\n}\n```\n\n2. margin负值法 relative -> absolute \n```css\ndiv {\n    position: relative;        /* 相对定位或绝对定位均可 */\n    width:500px;\n    height:300px;\n    top: 50%;\n    left: 50%;\n    margin: -150px 0 0 -250px;         /* 外边距为自身宽高的一半 */\n    /* transform: translate(-50%, -50%); */\n    background-color: pink;         /* 方便看效果 */\n\n}\n```\n\n3. flex布局\n```css\n.container {\n    display: flex;\n    align-items: center;         /* 垂直居中 */\n    justify-content: center;    /* 水平居中 */\n\n}\n.container div {\n    width: 100px;\n    height: 100px;\n    background-color: pink;        /* 方便看效果 */\n}  \n```\n\n4. table-cell未脱离文档流 设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。\n5. grid布局\n6. line-height单配height\n\n## visibility=hidden, opacity=0，display:none\n- opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的\n- visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件。\n- display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。\n\n## 块元素和行内元素的区别\n- 块元素：独占一行，并且有自动填满父元素，可以设置margin和padding以及高度和宽度。\n- 行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。\n- 内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。  \n\n## 深拷贝\n- 深拷贝的方法 1-2适用于一般的对象和数组 4-5适用于数组 3通用\n\n```JS\nlet obj = {\n    a: 1,\n    arr: [1, 2]\n};\nlet obj2 = deepCopy(obj);\nobj2.a = 2\nconsole.log(obj) // { a:1, arr: [1,2] };\n2.es6\nObject.assign()方法(深复制只有一层，之后为浅复制（除非再次使用Object.assign嵌套方式赋值）)\nlet obj = {\n    a: 1,\n    arr: [1, 2]\n};\nlet obj1 = Object.assign({}, obj);\nobj1.a = 2\n//不变\nconsole.log(obj) // { a:1, arr: [1,2] };\n3.immutable\n4.arr1=arr.slice(0) slice() 返回新数组\n5.arr1=arr.concat()\nvar deepCopy= function(source) { \n    var result={};\n    for (var key in source) {\n        result[key] = typeof source[key]==='object'? deepCoypy(source[key]): source[key];\n     } \n   return result; \n}\n```\n\n## 判断一个变量是否是数组\n```JS\nvar a = []; \n// 1.基于instanceof \na instanceof Array; \n// 2.基于constructor \na.constructor === Array; \n// 3.基于Object.prototype.isPrototypeOf \nArray.prototype.isPrototypeOf(a); \n// 4.基于getPrototypeOf \nObject.getPrototypeOf(a) === Array.prototype; \n// 5.基于Object.prototype.toString \nObject.prototype.toString.apply(a) === '[object Array]';\n// 6.Array.isArray\nArray.isArray(a); // true\n```\n以上，除了Object.prototype.toString外，其它方法都不能正确判断变量的类型。虽然Array继承自Object，也会有 toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：)😝\n\n* 由于每个iframe都有一套自己的执行环境，跨iframe实例化的对象彼此是不共享原型链的，因此导致检测代码失效。\n\n举个🌰\n```js\nvar iframe = document.createElement('iframe'); //创建iframe\ndocument.body.appendChild(iframe); //添加到body中\nxArray = window.frames[window.frames.length-1].Array;\nvar arr = new xArray(1,2,3); // 声明数组[1,2,3]\nalert(arr instanceof Array); // false\nalert(arr.constructor === Array); // false\n```\n\n* 最佳写法\n```JS\nvar arr = [1,2,3,1];\nvar arr2 = [{ abac : 1, abc : 2 }];\nfunction isArrayFn(value){\nif (typeof Array.isArray === \"function\") {\nreturn Array.isArray(value);\n}else{\nreturn Object.prototype.toString.call(value) === \"[object Array]\";\n}\n}\nconsole.log(isArrayFn(arr));// true\nconsole.log(isArrayFn(arr2));// true\n```\n\n## 优化\n- 按需加载（当用户触发了动作时才加载对应的功能）路由\n- 业务代码拆分\n- 第三方库提取vendor\n\n- 降低请求量：压缩文件图片，合并文件 减少http请求、minify/gzip压缩，webP，lazyload\n- 网络图、字体图标(雪碧图)\n- 缓存：HTTP协议缓存请求，离线缓存manifest\n- 加快请求速度：预解析DNS，减少域名数，并行加载，上cdn分发\n- 渲染：js、css优化，加载顺序，服务端渲染，pipeline\n\n## 行内、块级、空元素 \n- 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n- 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n- 常见空元素：即没有内容的HTML元素，例如：br、meta、hr、link、input、img\n- 不常见空元素：area、base、col、command、embed、keygen、param、source、track、wbr\n\n宽高和margin可以设置auto。对于块级元素来说，宽度设置为auto，则会尽可能的宽；高度设置为auto，则会尽可能的窄 注意： 如果没有显式声明包含块的height，则元素的百分数高度会重置为auto\n注意： 不管是上下padding还是左右padding，当我们使用百分比设置的时候，都是基于width的。\n注意： margin通过百分比设置的时候同样是基于宽度的。\n\n## px、em、rem的区别\npx和em都是长度单位,px的只是固定的,em的值是相对的继承父类元素的字体大小。浏览器的默认字体高位16px。1em=16px;\nrem单位基于html根元素的字体大小。\n\n- vw/vh(css3) vmin(vw和vh的较小值)/vmax(vw和vh的较大值)和百分比的区别\n\n|单位|含义|\n|:---|:---|\n|%|大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)|\n|vm/vh|相对于视窗的尺寸|\n\n## 路由权限管理\n- route render方法里进行判断 redirect or return null\n- 组件内部判断\n- 高阶组件\n- dva监听url subscription\n\n## node中的事件循环是什么样子的?\n- event loop其实就是一个事件队列，先加入先执行，执行完一次队列，再次循环遍历看有没有新事件加入队列．执行中的叫IO events, setImmediate是在当前队列立即执行,setTimout/setInterval是把执行定时到下一个队列，process.nextTick是在当前执行完，下次遍历前执行．所以总体顺序是: IO events >> setImmediate >> setTimeout/setInterval >> process.nextTick\n\n## 清空数组\n- 直接赋值空数组\n- splice(0,数组length)清空\n- 设置数组length=0\n\n## 判断数组中出现次数最多的元素\n1. 临时对象数组，原数组sort排序，判断前后位是否相等。临时对象数组排序\n\n```javascript\nfunction f(arr){\n    var temp=[];//对象数组\n    var i;\n    temp[0]={value:arr[0],index:1};//保存数组元素出现的次数和值\n    arr.sort();\n    for(i=1;i<arr.length;i++){\n        if(arr[i]==arr[i-1]){\n            temp[temp.length-1].index++;\n        }else{//不相同则新增一个对象元素\n            temp.push({index:1,value:arr[i]});\n        }\n    }\n    temp.sort(function(a,b){//按照出现次数从大到小排列\n        return b.index-a.index;\n    })\n    var max=temp[0].index;\n    var maxV=temp[0].value;\n    var second=temp[1].index;\n    var secondV=temp[1].value;\n\n    return {max,maxV,second,secondV};\n}\nvar arr=[2,2,3,4,5,100,100,,3,1,4,4,100,100];\nvar {max,maxV,second,secondV}=f(arr);\nconsole.log(max,maxV,second,secondV); // 4 100 3 4\n```\n\n2. 临时对象 判断属性名存不存在 2次遍历\n```javascript\nvar arr = [1,1,2,2,2,2,2,3,3,3,4,4];\n    var obj = {};\n    for(var i = 0; i<arr.length; i++){\n        if(!obj[arr[i]]){\n            obj[arr[i]] = 1;\n        }else {\n            obj[arr[i]]++;\n        }\n    }\n    /*\n        此时的obj对象包含了所有元素出现次数的信息\n        然后再遍历obj对象就可以查询出出现次数最多/最少的元素了\n    */\n    var maxNum = 0;\n    var minNum = obj[arr[0]];  //先随意给最少的变量赋值（但保证是数组中的元素出现的次数）\n    var maxEleArr = [],minEleArr = [];\n    //第一次遍历找出出现次数最多和最少的值\n    for(var key in obj){\n        if(obj[key] > maxNum){\n            maxNum = obj[key];\n        }\n        if(obj[key] < maxNum){\n            minNum = obj[key];\n        }\n    }\n    //第二次遍历找出所有出现次数最多和最少的元素\n    for(var key in obj){\n        if(obj[key] == maxNum){\n            maxEleArr.push(key);\n        }\n        if(obj[key] == minNum){\n            minEleArr.push(key);\n        }\n    }\n    console.log(maxEleArr + \":\" + maxNum );  // 2:5\n    console.log(minEleArr + \":\" + minNum );  // 1,4:2\n```\n\n3. reduce简写\n```js\nvar arr = 'abcdaabc';\n\nvar info = arr\n    .split('')\n    .reduce((p, k) => (p[k]++ || (p[k] = 1), p), {});\n\nconsole.log(info); //{ a: 3, b: 2, c: 2, d: 1 }\n```\n\n4. 临时对象简写\n```js\nconst map = {}\nconst str = 'hello world'\n\nstr.split('').forEach(key => {\n  map[key] = -~map[key]\n})\n\nconsole.log(map)\n// {\" \": 1, d: 1, e: 1, h: 1, l: 3, o: 2, r: 1, w: 1}\n// ~i = -(i + 1)，~undefined = -1\n```\n\n## 清除浮动\n**浮动元素的影响**\n- 浮动元素宽度默认为内容的宽度\n- 向指定的浮动方向一直移动\n- 对它之前的block没有影响\n- 会掩盖后面的block元素，但是不会遮盖其中的文本和内联元素\n\n**多个浮动元素**\n- 多个浮动元素不会相互重叠\n- 浮动元素按照在父元素中的书写顺序，从上至下排布\n- 当同一行有空间的时候，不管左浮动还是右浮动，都优先在同一行排列\n- 当同一行没有空间，后续浮动元素会从上至下寻找空间\n- 浮动元素的上下左右margin不会发生重叠合并\n\n清除浮动是为了清除浮动元素产生的影响。浮动元素的高度会发生坍塌，使页面后面的布局不能正常显示。\n设置成浮动后，display值会自动变成block。\n> 浮动会引起高度塌陷和文字环绕。\n1. 使用空标签清除浮动clear: both （增加了无意义的标签）\n2. 使用overflow: auto/hidden （使用zoom: 1兼容IE）\nzoom:1的清除浮动原理?\n清除浮动，触发hasLayout；\nZoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。\n譬如外边距（margin）的重叠，浮动清除，触发ie的hasLayout属性等。\n\n来龙去脉大概如下：\n当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。\n\n3. 给浮动元素的容器也添加浮动(创建父级BFC)\n4. 给浮动元素后面的元素添加clear属性\n5. 使用after伪元素清除浮动（用于非IE浏览器）\n\n```css\n.clear {\n    overflow: auto;\n    zoom: 1;\n}\n\n.clear::after {\n    display: block;\n    content: '清除浮动',\n    height: 0;\n    clear: both;\n}\n\n.clearfix::before, .clearfix::after {\n    content: \" \";\n    display: table;\n}\n```\n发现：除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。\n\n## margin-top和padding-left根据height还是width？\nwidth\n\n## vue的非父子组件传递\n1. vuex 2. 在同一个vue实例上调用$emit和$on\n\n## 原生js实现拖拽\n```html\n<div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"></div>\n<img\nid=\"img1\"\ndraggable=\"true\"\nondragstart=\"drag(event)\"\nsrc=\"http://dir.mydearest.cn/static/img/avatar.jpg\"\n/>\n<script>\n  function allowDrop(ev) {\n    ev.preventDefault();\n  }\n\n  function drag(ev) {\n    ev.dataTransfer.setData(\"Text\", ev.target.id);\n  }\n\n  function drop(ev) {\n    ev.preventDefault();\n    var data = ev.dataTransfer.getData(\"Text\");\n    ev.target.appendChild(document.getElementById(data));\n  }\n</script>\n```\n[拖拽](https://cosyer.github.io/jelly/drag/)\n\n## 实现函数监听函数发布订阅模式 on emit off 方法 类似 iflux\n```js\nfunction event() {\n  this.elem = document.createElement('div')\n}\nevent.prototype.on = function (name, fn) {\n  this.e = new Event(name)\n  this.elem.addEventListener(name, fn.call(this, this.e, this.e.type))\n}\nevent.prototype.emit = function(name) {\n  this.elem.dispatchEvent(this.e) // 这里接受的参数必须是Event类型的，不然报错\n}\nevent.prototype.off = function (name, fn) {\n  this.e = null\n}\nvar ee = new event()\nee.on('foo', function(){console.log(110)})\nee.emit('foo') // 110\n```\n\n## 左边固定，右边自适应布局\n1. float\n2. flex布局\n3. 通过position 父级relative\n\n## mysql 字符转换\n```sql\n-- date转字符串\nselect date_format(now(), '%Y-%m-%d'); \n--  date转时间戳\nselect unix_timestamp(now())\n--  字符串转时间\nselect str_to_date(\"2019-01-15\",'%Y-%m-%d %H')\n-- 20190115\n-- 时间戳转时间\nselect from_unixtime(1451997924)\n-- 时间戳转字符串\nselect from_unixtime(1451997924,\"%Y-%m-%d %H\")\n```\n\n## empty()和html(\"\")\n推荐使用empty html不会清除子组件的事件\n\n## react、vue多个class\n### react\n方法一：ES6 模板字符串 ``\n\nclassName={title ${index === this.state.active ? 'active' : ''}}\n　　\n\n方法二：join(\"\")\n\nclassName={[\"title\", index === this.state.active?\"active\":null].join(' ')}\n\n方法三：classnames\n\n### vue\n方法一：\n:class=\"[box,shadow]\"\n方法二：\n:class=\"{box:show1,shadow:show2}\"\n\n## vue组件通信\n```\n// 父传子\n// 父组件\n<note-address :data=\"msg\"></note-address> \n\n// 子组件\n\n<div>{{ data.partment }}</div>\n\nexport default {\n  //props:['data']\n  props: {\n    data: Object\n  }\n}\n// 子传父\n// 父组件\n<note-address @new=\"addNote\"></note-address> \n\n// 子组件\n<button type=\"small\" class=\"confirm\" @click=\"add\">设为教案</button>\n\nmethods: {\n add () {\n  this.$emit('new', false)\n }\n}\n// 兄弟相传\n// 1.创建 公共bus.js\n\n//bus.js\nimport Vue from 'vue'\nexport default new Vue()\n\n// 2.父组件注册两个子组件\ncomponents:{\n    firstChild,\n    secondChild\n}\n\n// 3.firstChild组件\n\n<input type=\"button\" value=\"点击触发\" @click=\"elementByValue\">\n\n<script>\n// 引入公共的bus，来做为中间传达的工具\n  import Bus from './bus.js'\n  export default {\n      methods: {\n      elementByValue: function () {\n        Bus.$emit('val', '兄弟，收到了吗？')\n      }\n    }\n  }\n</script>\n\n// 4.secondChild组件\n\n<span>{{msg}}</span>\n\n<script>\n  import Bus from './bus.js'\n  export default {\n      mounted(){\n            let self = this;\n            Bus.$on('val', function (msg) {\n                console.log(msg)\n                self.msg = msg\n            })\n      }\n    }\n  }\n</script>\n```\n\n## OSI七层协议\n![tcp](http://cdn.mydearest.cn/blog/images/tcp.png)\n\n- 应用层\n- 表示层\n- 会话层\n- 传输层\n- 网络层\n- 数据链路层\n- 物理层\n\n- 应用层（HTTP，FTP，NFS，SMTP）\n与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。例如，一个没有通信功能的字处理程序就不能执行通信的代码，从事字处理工作的程序员也不关心OSI的第7层。但是，如果添加了一个传输文件的选项，那么字处理器的程序员就需要实现OSI的第7层。示例：TELNET，HTTP，FTP，NFS，SMTP等。\n\n- 表示层\n这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的字符集转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。\n\n- 传输层（TCP，UDP，SPX）\n这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。\n\n- 会话层（RPC，SQL）\n它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等\n\n- 网络层（IP，IPX）\n这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。\n\n- 数据链路层（IP，IPX）\n它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。\n\n- 物理层（Rj45，802.3）\nOSI的物理层规范是有关传输介质的特这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。\n\n## call使用\n```js\nfunction add(a,b){\nconsole.log(a+b)\n}\n\nfunction sub(a,b){\nconsole.log(a-b)\n}\n\nadd.call(sub,3,1) // 4\n```\n\n## css选择器的优先级\n\n选择器：id选择器，class选择器，标签选择器，伪元素选择器，伪类选择器等等\n\n同一元素引用多个样式时，排在后面的样式属性的优先级高\n\n样式选择器的类型不同时。优先级顺序为：id>class>标签\n\n标签之间存在层级包含关系时，后代元素会继承祖先元素的样式，如果后代元素定义了与祖先元素相同的样式，则祖先元素的相同的样式会被覆盖。继承的样式优先级较低，至少比标签选择器低。\n\n带有！important标记的样式属性优先级最高\n\n样式表来源不同时优先级顺序为：内联>内部>外部>浏览器用户自定义的样式>浏览器默认样式\n\n## 事件队列（eventLoop）\n```js\n// 以下是头条的类似题目，这个考得更全面\nasync function a1 () {\n    console.log('a1 start')\n    await a2()\n    console.log('a1 end')\n}\nasync function a2 () {\n    console.log('a2')\n}\nconsole.log('script start')\nsetTimeout(() => {\n    console.log('setTimeout')\n}, 0)\nPromise.resolve().then(() => {\n    console.log('promise1')\n})\na1()\nlet promise2 = new Promise((resolve) => {\n    resolve('promise2.then')\n    console.log('promise2')\n})\npromise2.then((res) => {\n    console.log(res)\n    Promise.resolve().then(() => {\n        console.log('promise3')\n    })\n})\nconsole.log('script end')\n\n// script start\n// a1 start\n// a2\n// promise2\n// script end\n// promise1\n// a1 end\n// promise2.then\n// promise3\n// setTimeout\n```\n\n## vue中watch和computed的区别\n\n- computed，计算属性，随着依赖的数据响应式地改变，用于复杂逻辑处理\n\n- watch，命令式地监听数据变化进行操作\n\n## 简单介绍es6\n\nES6在变量的声明和定义方面增加了let、const声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时ES6对字符串、 数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6也 引入了新的数据类型symbol，新的数据结构set和map,symbol可以通过typeof检测出来，为解决异步回调问题，引入了promise和 generator，还有最为吸引人了实现Class和模块，通过Class可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用babel进行编译。\n\n## js模块化\n在ES6出现之前，js没有标准的模块化概念，这也就造成了js多人写作开发容易造成全局污染的情况，以前我们可能会采用立即执行函数、对象等方式来尽量减少变量这种情况，后面社区为了解决这个问题陆续提出了AMD规范和CMD规范，这里不同于Node.js的 CommonJS的原因在于服务端所有的模块都是存在于硬盘中的，加载和读取几乎是不需要时间的，而浏览器端因为加载速度取决于网速， 因此需要采用异步加载，AMD规范中使用define来定义一个模块，使用require方法来加载一个模块，现在ES6也推出了标准的模块加载方案，通过export和import来导出和导入模块。\n\n## 模块化的理解\n一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来\n越重要。\n\n由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。\n\n后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的所有的模块成员，外部代码可\n以修改内部属性的值。\n\n现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。\n\n## 图片加载成功或者失败\nonload/onerror\n\n## 递归和迭代的区别\n程序调用自身称为递归(从前有座山，山里有座庙，庙里有个老和尚在和小和尚讲故事，故事讲的是)，利用变量的原值推出新值称为迭代，递归的优点 大问题转化为小问题，可以减少代码量，同时应为代码精简，可读性好， 缺点就是，递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。迭代的好处 就是代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销， 缺点就是代码不如递归简洁\n\n## 原生JS操作DOM的方法有哪些？\n获取节点的方法getElementById、getElementsByClassName、getElementsByTagName、 getElementsByName、querySelector、querySelectorAll,对元素属性进行操作的 getAttribute、 setAttribute、removeAttribute方法，对节点进行增删改的appendChild、insertBefore、replaceChild、removeChild、 createElement等\n\n## setTimeout和setInterval的区别，包含内存方面的分析？\nsetTimeout表示间隔一段时间之后执行一次调用，而setInterval则是每间隔一段时间循环调用，直至clearInterval结束。 内存方面，setTimeout只需要进入一次队列，不会造成内存溢出，setInterval因为不计算代码执行时间，有可能同时执行多次代码， 导致内存溢出。\n\n## addEventListener有哪些参数？\n有三个参数，第一个是事件的类型，第二个是事件的回调函数，第三个是一个表示事件是冒泡阶段还是捕获阶段捕获的布尔值，true表示捕获，false表示冒泡\n\n## 将静态资源放在其他域名的目的是什么？\n这样做的主要目的是在请求这些静态资源的时候不会发送cookie，节省了流量，需要注意的是cookie是会发送给子域名的（二级域名），所以这些静态资源是不会放在子域名下的， 而是单独放在一个单独的主域名下。同时还有一个原因就是浏览器对于一个域名会有请求数的限制，这种方法可以方便做CDN。\n\n## http状态码301和302的区别\n- 301 redirect: 301 代表永久性转移(Permanently Moved) \n\n如何避免301跳转https(在response中header)\n\n- 302 redirect: 302 代表暂时性转移(Temporarily Moved)\n\n详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。\n\n[重定向](http://cdn.mydearest.cn/blog/images/redirectCache.png)\n\n## 在什么情况下a === a-1 ?\n- Infinity/-Infinity\n\n```js\nlet a = Infinity;\n\nconsole.log(a === a - 1); // true\n\nlet b = -Infinity;\n\nconsole.log(b === b - 1);  // true\n\nconsole.log(Infinity + Infinity); // Infinity\nconsole.log(Infinity - Infinity); // NaN\nconsole.log(Infinity * Infinity); // Infinity\nconsole.log(Infinity / Infinity); // NaN\nconsole.log(Infinity * 0); // NaN\n```\n\n- 安全数(-2 ** 53 + 1到2 ** 53 - 1) 即Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER 处理特殊情况\n\n```js\nlet a = Number.MIN_SAFE_INTEGER - 1;\nconsole.log(a === a - 1); // true\n```\n\n- a == a -1\n\n```js\nvar x = 1\nvar a = { x, valueOf: () => a.x }\nObject.defineProperty(a, 'x', { get() { return --x } })\n\nvar set = 1\nObject.defineProperty(window, \"a\", {\n  get : function(){\n    return set++\n  },\n  enumerable : true,\n  configurable : true\n});\n\nconst a = {\n times: 0,\n\n valueOf() {\n   if (this.times & 1) {\n     return 0;\n   }\n   this.times += 1;\n   return 1;\n },\n};\n```\n\n## placeholder样式设置\n\n```css\n::-webkit-input-placeholder{}    /* 使用webkit内核的浏览器 */\n:-moz-placeholder{}                  /* Firefox版本4-18 */\n::-moz-placeholder{}                  /* Firefox版本19+ */\n:-ms-input-placeholder{}           /* IE浏览器 */\n```\n\n## 巧用currentColor自定义checkbox样式\n```css\n/* 无法自定义checkbox样式 */\ninput[type=checkbox] {\n  background-color: red;\n  color: red;\n  border: solid red;\n}\n```\n\n```css\ninput[type=checkbox] {\n  position: relative;\n  color: inherit;\n}\n\ninput[type=checkbox]::before,\ninput[type=checkbox]::after {\n  position: absolute;\n  display: inline-block;\n  width: 12px;\n  height: 12px;\n  line-height: 12px;\n  border-radius: 3px;\n  text-align: center;\n}\n\ninput[type=checkbox]:checked::after {\n  content: 'x';\n  color: white;\n}\n\ninput[type=checkbox]::before {\n  content: ' ';\n  /* 表示将背景色设置为当前的文字颜色值。 */\n  background-color: currentColor;\n}\n```\n\n## 增补字符不适用String.prototype.charCodeAt和String.fromCharCode\n```js\n'🀄'.length // 2\n\nconst str = '🀄';\nconsole.log(str.codePointAt(0)); // 126980\n\nconsole.log(String.fromCodePoint(126980)); // 🀄\n\nconsole.log([...\"👨‍👩‍👧‍👦\"])\n// [\"👨\", \"‍\", \"👩\", \"‍\", \"👦\", \"‍\", \"👦\"]\n```\n\n## 三次握手、四次挥手\n- 建立连接-TCP的三次握手\n\n(1) 主机向服务器发送一个建立连接的请求\n\n(2) 服务器接到请求后发送同意连接的信号\n\n(3) 主机接到同意连接的信号后，再次向服务器发送了确认信号\n\n发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n- 断开连接-TCP的四次挥手\n(1) 主机向服务器发送一个断开连接的请求\n\n(2) 服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机)\n\n(3) 服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据)\n\n(4) 主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接\n\n> 注意：这里的四次挥手中服务器两次向主机发送消息，第一次是回复主机已收到断开的请求，第二次是向主机确认是否断开，确保数据传输完毕。\n\n## 幂等性\n\n其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。\n\n## src和href的区别(引入和引用)\n- src 指的是 source ，属性中可以设置 src  的标签多为替换标签，用于将资源加载后替换该标签的内容， src  加载的资源是会阻塞 DOM 解析的。\n\n- href 指的是 hypertext reference ，属性中可以设置 href  的标签多为引用或链接标签，用于引用互联网上的其他资源或设置锚点， href  引用的资源不会阻塞 DOM 解析，而是会并行加载。\n\n## a.b.c.d 和 a['b']['c']['d']，哪个性能更高？\n```js\nvar obj = {\n  a:{\n      b:{\n        c:{\n          d:1\n        }\n      }\n    }\n}\nconsole.time()\nconsole.log(obj.a.b.c.d)\nconsole.timeEnd() \n// console.time()\n// console.log(obj[\"a\"][\"b\"][\"c\"][\"d\"])\n// console.timeEnd() \n// default:1.100ms 0.964ms\n```\n\n## 对象引用\n```js\nvar a = {n: 1};\nvar b = a;\na.x = a = {n: 2};\n\nconsole.log(a.x) \t\nconsole.log(b.x)\n// undefined\n// {n:2}\n```\n首先，a和b同时引用了{n:1}对象，接着执行到a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a的引用改变，指向了新对象{n：2},而b依然指向的是旧对象。之后执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。\n后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即{n:2}。\n\n\n## Doctype作用？标准模式与兼容模式各有什么区别?\n1. <!DOCTYPE>声明位于HTML文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。\n\n2. 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。\n\n3. 有两种模式：严格模式：以该浏览器支持的最高标准运行 混杂模式：向后兼容，模拟老浏览器，防止浏览器无法兼容页面。\n\n## HTML5 为什么只需要写 <!DOCTYPE HTML>？\n- HTML5 不基于 SGML，因此不需要对DTD(文档类型定义)进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；\n\n- 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。\n\n- 新增语义化标签\n```html\n<header>、<footer>、<section>、<article>、<nav>、<hgroup>、<aside>、<figure>\n```\n\n- 删除的标签\n```html\n<big>、<u>、<font>、<basefont>、<center>、<s>、<tt>\n```\n\n- 多媒体\n```html\n<audio>、<video>\n```\n\n```html\n<!-- 只写属性名默认为true -->\n<input type=\"checkbox\"  checked/>\n<!-- 属性名=\"属性名\"也为true -->\n<input type=\"checkbox\"  checked=\"checked\"/>\n```\n\n## 对浏览器内核的理解？\n主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\nJS引擎：解析和执行javascript来实现网页的动态效果。\n\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n\n## html5新特性？\n- HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n### 绘画 canvas;\n### 用于媒介回放的 video 和 audio 元素;\n### 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除;\n### 语义化更好的内容元素，比如 article、footer、header、nav、section;\n表单控件，calendar、date、time、email、url、search;\n新的技术webworker, websocket, Geolocation;\n\n- 移除的元素：\n纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n对可用性产生负面影响的元素：frame，frameset，noframes；\n\n- 支持HTML5新标签：\nIE8/IE7/IE6支持通过document.createElement方法产生的标签，\n可以利用这一特性让这些浏览器支持HTML5新标签，\n浏览器支持新标签后，还需要添加标签默认的样式。\n当然也可以直接使用成熟的框架、比如html5shim;\n\n```js\n<!--[if lt IE 9]>\n<script> src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"</script>\n<![endif]-->\n```\n\n- 如何区分HTML5： DOCTYPE声明新增的结构元素功能元素\n语义化标签：header,footer,nav,aside,section 增强表单：为input增加了color,email,data,range等类型 存储：sessionStorage，localStorage，离线存储 多媒体：audio，vedio canvas 拖放 地理定位 webworker websocket\n\n## 对HTML语义化的理解？\n用正确的标签做正确的事情。\nhtml语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;\n搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n## iframe缺点\n* iframe会阻塞主页面的Onload事件；\n* 搜索引擎的检索程序无法解读这种页面，不利于SEO;\n* iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n\n使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值。\n\n## 多个标签页通信\n1. 使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。\n2. 使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。\n3. 也可以调用localstorge、cookies等本地存储方式；localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监\n听 storage 事件，控制它的值来进行页面信息通信。\n4. 获取对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。\n\n## CSS的盒子模型 border-sizing (border-box)\n（1）有两种， IE 盒子模型、W3C 盒子模型；\n（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n（3）区  别： IE的content部分把 border 和 padding计算了进去;\n\n- W3C 标准盒模型(content-box)：\n![w3c](http://cdn.mydearest.cn/blog/images/w3c-box.jpg)\n\n- IE 盒模型(border-box)：\n![ie](http://cdn.mydearest.cn/blog/images/ie-box.jpg)\n\n在 IE 盒模型中，盒子宽高不仅包含了元素的宽高，而且包含了元素的边框以及内边距。\n\n所以在同样的设置下，IE 下的元素会看起来相对于标准盒子来的小。\n\n## CSS选择器有哪些？哪些属性可以继承？(4+4+2+1)11种\n**4个属于简单选择器_**\n### id选择器（#myid）\n\n### 类选择器（.myclassname）\n\n### 标签选择器（div, h1, p）\n\n### 通配符选择器（*）\n\n**4个属于组合选择器**\n组合选择器是通过多个简单选择器进行组合\n\n### 相邻选择器（h1 + p）\n\n### 同级元素选择器：A~B，作用于A后面的所有同级的B\n\n### 子选择器（ul > li）\n\n### 后代选择器（li a）\n\n### 伪类选择器（a:hover, li:nth-child）\n|常见的伪类选择器|功能|\n|:--|:--|\n|:hover|鼠标移入元素上方|\n|:focus|元素获得焦点|\n|:checked|选中的表单元素|\n|:empty|没有任何子元素的元素|\n|:optional|表单元素中可以为空的元素|\n|:read-only|只读属性的元素|\n|:read-write|没有只读属性的元素|\n|:required|\t选择表单必填项的元素|\n|:valid|选择所有有效值的元素|\n|:target|当前活动元素|\n|:root|匹配到文档根元素|\n|:enabled|匹配到页面上可用状态的元素|\n|:disabled|匹配到不可用的元素|\n|:first-child|匹配到一个作为第一个子元素的元素|\n|:last-child|匹配到一个作为最后一个子元素的元素|\n|:nth-child(n)|匹配父元素的第n个子元素（允许食用乘法因子n作为换算）|\n|:nth-last-child(n)|匹配父元素的倒数第n个子元素|\n|:link|\t没有访问过的链接|\n|:visited|访问过的链接|\n\n### 伪元素选择器（::after）\n定义： 伪元素建立了对超出文档语言指定的文档树的抽象。\n|伪元素选择器|功能|\n|:--|:--|\n|::first-letter|选择元素的第一个字母|\n|::first-line|选择元素的第一行|\n|::before|在元素之前插入内容并定制样式|\n|::after|在元素之后插入内容并定制样式|\n|::selection|被用户选中的内容|\n\n### 属性选择器（a[rel = \"external\"]）\n```css\n/* 第一种 [attr] */\n[disabled]{\n    background-color: #ccc;\n}\n/* 第二种 [attr=val] */\n[type='button']{\n    background-color: #ccc;\n}\n/* 第三种 [attr~=val] 属性包含val */\n[class~='test']{\n    color:red;\n}\n/* 第四种 [attr^=val] 属性以val开头 */\n[class^='demo']{\n    background-color:red;\n}\n/* 第五种 [attr|=val] 属性以 val- 开头 */\n[class|='demo']{\n    background-color:red;\n}\n/* 第六种 [attr$=val] 属性以 val 结尾 */\n[class$='item']{\n    font-weight: bold;   \n}\n```\n\n* 可继承的样式： font-size font-family color, UL LI DL DD DT;\n\n* 不可继承的样式：border padding margin width height ;\n\n## css优先级算法\n内联样式 > ID选择器 > 伪类选择器=属性选择器=类选择器 > 标签选择器 > 通用选择器 > 继承样式\n* 优先级就近原则，同权重情况下样式定义最近者为准;\n* 载入样式以最后载入的定位为准;\n\n优先级为:\n同权重: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。\n!important > 行内样式 > id > class > tag > * > 继承 > 默认\nimportant 比 内联优先级高，选择器从右往左解析\n\n_权值_\n```\n内联样式 -> 1000\nID属性值 -> 100\n类属性值、属性选择或伪类 -> 10\n元素或伪元素 -> 1\n结合符和通配选择器 -> 0\n```\n\n## css3新增的伪类、伪元素\n举例：\np:first-of-type    选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\np:last-of-type    选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\np:only-of-type    选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\np:only-child        选择属于其父元素的唯一子元素的每个 <p> 元素。\np:nth-child(2)    选择属于其父元素的第二个子元素的每个 <p> 元素。odd奇数/even偶数\n\n::after            在元素之前添加内容,也可以用来做清除浮动。\n::before            在元素之后添加内容\n:enabled          \n:disabled         控制表单控件的禁用状态。\n:checked        单选框或复选框被选中。\n\n## display有哪些值？19种 这里只列举下常见的\nblock           块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\nnone            元素不显示，并从文档流中移除。\ninline          行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\ninline-block    默认宽度为内容宽度，可以设置宽高，同行显示。\nlist-item       像块类型元素一样显示，并添加样式列表标记。\ntable           此元素会作为块级表格来显示。\ntable-cell\ninherit         规定应该从父元素继承 display 属性的值。\nflex\n\n## position有哪些值？7种\n- fixed：固定定位。元素的位置相对于浏览器窗口定位，即是窗口是滚动的他也不会移动。fixed定位使元素的位置与文档流无关，因此不占据空间。fixed定位的元素和其它元素重叠\n\n- relative：如果对一个元素进行相对定位，它将出现在它所在的位置上，然后可以通过设置垂直或水平位置，让这个元素相对于它的起点移动，在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间，因此，移动元素将导致它覆盖其他框。\n\n- absolute：绝对定位的元素的位置相对于 static 定位以外的第一个父元素进行定位，如果元素没有已定位的父元素，那么他的位置相对于html。absolute定位使元素的位置与文档流无关，因此不占据空间，absolute定位的元素和其它元素重叠\n\n- sticky：粘性定位。元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为fixed定位\n\n- static：默认定位。也就是没有特殊定位，元素出现在正常的流中，忽略top，bottom，left或者z-index声明\n\n- inherit： 继承定位。规定应该从父元素继承position的值\n\n`float`元素的display为block。\n\n## CSS3有哪些新特性？\n### 新增各种CSS选择器（: not(.input)：所有 class 不是“input”的节点）\n### 圆角（border-radius:8px）\n### 阴影（border-shadow/border-image）\n### 多列布局（multi-column layout）\n### 反射（Reflect）\n-webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片\n### 文字特效（text-shadow）\n### 文字渲染（text-decoration）\n### 线性渐变（gradient）\n### 过渡（transition）\n### 形状转换（transform）\nrotate(30deg);   translate(30px,30px);   scale(.8);        skew(10deg,10deg);        rotateX(180deg);     rotateY(180deg);        rotate3d(10,10,10,90deg);\n### 动画（animation keyframes）\n### 滤镜（filter）\n### 弹性布局（flex）\n### 栅格布局（grid）\n### 媒体查询（media）\n\n## BFC规范(块级格式化上下文：block formatting context)的理解？\n\nBFC（Block Formatting Context）块级格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。\n\n也就是说BFC内部的元素和外部的元素不会互相影响。\n\n- 创建规则：\n\n1. 根元素\n2. 浮动元素（float不是none）\n3. 绝对定位元素（position取值为absolute或fixed）\n4. display取值为inline-block,table-cell,table-caption,flex,inline-flex之一的元素\n5. overflow不是visible的元素(hidden、auto、scroll)\n\n- 作用特性：\n1. 内部的 Box 会在垂直方向上一个接一个的放置\n2. 垂直方向上的距离由 margin 决定；（解决外边距重叠问题）\n3. bfc 的区域不会与 float 的元素区域重叠；（防止浮动文字环绕）\n4. 计算 bfc 的高度时，浮动元素也参与计算；（清除浮动）\n5. 内部的元素和外部的元素不会互相影响\n\n## css权重\n> 标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值\n> 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现\n\n```css\n/*权重为1*/\ndiv{\n}\n/*权重为10*/\n.class1{\n}\n/*权重为100*/\n#id1{\n}\n/*权重为100+1=101*/\n#id1 div{\n}\n/*权重为10+1=11*/\n.class1 div{\n}\n/*权重为10+10+1=21*/\n.class1 .class2 div{\n}\n```\n\n## .gitignore说明\n```shell\n.a # 忽略所有 .a 结尾的文件\n!lib.a # 但 lib.a 除外\n/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\nbuild/ # 忽略 build/ 目录下的所有文件\ndoc/.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n```\n规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交：\n\n```shell\ngit rm -r --cached .\ngit add .\ngit commit -m update .gitignore\n```\n\n## 外边距合并\n外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。\n[w3school介绍网址](https://www.w3school.com.cn/css/css_margin_collapsing.asp)\n\n## 如何优化css，提高性能？\n- 使用关键选择器，过滤掉无关的规则\n- 提取项目公共样式，增强可复用性、模块化编写组件\n- 预处理器以及构建工具(postcss`后处理器`补充前缀、打包压缩、自动优雅降级)\n\n## margin和padding分别适合什么场景使用？\nmargin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。\nmargin用于布局分开元素使元素与元素互不相干；\npadding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段\n\n## 如何修改chrome记住密码后自动填充表单的黄色背景 ？\n```css\ninput:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {\n  background-color: rgb(250, 255, 189); /*#FAFFBD;*/\n  background-image: none;\n  color: rgb(0, 0, 0);\n}\n```\n\n## 什么是Cookie 隔离？\n如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，\n所以不如隔离开。\n\n因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，\n这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。\n\n同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，\n提高了webserver的http请求的解析速度。\n\n## ajax缓存问题\n\n1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified-Since\",\"0\")。\n\n2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no-cache\")。\n\n3、在URL后面加上一个随机数： \"fresh=\" + Math.random();。\n\n4、在URL后面加上时间戳：\"nowtime=\" + new Date().getTime();。\n\n5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。\n\n模块化开发，采用立即执行函数不暴露私有成员。\n\n## jquery.extend 与 jquery.fn.extend的区别？\n- jquery.extend：为jquery类添加类方法，可以理解为添加静态方法\n- jquery.fn.extend: 源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数\n\n> jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。\n\n## jquery一个对象绑定多个事件\n```js\n// 多个事件同一个函数\n$(\"div\").on(\"click mouseover\", function(){});\n\n// 多个事件不同函数\n$(\"div\").on({\nclick: function(){},\nmouseover: function(){}\n});\n```\n\n## 如何不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标？\n```js\nArray.from(Array(100).keys())\n\n[...Array(100).keys()]\n```\n\n接着乱序排序\n```js\narr.sort( () => Math.random() > .5 ? -1 : 1 )\n```\n\n前十个数相加\n```js\nvar [a, b, c, d, e, f, g, h, i, j, ...last] = arr3;\nvar total = a + b + c + d + e + f + g + h + i + j;\n```\n\n```js\nconst foo = ((x, f = (y = x) => x + y) => {\n      let y = f();\n      x = y++;\n      return [x, y, f(y)]\n    })(2)\n// foo = [4,5,9]\n```\n\n## link与@import的区别\n- link 是 html 方式，@import是css方式，link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css\n\n- link最大限度支持并行下载，@import过多嵌套导致串行下载\n\n- link可以通过rel=\"alternate stylesheet\"指定候选样式。link 标签可以实现资源加载、DNS 预解析等功能。\n\n- 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式，@import需要 IE5 以上才能使用\n\n- @import必须在样式规则之前，可以在 css 文件中引用其他文件，link可以使用 js 动态引入，@import不行\n\n- 总体来说：link 优于@import\n\n## PNG,GIF,JPG 的区别\n- GIF:\n\n8 位像素，256 色\n无损压缩\n支持简单动画\n支持 boolean 透明\n适合简单动画\n\n- JPEG：\n\n颜色限于 256\n有损压缩\n可控制压缩质量\n不支持透明\n适合照片\n\n- PNG：\n\n有 PNG8 和 truecolor PNG\nPNG8 类似 GIF 颜色上限为 256，文件小，支持 alpha 透明度，无动画\n适合图标、背景、按钮\n\n## 什么是 FOUC?如何避免\n\nFlash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head\n\n## focus/blur 与 focusin/focusout的区别和联系\n1. focus/blur 不冒泡，focusin/focusout 冒泡\n2. focus/blur 兼容性好，focusin/focusout 在除 FireFox 外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在 FireFox 下使用事件捕获 elem.addEventListener('focus', handler, true)\n3. 可获得焦点的元素：\n- window\n- 链接被点击或键盘操作\n- 表单空间被点击或键盘操作\n- 设置tabindex属性的元素被点击或键盘操作\n\n## == 和 === 有什么区别？\n== 一般比较，在比较的时候可以转换数据类型，假定 x == y 表达式：\n\n1. 如果x和y类型相同，则 js 会换成 === 进行比较；如果x为null, y为undefined，则返回 true，顺序调换一样;\n2. 如果x的类型是number或者boolean, y的类型是string，那么返回x == toNumber(y)，顺序调换一样;\n3. 如果x是string、symbol或number，而y是object类型，则返回x == toPrimitive(y)，顺序调换一样;;\n\ntoPrimitive首先在对象中使用valueOf方法，然后使用toString方法来获取该对象的原始值剩下的返回 false\n\n=== 严格比较，只要类型不匹配就返回 false;\n\n## 对象到字符串的转换\n如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结\n果。如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结\n果否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError\n\n## 对象到数字的转换\n如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果\n否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果\n否则，throws a TypeError\n\n## <,>,<=,>=的比较规则\n所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:\n\n如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错\n经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小）\n否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较\n\n## +运算符工作流程\n如果有操作数是对象，转换为原始值\n此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接\n否则：所有操作数都转换为数字并执行加法\n\n## question\n```js\nlet i = 0;\nif (function temp(){}) {\n i+=typeof temp;\n}\nconsole.log(i)\n// '0undefined'\n```\n\n- Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。\n属性将会对值四舍五入取整。如果需要小数值\n\n## 什么是构造函数调用？\n使用new关键字，被称为“构造函数调用”\n\n## 什么是构造函数？\n构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。\n\n## querySelectorAll 与 getElementsBy 系列的区别\n\n1. querySelectorAll 属于 W3C 中 Selectors API 规范， 而 getElementsBy 系列则属于 W3C DOM 规范。\n\n2. querySelectorAll 方法接受参数是 CSS 选择符，当传入的是不符合 CSS 选择符规范时会抛出异常，而 getElementsBy 系列则接受的参数是单一的 className，tagName 等等。\n\n3. 从返回值角度来看，querySelectorAll 返回的是不变的结点列表，而 getElementsBy 系列返回的是动态的结点列表。\n\n```js\n// Demo 1\nvar ul = document.querySelectorAll('ul')[0],\n  lis = ul.querySelectorAll(\"li\");\nfor(var i = 0; i < lis.length ; i++){\n  ul.appendChild(document.createElement(\"li\"));\n}\n\n// Demo 2\nvar ul = document.getElementsByTagName('ul')[0], \n  lis = ul.getElementsByTagName(\"li\"); \nfor(var i = 0; i < lis.length ; i++){\n  ul.appendChild(document.createElement(\"li\")); \n}\n```\n因为 Demo 2 中的 lis 是一个动态的结点列表， 每一次调用 lis 都会重新对文档进行查询，导致无限循环的问题。\n\n而 Demo 1 中的 lis 是一个静态的结点列表，是一个 li 集合的快照，对文档的任何操作都不会对其产生影响。\n\n- 普遍认为：getElementsBy 系列性能比 querySelectorAll 好\n\n- querySelectorAll 返回值为一个 NodeList，而 getElementsBy 系列返回值为一个 HTMLCollection\n\n## NodeList 与 HTMLCollection 区别?\n1. HTMLCollection 是元素集合而 NodeList 是节点集合(即可以包含元素，文本节点，以及注释等等)。\n\n2. node.childNodes，querySelectorAll(虽然是静态的) 返回的是 NodeList，而 node.children 和 node.getElementsByXXX 返回 HTMLCollection。\n\n## 如何判断函数是 new 调用还是普通调用?\n- instanceof\n```js\nfunction Person() {\n  if(this instanceof arguments.callee) {\n    console.log('new 调用');\n  }else {\n    console.log('普通调用');\n  }\n}\nlet p1 = new Person(); // new 调用\nlet p2 = Person(); // 函数调用\n```\n\n- 通过 constructor\n```js\nfunction Person() {\n  if(this.constructor === arguments.callee) {\n    console.log('new 调用');\n  }else {\n    console.log('普通调用');\n  }\n}\nlet p1 = new Person(); // new 调用\nlet p2 = Person(); // 函数调用 \n```\n\n## fetch会发送两次请求的原因\nfetch发送post请求时总是发送两次，第一次状态码是204，第二次才会成功。 原因是，用fetch发送post请求时，第一次发送了一个options请求(预检、嗅探请求)，询问服务器是否支持修改的请求头，如果支持，则在第二次发送真正的请求\n\n## webworker\n在html页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后页面才变为可响应。web worker是运行在后台的js，独立于其他脚本，不会影响页面。并且通过postMessage将结果回转至主线程。\n\n现代浏览器为JavaScript创造的多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可独立运行，互不干扰，可通过自带的消息机制相互通信。\n```js\n// 创建 worker\nconst worker = new Worker('work.js');\n\n// 向主进程推送消息\nworker.postMessage('Hello World');\n\n// 监听主进程来的消息\nworker.onmessage = function (event) {\n  console.log('Received message ' + event.data);\n}\n```\n- 限制\n  - 同源限制\n  - 无法使用 document / window / alert / confirm\n  - 无法加载本地资源\n\n## 一句话概括RESTFUL\n用url定位资源，用http描述操作\n\n## 设备像素比（DPR device pixel redio）\n1DPR = 物理像素/分辨率 也就是物理像素在屏幕上最佳的逻辑像素大小\n\n在不缩放的情况下，一个逻辑像素就等于一个DPR，即1逻辑像素 = 物理像素/分辨率\n\n- 自适应\n - 媒体查询\n - 百分比\n - rem(都只相对于浏览器的根元素HTML 默认情况下html元素的font-size为16px，所以1rem=16px的font-size)\n为了计算方便\n```css\nhtml {\n  font-size: 62.5%\n}\n```\n这个意思是默认字体尺寸的62.5%，也就是 16*62.5%=10px，此时我们就有1rem = 10px。\n\n## click在ios上有300ms的延迟，原因和解决办法\n苹果上有一个双击缩放网页的功能，当第一次click时候浏览器会等待300ms判定用户是否要双击，所以点击一次后会延迟300ms才发生click事件。\n\n解决办法：\n1. 禁用缩放：\n```js\n<meta name=\"viewport\" content=\"width=device-width;user-scalable=no;\">\n```\n\n2. 利用fastClick：(`FastClick.attach(document.body)`)\n检测到touchend事件时立即发出模拟click事件，并且把浏览器300ms后发出的点击事件给阻断掉。\n\n## 浏览器缓存的四种实现方法\n按优先级从高到低：\n1. Service Worker：本质是一个web worker，是独立于网页运行的脚本。\n2. Memory Cache：Memory Cache指的是内存缓存，从效率上讲它是最快的。\n3. Disk Cache：Disk Cache就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。\n4. Push Cache：即推送缓存，是 HTTP/2 的内容。\n\n浏览器的三级缓存原理：\n\n1. 先去内存看，如果有，直接加载\n\n2. 如果内存没有，择取硬盘获取，如果有直接加载\n\n3. 如果硬盘也没有，那么就进行网络请求\n\n4. 加载到的资源缓存到硬盘和内存\n\n## 在地址栏里输入一个url到页面呈现出来，中间发生了什么？\n- 输入url，查询对应ip（dns解析）（DNS查询分为递归查询和迭代查询）\n  - 先查找缓存：浏览器缓存->系统缓存->路由器缓存\n  - 没有查到则查找系统的hosts文件中是否有记录，\n  - 没有则查询DNS服务器，缓存\n- 建立tcp连接（TCP三次握手）\n- 根据ip和端口号构建一个http请求，封装为tcp包，请求传输：应用层->传输层->网络层->数据链路层->物理层（发送请求，解析url，设置请求报文(头，主体)）\n  - 到达服务器，服务器解析请求作出响应\n- 浏览器接收到html构建DOM树（中途如果遇到js就会停止构建而去执行会下载脚本）（浏览器渲染）\n  - 构建CSSOM树\n  - 合并两树为渲染树（排除了非视觉结点）\n  - 布局（确定个元素的尺寸和位置）\n  - 渲染绘制页面\n\n## Cache-control的值有哪些\nCache-control是一个通用消息头字段，被用于HTTP请求和响应中。通过指定指令来实现缓存机制，这个缓存指令是单向的，常见的取值有：\n- private(默认)\n- no-cache\n- max-age\n- must-revalidate\n\n## 如何画0.5px的线\n- 采用视口控制\n```html\n<meta name=\"viewport\" content=\"width=device-width;initial-scale=0.5;user-scalable=no;\" />\n```\n\n- border-image\n需要自己制作一个0.5px的线条图片\n```css\np {\n    border-width: 0 0 1px 0;\n    border-image: url(xxx.png) 2 0 round;\n}\n```\n\n- transform\n```css\np {\n    transform: scaleY(0.5);\n    /* 设置基点 */\n    transform-origin: 50% 100%;\n}\n```\n\n## transition和animation的区别\n- animation：动画，不需要触发任何事件就可以改变属性值 \n- transition：过渡，侦听属性发生变化时触发，搭配其他样式属性能实现大多数过渡动画\n\n创建动画序列，需要使用animation属性或者其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现。动画的实际表现是由@keyframes规则实现\n\ntransition也可以实现动画，transition强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同途径获取样式，而第二个途径当某种改变发生时才能获取样式，这样就会产生过渡动画。transition多个属性用逗号隔开。\n```css\ntransition: transform 2s ease,border-radius 3s ease-out;\n```\n\n## 关于js动画和css3动画的差异性\n渲染线程分为main thread和compositor thread。如果css动画只改变transform和opacity，这时候整个css动画在compositor thread得以完成（而js动画会在main thread执行然后compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout和paint的.\n\n- 区别\n - 功能覆盖面，js比css大 实现或者重构难度不一，适合效果复杂且动态效果要求高的动画\n - css3比js简单，性能调优方向固定 能触发 GPU 加速，调用 GPU 能力，帧率高\n - css3可以做到自然降级 css动画有天然事件支持 css3有兼容性问题\n\n`calc属性使用户可以动态计算长度值。任何长度值都可以使用calc()函数来计算`\n\n## 快速下载git\nhttps://npm.taobao.org/mirrors/git-for-windows/\n科学计数法 1e3 === 1000\n\n## 双边距重叠问题（外边距折叠）\n现象：多个相邻（兄弟或者父子关系）普通流的块元素垂直方向margin会重叠\n\n折叠结果为：\n\n两个相邻的外边距都是正数时，折叠结果是较大者 两个相邻的外边距都是负数时，折叠结果是绝对值较大者 两个相邻的外边距一正一负时，折叠结果是两者的和\n\n## display：table和本身table有什么区别\ndisplay：table和本身table是相对应的，区别在于display：table的声明能够让一个html元素和它的子节点像table元素一样，使用基于表格的css布局，使我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了table那样的制表标签导致的语义化问题。\n\n之所以现在逐渐淘汰了table系列表格元素，是因为使用div+css编写出来的文件比用table编写出来的小，而table必须在页面完全加载完成后才显示，div则是逐行显示，table的嵌套性太多，没有div简洁\n\n## line-height和height的区别\nline-height一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的。height一般是指容器的整体高度\n\n## 重绘和重排\n\n### 重绘\n\n当盒子的位置，大小以及其他属性，例如颜色。字体大小等都确定下来之后，浏览器便把这些元素都按各自的特性绘制一遍，将内容呈现在页面上，重绘是指一个元素外观的改变触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。\n\n触发重绘的条件：改变元素的外观属性\n\n### 重排：当渲染树中的一部分或全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，每个页面至少经历一次重排，即首次加载\n\n重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，也就是意味着重排意味着重绘操作，而重绘不一定导致重排\n\n引起重排重绘的原因有:\n- 添加或者删除可见的DOM元素\n- 元素尺寸位置的改变\n- 浏览器页面的初始化\n- 浏览器窗口大小发生改变\n\n减少重绘重排的方法有\n- 不在布局信息改变时做DOM查询\n- 使用csstext，className一次性改变属性\n- 使用fragment\n- 对于多次重排的元素，比如动画，使用绝对定位脱离文档流，使其不影响其他元素\n\n## ajax阻止缓存请求\n- 在ajax发送请求前加上ajaxObj.setRequestHeader(\"If-Modified-Since\", \"0\")\n- 在ajax发送请求前加上ajaxObj.setRequestHeader(\"Cache-Control\", \"no-cache\")\n- 在url后面加一个随机数：\"fresh=\"+Math.rendom()\n- 在url后面加上时间戳：\"nowtime=\"+new Date().getTime()\n\n## 实现单例模式(闭包)\n- 模仿块级作用域，保存外部函数的变量，封装私有变量\n```js\nfunction Person(name) {\n    this.name = name;\n}\n\nfunction Singleton = function(constructor) {\n    var ret;\n    return function() {\n        if(!ret) ret = new constructor(...arguments);\n        return ret;\n    }\n}\n```\n\n## 三栏等宽图片布局\n```css\nimg {\n    display: block;\n    width: 30%;\n    margin: 2.5% 0 0 2.5%;\n    float: left;\n}\n```\n\n## 表单提交的常用方式是什么，应用层和通信层发生了什么过程？\n- 在form表单提交时我们最常用的方式时get和post，form表单提交时最要注意的就是enctype，enctype属性默认是application/x-www-form-urlencoded.\n- 在get方式时，浏览器会以当前的enctype编码方式将form数据转化成一个字符串，并将改字符串append到url上，以？分割。加载该新的url\n- 在post方式中：\n - 如果form中没有type为file的控件时，form也会以默认enctype进行编码。\n - 如果是具有type为file的控件时，enctype得设置成multipart/form-data，这样浏览器会将表单以控件为单位分割，并为每个部分加上Content-Disposition（form-data或者时file）、content-type（默认值为text/plain）、name等信息，并加上分割符（boundary）\n\n- 应用层和通信层发生了什么过程？\n - 浏览器发送请求后，DNS（Domain Name System）解析域名得到相应的IP地址。\n  - 通过域名访问网页\n  - 将域名发送到解析域名的服务器上，有很多专门解析.org、.cn、.com等，最主要有一台根域名服务器\n  - 找到对应的IP地址\n\n  - 应用层http协议（HyperText Transfer Protocol，超文本传输协议）\n    - 发送请求的我们称之为客户端（client）、而做出相应的服务器叫做源服务器（origin server）。在客户端和服务端之间可能存在很多中间层，比如代理，网关，隧道等。\n    - http协议中的请求报文和响应报文（具体格式大家可以百度了解下）\n  - 通信层（TCP/IP）：\n    - 生成http报文及请求\n    - TCP协议将http请求报文进行分割（为了方便传输），并在每个报文上标记序号和端口号发给网络层（IP协议）\n    - 网络层增加作为通信目的的MAC地址后转发给链路层（建立电路连接，整个网络的物理基础，典型协议为以太网和ADSL等）\n    - 链路层处理后生成的数据包通过物理层传输到接收端\n    - 接收到数据的服务端后按序网上传，\n    - TCP连接的三次握手四次挥手\n    - IP协议实现数据传递到对方计算机\n    - 解析请求报文并生成响应报文\nTCP协议是一种面向连接的、可靠的字节流的运输层通信协议，TCP是全双工模式。\n\n## flex: 0 1 auto 表示什么意思\n> flex: 0 1 auto 其实就是弹性盒子的默认值，表示 flex-grow, flex-shrink 和 flex-basis 的简写，分别表示放大比例、缩小比例、分配多余空间之前占据的主轴空间。\n\n\n## 小程序的技术架构和方案、小程序的出现主要解决什么问题？\n包含小程序容器、渲染引擎和 JavaScript 引擎。UI 层运行在 WebView 中，而逻辑层运行在独立的 JS 引擎中。\n\n降低获客成本、打通跨端\n\n## view 层、js 层分别在哪里、怎么通信 ?\n业务逻辑的 JS 在独立的 JavaScript 引擎（ServiceWorker）中，每个页面的 view 和 css 运行在各自独立的 webview 里面，页面之间是通过函数 navigateTo 进行页面的切换；JS 层和 view 层通过消息服务 MessageChannel 进行通信。\n\n## AST(抽象语法树)\n抽象语法树 (Abstract Syntax Tree)，是将代码逐字母解析成 树状对象 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。例如:\n```js\nfunction square(n){\n\treturn n * n\n}\n```\n![ast](http://cdn.mydearest.cn/blog/images/ast.png)\n\n## babel编译原理\n- babylon 将 ES6/ES7 代码解析成 AST (解析)\n- babel-traverse 对 AST 进行遍历转译，得到新的 AST (转换)\n- 新 AST 通过 babel-generator 转换成 ES5 (生成)\n\n## 函数式编程\n函数式编程是一种 编程范式，你可以理解为一种软件架构的思维模式。它有着独立一套理论基础与边界法则，追求的是 更简洁、可预测、高复用、易测试。其实在现有的众多知名库中，都蕴含着丰富的函数式编程思想，如 React / Redux 等。\n\n`函数式编程（缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用来构建软件的过程。`函数式编程是声明式的而不是命令式的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向\n对象中应用程序的状态通常与对象中的方法共享和共处。\n\n- 常见的编程范式:\n  - 命令式编程(过程化编程): 更关心解决问题的步骤，一步步以语言的形式告诉计算机做什么；\n  - 事件驱动编程: 事件订阅与触发，被广泛用于 GUI 的编程设计中；\n  - 面向对象编程: 基于类、对象与方法的设计模式，拥有三个基础概念: 封装性、继承性、多态性；\n  - 函数式编程(面向数学编程)：关心数据的映射。\n\n- 好处\n1. 函数副作用小，所有函数独立存在，没有任何耦合，复用性极高；\n2. 不关注执行时间，执行顺序，参数，命名等，能专注于数据的流动与处理，能有效提高稳定性与健壮性；\n3. 追求单元化，粒度化，使其重构和改造成本降低，可维护、可拓展性较好；\n4. 更易于做单元测试。\n\n## 什么是cdn及其好处\nCDN:CDN是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问\n题，适用于站点加速、点播、直播等场景。\n\n### 好处\n1. 多域名加载资源\n一般情况下，浏览器都会对单个域名下的并发请求数（文件加载）进行限制，通常最多有4个，那么第5个加载项将会被阻塞，直到前面的某一个文件加载完毕。\n因为CDN文件是存放在不同区域（不同IP）的，所以对浏览器来说是可以同时加载页面所需的所有文件（远不止4个），从而提高页面加载速度。\n\n2. 文件可能已经被加载过并保存有缓存\n一些通用的js库或者是css样式库，如jQuery，在网络中的使用是非常普遍的。当一个用户在浏览你的某一个网页的时候，很有可能他已经通过你网站使用的CDN访问过了其他的某一个网站，恰巧这个网站同样也使用了jQuery，那么此时用户浏览器已经缓存有该jQuery文件（同IP的同名文件如果有缓存，浏览器会直接使用缓存文件，不会再进行加载），所以就不会再加载一次了，从而间接的提高了网站的访问速度。\n\n3. 高效率\n你的网站做的再NB也不会NB过百度NB过Google吧？一个好的CDN会提供更高的效率，更低的网络延时和更小的丢包率。\n\n4. 分布式的数据中心\n假如你的站点布置在北京，当一个香港或者更远的用户访问你的站点的时候，他的数据请求势必会很慢很慢。而CDNs则会让用户从离他最近的节点去加载所需的文件，所以加载速度提升就是理所当然的了。\n\n5. 使用情况分析\n一般情况下CDNs提供商（如百度云加速）都会提供数据统计功能，可以了解更多关于用户访问自己网站的情况，可以根据统计数据对自己的站点适时适当的做出些许调整。\n\n6. 有效防止网站被攻击\n一般情况下CDNs提供商也是会提供网站安全服务的\n\n## 网站突然打不开有哪些可能\n断网，DNS 解析出现问题，代理服务器出现问题，流量被劫持了等等\n\n## 前端向后端发送请求有几种方式？\n1. link src=\"\"\n2. script src=\"\"\n3. img src=\"\" // audio video\n4. ajax请求\n5. 表单提交\n6. a href=\"\"\n7. iframe src=\"\"\n\n## axios 特点\n1. axios 是一个基于 promise 的 HTTP 库，支持 promise 所有的 API\n\n2. 它可以拦截请求和响应\n\n3. 它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON 类型的数据\n\n4. 安全性更高，客户端支持防御 XSRF\n\n5. 取消请求\n```js\nvar app = new Vue({\n  el: '#app',\n  data: {\n    message: 'Hello Axios!',\n    source: null\n  },\n  methods: {\n    sendRequest () {\n      this.source = this.axios.CancelToken.source(); // 这里初始化source对象\n      this.axios.get(url, {\n        cancelToken: this.source.token // 这里声明的cancelToken其实相当于是一个标记，\n        // 当我们要取消请求的时候，可以通过这个找到该请求\n      })\n        .then(res => {\n          // 你的逻辑\n        })\n        .catch(res => {\n          // 如果调用了cancel方法，那么这里的res就是cancel传入的信息\n          // 你的逻辑\n        })\n    },\n    cancel () {\n      this.source.cancel('这里你可以输出一些信息，可以在catch中拿到')\n    }\n  }\n})\n```\n\n默认 Content-Type: application/json;charset=utf-8\n- Content-Type: application/json ： 请求体中的数据会以json字符串的形式发送到后端\n- Content-Type: application/x-www-form-urlencoded：请求体中的数据会以普通表单形式（键值对）发送到后端\n- Content-Type: multipart/form-data： 它会将请求体的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。\n\n数据发送字段：params(get)、data(post、put)\n\n### 配置axios请求头中的content-type为指定类型\n```js\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 或者 \n\n{headers:{'Content-Type':'application/x-www-form-urlencoded'}}\n```\n\n## Base64的编码原理\n字符选用了\"A-Z、a-z、0-9、+、/\" 64个可打印字符，这是标准的Base64协议规定。\n```js\n['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']\n```\n\n### 具体转换步骤\n- 第一步 将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。\n- 第二步 将上面的24个二进制位每6个一组，共分为4组。\n- 第三步 在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。\n- 第四步 根据Base64编码对照表获得对应的值。\n\n## {}和[]的valueOf和toString结果\n```js\nvar a = {}\na.valueOf() // {}\na.toString() // [object Object]\n\nvar b = []\nb.valueOf() // []\nb.toString()  // \"\"\n```\n\n## 三种事件模型\n- 事件(是用户操作网页时发生的交互动作或者网页本身的一些操作)\n原始事件模型（DOM0），DOM2事件模型，IE事件模型\n\n### DOM0级模型\n这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js属性来指定监听函数。这种方式是所有浏览器都兼容的。\n- 缺点\n  - 逻辑和显示没有分离\n  - 相同事件的监听函数只能绑定一个，后面绑定的会覆盖掉前面的\n  - 无法处理事件的冒泡和委托\n```html\n<!-- 在 html 代码中直接指定属性值 -->\n<button onclick=\"doSomeTing()\">test</button>\n\n<script>\n  // 在 js 代码中\n  document.getElementsById('demo').onclick = doSomeTine();\n</script>\n```\n\n### IE 事件模型\n在该事件模型中，一次事件共有两个过程，事件处理(目标)阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。\n\n### DOM2 级事件模型\n在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。\n\n所有的事件类型都会经历事件捕获，但是只有部分事件会经历事件冒泡阶段，例如 submit 事件就不会冒泡。\n\n## 简单介绍一下V8引擎的垃圾回收机制\n```\nv8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。\n\n新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。\n\n新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算\n法分为三步：\n\n（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。\n\n（2）如果对象不存活，则释放对象的空间。\n\n（3）最后将 From 空间和 To 空间角色进行交换。\n\n新生代对象晋升到老生代有两个条件：\n\n（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。\n\n（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后\n会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。\n\n老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎\n片的问题引入了标记压缩法。\n\n由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的\n方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。\n```\n\n## 获取原型的方法\n```js\np.__proto__\n\np.construtor.prototype\n\nObject.getProtorypeOf(p)\n```\n\n## 造火箭\n- 什么是xxx\n- 讲讲你对xxx的理解\n- xxx的原理、xxx怎么实现\n- xxx的优缺点\n- xxx怎么进行优化\n- 讲讲xxx的思想，设计思路\n- xxx的作用是什么，怎么做的\n- 项目中(react/vue)遇到的问题\n- 最满意的项目，什么地方做的好\n- 如何实现一个 animate.js\n- 三个词描述自己\n- 觉得自己为啥能符合这个岗位\n- xxx解决了什么问题\n- 如何搭建前端监控体系\n- 随机应变\n\n- 人才的定义，想招什么样的人\n过硬的技术基础外，还需要有良好的表达能力、处事能力等软实力。\n\n### 工具\n短命令行工具、自动化上传部署、i18n词条翻译、eslint校验目录格式、chrome插件、模板编译、axios封装、基建\n\n## Iterator是什么，有什么作用？\nterator（迭代器）是一种接口，也可以说是一种规范。为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即\n依次处理该数据结构的所有成员）。\n\n```js\nconst obj = {\n    [Symbol.iterator]:function(){}\n}\n```\n\n迭代器的遍历方法是首先获得一个迭代器的指针，初始时该指针指向第一条数据之前，接着通过调用 next 方法，改变指针的指向，让其指向下一条数据 每一次的 \nnext 都会返回一个对象，该对象有两个属性\n\n- value 代表想要获取的数据\n- done 布尔值，false表示当前指针指向的数据有值，true表示遍历已经结束\n\n### 作用\n1. 为各种数据结构，提供一个统一的、简便的访问接口；\n2. 使得数据结构的成员能够按某种次序排列；\n3. ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。\n\n## 检测对象中存在某个属性\n- prop in obj：返回布尔值，指示指定的属性在指定的对象或其原型链中；\n\n- obj.hasOwnProperty(prop)：返回布尔值，指示对象自身属性中是否具有指定的属性，因此这个方法会忽略掉那些从原型链上继承到的属性；\n\n- obj[\"prop\"]：读取属性值，存在则返回值，否则返回 undefined；\n\n## JS 中的主要有哪几类错误\n- 加载时错误：加载web页面时出现的错误(如语法错误)称为加载时错误，它会动态生成错误。\n\n- 运行时错误：由于滥用HTML语言中的命令而导致的错误。  \n\n- 逻辑错误：这些错误是由于对具有不同操作的函数执行了错误的逻辑而导致的\n\n## mul函数乘法指令\n```js\nfunction mul (x) {  \n return function (y) { \n   return function (z) {   \n     return x * y * z;\n   }\n  }\n}\n```\n\n## js实现枚举\n> 枚举的特点\n- 枚举值不能重复\n- 不能被修改\n- switch case可以直接判断\n\n```js\nconst EnumSex = Object.freeze({\n    man: Symbol('男'),\n    woman: Symbol('女')\n})\n```\n\n## 数组和链表的区别\n> 数组是我们平时用的最多的数据结构，它的特点是查询数据快，插入数据慢，查询的时间复杂度是O(1),插入的时间复杂度是O(n).\n\n> 链表我们平时用的比较少，它的特点是:插入数据快，查询数据慢，查询的时间复杂度是：O(n)，插入的时间复杂度是：O(1)，它的特点是和数组相反的；\n\n1. 数组是将元素在内存中连续存放。链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。\n\n2. 数组必须事先定义固定的长度，不能适应数据动态的增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费；链表动态地进行存储分配，可以适应数据动态地增减的情况。\n\n### 时间复杂度\n||数组|链表|\n|插入|O(n)慢|O(1)快|\n|删除|O(n)慢|O(1)快|\n|查询|O(1)快|O(n)慢|\n\n哈希表(数组链表)具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”\n\n## 内存有哪些分区？\n### 栈区（stack）\n由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  \n\n### 堆区（heap）\n一般由分配释放，若不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。  \n\n### 全局区（静态区）（static）\n全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。  \n\n### 文字常量区\n常量字符串就是放在这里的。程序结束后由系统释放。\n\n### 程序代码区\n存放函数体的二进制代码。  \n\n## 单元测试框架\n- Unit.js\n- Jasmine\n- Karma\n- Chai \n- AVA\n- Mocha\n- JSUnit\n- QUnit\n- Jest\n\n## BOM 和 DOM 的关系\n- BOM全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架。(location/history/navigator)\n- DOM全称Document Object Model，即文档对象模型，是 HTML 和XML 的应用程序接口（API），遵循W3C 的标准，所有浏览器公共遵守的标准。\n\nBOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。\n\n## js实现Map(数组存放对象实现api)，reduce方法\n```js\n// 归并方法\nconst reduceHelper = (f, acc, arr) => {\n  if (arr.length === 0) return acc\n  const [head, ...tail] = arr\n  return reduceHelper(f, f(acc, head), tail)\n}\n\nArray.prototype.fakeReduce = function (fn, initialValue) {\n  return reduceHelper(fn, initialValue, this)\n}\n```\n\n## reduce实现数组map\n```js\n\nArray.prototype._map = function(fn, thisArg) {\n  const result = [];\n  this.reduce((prev, curr, index, array) => {\n    result[index] = fn.call(thisArg, array[index], index, array);\n  }, 0)\n  return result;\n}\n```\n\n## Label 的作用是什么？是怎么用的？\nlabel 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。\n```html\n<label for=\"Name\">Number:</label>\n<input type=“text“ name=\"Name\" id=\"Name\"/>\n```\n\n## Canvas 和 SVG 有什么区别？\n> Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。依赖于像素，无法高效保真，画布较大时候性能较\n低。\n \n> SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函\n数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。svg:dom形式，涉及到动画时候需要更新dom，性能较低。\n\n## 网页验证码是干嘛的，是为了解决什么安全问题？\n1. 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水\n2. 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试\n\n## 渐进增强和优雅降级的定义\n- 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n- 优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n> 无头浏览器（Headless browser）指没有用户图形界面的(GUI)的浏览器，目前广泛运用于web爬虫和自动化测试中。\n\n## Window.getComputedStyle()\n`Window.getComputedStyle()`方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。 私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS\n属性名称进行索引来访问。\n```js\nlet elem1 = document.getElementById(\"elemId\");\nlet style = window.getComputedStyle(elem1, null);\n\n// 它等价于\n// let style = document.defaultView.getComputedStyle(elem1, null);\n```\n\n## 如何取消fetch请求\nFetch API已经成为现在浏览器异步网络请求的标准方法，但Fetch也是有弊端的，比如： Fetch还没有方法终止一个请求，而且Fetch无法检测上传进度。\n### 流程\n- 创建一个 AbortController 实例\n- 该实例具有 signal 属性\n- 将 signal 传递给 fetch option 的 signal\n- 调用 AbortController 的 abort 属性来取消所有使用该信号的 fetch。\n\n```js\nconst controller = new AbortController();\nconst { signal } = controller;\n\nfetch(\"http://localhost:8000\", { signal }).then(response => {\n    console.log(`Request 1 is complete!`);\n}).catch(e => {\n   if(e.name === \"AbortError\") {\n        // We know it's been canceled!\n    }\n    console.warn(`Fetch 1 error: ${e.message}`);\n});\n\n// Abort request\ncontroller.abort();\n```\n\n## 协议相对URL\n如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现警告信息，不同浏览器警告信息展现形式\n不同。\n\n为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为protocol-relative URL，暂且可译作协议相\n对 URL。\n\n## MVC模式\n![mvc](http://cdn.mydearest.cn/blog/images/mvc.png)\n\n用户把对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。\n\nMVC模式可以这样理解。将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完\n成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。\n\n\n## MVVM模式\n![mvvm](http://cdn.mydearest.cn/blog/images/mvvm.png)\n\nMVVM与MVC两者之间最大的区别就是：MVVM实现了对View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素来改变View的变化，\n而是改变其属性后，该属性对应的View层数据会自动改变。\n\n- Model代表数据模型，也可以在Model中定义操作数据变化的业务逻辑；\n- View代表UI视图，它负责将数据模型转化成UI展现出来；\n- ViewModel监听Model中数据的改变和控制View层的展现；\n\n### 不同空格符合的区别\n- &nbsp; 半角的不断行的空白格（推荐使用）\n\n- &ensp; 半角的空格\n\n- &emsp; 全角的空格\n\n_详细的含义：_\n\n1. `&nbsp;`：这是我们使用最多的空格，也就是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加。该空格占据宽度受字体影响明显而强烈。在inline-block布局中会搞些小破坏，在两端对齐布局中又是不可少的元素。\n\n2. `&ensp;`：此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。\n\n3. `&emsp;`：此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。\n\n### 浏览器私有属性\n|-webkit-|-moz-|-ms-|-o-|\n|chrome,safari|firefox||||\n\n### CSS变量\n自从CSS3，我们可以在CSS中定义变量，从而使得页面的样式更统一。\n```css\n/* 声明全局变量 */\n:root{\n    --color-main-font: #303133;\n    --color-normal-font: #606266;\n    --color-secondary-font: #909399;\n    --size-main-title: 20px;\n    --size-title: 18px;\n    --size-second-title: 16px;\n    --size-body: 14px;\n    --size-tip: 12px;\n}\n/* 声明局部变量 */\ndiv{\n    --color: green;\n}\n/* 使用变量 */\n.example{\n    color:var(--color-main-font);\n    /* 如果变量不存在就会使用逗号后面的值 */\n    font-size:var(--color-body,20px);\n}\n```\n注： 当有重复变量名的时候，遵循优先级规则覆盖！\n\n#### 媒体查询(@media)\n```csss\n@media only screen and (max-width: 600px) {\n    .example {background: red;}\n}\n```\n\n我们也可以在HTML文件中通过媒体查询判断是否引入一个CSS\n\n```html\n<link rel=\"stylesheet\" media=\"(min-width:480px)\" href=\"mystylesheet.css\">\n```\n\n#### 自定义字体(@font-face)\n```css\n@font-face{\n    font-family:'myFont';\n    src:url('./font/example.svg')format('svg'),\n        url('./font/example.ttf')format('truetype');\n}\n\n/* 可以直接将上面定义好的的 `my-font` 作为字体 */\n.my-font{\n    font-family: 'myFont';\n}\n/* 如果是小图标，可以作为伪元素插入到页面中 */\n.icon-back:before{\n    content:'\\800';\n}\n\n/* <span class=\"my-font icon-back\"></span> */\n```\n\n### 装饰器的原理\n语法糖，实则调用Object.defineProperty，可以添加、修改对象属性\n\n### 堆栈的区别\n\n- 申请方式\n内存中的堆和栈第一个区别就是申请方式的不同：栈是系统自动分配空间的，而堆则是程序员根据需要自己申请的空间。由于栈上的空间是自动分配自动回收的，所以栈上的数据的生存周期只是在函数的运行过程中，\n运行后就释放掉，不可以再访问。而堆上的数据只要程序员不释放空间，就一直可以访问到，不过缺点是一旦忘记释放会造成内存泄露。\n申请效率的比较：栈由系统自动分配，速度较快。但程序员是无法控制的。堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。\n\n- 申请大小的限制：\n栈：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M（也有的说是1M，总之是一个编译时就确\n定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。\n堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由\n此可见，堆获得的空间比较灵活，也比较大。\n\n### 为什么不要扩展js内置对象\n如果浏览器或javascript本身就会实现这个方法，而且和你扩展的实现有不一致的表现。到时候你的javascript代码可能已经在无数个页面中执行了数年，而浏览器的实现导致所有使用扩展原型的代码都崩溃。\n\n### 可变 (mutable) 和不变 (immutable) 对象的区别\n- Mutable对象：\n在JavaScript中，对象是引用类型的数据，其优点在于频繁地修改对象时都是在原对象的基础上修改，并不需要重新创建，这样就可以有效地利用内存，不会造成内存空间的浪费\n\n- Immutable对象：(string, number)\n每次修改一个immutable对象时都会创建一个新的不可变对象，在新对象上的操作不会影响到原对象的数据\n\n- 区别：\nImmutable对象在修改数据时并不会复制一整份数据，而是将变化的节点与未变化的节点的父子关系转移到一个新节点上(结构共享)，而Mutable在复制时是“全量”。Immutable对象需要通过set和get来对数据进行\n读和写。\n\n#### 不可变优点\n- 降低 Mutable 带来的复杂度\n- 节省内存空间\n- 方便实现撤销重做功能\n- 拥抱函数式编程\n\n#### 不可变缺点\n- 容易与原生对象搞混\n\n### 防止重复发送ajax请求\n1. 点击按钮后disabled\n2. 函数节流\n3. abort上一个请求\n\n### Ajax和Fetch区别\n- fetch优点\n语法简洁，更加语义化\n基于标准 Promise 实现，支持 async/await\n同构方便，使用 isomorphic-fetch\n\n- ajax是使用XMLHttpRequest对象发起的，但是用起来很麻烦，所以ES6新规范就有了fetch，fetch发一个请求不用像ajax那样写一大堆代码。\n- 使用fetch无法取消一个请求，这是因为fetch基于Promise，而Promise无法做到这一点。\n- 在默认情况下，fetch不会接受或者发送cookies\n- fetch没有办法原生监测请求的进度，而XMLHttpRequest可以(xhr.upload.onprogress)\n- fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理\n- fetch由于是ES6规范，兼容性上比不上XMLHttpRequest\n\n### setTimeout() 的第二个参数的最小值不得小于4毫秒，如果低于这个值，则默认是4毫秒\n\n### 面向过程、面向对象\n面向对象特点：封装、继承、多态\n- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现。\n- 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。面向对象是以功能来划分问题，而不是步骤\n\n面向对象思想：\n基本思想是使用对象，类，继承，封装等基本概念来进行程序设计。\n优点\n1. 易维护\n采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的\n2. 易扩展\n开发工作的重用性、继承性高，降低重复工作量。缩短了开发周期\n\n### 100 * 100 的 Canvas 占内存多大\n我们在定义颜色的时候就是使用 rgba(r,g,b,a) 四个维度来表示，而且每个像素值就是用十六位 00-ff 表示，即每个维度的范围是 0~255，即 2^8 位，即 1 byte, 也就是 Uint8 能表示的范围。\n所以 100 * 100 canvas 占的内存是 100 * 100 * 4 bytes = 40,000 bytes\n\n### 实现Object.create\n```js\nfunction create(proto) {\n  function Fn() {}\n  Fn.prototype = proto\n  Fn.prototype.constructor = Fn\n  return new Fn()\n}\n```\n\n### 10进制转换\n```js\nfunction convert(number, base = 2) {\n  let rem, res = '', digits = '0123456789ABCDEF', stack = [];\n\n  while (number) {\n    rem = number % base;\n    stack.push(rem);\n\n    number = Math.floor(number / base);\n  }\n\n  while (stack.length) {\n    res += digits[stack.pop()].toString();\n  }\n  \n  return res;\n}\n```\n\n### 相邻的两个inline-block节点出现间隔的原因以及解决方法\n原因：元素被当成行内元素排版的时候，原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间\n就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-size:16px时，间距为8px。\n\n解决方案：\n1. 给父级元素设置font-size： 0；子元素设置相应的font-size\n2. 改变书写方式(去掉空格)\n3. margin负值和字体大小有关不推荐\n4. 设置父元素，display:table和word-spacing:0\n\n\n### Promise.reject\n```js\nPromise.reject(2).catch(e => e).then(d => {\n  console.log(d);\n});\n// 2\n```\n\n### 字符编码\n- ASCII：编码的规范标准\n- Unicode：将全\n世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。Unicode码是ASCII码的一个超集\n(superset)\n- UTF-32 UTF-8 UTF-16 都是Unicode码的编码形式\n- UTF-32：用固定长度的四个字节来表示每个码点\n- UTF-8：用可变长度的字节来表示每个码点,如果只需要一个字节就能表示的,就用一个字节,一个不够,就用两个…所以,在UTF-8编码下,一个字符有可能由1-4个字节组成.\n- UTF-16：结合了固定长度和可变长度,它只有两个字节和四个字节两种方式来表示码点\n\n### 前后端分离的项目如何seo\n1. 使用prerender。\n2. 先去 `https://www.baidu.com/robots.txt` 找出常见的爬虫，然后在nginx上判断来访问页面用户的User-Agent是否是爬虫，如果是爬虫，就用nginx方向代理到我们自己用nodejs + \npuppeteer实现的爬虫服务器上，然后用你的爬虫服务器爬自己的前后端分离的前端项目页面，增加扒页面的接收延时，保证异步渲染的接口数据返回，最后得到了页面的数据，返还给来访问的爬虫即\n可。\n\n### 常见模板语言\n- jade\n- pug\n- thymeleaf\n\n### BFF(Back-end for Front-end)中间层\n![bff](http://cdn.mydearest.cn/blog/images/bff.png)\n前端分层和建模，实现上没太大限制，就是一层nodejs，能做请求转发和数据转化即可。\n\n- 优点\n1. 前后端彻底分离，即便是后期有微服务迁移，也不需改动前端代码\n\n2. 业务更向前靠拢，琐碎的api由前端开发自己决定，更适配前端框架\n\n3. BFF可以自开mock，插件也能生成API文档，相比后端单开这类服务要方便些吧\n\n4. 留给后端更清晰的服务边界，只需要提供粗粒度的接口即可\n\n- 缺点\n1. 中间层转发会增加请求延迟。\n\n2. 需要保证端到端测试\n\n3. 必须随时准备好后端异常请求\n\n4. BFF分层会增加开发成本\n","tags":["面试"],"categories":["知识"]},{"title":"正确设置网站title、keywords、description","url":"%2Fseo.html","content":"\n---\n<!--more-->\n\nSEO：搜索引擎优化，提高网站浏览量\n\nSEM：搜索引擎营销\n\nIP：独立IP访问的用户\n\nPV：页面浏览量或点击量\n\nUV：独立访客数\n\n## title（网站标题）\n\ntitle，就是浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。\n\n```html\n用法：<title>网站标题</title>\n```\n\n1. 首页title写法，一般是“网站名称-主关键词或一句含有主关键词的描述”。在做优化时习惯把主关键词放最前面，网站名称放后面，因为搜索引擎给予标题最前面的词比后面的高。比如，做“招聘”这个词，就这样写“企业招聘-创业公司招聘技巧-xx招聘”。\n\n2. 栏目页title写法，一般有2种：“栏目名称-网站名称”、“栏目名称栏目关键词-网站名称”。建议用“栏目名称-网站名称”。而且栏目名称最好用关键词来确定，比如企业招聘栏目最好就用企业招聘，而不要起个让人无法识别的名字如企业来人，企业看看，或企业加上一些特殊符号，这种写法虽然很有个性，但会让你的网站在优化上占了下风。\n\n3. 分类列表页title写法，一般是“分类列表页名称-栏目名称-网站名称”，这个和栏目页差不多。\n\n4. 文章页title写法，一般有3种：“文章标题-网站名称”、“内容标题-栏目名称”、“内容标题-栏目名称-网站名称”。其中，“内容标题-栏目名称-网站名称”的写法最为规范，但也相对复杂，它能给用户很好的提示，让用户知道他在访问哪篇文章，并且是在哪个网站的哪个栏目下。\n\n \n\n## keywords（关键词）\n\nkeywords，是用户不查看源代码看不到的。主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此keywords的每个词都要能在内容中找到相应匹配，才有利于排名。keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。为什么用英文上文已经说过。而且，尽量将重要的关键字靠前放，因为靠后的关键字排名较差，除非你站有很高的权重。\n\n小道消息称keywords曾被百度、谷歌、雅虎等搜索引擎剔除，将不会再影响搜索引擎的排序结果，设置一下总没坏处，还是有一些搜索引擎比较重视keywords标签的。\n\n```html\n用法：<meta name=\"Keywords\" Content=\"关键词1,关键词2,关键词3,关键词4\">\n```\n\n1. 首页keywords写法，一般是“网站名称,主要栏目名,主要关键词”。\n\n2. 栏目页keywords写法，一般是“栏目名称,栏目关键字,栏目分类列表名称”。\n\n3. 分类列表页keywords写法，这个就比较简单了，只要将你这个栏目中的主要关键字写入即可。\n\n4. 文章页keywords写法，建议大家提取文章中的关键词，比如我的文章主要是讲SEO优化的，那么我关键词肯定是SEO优化，如果你觉得你提取关键词的能力较差，也可以选择文章中出现比较多的词来作为关键词，比如我现在写的内容是关于title、keywords、description的，那我的文章页关键词就是这3个。\n\n## description（内容摘要）\n\ndescription，和上面的keywords一样，是用户不查看源代码看不到的，而且也是对于一个网页的简要内容概况。不同的是，keywords是由几个词语的组成的，而description则是完整的一句话。description一般不超过150个字符，描述内容要和页面内容相关。\n\n```html\n用法：<meta name=”Description” Content=”你网页的简述”>\n```\n\n1. 首页description写法，一般是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍。\n\n2. 栏目页description写法，一般是将栏目的标题、关键字、分类列表名称融合到里面，写成简单的介绍。\n\n3. 分类列表页description，这个就比较简单了，一般只需要把分类列表的标题、关键词融合在一起，写成简单的介绍。\n\n4. 文章页description写法，一般有2种写法，标准写法就和前面的一样，将文章标题、文章中的重要内容和关键词融合在一起，写成简单的介绍。这是最好最标准的写法。但是这样写比较麻烦，可以在文章首段和标题中加入关键词，比如我这篇文章是讲title、keywords、description的，那么在文章首段和标题中就加入这些内容，然后直接将文章首段的内容复制到description中即可。\n\n**PS：3个标签按重要性来分：title>description>keywords**\n\n## 其他优化技巧\n\n1）标签语义化(正确的标签包含了正确的内容，结构良好，便于阅读)\n2）一个页面中的H1标签只能使用一次 \n3）img标签都要设置 alt 属性，在这个属性中声明当前图片(非纯装饰图片)的信息（spider不能收录图片，但是可以抓取到图片alt属性的值） \n4）HTML的层级不要太深的层级，蜘蛛可能不会抓取和收录 \n5）把需要推广的关键词尽可能的在页面中曝光（最好都写在H（2~6）标签中）\n6）提高网站速度 \n7）少用iframe，不用js输出重要内容\n","tags":["优化"],"categories":["知识"]},{"title":"JavaScript整理总结","url":"%2Fjssummary.html","content":"\nJS的相关知识点比较繁杂，特此开篇整理一波，方便回顾总结查阅。\n\n- 运行在宿主环境环境中，比如浏览器或node环境\n- 不用预编译，直接解释执行代码\n- 是弱类型语言，较为灵活\n- 与操作系统无关，跨平台的语言\n- 脚本语言，解释性语言\n\n--- \n<!--more -->\n\n## 概念\nJavaScript 是一门跨平台、面向对象、基于原型的轻量级动态脚本语言。\n\n与java的对比：\n\n|JavaScript|Java|\n|:---|:---|\n|面向对象。不区分对象类型。通过原型机制继承，任何对象的属性和方法均可以被动态添加。|基于类系统。分为类和实例，通过类层级的定义实现继承。不能动态增加对象或类的属性或方法。|\n|变量类型不需要提前声明(动态类型)。|变量类型必须提前声明(静态类型)。|\n|不能直接自动写入硬盘。|可以直接自动写入硬盘。|\n\n## 变量声明\n### var(存在变量提升)\n声明一个变量，可赋一个初始化值。\n\n### let(let 同一变量在同一作用域不能同时声明)\n声明一个块作用域的局部变量，可赋一个初始化值。\n\n### const(const 声明时必须赋初始值,也不可以在脚本运行时重新声明)\n声明一个块作用域的只读的命名常量。\nconst声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。\n如const a=[1,2,3] a[1]=4; const b={} b.name=\"1\" 数组元素和对象属性不受保护。\n\n## 变量的作用域\n在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的任何其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。全区变量是全局对象的属性，在浏览器中可以用window.xx或xx来访问。\n\n```javascript\nif(true){\n    var a=5\n}\nconsole.log(a) // 5 使用let声明块级则是undefined\n```\n## 变量提升\nJavaScript 变量的另一特别之处是，你可以引用稍后声明的变量而不会引发异常。这一概念称为变量声明提升(hoisting)；\nvar ok ; let 和 const 则不会存在变量提升\n\n```javascript\n1.\nconsole.log(x === undefined); // true\nvar x = 3;\n\n2.\nvar myvar = \"my value\";\n\n(function() {\n  console.log(myvar); // undefined\n  var myvar = \"local value\";\n})();\n\n1.1 也可写作\nvar x;\nconsole.log(x === undefined); // true\nx = 3;\n\n2.1\nvar myvar = \"my value\";\n \n(function() {\n  var myvar;\n  console.log(myvar); // undefined\n  myvar = \"local value\";\n})();\n```\n\n## 函数提升\n声明函数的3种方式：\n\n```javascript\nfunction foo(){} // 函数声明 存在函数提升且大于变量提升\nvar foo=function (){} // 函数表达式 var foo=function foo1(){} 函数名可写\nnew Function(\"参数1\",\"参数2\",...,\"参数n\",\"函数体\"); // 使用Function构造函数\n```\n\n从作用域上来说，函数声明式和函数表达式使用的是局部变量，而 Function()构造函数却是全局变量。\n```js\nvar name = '我是全局变量 name';\n\n// 声明式\nfunction a () {\n  var name = '我是函数a中的name';\n  return name;\n}\nconsole.log(a()); // 打印: \"我是函数a中的name\"\n\n// 表达式\nvar b = function() {\n  var name = '我是函数b中的name';\n  return name; // 打印: \"我是函数b中的name\"\n}\nconsole.log(b())\n\n// Function构造函数\nfunction c() {\n  var name = '我是函数c中的name';\n  return new Function('return name')\n}\nconsole.log(c()()) // 打印：\"我是全局变量 name\"，因为Function()返回的是全局变量 name，而不是函数体内的局部变量。\n```\n\n从执行效率上来说，Function()构造函数的效率要低于其它两种方式，尤其是在循环体中，因为构造函数每执行一次都要重新编译，并且生成新的函数对象。\n\n此时的3种递归调用自身的方式 \n- foo()\n- foo1()\n- arguments.callee() \n\n现在已经不推荐使用arguments.callee()；\n原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。\n\n## 数据类型 8种\n### 原始类型\n- Boolean\n- null\n- undefined\n- String \n- Number 标识范围 -2^53~2^53 数字均为双精度浮点类型\n  - 实质是一个 64 位的浮点数。使用 53 位表示小数位，10 位表示指数位，1 位表示符号位。\n- Symbol(它的实例是唯一且不可改变)\n- bigint\n\nObject 是 JavaScript 中所有对象的父对象（object、array、function）\n\n两种类型的区别是：存储位置不同；\n原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先\n检索其在栈中的地址，取得地址后从堆中获得实体\n\n数据封装类对象：Object、Array、Boolean、Number 和 String\n其他对象：Function、Arguments、Math、Date、RegExp、Error\n\n为什么 x=0.1 能得到 0.1？\n恭喜你到了看山不是山的境界。因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 \n\n9.007199254740992，这也是 JS 最多能表示的精度。它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。\n\n不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此；\n\n`在JavaScript中，所有的Number都是以64-bit的双精度浮点数存储的，在用二进制存储时会存在精度误差；`\n\n`原因：计算机不能精确表示0.1， 0.2这样的浮点数，计算时使用的是带有舍入误差的数，但不是所有的浮点数在计算机内部都存在舍入误差，比如0.5就没有舍入误差`\n\n双精度的浮点数在这64位上划分为3段，而这3段也就确定了一个浮点数的值，64bit的划分是“1-11-52”的模式，具体来说：\n\n1.就是1位最高位（最左边那一位）表示符号位，0表示正，1表示负；\n\n2.11位表示指数部分；52位表示尾数部分，也就是有效域部分\n\n任何原始类型都有字面量形式，可以不被变量所存储。\n\nJavaScript语言有\"垃圾回收\"功能，所以在使用引用类型的时候无需担心内存分配。但是为了防止\"内存泄漏\"还是应该在不实用对象的时候将该对\n\n象的引用赋值为null。让\"垃圾回收\"器在特定的时间对那一块内存进行回收。\n\n64位浮点数：1位符号位 + 52位整数位 + 11位小数位，如果符号位为1，其他各位均为0，那么这个数值会被表示成\"-0\"。同理还可以表示\"+0\"\n\n```js\n// 二进制构造-0\n// 首先创建一个8位的ArrayBuffer\nconst buffer = new ArrayBuffer(8);\n// 创建DataView对象操作buffer\nconst dataView = new DataView(buffer);\n\n// 将第1个字节设置为0x80，即最高位为1\ndataView.setUint8(0, 0x80);\n\n// 将buffer内容当做Float64类型返回\nconsole.log(dataView.getFloat64(0)); // -0\n```\n\n- 判断+-0\n```js\n0 === -0 // true\n// Object.is(-0, 0)返回false，Object.is(NaN, NaN)返回true\n// 早期es利用1/-0为-Infinity的特点来判断\nfunction isNegativeZero(num) {  \n  return num === 0 && (1 / num < 0);\n}  \n```\n\n- Object.is()方法的polyfill\n```js\nif (!Object.is) {\n  Object.is = function(x, y) {\n    // SameValue algorithm\n    if (x === y) { // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  };\n}\n```\n\n### 原始封装类型\n```js\nvar a ='qwer';\nvar firstChar = a.chatAt(0);\nconsole.log(firstChar);// q\n```\n\n在js引擎中发生了\n```js\nvar a ='qwer';\nvar temp = new String(a);\nvar firstChar = temp.chatAt(0);\ntemp =null;\nconsole.log(firstChar);// q\n```\n\n```js\n0.10000000000000000555.toPrecision(16)\n// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1\n\n// 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试：\n0.1.toPrecision(21) = 0.100000000000000005551\n```\n\n`\"getters\"/\"setters\"`可以想象一个给定的字符串就像一个附加了一堆方法和属性的对象。当访问数组的长度时，你只需调用相应的 getter。setter 函数用于设置操作:\n```js\nvar array = {\n  value: [\"Hello\", 89, false, true],\n  push: function(element) {\n    //\n  },\n  shift: function() {\n    //\n  },\n  get length() {\n    // gets the length\n  },\n  set length(newLen) {\n    // sets the length\n  }\n};\n\n// Getter call\nvar len = array.length\n\n// Setter call\narray.length = 50;\n```\n\n### 对象Object\nObject 是 JS 中最重要的类型，因此几乎所有其他实体都可以从中派生。 例如，函数和数组是专用对象。 JS 中的对象是键/值对的容器。\n\n对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。\n\n只有null和undefined无法拥有方法\n\nFunction Array Number Boolean String Date Math RegExp类\n\n```javascript\ntypeof null === 'object' // true\nnull instanceof Object // false \nnull instanceof null // error\n\n// 不同的对象在底层都表示为二进制\n// 在JavaScript中二进制前三位为0的话都会被判断为object类型\n// null的二进制表示全是0，自然前三位也是0\n// 所以 typeof null === “object”\n\ntypeof Function; // 'function'\ntypeof new Function(); // 'function'\ntypeof function() {}; // 'function'\n\ntypeof Array; // 'function'\ntypeof Array(); // 'object'\ntypeof new Array(); // 'object'\ntypeof []; // 'object'\n\ntypeof Boolean; // \"function\"\ntypeof Boolean(); // \"boolean\"\ntypeof new Boolean(); // \"object\"\n\ntypeof Math; // 'object'\ntypeof Math(); // Math is not a function\ntypeof new Math(); // Math is not a constructor\n\n[]+[] // \"\"\n[]+{} // \"[object Object]\"\n{}+[] // 0\n\n!+[]+[]+![] // \"truefalse\"\n\nMath.max() // -Infinity\nMath.min() // Infinity\n```\n\n> 构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的\n\n## MDN基本数据类型的定义\n> 除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的\n>（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。\n\n```javascript\nvar a = 'string'\na[0] = 'a'\nconsole.log(a)  // string\n```\n我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。在 js 中是没有方法是可以改变布尔值和数字的。\n倒是有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。\n\n### 引用数据类型\n引用类型（object）是存放在堆heap内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。\n\n### 传值和传址\n了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。\n在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再将值赋值到新的栈中。例如:\n\n```javascript\nvar a = 10;\nvar b = a;\n\na ++ ;\nconsole.log(a); // 11\nconsole.log(b); // 10\n```\n所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。\n\n但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：\n\n```javascript\nvar a = {}; // a保存了一个空对象的实例\nvar b = a;  // a和b都指向了这个空对象\n\na.name = 'jozo';\nconsole.log(a.name); // 'jozo'\nconsole.log(b.name); // 'jozo'\n\nb.age = 22;\nconsole.log(b.age);// 22\nconsole.log(a.age);// 22\n\nconsole.log(a == b);// true\n```\n\n## 字面量\n字面量是由语法表达式定义的常量\n\n- 数组字面量(Array literals) []\n- 布尔字面量(Boolean literals) true/false\n- 浮点数字面量(Floating-point literals) 3.14\n- 整数(Intergers) 5 \n- 对象字面量(Object literals) {}\n- RegExp literals 一个正则表达式是字符被斜线（译注：正斜杠“/”）围成的表达式 /a+b/ \nRegExp.test() RegExp.exec() string.match() \n- 字符串字面量(String literals) \"1212\" '1212'\nJavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象。你也能用对字符串字面值使用类似\n\n```javascript\nString.length的属性：\nconsole.log(\"John's cat\".length)\n```\n\n```javascript\nvar obj={\n  say:funciton(){\n\n  },\n  // 简写\n  say(){\n\n  }\n}\n```\n十进制整数字面量由一串数字序列组成，且没有前缀0。\n八进制的整数以 0（或0O、0o）开头，只能包括数字0-7。\n十六进制整数以0x（或0X）开头，可以包含数字（0-9）和字母 a~f 或 A~F。\n二进制整数以0b（或0B）开头，只能包含数字0和1。\n\n## 模板字符串\n```javascript\nvar name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n\n## 布尔环境的假值\n* false\n* undefined\n* null\n* 0\n* NaN\n* 空字符串（\"\"）\n\n## try-catch \n如果finally块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：\n\n```javascript\nfunction f() {\n  try {\n    console.log(0);\n    throw \"bogus\";\n  } catch(e) {\n    console.log(1);\n    return true; // this return statement is suspended\n                 // until finally block has completed\n    console.log(2); // not reachable\n  } finally {\n    console.log(3);\n    return false; // overwrites the previous \"return\"\n    console.log(4); // not reachable\n  }\n  // \"return false\" is executed now  \n  console.log(5); // not reachable\n}\nf(); // console 0, 1, 3; returns false\n```\n\n## for of 和 for in循环\n- for in 更适合对象，遍历数组和对象\n- for of 适合遍历数组，遍历没有Symbol.iterator属性的对象是会报错的\n```javascript\nlet arr = [3, 5, 7];\narr.foo = \"hello\";\n\nfor (let i in arr) {\n   console.log(i); // logs \"0\", \"1\", \"2\", \"foo\"\n}\n\n// 所有可枚举的属性名\nfor (let i of arr) {\n   console.log(i); // logs \"3\", \"5\", \"7\" // 注意这里没有 hello\n}\n\n// for in 的循环顺序 => 遍历首先数字的可以接着按照创建顺序遍历\n// 对象数字键名会转成字符串 对象的key值只有string和symbol类型\n// 排序规则同样适用于下列API：\n// Object.entries\n// Object.values\n// Object.keys\n// Object.getOwnPropertyNames\n// Reflect.ownKeys\n\nvar a = {1:1,name:'cosyer',2:2}\nfor (let i in a) {\n  if(a.hasOwnProperty(i)){\n      console.log(i)\n  }\n}\n// 1 2 name\n```\n\n## 嵌套函数和闭包\n一个闭包是一个可以自己拥有独立的环境与变量的的表达式。\n- 内部函数包含外部函数的作用域。\n- 内部函数只可以在外部函数中访问。\n- 内部函数可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。\n\n## 多层嵌套函数\n函数可以被多层嵌套。例如，函数A可以包含函数B，函数B可以再包含函数C。B和C都形成了闭包，所以B可以访问A，C可以访问B和A。因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域。这个称之为作用域链。\n\n```javascript\nfunction A(x) {\n  function B(y) {\n    function C(z) {\n      console.log(x + y + z);\n    }\n    C(3);\n  }\n  B(2);\n}\nA(1); // logs 6 (1 + 2 + 3)\n```\n\n在这个例子里面，C可以访问B的y和A的x。这是因为：\n\n1. B形成了一个包含A的闭包，B可以访问A的参数和变量\n2. C形成了一个包含B的闭包\n3. B包含A，所以C也包含A，C可以访问B和A的参数和变量。换言之，C用这个顺序链接了B和A的作用域\n\n反过来却不是这样。A不能访问C，因为A看不到B中的参数和变量，C是B中的一个变量，所以C是B私有的。\n\n## 作用域链解释说明\n当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。\n\n`全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。\n当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，\n直至全局函数，这种组织形式就是作用域链。`\n\n```javascript\nfunction outside() {\n  var x = 5;\n  function inside(x) {\n    return x * 2;\n  }\n  return inside;\n}\n\noutside()(10); // returns 20 instead of 10\n```\n命名冲突发生在return x上，inside的参数x和outside变量x发生了冲突。这里的作用域链是{inside, outside, 全局对象}。因此inside的x具有最高优先权，返回了20（inside的x）而不是10（outside的x）。\n\n## 闭包\nJavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数将的生存周期比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。\n\n```javascript\nvar pet = function(name) {          //外部函数定义了一个变量\"name\"\n  var getName = function() {            \n    //内部函数可以访问 外部函数定义的\"name\"\n    return name; \n  }\n  //返回这个内部函数，从而将其暴露在外部函数作用域\n  return getName;               \n};\nmyPet = pet(\"Vivie\");\n    \nmyPet();                            // 返回结果 \"Vivie\"\n```\n\n## arguments 对象\n函数的实际参数会被保存在一个类似数组的arguments对象中。\n\n```javascript\narguments[i] // 访问\n```\narguments变量只是 ”类数组对象“，并不是一个数组。称其为类数组对象是说它有一个索引编号和length属性。尽管如此，它并不拥有全部的Array对象的操作方法。\n\n## 函数参数(默认参数、剩余参数(rest))\n剩余参数语法允许将不确定数量的参数表示为数组\n\n```javascript\nfunction multiply(a, b = 1,...[1,2,3]) {\n  return a*b;\n}\n```\n\n## 箭头函数\n箭头函数总是匿名的\n引入箭头函数的原因\n\n1. 更简洁的语法\n2. 捕捉闭包上下文的this值\n```javascript\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    this.age++; // |this| properly refers to the person object\n  }, 1000);\n}\n\nvar p = new Person();\n```\n\n## 扩展语句\n适用于对象，数组\n```javascript\nfunction f(x, y, z) { }\nvar args = [0, 1, 2];\nf(...args);\n```\n## 临时对象\n你可以在String字面值上使用String对象的任何方法—JavaScript自动把String字面值转换为一个临时的String对象, 然后调用其相应方法,最后丢弃销毁此临时对象.在String字面值上也可以使用String.length属性.\n\n```javascript\nvar s1 = \"2 + 2\"; // Creates a string literal value\nvar s2 = new String(\"2 + 2\"); // Creates a String object\neval(s1); // Returns the number 4\neval(s2); // Returns the string \"2 + 2\"\nNumber(null) // 0\n```\n\n## 数组方法\n\n### concat() 连接两个数组并返回一个新的数组。\n```javascript\nvar myArray = new Array(\"1\", \"2\", \"3\");\nmyArray = myArray.concat(\"a\", \"b\", \"c\"); \n// myArray is now [\"1\", \"2\", \"3\", \"a\", \"b\", \"c\"]\n```\n\n###  join() 将数组的所有元素连接成一个字符串。\n```javascript\nvar myArray = new Array(\"Wind\", \"Rain\", \"Fire\");\nvar list = myArray.join(\" - \"); // list is \"Wind - Rain - Fire\"\n```\n\n### push() 在数组末尾添加一个或多个元素，并返回数组操作后的长度。\n```javascript\nvar myArray = new Array(\"1\", \"2\");\nmyArray.push(\"3\"); // myArray is now [\"1\", \"2\", \"3\"]\n```\n\n### pop() 从数组移出最后一个元素，并返回该元素。\n```javascript\nvar myArray = new Array(\"1\", \"2\", \"3\");\nvar last = myArray.pop(); \n// myArray is now [\"1\", \"2\"], last = \"3\"\n```\n\n### shift() 从数组移出第一个元素，并返回该元素。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nvar first = myArray.shift(); \n// myArray is now [\"2\", \"3\"], first is \"1\"\n```\n\n### unshift()在数组开头添加一个或多个元素，并返回数组的新长度。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nmyArray.unshift(\"4\", \"5\"); \n// myArray becomes [\"4\", \"5\", \"1\", \"2\", \"3\"]\n```\n\n### slice(开始索引，结束索引) 从数组提取一个片段，并作为一个新数组返回。 \n```javascript\nvar myArray = new Array (\"a\", \"b\", \"c\", \"d\", \"e\");\nmyArray = myArray.slice(1, 4); // until index 3, returning [ \"b\", \"c\", \"d\"]\n```\nslice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。只需将该方法绑定到这个对象上。 一个函数中的 arguments 就是一个类数组对象的例子。\n\n```javascript\nArray.prototype.slice.call({0:1,1:3,length:2});\n```\n\n### splice(index, count_to_remove, addElement1, addElement2, ...)从数组移出一些元素，（可选）并替换它们。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\", \"4\", \"5\");\nmyArray.splice(1, 3, \"a\", \"b\", \"c\", \"d\"); \n// myArray is now [\"1\", \"a\", \"b\", \"c\", \"d\", \"5\"]\n```\n\n### reverse() 颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nmyArray.reverse(); \n// transposes the array so that myArray = [ \"3\", \"2\", \"1\" ]\n```\n\n### sort() 给数组元素排序。\n```javascript\nvar arr=[2,1,3]\narr.sort() // [1,2,3]\n```\nsort() 也可以带一个回调函数来决定怎么比较数组元素。这个回调函数比较两个值，并返回3个值中的一个：\n- 如果 a 小于 b ，返回 -1(或任何负数) 降序\n- 如果 a 大于 b ，返回 1 (或任何正数) 升序\n- 如果 a 和 b 相等，返回 0。\n\n### indexOf(searchElement[, fromIndex]) 在数组中搜索searchElement 并返回第一个匹配的索引。\n```javascript\nvar a = ['a', 'b', 'a', 'b', 'a'];\nconsole.log(a.indexOf('b')); // logs 1\n// Now try again, starting from after the last match\nconsole.log(a.indexOf('b', 2)); // logs 3\nconsole.log(a.indexOf('z')); // logs -1, because 'z' was not found\n```\n\n### lastIndexOf(searchElement[, fromIndex]) 和 indexOf 差不多，但这是从结尾开始，并且是反向搜索。\n\n### forEach() 循环数组 不定的顺序 不能用break,return false跳出循环遍历\n\n遍历都不会修改原来的基本类型（只能返回新数组）引用类型可以。\n\n### map() 循环数组返回新数组\n```javascript\nvar a1 = ['a', 'b', 'c'];\nvar a2 = a1.map(function(item) { return item.toUpperCase(); });\nconsole.log(a2); // logs A,B,C\n```\n\n### find() 找到满足条件的第一个元素\n\n### filter() 循环数组返回符合条件的元素\n```javascript\nvar a1 = ['a', 10, 'b', 20, 'c', 30];\nvar a2 = a1.filter(function(item) { return typeof item == 'number'; });\nconsole.log(a2); // logs 10,20,30\n```\n### every() 循环数组 如果全部元素满足条件则返回true 否则返回false\n\n### some() 循环数组 只要有一项满足条件则返回true 全部不满足返回false\n\n### reduce() 迭代 使用回调函数 callback(firstValue, secondValue) 把数组列表计算成一个单一值 reduceRight() 从右边开始\n```javascript\nvar a = [10, 20, 30];\nvar total = a.reduce(function(first, second) { return first + second; }, 0);\nconsole.log(total) // Prints 60\n\n[3,2,1].reduce(Math.pow) // 9\n[].reduce(Math.pow) // error\n```\n\n### 填充fill/splice\n```javascript\nvar fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\nfruits.fill(\"cosyer\", 2, 4); // 开始和结束索引\nfruits.splice(2,2,'cosyer','cosyer'); // splice方法需要手动添加多个\n// [\"Banana\", \"Orange\", \"cosyer\", \"cosyer\"]\n```\n\n### copyWithin\n```javascript\nvar fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\nfruits.copyWithin(2, 0); // Banana,Orange,Banana,Orange\n// copyWithin(target, start, end);\n```\n\n### entries 一个数组的迭代对象，该对象包含数组的键值对\n```javascript\nvar a = ['a','b','c']\nvar iterator = a.entries()\nconsole.log(iterator) // Array Iterator{}\nconsole.log(iterator.next().value) // [0,'a']\nfor(let a of iterator){\n    console.log(a)\n}\n//[0,'a']\n//[1,'b']\n//[2,'c']\n// keys返回键() values()返回值\n```\n\n## Map简单的键值对集合(字典的数字结构类似对象，键可以是各种类型的值)\n```javascript\nvar sayings = new Map();\nsayings.set('dog', 'woof');\nsayings.set('cat', 'meow');\nsayings.set('elephant', 'toot');\nsayings.size; // 3\nsayings.get('fox'); // undefined\nsayings.has('bird'); // false\nsayings.delete('dog');\nsayings.has('dog'); // false\n\nfor (var [key, value] of sayings) {\n  console.log(key + ' goes ' + value);\n}\n// \"cat goes meow\"\n// \"elephant goes toot\"\n\nsayings.clear();\nsayings.size; // 0\n```\nnew Map() 参数可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。\n```js\nconst set = new Set([\n  ['foo', 1],\n  ['bar', 2]\n]);\nconst m1 = new Map(set);\nm1.get('foo') // 1\n\nconst m2 = new Map([['baz', 3]]);\nconst m3 = new Map(m2);\nm3.get('baz') // 3\n```\n\n### WeakMap（类似Map，只接受对象作为键名（null除外），WeakMap的键名所指向的对象，不计入垃圾回收机制）\n\n**Object和Map的比较**\n\n1. 一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。\n2. Object的键均为Strings类型，在Map里键可以是任意类型。\n3. 必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。\n4. Map的遍历遵循元素的插入顺序。\n5. Object有原型，所以映射中有一些缺省的键。（可以理解为map = Object.create(null)）。\n\n如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。\n如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。\n如果需要对个别元素进行操作，使用Object。\n\n## Set集合(类似数组，成员的值都是唯一且无序的)\n```javascript\nvar mySet = new Set();\nmySet.add(1);\nmySet.add(\"some text\");\nmySet.add(\"foo\");\n\nmySet.has(1); // true\nmySet.delete(\"foo\");\nmySet.size; // 2\nmySet.clear(); // 清空集合\n\nfor (let item of mySet) console.log(item);\n// 1\n// \"some text\"\n\nmySet2 = new Set([1,2,2,4]);\nArray.from(mySet2);  // [1,2,3] 常用来去重\n\n// argument对象（类数组）转成数组\n// Array.from({0:111,1:222,2:333,length:3}) [111,222,333]\n```\n\n### WeakSet（类似Set，成员都是对象，弱引用）\nWeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素。\n\n**Array和Set的比较**\n\n1. 数组中用于判断元素是否存在的indexOf 函数效率低下。\n2. Set对象允许根据值删除元素，而数组中必须使用基于下标的 splice 方法。\n3. 数组的indexOf方法无法找到NaN值。\n4. Set对象存储不重复的值，所以不需要手动处理包含重复值的情况。\n5. 数组是特殊的对象,对象是关联数组 字符串是特殊的数组\n6. 方括弧取值为动态判定[]，数字非有效的js标识符   \n\n## setter和getter (get set修饰function)\n```javascript\nvar o = {\n  a: 7,\n  get b() { \n    return this.a + 1;\n  },\n  set c(x) {\n    this.a = x / 2\n  }\n};\n\nconsole.log(o.a); // 7\nconsole.log(o.b); // 8 取b值时调用\no.c = 50;         // 给c设置值调用\nconsole.log(o.a); // 25\n-----------------------\nvar o = {\n  a: 7,\n  b:function(){ \n    return this.a + 1;\n  }\n};\n\nconsole.log(o.b()); // 8\n```\n\n## 访问所有可枚举对象属性\n1. for in 无序\n2. Object.keys() 不包括原型的属性名数组\n3. Object.getOwnPropertyNames()\n\n## Symbol(原始数据类型) 不可枚举的 符号类型\n- 应用于对象的属性,Symbol类型的属性具有一定的隐藏性。\n```javascript\nvar  myPrivateMethod  = Symbol(); // 不能使用new Symbol()创建，它是一个不完整的类属于基本类型\nthis[myPrivateMethod] = function() {...};\n```\n\nfor in 和 Object.getOwnPropertyNames()访问不到，只能通过myPrivateMethod或者Object.getOwnPropertySymbols()来访问\n\n```javascript\nSymbol(\"foo\") !== Symbol(\"foo\") // true\nconst foo = Symbol()\nconst bar = Symbol()\ntypeof foo === \"symbol\" // true\ntypeof bar === \"symbol\" // true\nlet obj = {}\nobj[foo] = \"foo\"\nobj[bar] = \"bar\"\nJSON.stringify(obj) // {}\nObject.keys(obj) // []\nObject.getOwnPropertyNames(obj) // []\nObject.getOwnPropertySymbols(obj) // [ foo, bar ]\n\nSymbol.for(\"foo\"); // 创建一个 symbol 并放入 symbol 注册表中，键为 \"foo\"\nSymbol.for(\"foo\"); // 从 symbol 注册表中读取键为\"foo\"的 symbol\nSymbol.for(\"bar\") === Symbol.for(\"bar\"); // true，证明了上面说的\n\n// 创建一个 symbol 并放入 Symbol 注册表，key 为 \"foo\"\nvar globalSym = Symbol.for(\"foo\"); \nSymbol.keyFor(globalSym); // \"foo\"\n```\n\n```js\nlet name = Symbol('name');\nlet obj = {\n  age:22,\n  [name]:'Joh'\n};\n\nconsole.log(Object.keys(obj)); // 打印不出 类型为Symbol的[name]属性\n\n// 使用for-in也打印不出 类型为Symbol的[name]属性\nfor(var k in obj) {\n  console.log(k);\n}\n\n// 使用 Object.getOwnPropertyNames 同样打印不出 类型为Symbol的[name]属性\nconsole.log(Object.getOwnPropertyNames(obj)); \n\n// 使用 Object.getOwnPropertySymbols 可以\nvar key = Object.getOwnPropertySymbols(obj)[0];\nconsole.log(obj[key]); // Joh\n```\n- 使用Symbol.iterator迭代器来逐个返回数组的单项\n```js\net arr = ['a', 'b', 'c'];\nvar iterator = arr[Symbol.iterator]();\n// next 方法返回done表示是否完成\nconsole.log(iterator.next()); // {value: \"a\", done: false}\nconsole.log(iterator.next()); // {value: \"b\", done: false}\nconsole.log(iterator.next()); // {value: \"c\", done: false}\nconsole.log(iterator.next()); // {value: undefined, done: true}\nconsole.log(iterator.next()); // {value: undefined, done: true}\n```\n\n## Proxy 代理\n`let p= new Proxy(target,handler)`\n- target\n用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n\n- handler\n一个对象，其属性是当执行一个操作时定义代理的行为的函数。\n\n```javascript\n// 设置缺省值\nlet handler = {\n    get: function(target, name){\n        return name in target ? target[name] : 37;\n    }\n};\n\nlet p = new Proxy({}, handler);\n\np.a = 1;\np.b = undefined;\n\nconsole.log(p.a, p.b);    // 1, undefined\n\nconsole.log('c' in p, p.c);    // false, 37\n\n// 转发代理\nlet target = {};\nlet p = new Proxy(target, {});\n\np.a = 37;   // 操作转发到目标\n\nconsole.log(target.a);    // 37. 操作已经被正确地转发\n\n// demo\nlet book  = {\"name\":\"《ES6基础系列》\",\"price\":56 };\nlet proxy = new Proxy(book,{\n    get:function(target,property){\n        if(property === \"name\"){\n            return \"《入门到懵逼》\";\n        }else{\n            return target[property];\n        }\n    },\n    set:function(target,property,value){\n        if(property === 'price'){\n            target[property] = 56;\n        }\n    }\n})\n```\n\n## 生成器 generator \nfunction* 来修饰GeneratorFunction函数\n\n```javascript\nfunction* idMaker() {\n  var index = 0;\n  while(true)\n    yield index++;\n}\n\nvar gen = idMaker();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n// ...\n```\n\n对象实现迭代行为\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n\nfor (let value of myIterable) { \n    console.log(value); \n}\n// 1\n// 2\n// 3\n\nor\n[...myIterable]; // [1, 2, 3]\n```\n\n## 3行实现Promise\n```javascript\nfunction Promise (fn) {\n    this.then = cb => this.cb = cb\n    this.resolve = data => this.cb(data)\n    fn(this.resolve)\n}\n// 使用\nnew Promise((resolve) => {\n    setTimeout(() => {\n        resolve(\"延时执行\")\n    }, 1000)\n}).then((data) => {\n    console.log(data)\n})\n\nfunction Promise(fn) {\n  var value = null,\n      callbacks = [];  //callbacks为数组，因为可能同时有很多个回调\n\n  this.then = function (onFulfilled) {\n      callbacks.push(onFulfilled);\n  };\n\n  function resolve(value) {\n      callbacks.forEach(function (callback) {\n          callback(value);\n      });\n  }\n\n  fn(resolve);\n}\n```\n- 简单版\n```js\nfunction myPromise(constructor) {\n    let self = this;\n    self.status = \"pending\";\n    // resolved时候的值\n    self.value = undefined;\n    // rejected时候的值\n    self.reason = undefined;\n    // 存放成功回调的数组\n    self.onResolveCallbacks = [];\n    // 存放失败回调的数组\n    self.onRejectedCallbacks = [];\n    function resolve(value) {\n        if(self.status === 'pending') {\n            self.value = value;\n            self.status = \"resolved\";\n            self.onResolveCallbacks.forEach(cb => cb(self.value))\n        }\n    }\n    function reject(reason) {\n        if(self.status === 'pending') {\n            self.reason = reason;\n            self.status = \"rejected\";\n            self.onRejectedCallbacks.forEach(cb => cb(self.value))\n        }\n    }\n    // 捕获构造异常\n    try {\n        constructor(resolve, reject);\n    } catch(e) {\n        reject(e);\n    }\n}\n\nmyPromise.prototype.then = function(onFulfilled, onRejected) {\n  // let self = this;\n  // switch(self.status) {\n  //     case \"resolved\":\n  //         resolved(self.value);\n  //         break;\n  //     case \"rejected\":\n  //         rejected(self.reason);\n  //         break;\n  //     default:\n\n  // 如果成功和失败的回调没有传，表示这个then没有任何逻辑，只负责把值往后抛\n  onFulfilled = typeof onFulfilled == 'function' ? onFulfilled : value => value\n  onRejected = typeof onRejected == 'function' ? onRejected : reason => { throw reason }\n  let self = this;\n  let promise2;\n  // 实现链式调用，每一种状态都要返回的是一个promise实例\n  if(self.status == \"resolved\"){ // 如果promise状态已经是成功态，onFulfilled直接取值\n    return promise2 = new Promise(function(resolve, reject){\n      setTimeout(function(){  // 保证返回的promise是异步\n        try{\n          onFulfilled(self.value)\n        } catch (e){\n          //  如果执行成功的回调过程中出错，用错误原因把promise2 reject\n          reject(e)\n        }\n      })\n    })\n  }\n  if(self.status == \"rejected\"){\n    return promise2 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        try{\n          onRejected(self.reason)\n        } catch (e){\n          reject(e)\n        }\n      })\n    })\n  }\n  if(self.status === \"pending\"){\n    return promise2 = new Promise(function(resolve, reject){\n      // pending 状态时就会把所有的回调函数都添加到实例中的两个堆栈中暂存，等状态改变后依次执行，其实这个过程就是观察者模式\n      self.onResolveCallbacks.push(function(){\n        setTimeout(function(){\n          try{\n            onFulfilled(self.value)\n          } catch(e){\n            reject(e)\n          }\n        })\n      })\n      self.onRejectCallbacks.push(function(){\n        setTimeout(function(){\n          try{\n            onRejected(self.reason)\n          } catch(e){\n            reject(e)\n          }\n        })\n      })\n    })\n  }\n}\n```\n\n## 现一个函数，将一个字符串中的空格替换成“%20”\n```javascript\nfunction convertSpace2percent20(str){\n  return str.replace(/\\s+?/g,\"%20\"); //开启非贪婪模式\n}\n\nconvertSpace2percent20(\"hellow world\")\n// \"hellow%20world\"\n```\n\n## var obj = { 1: \"Hello\", 2: \"World\" }打印Hello World\n```javascript\nvar obj = {\n    1: \"Hello\",\n    2: \"World\"\n};\n\nvar str = '';\n\n// 方法1\nfor (var i = 1; i < 3; i++) {\n\tstr += obj[i] + \" \"; //注意不能使用obj.i\n}\n\n// 方法2\nfor (var key of Object.keys(obj)) {\n\tstr += obj[key] + \" \";\n}\n\n// 方法3\nfor (let i in obj) {\n  str += obj[i] + \" \"; \n}\n\n// 方法4\nObject.values(obj).join(\" \")\n```\n\n## 循环\n- while - 只要指定的条件成立，则循环执行代码块\n- do...while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环\n- for - 循环执行代码块指定的次数\n- foreach - 根据数组中每个元素来循环代码块\n### forEach等函数的第二个参数的用法\nforEach函数用得平时用得比较多，但是从来没想到forEach函数还有第二个参数。\n\n简单点来说，就是我们可以直接使用第二个参数来指定函数里的this的值，而不需要使用箭头函数或者在外面定义var that = this;等操作。\n\n```javascript\nvar obj = {\n    name: \"小明\",\n    say: function() {\n        console.log(this.name); // \"小明\"\n    },\n    think: function() {\n        var arr = [1];\n        arr.forEach(function(item) {\n            console.log(this); // window\n        })\n        console.log('---------')\n        arr.forEach(function(item) {\n            console.log(this); // obj\n        }, this)\n    }\n}\n\nobj.say();\nobj.think();\n\n[3,2,4,1].sort((a,b)=>{\n    return a > b ? 1 : -1; // return a-b\n})\n```\n\n## 数组扁平化(将多维数组展开为一维数组)\n```javascript\n//  es6 递归+判断是不是数组 也可以使用reduce进行遍历\nconst flattenES6 = (arr) => {\n  let result = [];\n  arr.forEach((item, i, arr) => {\n    if (Array.isArray(item)) {\n      result = result.concat(flattenES6(item));\n    } else {\n      result.push(arr[i])\n    }\n  })\n  return result;\n};\nconsole.log(flattenES6([1, [2, [3, [4]], 5]]))\n\n// some+concat\nArray.prototype.flat02 = function () {\n  let arr = this\n  while (arr.some(item => Array.isArray(item))) {\n    arr = [].concat(...arr)\n  }\n  return arr\n}\n\n\n// toString方法\nconst flattenES6 = (arr) => arr.toString().split(',').map((item) => +item);\nconsole.log(flattenES6([1, [2, [3, [4]], 5]]))\n\n// ...\nvar entries = [1, [2, 5], [6, 7], 9];\nvar flat_entries = [].concat(...entries);\n\n// flat方法 返回新数组，不会改变原数组\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4] 默认拉平一层\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5] 拉平两层的嵌套数组\n\n[1, [2, [3]]].flat(Infinity)\n// Infinity无论多少层都拉平\n\n// flatMap()方法对原数组的每个成员执行一个函数，相当于执行Array.prototype.map(),然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat() flatMap()只能展开一层数组\n[2, 3, 4].flatMap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n```\n\n## 自定义错误类型\n```javascript\n// ES6\nclass CustomError extends Error {\n  constructor(message) {\n    super(message)\n    this.name = 'CustomError'\n  }\n}\n\n// ES5\nfunction CustomError(message) {\n  this.name = 'CustomError'\n  this.message = message\n  Error.captureStackTrace(this, CustomError)\n}\n\nCustomError.prototype = new Error()\nCustomError.prototype.constructor = CustomError\n\n// img标签来埋点处理错误日志\nfunction logError(msg) {\n  const img = new Image()\n  img.src = `/log?${encodeURIComponent(msg)}`\n}\n```\n\n## 命令式编程和声明式编程\n- 纯粹性：纯函数不改变除当前作用域以外的值;\n- 数据不可变性: Immutable\n\n```javascript\n// 反面示例\nlet a = 0\nconst add = (b) => a = a + b // 两次 add(1) 结果不一致\n\n// 正确示例\nconst add = (a, b) => a + b\n```\n\n- 函数柯里化 将多个入参的函数转化成1个入参的函数\n```javascript\nconst add = a => b => c => a + b + c\nadd(1)(2)(3)\n```\n问题：sum(2, 3)实现sum(2)(3)的效果\n```js\n// 闭包\nfunction sub_curry(fn) {\n    let args = [].slice.call(arguments, 1);\n    return function() {\n        return fn.apply(this, args.concat([].slice.call(arguments)));\n    };\n}\n\nfunction curry(fn, length) {\n    // 初始化时赋值为fn的形参个数，用以标示剩余需要传入参数的个数\n    length = length || fn.length;\n\n    const slice = Array.prototype.slice;\n\n    return function() {\n        if (arguments.length < length) {\n            const combined = [fn].concat(slice.call(arguments));\n            // length - arguments.length用以计数当前已传入的参数\n            return curry(sub_curry.apply(this, combined), length - arguments.length);\n        } else {\n            return fn.apply(this, arguments);\n        }\n    };\n}\n\nfunction add(a, b) {\n  return a + b\n}\nvar sum = curry(add)\n```\n\n\n- 偏函数 将多个入参的函数转化成两部分(返回一个包含预处理参数的新函数)\n```javascript\nconst add = a => (b, c) => a + b + c\nadd(1)(2, 3)\n```\n\n- 组合函数\n```javascript\nconst add = (x) => x + x\nconst mult = (x) => x * x\n\nconst addAndMult = (x) => add(mult(x))\n```\n\n## 实现bind函数\n```javascript\n// 第一种: 借助 call/apply\nFunction.prototype.bind1 = function (context) {\n  const self = this\n  return function () {\n    return self.call(context)\n  }\n}\n\n// 测试:\nconst obj = {\n  value: 'cosyer',\n}\nfunction testBind() {\n  console.log(this.value)\n}\nconst resultBind = testBind.bind1(obj)\nresultBind() // cosyer\n\n// 第二种: 借助 arguments\nFunction.prototype.bind2 = function (context) {\n  const arr = Array.prototype.slice.call(arguments, 1)\n  const self = this\n  return function () {\n    const restArr = Array.prototype.slice.call(arguments)\n    return self.apply(context, arr.concat(restArr))\n  }\n}\n\n// 考虑到原型链 因为在new 一个bind过生成的新函数的时候，必须的条件是要继承原函数的原型\nFunction.prototype.bind2New = function(context){\n  var arr = Array.prototype.slice.call(arguments, 1);\n  var self = this;\n  var bound = function() {\n    restArr = restArr.concat(Array.prototype.slice.call(arguments));\n    return self.apply(context, restArr);\n  }\n  var F = function(){}\n  // 这里需要一个寄生组合继承\n  F.prototype = context.prototype;\n  bound.prototype = new F();\n  // bound.prototype = Object.create(context.prototype);\n  return bound;\n}\n// 这种方式的实现其实是函数柯里化的变版\n\n// 比如在监听事件时可以这样子用:\n\ndom.addEventListener('click', fn.bind(this))\n// 进行如下测试:\n\nconst obj2 = {\n  value: 'cosyer',\n}\nfunction testBind2(age, gender) {\n  console.log(this.value) // cosyer\n  console.log(age)        // 23\n  console.log(gender)     // male\n}\nconst resultBind2 = testBind2.bind2(obj2, 23)\nresultBind2('male')\n\n// 第三种: 区分环境, 是普通调用还是 new 调用\nFunction.prototype.bind3 = function (context) {\n  const arr = Array.prototype.slice.call(arguments, 1)\n  const self = this\n  return function () {\n    const restArr = Array.prototype.slice.call(arguments)\n    return self.apply(this !== windows ? this : context, arr.concat(restArr))\n  }\n}\n\n// 测试: 使用 new 以后 this 会指向 newObj\nconst obj3 = {\n  value: 'cosyer',\n}\nfunction testBind3(age, gender) {\n  console.log(this.value)\n  console.log(age)\n  console.log(gender)\n}\nconst resultBind3 = testBind3.bind3(obj3, 23, 'male')\nconst newObj = new resultBind3()\n```\n\n## call函数的实现\n```javascript\n// 对象属性指向函数并调用\n// 将函数引用到对象里\n// 调用函数\n// 删除对象里的函数\nFunction.prototype.call1 = function (context, ...args) {\n  let key = Symbol('KEY')\n  // 把函数当成对象的某个成员,(成员名唯一:防止修改原始对象的结构值)\n  context[key] = this;\n  let result = context[key](...args) // ...args\n  delete context[key]\n  return result\n}\n\nconst obj = {\n  value: 'cosyer',\n}\n\nfunction testCall() {\n  console.log(this.value)\n}\n\nconst resultCall = testCall.call1(obj) // cosyer\n\n// 传入函数的实现\nFunction.prototype.call2 = function (context) {\n  const arr = Array.prototype.slice.call(arguments, 1)\n\n  context.fn = this // this 指向实例\n  context.fn(...arr)\n  delete context.fn\n}\n\n// 测试:\nconst obj2 = {\n  value: 'cosyer',\n}\n\nfunction testCall2(age) {\n  console.log(this.value, age) // cosyer 23\n}\n\nconst resultCall = testCall2.call2(obj2, 23)\n```\n\n## 稀疏数组\n```javascript\nvar ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) { return x === undefined;}); // []\n// 3 - 9 都是没有初始化的'坑'!, 这些索引并不存在与数组中. 在 array 的函数调用的// 时候是会跳过这些'坑'的.\n```\n\n## switch严格比较\n```javascript\nfunction showCase(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase(new String('A')); // 'Do not know!'\n// switch 是严格比较, String 实例和 字符串不一样.\n\nfunction showCase2(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase2(String('A')); // 'Case A'\n// String 不仅是个构造函数 直接调用返回一个字符串哦.\n```\n\n## 为什么JS是单线程的\n> 与用途有关，JavaScript的主要用途是与用户互动，以及操作DOM\n> 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n\n为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\n\n## 去重总集篇\n1. Set\n```javascript\n[...new Set([1,1,2,3])]\nArray.from(new Set([1,1,2,3]))\n```\n\n2. filter\n```javascript\n[1,1,2,3].filter((element,index,array)=>{\n  return array.indexOf(element) === index;\n})\n```\n\n3. Map\n```javascript\nvar set =new Set()\n[1,1,2,3].filter((item)=>{\nreturn !set.has(item)&&set.add(item)\n})\n// 一个道理\nvar map =new Map();\n[1,1,2,3].filter((item,index)=>{\nreturn !map.has(item)&&map.set(item,index)\n})\n```\n\n4. 基础\n```js\n// 不使用es6,考虑到（ie6-8）indexOf兼容性问题\n// 对象容器\nfunction unique(arr) {\n  var ret = []\n  var hash = {}\n\n  for (var i = 0; i < arr.length; i++) {\n    var item = arr[i]\n    // typeof 区分 1 与 ‘1’\n    var key = typeof(item) + item\n    if (hash[key] !== 1) {\n      ret.push(item)\n      hash[key] = 1\n    }\n  }\n  return ret\n}\n\n// 数组\nfunction unique(arr) {\n  const temp = []\n  arr.forEach(item => {\n    if (temp.indexOf(item) === -1) {\n      temp.push(item)\n    }\n  })\n  return temp\n}\n```\n\n5. reduce\n```js\nfunction unique(arr) {\n  return arr.reduce((pre, cur) => {\n    !pre.includes(cur) && pre.push(cur)\n    return pre\n  }, [])\n}\n```\n\n## 2对象\n```javascript\n(2).toString() // '2'\n2 .toString() // '2'\n[(1,2,3)] // [3]\n```\n\n## 递归运用斐波那契数列 js 实现\n\n```js\nfunction* fibo()\n{\n    let [pre,curr] = [0,1];\n    for(;;)\n    {\n        yield curr;\n        [pre,curr] = [curr,pre + curr];\n    }\n}\nfor(let i of fibo())\n{\n    if(i > 10000)\n    {\n        break;\n    }\n    console.log(i);\n}\n// 实现10000以内的数列\n```\n爬楼梯问题\n初始在第一级，到第一级有1种方法(s(1) = 1)，到第二级也只有一种方法(s(2) = 1)， 第三级(s(3) = s(1) + s(2))\n```js\nfunction cStairs(n) {\n    if(n === 1 || n === 2) {\n        return 1;\n    } else {\n        return cStairs(n-1) + cStairs(n-2)\n    }\n}\n```\n\n## arguments对象的length属性显示实参的个数，函数的length属性显示形参的个数。\n\n## 在不改变原数组的前提下，添加或删除某个元素\n- concat\n```js\nlet arr = [1, 2, 3, 4]\nlet newArr = [].concat(0, arr)\n```\n\n- 扩展运算符\n```js\nlet arr = [1, 2, 3, 4]\nlet newArr = [0, ...arr]\n```\n\n- reduce\n```js\nlet arr = [1, 2, 3, 4]\n, newArr = arr.reduce((acc, cur) => {\n  acc.push(cur)\n  return acc\n}, [0])\n```\n\n- slice\n```js\nlet arr = [1, 2, 3, 4]\n, newArr = arr.slice(0, -1)\n```\n### 总结·归纳\n- 不修改原数组\n - slice\n - concat\n - forEach\n - map\n - every\n - some\n - filter\n - reduce\n - reduceRight\n - keys\n - values\n - entries\n - includes\n - find\n - findIndex\n - flat\n - flatMap\n\n- 修改原数组\n - splice\n - pop\n - push\n - shift\n - unshift\n - sort\n - reverse\n - fill\n - copyWithin\n\n## polyfill(腻子)\npolyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。\n\n- 常用的方案\n> html5shiv、Geolocation、Placeholder\n","tags":["整理"],"categories":["JS"]},{"title":"redux状态传播","url":"%2Freduxstate.html","content":"\n## Redux三大概念\n> Redux 是JavaScript状态容器，提供可预测化的状态管理\n\n> action 普通的JS对象描述发生什么\n\n> reducer 只是一个接收 state 和 action，并返回新的 state 的函数\n\nStore — 数据存储中心，同时连接着Actions和Views（React Components）。\n\n1. Store需要负责接收Views传来的Action\n2. 然后，根据Action.type和Action.payload对Store里的数据进行修改\n3. 最后，Store还需要通知Views，数据有改变，Views便去获取最新的Store数据，通过setState进行重新渲染组件（re-render）。\n\n### 三大原则\n\n1. 单一数据源\n\n整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。和根级的reducer,拆成多个reducer而不是多个store。\n\n2. State 是只读的\n\n唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。\n\n3. 使用纯函数来执行修改\n\n为了描述 action 如何改变 state tree ，你需要编写 reducers。传递数据 payload规范。\n\n当 state 变化时需要返回全新的对象，而不是修改传入的参数。\n\n--- \n<!-- more -->\n\n### api\n~~~javascript\n// API 是 { subscribe, dispatch, getState }。\nlet store = createStore(counter);\n\n// 可以手动订阅更新，也可以事件绑定到视图层。\nstore.subscribe(() =>\n  console.log(store.getState())\n);\n\n// 改变内部 state 唯一方法是 dispatch 一个 action。\n// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行\nstore.dispatch({ type: 'INCREMENT' });\n// 1\nstore.dispatch({ type: 'INCREMENT' });\n// 2\nstore.dispatch({ type: 'DECREMENT' });\n// 1\n~~~ \n\n不要再reducer里做以下操作保持纯净\n\n> 修改传入参数；\n\n> 执行有副作用的操作，如 API 请求和路由跳转；\n\n> 调用非纯函数，如 Date.now() 或 Math.random()。\n\n通过reducer修改数据带来的好处\n1. 数据拆解 => 通过定义多个reducerr对数据进行拆解访问或者修改，最终再通过combineReducers函数将零散的数据拼装回去。\n\n```javascript\nimport { combineReducers } from 'redux';\n\n// 叶子reducer\nfunction aReducer(state = 1, action) {/*...*/}\nfunction cReducer(state = true, action) {/*...*/}\nfunction eReducer(state = [2, 3], action) {/*...*/}\n\nconst dReducer = combineReducers({\n  e: eReducer\n});\n\nconst bReducer = combineReducers({\n  c: cReducer,\n  d: dReducer\n});\n\n// 根reducer\nconst rootReducer = combineReducers({\n  a: aReducer,\n  b: bReducer\n});\n```\n2. 数据不可变\n组件的生命周期函数shouldComponentUpdate进行判断是否有必要进行对该组件进行更新（即，是否执行该组件render方法以及进行diff计算）\n\n#### 维持应用的 state\n\n> 提供 getState() 方法获取 state；\n\n> 提供 dispatch(action) 方法更新 state；发送通知；\n\n> 通过 subscribe(listener) 注册监听器;\n\n> 通过 unsubscribe() 返回的函数注销监听器。\n\n纯函数是这样一种函数，即相同的输入，永远会得到相同的输出。\nstore.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。\n\n中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。\n\n```javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport createLogger from 'redux-logger';\nimport rootReducer from '../reducers';\n\n// store扩展\nconst enhancer = applyMiddleware(\n  thunk,\n  createLogger()\n);\n\nconst store = createStore(rootReducer, initialState, enhancer);\n```\n\n## react-redux\nRedux 本身和React没有关系，只是数据处理中心，是React-Redux让它们联系在一起。\n\nReact-Redux提供两个方法：connect和Provider。\n\n### connect\nconnect连接React组件和Redux store。connect实际上是一个高阶函数，返回一个新的已与 Redux store 连接的组件类。\n\n```javascript\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n```\n\nTodoList是 UI 组件，VisibleTodoList就是由 react-redux 通过connect方法自动生成的容器组件。\n\nmapStateToProps：从Redux状态树中提取需要的部分作为props传递给当前的组件。\nmapDispatchToProps：将需要绑定的响应事件（action）作为props传递到组件上。\n\n### Provide(将 store 通过 context 传入组件中)\nProvider实现store的全局访问，将store传给每个组件。\n原理：使用React的context，context可以实现跨组件之间的传递。\n\n### reducer的拆分和重构\n随着项目越大，如果将所有状态的 reducer 全部写在一个函数中，将会 难以维护；可以将 reducer 进行拆分，也就是 函数分解，最终再使用`combineReducers()`进行重构合并；\n\n### 异步Action\n由于 Reducer 是一个严格的纯函数，因此无法在 Reducer 中进行数据的请求，需要先获取数据，再dispatch(Action)即可，下面是三种不同的异步实现:\n- [redex-thunk](https://github.com/reduxjs/redux-thunk)\n- [redux-saga](https://github.com/redux-saga/redux-saga)\n- [redux-observable](https://github.com/redux-observable/redux-observable)\n\n## 使用 复杂性 数据交互 结构复杂繁琐 大型\n- \"如果你不知道是否需要 Redux，那就是不需要它。\"\n- \"只有遇到 React 实在解决不了的问题，你才需要 Redux。\"\n","tags":["redux"],"categories":["JS"]},{"title":"响应式网页设计","url":"%2Fresponsive.html","content":"\n## 什么是响应式网站\n\n响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。Web设计应该做到根据不同设备环境自动响应及调整。当然响应式Web设计不仅仅是关于屏幕分辨率自适应以及自动缩放的图片等等，它更像是一种对于设计的全新思维模式；我们应当向下兼容、移动优先。\n\n--- \n<!--more -->\n\n## 背景\n\n1. PC互联网加速向移动端迁移\n2. 移动端入口\n3. 开发成本低，门槛低\n4. 跨平台和终端且不需要分配子域，1页面适配多终端\n\n- PC – http://qzone.com\n- Mobile – http://m.qzone.com\n- 响应式：PC & Mobile – http://qzone.com 无需跳转\n5. 无需安装成本，迭代更新容易\n\n![setup](http://cdn.mydearest.cn/blog/images/setup.png)\n\n如我们需要兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏(portrait)、横屏(landscape)，怎样才能做到让一种设计方案满足所有情况？\n那么我们的布局应该是一种弹性的栅格布局，不同尺寸下弹性适应，如以下页面中各模块在不同尺寸下的位置：\n\n![responsive-layout](http://cdn.mydearest.cn/blog/images/responsive-layout.png)\n\n那么我们要怎么做？\n- Meta标签定义\n\n1. 使用 viewport meta 标签在手机浏览器上控制布局\n```html\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1\" />\n```\n\n2. 通过快捷方式打开时全屏显示\n```html\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n```\n\n3. 隐藏状态栏\n```html\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"blank\" />\n```\n\n4. iPhone会将看起来像电话号码的数字添加电话连接，应当关闭\n```html\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n## 优点\n\n- 面对不同分辨率设备灵活性强\n- 能够快捷解决多设备显示适应问题\n\n## 缺点\n\n- 兼容各种设备工作量大，效率低下\n- 代码累赘，会出现隐藏无用的元素，加载时间加长\n- 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果\n- 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况\n\n## 栗子🌰\n\n```css\n/* Extra small devices (phones, 600px and down) */\n@media only screen and (max-width: 600px) {\n    .example {background: red;}\n}\n\n/* Small devices (portrait tablets and large phones, 600px and up) */\n@media only screen and (min-width: 600px) {\n    .example {background: green;}\n}\n\n/* Medium devices (landscape tablets, 768px and up) */\n@media only screen and (min-width: 768px) {\n    .example {background: blue;}\n} \n\n/* Large devices (laptops/desktops, 992px and up) */\n@media only screen and (min-width: 992px) {\n    .example {background: orange;}\n} \n\n/* Extra large devices (large laptops and desktops, 1200px and up) */\n@media only screen and (min-width: 1200px) {\n    .example {background: pink;}\n}\n```\n\n## 实战\n\n谷歌教程用HTML5以及CSS3的媒体查询完成了一个响应式布局的demo，大家可以用不同的尺寸的设备，查看不同分辨率下的表现。也可以在控制台模拟各种设备，欢迎大家提出意见。\n\n在线地址：[http://dir.mydearest.cn/responsive/](http://dir.mydearest.cn/responsive/)\n","tags":["前端"],"categories":["CSS"]},{"title":"有趣的摧毁页面","url":"%2Fdestory.html","content":"\n食用方法\n\n使用【上下左右键】来控制飞行器的运动\n\n使用【空格键】来发射导弹\n\n<a href=\"javascript:var%20KICKASSVERSION='2.0'; var%20s%20=%20document.createElement('script'); s.type='text/javascript'; document.body.appendChild(s); s.src='//hi.kickassapp.com/kickass.js'; void(0);\"> 点击开始摧毁 </a>\n\n---\n<!--more -->\n\n引入JS代码\n\n```javascript\n<a href=\"javascript:var%20KICKASSVERSION='2.0'; \nvar%20s%20=%20document.createElement('script'); \ns.type='text/javascript'; document.body.appendChild(s); \ns.src='//hi.kickassapp.com/kickass.js'; void(0);\"> 点击开始摧毁 </a>\n```\n页面崩溃\n- plan A\n```javascript\nvar total = \"\"; \nfor (var i = 0; i < 10000; i++) { \n    total = total + i.toString(); \n    history.pushState(0, 0, total); \n}\n\nwhile(true){\n  console.log('hello world');\n}\n\nfunction fn(){\n  fn();\n}\nfn();\n```\n- plan B (BitInt 出现后，不用死循环也能实现 CPU 100% 的效果)\n```js\n9n ** 9n ** 9n > 0\n```\n\n转动吧，风扇！！！\n\n## localstorage撑爆电脑硬盘\nhtml5的本地存储，相信大家都不陌生。将数据以二进制文件形式存储到本地，在当前应用得非常广泛。\nwindows下的chrome，localStorage存储于C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Local Storage文件夹中。但如果任由网页无限写文件，对用户硬盘的伤害可想而知，因而浏览器对其做了大小限制。\n\n对于一个域名+端口，PC端的上限是5M-10M之间，移动端是则不大于2.5M。\n\n详情请见[作为一个前端，可以如何机智地弄坏一台电脑？](http://litten.me/2015/07/06/hack-in-localstorage/)","tags":["优化"],"categories":["JS"]},{"title":"console控制台优化","url":"%2Fconsole.html","content":"\n谷歌开发者中心上面关于谷歌浏览器控制台console.log()的文档：\n\n|格式说明符|描述|\n|:---|---:|\n|%s|将值格式化为字符串。|\n|%d?or?%i|将值格式化为整数。|\n|%f|将值格式化为浮点值。|\n|%o|将值格式化为可扩展的DOM元素（如在元素面板中）。|\n|%O|将值格式化为可扩展的JavaScript对象。|\n|%c|根据您提供的CSS样式格式化输出字符串。|\n\n\\n是换行，可以将一个字符串设置成多行\n%c标记之后的内容使用对应样式，格式如 console.log(‘%c第一个样式%c第二个样式’,’css1′,’css2′); 如此对应\n样式和普通的css效果基本一致，可以设置文字颜色，背景颜色，字体大小，间距，边距等等。还支持部分css3高级效果。\n\n---\n<!-- more -->\n\n## 3D字体效果 Text\n\n```javascript\n<script>console.log(\"%c3D Text\",\" text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em\")</script>\n```\n\n## Colorful彩色背景 CSS\n\n```javascript\n<script>console.log(\"%cColorful CSS\",\"background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em\")</script>\n```\n\n## Rainbow彩虹字 Text\n\n```javascript\n<script>console.log('%cRainbow Text ', 'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;');</script>\n```\n\n## 在Chrome控制台输出图片\n```javascript\n<script>console.log(\"%c\", \"padding:50px 700px;line-height:120px;background:url('http://wx1.sinaimg.cn/large/ba098b64ly1fjz4j8pju5j20p002sgm4.jpg') no-repeat;\");</script>\n```\n\n## 示例\n```javascript\n<script>\nconsole.log(\"%c%c源码作者%ccosyer chenyu@mydearest.cn\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\nconsole.log(\"%c%c网站地址%chttps://mydearest.cn\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\nconsole.log(\"%c%cgithub%https://github.com/cosyer\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\n</script>\n```\n\n- 未曾遗忘的青春\n```js\nfunction setConsole() {\nvar text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'this is console!';\nvar isOneLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\nvar author = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '未曾遗忘的青春';\n\nif (isOneLine) {\n    console.log('');\n    console.log('%c' + text + '  ---  ' + author, 'background-image: url(\\'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4gPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkIiBncmFkaWVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeDE9IjAuMCIgeTE9IjAuNSIgeDI9IjEuMCIgeTI9IjAuNSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzY2Y2NjYyIvPjxzdG9wIG9mZnNldD0iMjAlIiBzdG9wLWNvbG9yPSIjMzM5OTk5Ii8+PHN0b3Agb2Zmc2V0PSI0MCUiIHN0b3AtY29sb3I9IiNjY2NjOTkiLz48c3RvcCBvZmZzZXQ9IjYwJSIgc3RvcC1jb2xvcj0iIzk5Y2NmZiIvPjxzdG9wIG9mZnNldD0iODAlIiBzdG9wLWNvbG9yPSIjY2NjY2ZmIi8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjZmY5OWNjIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNncmFkKSIgLz48L3N2Zz4g\\');background-size: 100%;background-image: -webkit-gradient(linear, 0% 50%, 100% 50%, color-stop(0%, #66cccc), color-stop(20%, #339999), color-stop(40%, #cccc99), color-stop(60%, #99ccff), color-stop(80%, #ccccff), color-stop(100%, #ff99cc));background-image: -moz-linear-gradient(left, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);background-image: -webkit-linear-gradient(left, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);background-image: linear-gradient(to right, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);padding:20px 40px;color:#fff;font-size:12px;');\n    console.log('');\n} else {\n    console.log('%c' + text + '  ---  ' + author, 'background-image: url(\\'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4gPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkIiBncmFkaWVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeDE9IjAuMCIgeTE9IjAuNSIgeDI9IjEuMCIgeTI9IjAuNSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzY2Y2NjYyIvPjxzdG9wIG9mZnNldD0iMjAlIiBzdG9wLWNvbG9yPSIjMzM5OTk5Ii8+PHN0b3Agb2Zmc2V0PSI0MCUiIHN0b3AtY29sb3I9IiNjY2NjOTkiLz48c3RvcCBvZmZzZXQ9IjYwJSIgc3RvcC1jb2xvcj0iIzk5Y2NmZiIvPjxzdG9wIG9mZnNldD0iODAlIiBzdG9wLWNvbG9yPSIjY2NjY2ZmIi8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjZmY5OWNjIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNncmFkKSIgLz48L3N2Zz4g\\');background-size: 100%;background-image: -webkit-gradient(linear, 0% 50%, 100% 50%, color-stop(0%, #66cccc), color-stop(20%, #339999), color-stop(40%, #cccc99), color-stop(60%, #99ccff), color-stop(80%, #ccccff), color-stop(100%, #ff99cc));background-image: -moz-linear-gradient(left, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);background-image: -webkit-linear-gradient(left, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);background-image: linear-gradient(to right, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);padding:0;color:#fff;font-size:12px;');\n }\n}\n```\n\n- FBI WARNING (暂只支持 Chrome)\n```js\nconsole.log(`%c                                                                            \n                                                                            \n                                                                            \n                               %c FBI WARNING %c                                \n                                                                            \n                                                                            \n%c        Federal Law provides severe civil and criminal penalties for        \n        the unauthorized reproduction,distribution, or exhibition of        \n         copyrighted motion pictures (Title 17, United States Code,         \n        Sections 501 and 508). The Federal Bureau of Investigation          \n         investigates allegations of criminal copyright infringement        \n                 (Title 17, United States Code, Section 506).               \n                                                                            \n                                                                            \n                                                                            \n`,\n'background: #000; font-size: 18px; font-family: monospace',\n'background: #f33; font-size: 18px; font-family: monospace; color: #eee; text-shadow:0 0 1px #fff',\n'background: #000; font-size: 18px; font-family: monospace',\n'background: #000; font-size: 18px; font-family: monospace; color: #ddd; text-shadow:0 0 2px #fff'\n)\n```\n[FBI](http://cdn.mydearest.cn/blog/images/FBI.png)\n\n### 设计相关\n\n- https://icomoon.io/\n\n- https://zh-cn.cooltext.com/\n\n- https://www.logaster.cn/logo/#logos\n\n- http://www.logoko.com.cn/design\n\n- http://www.beipy.com/335.html","tags":["优化"],"categories":["JS"]},{"title":"JavaScript停止冒泡和阻止浏览器默认行为","url":"%2Fbubble.html","content":"\n## 防止冒泡\n\nw3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true\n\nstopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。\n\n---\n<!-- more -->\n\n## 阻止默认行为\n\nw3c的方法是e.preventDefault()，IE则是使用e.returnValue = false\n\npreventDefault它是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是说默认行为，当然是元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用当然就无效了。什么元素有默认行为呢？如链接`<a>`，提交按钮`<input type=”submit”>`等。当Event 对象的 cancelable为false时，表示没有默认行为，这时即使有默认行为，调用preventDefault也是不会起作用的。\n\n```javascript\n <!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n</head>\n<body>\n<div id=\"box\" style=\"width: 300px;height: 300px;background: pink;\">\n\t<input type=\"button\" name=\"按钮\" value=\"按钮\" id=\"btn\">\n</div>\n<script type=\"text/javascript\">\n\tvar box1=document.getElementById(\"box\");\n\tvar btn1=document.getElementById(\"btn\");\n\tbtn1.onclick=function(e){\n\t\talert(\"按钮\");\n\t\t//阻止冒泡；\n\t\tvar e=e|| window.event;\n\t\t//w3c取消冒泡\n\t\te.stopPropagation();\n\t\t//ie取消冒泡\n\t\t//判断他现在的状态，然后给他赋值true，\n\t\tif(typeof e.cancelBubble=='undefined'){\n\t\t\te.stopPropagation();\n\t\t}else{\n\t\t\te.cancelBubble=true;\n\t\t}\n\t}\n\tbox1.onclick=function(){\n\t\talert(\"div\");\n\t}\n\tdocument.body.onclick=function(){\n\t\talert(\"body\");\n\t}\n\tdocument.documentElement.onclick=function(){\n\t\talert(\"html\");\n\t}\n\tdocument.onclick=function(){\n\t\talert(\"document\");\n\t}\n</script>\n</body>\n</html>\n```","tags":["前端"],"categories":["JS"]},{"title":"微信小程序面试题","url":"%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98.html","content":"\n\n## 简单描述下微信小程序的相关文件类型？\n答：微信小程序项目结构主要有四个文件类型,如下：\n一、WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。\n二、WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，\n二、js 逻辑处理，网络请求\n三、json 小程序设置，如页面注册，页面标题及tabBar。\n四、app.json\n必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。\n五、app.js\n必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。\n六、app.wxss\n\n---\n<!-- more -->\n\n## 你是怎么封装微信小程序的数据请求的？\n答：\n一、将所有的接口放在统一的js文件中并导出\n二、在app.js中创建封装请求数据的方法\n三、在子页面中调用封装的方法请求数据\n\n## 有哪些参数传值的方法？\n答：\n一、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或onload的param参数获取。但data-名称不能有大写字母和不可以存放对象\n二、设置id的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值\n三、在navigator中添加参数传值 onload中options参数中取值\n\n## 你使用过哪些方法，来提高微信小程序的应用速度？\n答：\n一、提高页面加载速度\n二、用户行为预测\n三、减少默认data的大小\n四、组件化方案\n\n## 小程序与原生App哪个好？ \n答： 小程序除了拥有公众号的低开发成本、低获客成本低以及无需下载等优势，在服务请求延时与用户使用体验是都得到了较大幅度  的提升，使得其能够承载跟复杂的服务功能以及使用户获得更好的用户体验。\n\n## 简述微信小程序原理？ \n答：微信小程序采用JavaScript、WXML、WXSS三种技术进行开发，从技术讲和现有的前端开发差不多，但深入挖掘的话却又有所不同。\n\nJavaScript：首先JavaScript的代码是运行在微信App中的，并不是运行在浏览器中，因此一些H5技术的应用，需要微信App提供对应的API支持，而这限制住了H5技术的应用，且其不能称为严格的H5，可以称其为伪H5，同理，微信提供的独有的某些API，H5也不支持或支持的不是特别好。\n\nWXML：WXML微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。\n\nWXSS：WXSS具有CSS的大部分特性，但并不是所有的都支持，而且支持哪些，不支持哪些并没有详细的文档。\n\n微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。\n\n小程序分为两个部分webview和appService。其中webview主要用来展现UI，appService有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理\n\n## 分析下微信小程序的优劣势？\n答：\n### 优势：\n1、无需下载，通过搜索和扫一扫就可以打开。\n2、良好的用户体验：打开速度快。\n3、开发成本要比App要低。\n4、安卓上可以添加到桌面，与原生App差不多。\n5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的。\n\n### 劣势：\n1、限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。\n2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。\n3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。\n4、依托于微信，无法开发后台管理功能。\n8、微信小程序与H5的区别？\n答：\n第一条是运行环境的不同\n传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。\n第二条是开发成本的不同\n只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG\n第三条是获取系统级权限的不同\n系统级权限都可以和微信小程序无缝衔接\n第四条便是应用在生产环境的运行流畅度\n长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立\n\n## 怎么解决小程序的异步请求问题？\n答：\n在回调函数中调用下一个组件的函数：\napp.js\n\nsuccess: function (info) {         \n  that.apirtnCallback(info)\n}\n\nindex.js\n\nonLoad: function () {\n  app.apirtnCallback = res => {\n    console.log(res) \n  }\n｝\n\n## 小程序的双向绑定和vue哪里不一样？\n答：\n小程序直接this.data的属性是不可以同步到视图的，必须调用：\n\nthis.setData({\n  noBind:true\n})\n\n## 常用\n\n### 表单提交\n```js\n<form bindsubmit=\"formSubmit\">\n  <input value=\"{{address.name}}\" name=\"name\" placeholder=\"姓名\"/>\n  <input type=\"number\" name=\"phone\" value=\"{{address.phone}}\" placeholder=\"电话号码\"/>\n  <input name=\"detail\" value=\"{{address.detail}}\" placeholder=\"详细地址\"/>\n  <button form-type=\"submit\">保存</button>\n</form>\n // formData=e.detail.value value.name...\n // 诸如bindinput \n```\n\n### wx:for\n```js\n<view wx:for=\"{{answerArr}}\" wx:key=\"index\" data-id=\"{{item.id}}\" bindtap='userSelect'>\n    {{item.value}}\n</view>\n```\n\n### image组件\n默认宽高：300px/225px\n- 本地引用\n- 网络资源引用\n不支持background:url()形式\n\n## 生命周期\n### onLauch 启动\n### onLoad(Object query)\n页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。\n### onShow()\n页面显示/切入前台时触发。\n### onReady()\n页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。调用接口\n### onHide()\n页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。\n### onUnload()\n页面卸载时触发。如redirectTo或navigateBack到其他页面时。\n\n## 注意点\n1. import 的路径不支持绝对路径，比如你希望引用 utils/fetch.js，在不管多深的组件里面你都要慢慢 ../ 点到根目录，同样 .wxss 文件 @import 导入文\n件时也只能使用相对路径，所以就会出现 ../../../../../../utils/fetch.js 这种东西\n\n2. setData 连一个对象合并都懒得做，如果 data: {a: {b: 1, c: 1}}，那么 setData({a: {b: 2}}) 就会丢失 a.c 的值，真是让人火冒三丈啊，还要 \nsetData({['a.b': 2]}) 这样才行；通常使用`wx-updata` this.updata\n\n3. 微信请求promise化\n```js\nimport { promisifyAll } from 'wx-promise-pro'\n\npromisifyAll()  // promisify all wx api\n\nApp({ ... })\n```\n\n4. 自己实现promisify\n```js\nfunction promisify(api) {\n    return (opt = {}) => {\n        return new Promise((resolve, reject) => {\n            api({\n                ...opt,\n                fail: reject,\n                success: resolve\n            })\n        })\n    }\n}\n```\n","tags":["小程序"],"categories":["知识"]},{"title":"侠之大者，为国接盘","url":"%2Fhouseprice.html","content":"\n{% centerquote %} \n炒房兴邦，实业误国\n{% endcenterquote %}\n\n---\n<!-- more -->\n\n近年来，房价成为了生活中重要的谈资和话题，几乎所有的聊天场合都会聊到房子，什么谁谁谁有几套房，不用工作每月靠房租过活。坐公交车上都是听到一些阿姨手里几套房，在手里在捂一会，转手卖给有刚需的年轻人，后悔没多买几套之类的话。\n\n房价的上涨，刚需不敢不买，等下去看不到希望，掏空了一家父母的过去和年轻人的未来，面对zf的货币超发引起的通货膨胀，却又无可奈何。房价再涨个3、4倍，分分钟GDP超过美国啊。现在基本的理财方式已经赶不上通货膨胀的速度了，眼看着手里的钱越来越不值钱，人人自危，都只能通过购房来保值。被zf逼的哪怕背上几十年的贷款也要坐上这趟车，给zf当几十年的免费劳动力来消化这巨大的泡沫。\n\n这个浮躁社会的高房价，让我们这些刚毕业工作几年的年轻人，要我们的青春和汗水给你们买单。现在的年轻人，怎么可能刚毕业就能积攒到买房的首付，被逼的去‘啃老’，掏空全家人的钱包，成为房奴。2017年前yz的房价大概7000/m2，恒大在年初当了一波地王2w/m2买了邗江中专那边的地后，各个楼盘开始疯长，在年底11月份购入1w/m2后，如今短短半年已经涨到了1.3w/m2。试想以100m2为例如果不早点买，就得平白无故多交20w的韭菜钱。房价降是不可能降的，这个牵扯到太多人和行业的利益，一旦崩盘了，其他行业也会受到影响，经济陷入低迷，zf不断地增发货币来救市。一线城市政府来主导市场看上去房价跌了，这也只是杯水车薪，高额的房价不断地在驱逐这所谓的低端人口，也是啊，毕竟要实现小康社会啊，让先富带动后富，实现共同小康，还是直接消灭低端人口容易些。房价的压力让现在的中国人充满着戾气、浮躁。上了车的人在嘲讽着没上车的人，一旦买了房，两者就成了对立面，高房价改变了人们的价值观。如今人们对于成功的标准定义有几辆车，几套房。现在各个城市推行的所谓吸引人才政策，不就是为了让人来接盘去库存么。\n\n房价带来了价值观的革命，中下层把买房当成了人生目标，中产把买房当成了支付手段，政府把卖地当作经济支柱，将企业债务转化成了居民债务。房价捆绑了经济、政治、户籍、教育、爱情、事业甚至社会地位，集万千宠爱于一身。随着房价越来越高，社会阶层出现固化趋势，多少年轻人的梦想倍房价无情碾压，多少家庭为了买房背上沉重的债务，多少爱情因为房价变得支离破碎，还有的夫妻为了多买套房选择离婚。而在房价面前我们崇尚的个人奋斗，不值一文。年轻人开始选择佛系，不再憧憬爱情，坚持和努力并没有什么卵用，开始相信投机的价值。金钱至上主义横行，勤劳致富成为了笑话，炒房的人成为了羡慕对象，所谓的梦想是多么的幼稚可笑。这个xx的时代，只要你买不起房救市没出息的男人。毕竟男生在婚姻当中是向下兼容，而女生是向上兼容的。现在的知乎上现在的男生为什么不追求女生、为什么现在的女孩子活得都很潇洒，男孩子确郁郁寡欢这类的问题比比皆是。毕竟女性才是消费的主力，那些商家们为了自己的利益，各种推出什么女神节等等之类的活动和营销号无底线地讨好女性发软文毒鸡汤，恶心至极。什么公主、女王、仙女，拜拜了您！大家又不是笨蛋，看透了资本主义生产方式，不想再沦为奴隶了，工作只会使自己越来越贫穷。劳动法就是个笑话，各种被所谓的企业文化所绑架，压榨干你的劳动力。员工和公司的关系很简单，你付给我钱，我帮你工作罢了，我们并不是一家人。永远不要试探人性的底线，没有完美的人。抱歉，中国特色社会主义的大饼我吃不下了。\n\n从古至今，中国还是没有发生什么大的变化，权利还是掌握在少部分人手里，层层剥削的金字塔结构，什么人民当家作主，到头来还不是被代表了。所谓的法律还不是为了维护阶级统治的利益。我国是领导人选举能全票通过的国家，神奇不神奇呵呵。一个个大腹便便的领导们，嘴上说着服务人民，背地里作者贪污腐败的行当。这年头都希望考公务员，公务员是什么，为人民服务。一个个都争着抢着去当人民的公仆，还不是为了铁饭碗、利益。在小城市里，都是靠关系，所谓的人情社会。有些人只是想听到他们想听到的话罢了，成年人的价值观一旦成型一般是很难改变的。国家开放二胎政策还不是为了拉动内需，劳动力不足，老龄化严重。现在地区间发展不平衡，中国就只有这北上广深等一线城市罢了，很多人背井离乡去这些大城市打工，这些人是去赚钱而不是来消费的，当地的zf是很讨厌的。春运很值得骄傲吗，你以为人人都愿意远离自己的家乡，在陌生的城市中打拼吗？这些繁华都与自己无关。很久之前被教导不乱扔垃圾，可现实是如果大家都不乱扔垃圾了，那些环卫工人们是真的会失业的，资本家会让人白白领一份工资么？答案当然是不会的，他们宁可把过剩的商品都愿意倒掉销毁，也不愿意救济贫民，扰乱消费市场。中国有着最大的局域网，保护本国的互联网产品的利益，没什么创新，都是对标国外的产品。除了抄袭还是抄袭，科研没有实际的成果都只是为了骗取国家的补贴。\n\n这年头的幼儿教育也是问题不断。应试教育也就算了，再怎么培养也是考试型人才。为了不让自己的孩子输在起跑线，给孩子报了大大小小的培训班。中国大多数父母都不希望自己的孩子是个“普通学生”，而是希望孩子能像别人家的孩子一样能考进名牌大学（被国家归为 211 或者 985 的大学），但事实上每年能挤过高考独木桥考取 211/985 的孩子有多少呢？ 全国平均下来大约是 7% 。对 93% 的学生和家长来说，十几年来他们承受着巨大的压力，最后却几乎可以说在“读书”上是失败的。我们的学校除了教学生读书还教他们什么呢？\n\n不论社会如何变化动荡，大家只想守护好自己的小小幸福罢了。\n\n","tags":["房价"],"categories":["杂谈"]},{"title":"JS执行顺序-函数声明提升、匿名函数、函数表达式","url":"%2FexecutionOrder.html","content":"\n{% centerquote %} \n JS 是按照`代码块`进行 编译、执行 的。\n{% endcenterquote %}\n\n---\n<!-- more -->\n## script标签区分代码块\n```javascript\n<script>\n  alert('代码块一');\n</script>\n<script>\n  alert('代码块二');\n</script>\n```\n\n## 关于函数(声明式函数、赋值型（函数表达式）函数、匿名函数、自执行函数)\n### 函数提升\n`声明函数与赋值函数的区别在于： 在 JS 的预编译期间，声明式函数会被先提取出来，然后才按照顺序执行 JS代码。`\n\n```javascript\nA();  // 'A '\nfunction A() {\n  console.log('A');\n}\n\nB(); // error， B is not a function\nvar B = function() {\n  console.log('B');\n}\n```\n\n### 匿名函数（没有名字的函数）\n```javascript\nfunction() {} // 匿名函数\n```\n\n### 自执行函数\n```javascript\n(function() {\n  console.log(3);\n})();\n\n// 带参数\n(function(num){\n  console.log(num);\n})(3); // 3\n\n// 没有括号会报错 如下\nfunction() {\n  console.log(3);\n}();\n```\n原因如下：\n- function {}()其实这是一个函数声明。\n- JS运行的时候，会对函数声明进行预编译，然后在执行其他语句。\n- 也就是说function(){}先被预编译了。然后JS看见了()。JS一脸懵逼，这不得报错吗。\n- 而匿名函数实际上是一个语句，正常执行。\n\n自执行函数的标识也可以是\n```javascript\n!function(){}()      (function(){})()    \n~function(){}()      void function(){}()\n```\n\n## 预编译期和执行期\n{% note info %}\nJS的解析分为两个阶段：预编译 和 执行期。\n{% endnote %}\n- 预编译期间：对本代码块中的所有声明变量和函数进行处理(类似于C语言的编译) ，但需要注意，1.此时处理函数的只是 声明式函数2.变量也只是进行了声明但是没有进行初始化和赋值\n- 编译期间：从上到下编译代码块。\n\n### 函数声明提前且后来居上覆盖\n```javascript\ngetName(); // 6\nfunction getName() { alert (5);}\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\n\n---\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\ngetName(); // 4 函数声明都被提升了，表达式会覆盖掉\n```\n\n### 练习题\n```javascript\nfunction Foo() {\n    // 全局变量\n    getName = function () { alert (1); };\n    return this;\n}\nFoo.getName = function () { alert (2);};\nFoo.prototype.getName = function () { alert (3);};\nvar getName = function () { alert (4);};\nfunction getName() { alert (5);} // 函数提升 JavaScript永远不会有函数重载\n \n//请写出以下输出结果：\nFoo.getName(); // 2\ngetName();  // 4\nFoo().getName(); // 1 覆盖了函数表达式\ngetName(); // 1\nnew Foo.getName(); // 2 new (Foo.getName)()\nnew Foo().getName(); // 3 (new Foo()).getName();\n```\n\n## ES6之前，JS没有变量作用域。只有 函数作用域 和 全局作用域。\n```javascript\n{\n  var a = 3;\n}\nconsole.log(a); // 3\n---\n{\n  let a = 3;\n}\nconsole.log(a); // error\n```","tags":["知识"],"categories":["JS"]},{"title":"JavaScript深入之执行上下文","url":"%2Fcontext.html","content":"\n**执行上下文(EC)就是当前JavaScript代码被解析和执行是所在环境的抽象概念，JavaScript中运行任何的代码都是在执行上下文中运行。**\n\n## 变量/函数提升(函数及变量的声明都将被提升到函数的最顶部，且函数声明在变量声明上边)\n\n```javascript\nif(!(\"a\" in window)){ // false\n    var a=1;\n}\nconsole.log(a) // undefined\n// if(o.x){} // 不能判断属性存不存在 假值undefine,null,false,\" \",0或NaN\n```\n\n```javascript\nfunction foo() {\n    console.log('foo1');\n}\n\nfoo();  // foo2\n\nfunction foo() {\n    console.log('foo2');\n}\n\nfoo(); // foo2\n---\nvar getName = function () { alert (4);};\nfunction getName() { alert (5);}\ngetName(); // 4\n---\nfunction getName() { alert (5);}\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\ngetName(); // 4\n```\n函数表达式执行的优先级==!主要原因是函数声明都被提前了，所以函数表达式在最后会覆盖。\n\nJavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。插槽slot\n可执行代码的类型：全局代码、函数代码、eval代码。\nJavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文\n\n--- \n<!-- more -->\n\n- 作用域：作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。\n\n- 作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。\n\n## 分为三个部分\n- 变量对象(VO)\n- 作用域链\n- this 指向\n\n### 变量对象\n变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有变量和函数声明(不包含函数表达式)。\n> 活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。\n\n### 作用域链(访问到父级甚至全局的变量)\n执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 `变量和声明的作用范围`。可分为 全局作用域、块级作用域 \n和 函数作用域\n\n- 声明提前: 一个声明在函数体内都是可见的, 函数优先于变量\n- 非匿名自执行函数，函数变量为 只读 状态，无法修改\n```js\nlet foo = function() { console.log(1) };\n(function foo() {\n    foo = 10  // 由于foo在函数中只为可读，因此赋值无效\n    console.log(foo)\n}())\n```\n\n## 执行上下文的类型，主要有三类：\n\n- 全局执行上下文：这是默认的，最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。共有两个过程：1.创建有全局对象，在浏览器中这个全局对象就是window对象。2.将this指针指向这个全局对象。一个程序中只能存在一个执行上下文。\n\n- 函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在多个函数执行上下文，这些函数执行上下文按照特定的顺序执行一系列步骤。\n\n- eval执行上下文\n\n## 调用栈\n调用栈，具有LIFO（Last in, First out 后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。\n\n为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：\n\n```javascript\nECStack = [];\n```\n\n试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：\n\n```javascript\nECStack = [\n    globalContext\n];\n```\n\n现在 JavaScript 遇到下面的这段代码了：\n\n```javascript\nfunction fun3() {\n    console.log('fun3')\n}\n\nfunction fun2() {\n    fun3();\n}\n\nfunction fun1() {\n    fun2();\n}\n\nfun1();\n```\n\n当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：\n\n```javascript\n// 伪代码\n\n// fun1()\nECStack.push(<fun1\\> functionContext);\n\n// fun1中竟然调用了fun2，还要创建fun2的执行上下文\nECStack.push(<fun2\\> functionContext);\n\n// 擦，fun2还调用了fun3！\nECStack.push(<fun3\\> functionContext);\n\n// fun3执行完毕\nECStack.pop();\n\n// fun2执行完毕\nECStack.pop();\n\n// fun1执行完毕\nECStack.pop();\n\n// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext\n```\n\n```js\nfunction a() {\n    var value = 'local scope'\n    function b() {\n        console.log(value)\n    }\n    return b()\n}\na()\nfunction a() {\n    var value = 'local scope'\n    function b() {\n        console.log(value)\n    }\n    return b\n}\na()()\n```\n分析如下👁：\n```js\n// a()执行的时候，创建执行上下文入栈\nECsatck.push(<fun\\> a)\n// 函数a遇到b可执行函数，执行b函数创建可执行上下文入栈\nECstack.push(<fun\\> b)\n// 后进先出原则b执行完出栈\nECstack.pop()\n// a执行完出栈\nECstack.pop()\n\n第二段代码\n\n// a()执行的时候，创建执行上下文入栈\nECsatck.push(<fun\\> a)\n// a执行完后返回了b函数，注意这里没有直接执行而是直接返回了b,所有没有创建b函数的上下文，a执行完直接出栈\nECstack.pop() //a出栈\n// 在外部返回的b函数被执行， 创建b的执行上下文，压入栈，\nECstack.push(<fun\\> b)\n// b执行完出栈\nECstack.pop()\n```\n\n## 调用栈执行的顺序\n- 创建全局上下文(global EC)\n\n- 每个函数的创建，函数执行上下文，外部环境的引用及 this，会push到执行栈顶层\n\n- 函数调用时，函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起\n\n- 函数执行结束后会从堆栈中弹出pop，并且它的执行上下文被垃圾收集回收(闭包除外)。控制权交还全局上下文 (caller)，继续执行\n\n- 当调用堆栈为空时，它将从事件队列中获取事件\n\n当浏览器加载某些JS代码时，JS引擎会逐行读取并执行以下步骤：\n- 将变量和函数的声明放入全局内存(堆)中\n- 将函数的调用放入调用堆栈\n- 创建全局执行上下文，在其中执行全局函数\n- 创建多个本地执行上下文(如果有内部变量或嵌套函数)\n\n每个异步函数在被放入调用堆栈之前必须通过回调队列，但这个工作是谁做的呢，那就是事件循环(Event Loop)。\n\n事件循环只有一个任务:它检查调用堆栈是否为空。如果回调队列中(Callback Queue)有某个函数，并且调用堆栈是空闲的，那么就将其放入调用堆栈中。\n\n## 全局对象\n{% note info %}\n\n全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。\n\n{% endnote %}\n\n{% note info %}\n\n例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。\n\n{% endnote %}\n\n```javascript\n// 在浏览器客户端 全局对象就是window对象\n// 通过this引用\nthis === window  // true\nthis.window === window // true\nthis instanceof Object // true 是通过Object构造函数实例出来的对象\nMath.random() \nthis.Math.random() // 预定义了一些函数和属性\n\n// window指向自身\nvar a=1;\na // 1\nthis.a // 1\nwindow.a // 1 \nthis.window.a // 1\n```\n\n## 函数声明>变量声明\n\n```javascript\nconsole.log(foo); // 打印函数\n\nfunction foo(){\n    console.log(\"foo\");\n}\n\nvar foo = 1;\n```\n执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。\n","tags":["前端"],"categories":["JS"]},{"title":"JavaScript深入之作用域","url":"%2Fscope.html","content":"\n## 作用域\n\n作用域是我们可以有效访问变量或函数的区域，包含全局作用域、函数作用域、块级作用域（ES6） 三种；\n\nJavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。它的作用域是指在词法分析阶段就确定了，不会改变。而与词法作用域相对的是动态作用域，\n\n函数的作用域是在函数调用的时候才决定的。\n\n**函数的作用域在函数定义的时候就决定了，函数的作用域基于函数创建的位置。**\n\n---\n<!-- more -->\n\n```javascript\nvar value=1\nfunction print(){\n  console.log(value)\n}\nfunction foo(){\n  var value=2\n  print()\n}\nfoo() // value 1 如果是动态作用域则是2\n```\n静态作用域是产生闭包的关键，即它在代码写好之后就被静态决定它的作用域了。\n\n- 动态域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时，到函数调用的环境去查询\n在 JS 中，关于 this 的执行是基于动态域查询的，下面这段代码打印出 1，如果按静态作用域的话应该会打印出 2\n```js\nvar foo = 1;\n\nvar obj = {\n  foo: 2,\n  bar: function() {\n    console.log(this.foo);\n  }\n};\n\nvar bar = obj.bar;\nbar();\n```\n\n我们再来看两道题：\n\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n```\n\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n```\n两道题的执行结果都是 \"local scope\"\n\nJavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。\n\n```javascript\nvar name=\"999999\"\nvar b = {\nname :\"The Window\",\nobject:{\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n                return this.name\n              }\n　　　　}\n　　}\n}\nconsole.log(b.object.getNameFunc()()) // 999999\n---\nvar name=\"999999\"\nvar b = function(){\nvar name = \"The Window\";\n　　var object = {\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n \n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　console.log(object.getNameFunc()())\n}\nb() // 999999\n```\n\n## 作用域链\n作用域链：作用域也是一组用于查找变量的规则。如果变量在当前作用域中不存在，它将向外部作用域中查找并搜索，如果该变量不存在，它将再次查找直到到达全局作用\n域，如果找到，则可以使用它，否则引发错误，这种查找过程也称为作用域链。\n","tags":["作用域"],"categories":["JS"]},{"title":"JavaScript深入之从原型到原型链","url":"%2Fprototype.html","content":"\n{% centerquote %} \n原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已，仅有一份。\n{% endcenterquote %}\n\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，\n如果这个对象内部不存在这个属性，那么它就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念\n\n- “prototype” 是什么？\nprototype 是所有公共方法和属性的宿主，从祖先派生的“子”对象可以从使用祖先的方法和属性。\n\n原型是一个用于实现对象属性继承的对象。\n\n## 构造函数创建对象\n\n我们先使用构造函数创建一个对象：\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nperson.name = \"cosyer\";\nconsole.log(person.name); // cosyer\n```\n\n在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。\n\n---\n\n<!-- more -->\n\n很简单吧，接下来进入正题：\n\n### prototype\n\n每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：\n\n```javascript\nfunction Person() {}\n// prototype是函数才会有的属性\nPerson.prototype.name = \"cosyer\";\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name); // cosyer\nconsole.log(person2.name); // cosyer\n```\n\n那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？\n\n其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。\n\n那什么是原型呢？你可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\n\n让我们用一张图表示构造函数和实例原型之间的关系：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype1.png)\n\n在这张图中我们用 Object.prototype 表示实例原型。\n\n那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：\n\n### **proto**\n\n为了证明这一点,我们可以在火狐或者谷歌中输入：\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n于是我们更新下关系图：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype2.png)\n\n既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？\n\n> __proto__标准是浏览器实现的。\n\n### constructor\n\n指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。\n\n为了验证这一点，我们可以尝试：\n\n```javascript\nfunction Person() {}\nconsole.log(Person === Person.prototype.constructor); // true\n```\n\n所以再更新下关系图：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype3.png)\n综上我们可以得出：\n\n```javascript\nfunction Person() {}\n\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype); // true\nconsole.log(Person.prototype.constructor == Person); // true\n// 顺便学习一个ES5的方法,可以获得对象的原型 实例原型的constructor指向构造函数,构造函数的prototype指向实例原型,实例对象的__proto__指向实例原型,实例原型也是对象,它也有原型 最后的一个环节是null。访问实例对象的constructor时,也能从实例原型上去找,从而指向到构造函数。是一个用来实现继承和共享属性的有限的对象链。\nconsole.log(Object.getPrototypeOf(person) === Person.prototype); // true\n```\n\n## 实例与原型\n\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n举个例子：\n\n```javascript\nfunction Person() {}\n\nPerson.prototype.name = \"cosyer\";\n\nvar person = new Person();\n\nperson.name = \"Daisy\";\nconsole.log(person.name); // Daisy\n\ndelete person.name;\nconsole.log(person.name); // cosyer\n```\n\n在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。\n\n但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.\\_\\_proto\\_\\_ ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 cosyer。\n\n但是万一还没有找到呢？原型的原型又是什么呢？\n\n## 原型的原型\n\n在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```javascript\nvar obj = new Object();\nobj.name = \"cosyer\";\nconsole.log(obj.name); // cosyer\n```\n\n其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 **proto** 指向构造函数的 prototype ，所以我们再更新下关系图：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype4.png)\n\n## 原型链\n\n那 Object.prototype 的原型呢？\n\nnull，我们可以打印：\n\n```javascript\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n然而 null 究竟代表了什么呢？\n\n引用阮一峰老师的 《undefined 与 null 的区别》 就是：\n\nnull 表示“没有对象”，即该处不应该有值。\n\n所以 Object.prototype.**proto** 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n\n最后一张关系图也可以更新为：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype5.png)\n\n图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。\n\n## 补充\n\n### constructor\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nconsole.log(person.constructor === Person); // true\n```\n\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\n\n```javascript\nperson.constructor === Person.prototype.constructor;\n```\n\n### **proto**\n\n其次是 **proto** ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.**proto** 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n\n### 继承\n\n最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n\n- class 的引入只是语法糖本身还是基于原型的\n- 几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。\n\n```javascript\nclass Cat {\n    say() {\n        console.log(\"meow ~\");\n    }\n}\n\n// 等价于\nfunction Cat() {}\nObject.defineProperty(Cat.prototype, \"say\", {\n    value: function() { console.log(\"meow ~\"); },\n    enumerable: false,\n    configurable: true,\n    writable: true\n});\n\n// es6 class是没有静态属性的 只有静态方法\nvar cat = new Cat();\ncat.say(); // meow~\nCat.say(); // error 加上static修饰正确  \n\n// 注解\nfunction isAnimal(target) {\n    target.isAnimal = true;\n  \treturn target;\n}\n@isAnimal\nclass Cat {\n    ...\n}\n// 等价于\nCat=isAnimal(function Cat(){})\n\nconsole.log(Cat.isAnimal);    // true\n```\n\n### 描述符\n- Configurable 特性\nconfigurable 特性表示对象的属性是否可以被删除，以及除 writable 特性外的其他特性是否可以被修改。\n\n- Enumerable 特性\n属性特性 enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。\n\n- Writable 属性\n当属性特性（property attribute） writable 设置为false时，表示 non-writable，属性不能被修改。\n\n\n```javascript\nvar p = Object.create(o);\n// p是一个继承自 o 的对象\n对象的原型链\no===>Object.prototype===>null\n数组的原型链\na===>Array.prototype===>Object.prototype===>null\n函数的原型链\nf===>Function.prototype===>Object.prototype===>null\n\nFunction.__proto__==Object.prototype // false\nFunction.__proto__==Function.prototype // true Function的原型也是Function\n\nvar Tom = Object.create(Person, {\n  age: {\n    value: 34,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  },\n  name: {\n    value: \"Tom\",\n    enumerable: true,\n    writable: true,\n    configurable: true\n  }\n});\n// 以这种方式配置的属性默认情况下不可写，不可枚举，不可配置。 不可写意味着之后无法更改该属性，更改会被忽略。\n```\n\n### 原型对象的添加属性\n```javascript\nfunction Persion(){}\nPersion.prototype.sayName=function(){\n  console.log('darling')\n}\n// Persion.prototype={\n//   sayName:function(){\n//     console.log('darling')\n//   } \n// }\nlet persion =new Persion()\npersion.sayName() // darling\n\nfunction Persion(){}\nlet persion=new Persion()\n// 这里重写了原型对象，实例对象和最初的原型对象断开了联系\n// persion的proto指向一个空对象\nPersion.prototype={\n  sayName:function(){\n    console.log('darling')\n  } \n}\npersion.sayName() // error\n```\n\n### new 操作符具体干了什么\n1. 创建空对象，并且this变量引用该对象同时继承该函数的原型\n2. 属性和方法加入到this引用的对象中\n3. 新创建的对象用this引用，并且隐式地返回this\n\n1. 创建一个新对象(\\_\\_proto\\_\\_ 指向构造函数的prototype)\n2. 把作用域（this）指给这个对象\n3. 执行构造函数的代码\n4. 如果构造函数中没有返回其它对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象\n\n```javascript\nfunction Base(){\n  this.id = \"base\";\n}\nvar obj = new Base();\n```\n\n**new干了什么？** \n\n1. var obj = {};\n\n2. obj.\\_\\_proto\\_\\_ = Base.protptype;\n\n3. Base.call(obj);\n\n- es5使用Object.create()来创建对象 new Object() 字面量写法{}\n使用Object.create()是将对象继承到__proto__属性上，\nObject.create(null)没有继承任何原型方法，也就是说它的原型链没有上一层。\n- es6使用class关键字\n\n- 构造器就是普通的函数,new来作用称为构造方法(构造函数)\n\n- 访问原型链会损耗性能,不存在的属性会遍历原型链直到最后一层\n\n- hasOwnProperty 是 JavaScript 中唯一处理属性并且不会遍历原型链的方法。通常在for in循环中使用。\n\n### 实现 new 函数\n```js\nfunction _new(func) {\n    // 第一步 创建新对象\n    let obj= {}; \n    // 第二步 空对象的_proto_指向了构造函数的prototype成员对象\n    obj.__proto__ = func.prototype;//\n    // 一二步合并就相当于 let obj=Object.create(func.prototype)\n\n    // 第三步 使用apply调用构造器函数，属性和方法被添加到 this 引用的对象中\n    let result = func.apply(obj);\n    if (result && (typeof (result) == \"object\" || typeof (result) == \"function\")) {\n    // 如果构造函数执行的结果返回的是一个对象，那么返回这个对象\n        return result;\n    }\n    // 如果构造函数返回的不是一个对象，返回创建的新对象\n    return obj;\n}\n```\n","tags":["原型链"],"categories":["JS"]},{"title":"你所不知道的前端冷门小知识(长期更新)","url":"%2Fsmallknowledge.html","content":"\n[javascript-puzzlers](http://javascript-puzzlers.herokuapp.com/)\n\n## void \nvoid其实是javascript中的一个函数，接受一个参数，返回值永远是undefined\nvoid expression\n\n```javascript\nvoid 0  \nvoid() // 报错\nvoid (0)  \nvoid \"hello\"  \nvoid (new Date())  \n// all will return undefined  \ncontext === void 666\n```\n\n---\n<!-- more -->\n\n## Element.scrollIntoViewIfNeeded\nElement.scrollIntoViewIfNeeded()方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。\n ```javascript\nelement.scrollIntoView(); // 等同于element.scrollIntoViewIfNeeded(true) \nelement.scrollIntoViewIfNeeded(true); \nelement.scrollIntoViewIfNeeded(false);\n ```\n- 当元素已经在可视区域时，调用 Element.scrollIntoView()，无论设置什么参数，均发生滚动。\n- 当元素已经在可视区域时，调用 Element.scrollIntoViewIfNeeded()，无论设置什么参数，均不发生滚动。\n\n## JS取整数部分\n\n```javascript\n~~2.5 // 2 按位取反 -2^31~2^31-1 -2147483648~2147483647\n2147483647 >> 0; // => 2147483647\n2147483648 >> 0; // => -2147483648\n2147483649 >> 0; // => -2147483647\n\n0|3.123;// 3 或运算\n4.3|0; // 4\n4.3<<0; // 4\n```\n\n与Math.floor()的对比\n\n|区别|Math.floor|~~|\n|:---|:---:|---:|\n|NaN|NaN|0|\n|+0|+0|0|\n|-0|-0|0|\n|+Infinity|+Infinity|0|\n|-Infinity|-Infinity|0|\n|1.2|1.2|1.2|\n|-1.2|-1|-1|\n\n```javascript\n1. 位运算：~ 的结果是 int32 的有符号整数，所以肯定不可能是 NaN 和无穷 x|0 x^0 x<<0 x>>0\n\n2. Math.floor向下取整 Math.ceil向上取整 Math.trunc返回整数部分 实现：if(value>0){return Math.floor(value)}else{return Mathg.ceil(value)}\n\n3. parseInt(string, radix);\n\nparseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。\n\nparseInt 解析字符串 '-0' 会得到 -0。如果参数是数字 -0，会得到 0。\n\n4. function trunc(num) {\n  if(num >= 0) return Math.floor(num);\n  return Math.ceil(num);\n}\n\n5. function trunc(num) {\n  return num - num % 1;\n}\n```\n\n> 在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：\n> 如果字符串 string 以\"0x\"或者\"0X\"开头, 则基数是16 (16进制).\n> 如果字符串 string 以\"0\"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个\n> 基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个\n> 规定。因此，永远都要明确给出radix参数的值。\n> 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。\n\n```javascript\nparseInt(0.0000000003) // 3\n\nparseInt('2017-07-04') // 2017\n\nparseInt(\"010\");\t// 8\nparseInt(\"010\", 8);\t// 8\nparseInt(\"010\", 10); // 10\n```\n\n- parseFloat(string)\n它的规则与parseInt基本相同，但也有点区别：字符串中第一个小数点符号是有效的，另外parseFloat会忽略所有前导0，如果字符串包含一个可解析为整数的数，则返回整数值而不是浮点数值。\n```js\nparseInt(\"0xA\") // 10\nparseFloat(\"0xA\") // 0\n\nparseInt(\".1\") // NaN\nparseFloat(\".1\") // 0.1\n\n```\n\n## js取小数部分\n```js\nfunction fract(num) {\n  return num - Math.trunc(num);\n}\n\nconsole.log(fract(3.75)); // 0.75\nconsole.log(fract(-3.75)); // -0.75\n\nconsole.log(3.75 % 1); // 0.75\nconsole.log(-3.75 % 1); // -0.75\n```\n\n## JS浮点数运算(原因浮点数无法用二进制准确表示)\n\n```javascript\n0.1+0.2 // 0.30000000000000004\n1. parseFloat().toFixed() \n2. *100/100 \n```\n\n## Object.toString()\n```javascript\nvar a = {name:'cosyer'}\na.toString() // [object Object] [typeof a instanceof a]\n// 除了Object其他对象需要用call返回真正的类型信息\n```\n## 全等判断\njavascript 中 +0 完全等于 -0，那么怎么分区两者呢？\n\n```javascript\n1/0 === 1/-0 // false \n+0 === -0 // true\nObject.is(+0,-0) // false\n```\n区分NaN\n\n```javascript\nNaN !== NaN // true\nNaN === NaN // false \nObject.is(NaN,NaN) // true\n```\n\n## 判断NaN\n```js\nNumber.isNaN(); // true 与isNaN全局函数相比，不存在类型转换更加严格\nNumber.isNaN('测试') // false\nisNaN('测试') // true\nx!==x // =>NaN false\n// {}!=={} []!==[]\n```\n\n## isFinite\n判定一个数字是否是有限数字(如果参数是 NaN，正无穷大或者负无穷大，会返回false，其他返回 true)\n```js\nisFinite(Infinity);  // false\nisFinite(NaN);       // false\nisFinite(-Infinity); // false\nisFinite(0);         // true\nisFinite(2e64);      // true, 在更强壮的Number.isFinite(null)中将会得到false\nisFinite(\"0\");       // true, 在更强壮的Number.isFinite('0')中将会得到false\n```\n\n## try-catch跳出forEach循环\nforEach遍历不能保证遍历的顺序，以及不能break;一般for循环的性能是forEach的20倍\n\n```javascript \ntry {\n    [1, 2, 3].forEach(v => {\n        if (v === 2) {\n            throw new Error('my err')\n        }\n    })\n} catch (e) {\n    if (e.message === 'my err') {\n        console.log('breaked') \n    } else {\n        throw e\n    }\n}\n\n// 用some也可以在遍历中跳出循环\n[1,2,3].some((item)=>{\n\tconsole.log(item)\n  return item === 2 // 如果item等于2就跳出循环\n})\n```\n\n## fetch模拟post进行api测试\n```javascript\nfetch(apiUrl, {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({q: 1})\n}).then(async res => console.log(await res.json()))\n```\n\n## 实现var a = add(2)(3)(4) 函数柯里化\njs中console.log一个对象时，会对这个对象进行toString()操作，还有些情况会对对象进行valueOf()操作\nvauleOf优先于toString()被调用\n\n```javascript\nfunction add(num){\n    var _add = function(args){\n        num+=args;\n        return arguments.callee; //  return add(num+args);\n        // 现在已经不推荐使用arguments.callee();推荐这样写var _add = (function foo(args){num+=args return foo;}) callee被调用者、callee调用者\n        // 原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。\n    }\n    _add.toString = _add.valueOf = function(){\n        return num;\n    }\n    return _add;\n}\nadd(2)(3)(4);// function 9\n+add(2)(3)(4) // 9\nadd(2)(3)(4)+'' // '9'\n```\n\n## 阶乘\n```javascript\nfunction factorial(num){    \n   if (num <=1) {         \n      return 1;     \n   } else {         \n   return num * factorial(num-1)     \n   } \n} \n// 定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。 \n// 但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee\n// arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，返回正被执行的 Function 对象，\n// 也就是所指定的 Function 对象的正文，这有利于匿名函数的递归或者保证函数的封装性。 \n\nfunction factorial(num){    \n   if (num <=1) {         \n      return 1;     \n   } else {         \n   return num * arguments.callee(num-1);\n   } \n}\n\nvar trueFactorial = factorial;\nfactorial = function() {\n    return 0;\n}                \nalert(trueFactorial(5));// 120 如果没有使用arguments.callee，将返回0\n```\n\n## arguments.callee的替换方案\n```javascript\nfunction show(n) {\n    var arr = [];\n    return (function () {\n        arr.unshift(n);\n        n--;\n        if (n != 0) {\n            arguments.callee();\n        }\n        return arr;\n    })()\n}\nshow(5)//[1,2,3,4,5]\n\n// 给内部函数一个名字（当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用。）\nfunction show(n) {\n    var arr = [];\n    return (function fn() {\n        arr.unshift(n);\n        n--;\n        if (n != 0) {\n            fn();\n        }\n        return arr;\n\n    })()\n}\nshow(5)//[1,2,3,4,5]\n```\n\n## Date相关 \n\n### Date构造函数\n```javascript\n4种表示时间戳的方式\n1. Date.now()\n2. new Date().getTime()\n3. +new Date() / +new Date +相当于.valueOf();\n4. new Date().valueOf()\n5. new Date*1 / new Date()*1 \n\n解释：JavaScript中可以在某个元素前使用'+'号，这个操作是将该元素转换秤Number类型，如果转换失败，那么将得到 NaN。\n所以 +new Date 将会调用 Date.prototype 上的 valueOf 方法，而根据MDN，Date.prototype.value 方法等同于 Date.prototype.getTime()\n\nDate.parse(\"2018-06-13\") === new Date(\"2018-06-13\").getTime()\n// 浏览器之间解析时间不同 safari 解析横杠 - 会出错所以尽量用斜杠 /\n```\n### 当前时间\n```javascript\nlet d = new Date()\nlet year=d.getFullYear();\nlet month=d.getMonth()+1; // 月份索引从0开始\nlet day=d.getDate(); // getDay()用于获取星期\nlet hour=d.getHours();\nlet minute=d.getMinutes();\nlet second=d.getSeconds();\nconsole.log(`${year}-${month}-${day} ${hour}:${minute}:${second}`) // 2018-6-13 21:20:48\n// 不足2位数补0\nconsole.log([year, month, day].map((item)=>{\n        item = item.toString();\n    return item[1] ? item : \"0\" + item;\n}).join(\"-\") +\" \" +[hour, minute, second].map((item)=>{\n        item = item.toString();\n    return item[1] ? item : \"0\" + item;\n}).join(\":\"))  // 2018-06-13 21:20:48\n```\n### Date计时\n以博客存活时间为例\n\n```javascript\nvar time = new Date(); \nvar t = \"博客存活了\"+Math.floor((+new Date - 1527868800000) / (1000 * 60 * 60 * 24)) + \"天\" + time.getHours() + \"小时\" \n+ time.getMinutes() + \"分\" + time.getSeconds() + \"秒\"; \n// 博客存活了11天 21小时28分51秒 1527868800000当时的时间转的时间戳 new Date(1527868800000).toLocaleString() \"2018/6/2 上午12:00:00\"\n```\n\n### Date原型扩展方法\n```javascript\nDate.prototype.format = function (format) {\n\t\t\tvar o = {\n\t\t\t\t\t\"M+\": this.getMonth() + 1,\n\t\t\t\t\t\"d+\": this.getDate(),\n\t\t\t\t\t\"h+\": this.getHours(),\n\t\t\t\t\t\"m+\": this.getMinutes(),\n\t\t\t\t\t\"s+\": this.getSeconds(),\n\t\t\t\t\t\"q+\": Math.floor((this.getMonth() + 3) / 3),\n\t\t\t\t\t\"S\": this.getMilliseconds()\n\t\t\t};\n\t\t\tif (/(y+)/.test(format)) {\n\t\t\t\t\tformat = format.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n\t\t\t}\n\t\t\tfor (var k in o) {\n\t\t\t\t\tif (new RegExp(\"(\" + k + \")\").test(format)) {\n\t\t\t\t\t\t\tformat = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn format;\n\t};\n\n\tDate.prototype.addDays = function (d) {\n\t\t\tthis.setDate(this.getDate() + d);\n\t};\n\n\tDate.prototype.addWeeks = function (w) {\n\t\t\tthis.addDays(w * 7);\n\t};\n\n\tDate.prototype.addMonths = function (m) {\n\t\t\tvar d = this.getDate();\n\t\t\tthis.setMonth(this.getMonth() + m);\n\t\t\t//if (this.getDate() < d)\n\t\t\t//  this.setDate(0);\n\t};\n```\n\n## 页面加载时间\n```javascript\nwindow.onload = function () {\n  var loadTime = window.performance.timing.domContentLoadedEventEnd-window.performance.timing.navigationStart; \n  console.log('Page load time is '+ loadTime);\n}\n// DOMContentLoad是HTML文档被加载和解析完成后触发\n```\nonload和onready的区别：\n\n1. 执行时间\n\n　　window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 \n\n　　$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。\n\n2. 编写个数不同\n\n　　window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。\n\n　　$(document).ready()可以同时编写多个，并且都可以得到执行。\n\n3. 简化写法\n\n　　window.onload没有简化写法。\n\n　　$(document).ready(function(){})可以简写成$(function(){});\n\n## 常用标签\n```javascript\n<meta charset=\"utf-8\">\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\">\n<link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" />\n// seo\n<title></title>\n<meta name=\"author\" name=\"cosyer\">\n<meta name=\"keywords\" name=\"cosyer\">\n<meta name=\"description\" name=\"cosyer\">\n<link rel=\"stylesheet\" href=\"\">\n<script src=\"\"></script>\n```\n\n## 获取url参数\n```javascript\nlet reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\")\nlet r = window.location.search.substr(1).match(reg)\nif (r != null) return decodeURIComponent(r[2]) // encodeURIComponent()\nreturn null\n```\n\n## String原型方法扩展\n```javascript\n// 连字符转驼峰\nString.prototype.hyphenToHump = function () {\n\t\treturn this.replace(/-(\\w)/g, function () {\n\t\t\t\treturn arguments[1].toUpperCase()\n\t\t})\n}\n\n// 连字符转驼峰 简单版本\n// 假设分隔符有_和-两种\nfunction camel(str) {\n  let cut = ['_', '-'];\n  let ar = str.split('');\n  let l = ar.length;\n  let flag = false;\n  for(let i = 0;i < l;i++) {\n    let cur = ar[i];\n    if(cut.indexOf(cur) !== -1) {\n      ar[i] = '';\n      flag = true;\n    } else if(flag) {\n      ar[i] = ar[i].toUpperCase();\n      flag = false;\n    }\n  }\n  return ar.join('');\n}\n\n// 驼峰转连字符\nString.prototype.humpToHyphen = function () {\n\t\treturn this.replace(/([A-Z])/g, \"-$1\").toLowerCase()\n}\n```\n\n## 拦截控制台、右键和F12\n```javascript\ndocument.onkeydown = function () {\n        var e = window.event || arguments[0];\n        //屏蔽F12\n        if (e.keyCode == 123) {\n                return false;\n                //屏蔽Ctrl+Shift+I\n        } else if ((e.ctrlKey) && (e.shiftKey) && (e.keyCode == 73)) {\n                return false;\n                //屏蔽Shift+F10\n        } else if ((e.shiftKey) && (e.keyCode == 121)) {\n                return false;\n        }\n};\n//屏蔽右键单击\ndocument.oncontextmenu = function () {\n        return false;\n};\n```\n\n## 崩溃欺骗\n```javascript\nvar OriginTitle = document.title;\nvar titleTime;\ndocument.addEventListener('visibilitychange', function () {\n    if (document.hidden) {\n        $('[rel=\"icon\"]').attr('href', \"/img/TEP.ico\");\n        document.title = '╭(°A°`)╮ 页面崩溃啦 ~';\n        clearTimeout(titleTime);\n    }\n    else {\n        $('[rel=\"icon\"]').attr('href', \"/favicon.ico\");\n        document.title = '(ฅ>ω<*ฅ) 噫又好了~' + OriginTitle;\n        titleTime = setTimeout(function () {\n            document.title = OriginTitle;\n        }, 2000);\n    }\n});\n```\n\n## a标签\n```javascript\n    // 邮件\n\t<a href={'mailto:'+props.email}></a>\n\t// 下载只有 Firefox 和 Chrome 支持 download 属性。\n\t<a href=\"/images/myw3schoolimage.jpg\" download=\"w3logo\"></a>\n    // QQ\n\t<a href=\"tencent://message/?uin=535509852&Site=-&Menu=yes\" target=\"_blank\">QQ:535509852</a>\n```\n\n##  `<script>`元素放在 HTML 文件底部\n\n我们将 `<script>`元素放在 HTML 文件底部的原因是，浏览器按照代码在文件中的顺序解析 HTML。如果 JavaScript在最前面被加载，HTML还未加载，JavaScript将无法作用于HTML，所以JavaScript无效，如果 JavaScript 代码出现问题则 HTML 不会被加载。所以将 JavaScript 代码放在底部是最好的选择。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。\n\n## 某个字符在字符串中的个数\n```javascript\nlet str=\"11112234241\"\nconsole.log(str.split(\"1\").length-1)\n```\n\n## 数组求最大值方法汇总\n```javascript\n1. es6拓展运算符...\nMath.max(...arr)\n2. es5 apply(与方法1原理相同)\nMath.max.apply(null,arr)\n3. for循环\nlet max = arr[0];\nfor (let i = 0; i < arr.length - 1; i++) {\n    max = max < arr[i+1] ? arr[i+1] : max\n}\n4. 数组sort\narr.sort((a,b)=>{\n\treturn b-a // 降序\n})\n5. 数组reduce\narr.reduce((a,b)=>{\n\treturn a>b?a:b\n})\n```\n\n```javascript\nfunction foo(p1,p2) {\nthis.val = p1 + p2;\n}\nvar bar = foo.bind( null, \"p1\" );\nvar baz = new bar( \"p2\" );\nbaz.val; // p1p2\n```\n\n## 回到顶部\n```javascript\nfunction goback() {\n// 1.回到顶部\n// scrollTo(0, 0); // 滚动条滚动 x y \n// 2.渐渐回到顶部 距离顶部高度\n//var iScrollTop = document.body.scrollTop; //360,Chrome,\n//var iScrollTop = document.documentElement.scrollTop;  //IE8,火狐\n    var iScrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    var timer = setInterval(function () {  //定时器\n        scrollTo(0, iScrollTop -= 100);\n        console.log(iScrollTop);\n        if (iScrollTop <= 0) {\n            clearInterval(timer);  //清除定时器\n        }\n    }, 100);\n}\n```\n\n## 手机号处理中间4位替换成*(数据脱敏)\n\n### 方法1 substr方法\n```javascript\nlet phone=\"18883269663\"\nlet phone1=phone.substr(0,3)+\"****\"+phone.substr(7)\n```\n\n### 方法2 正则匹配分组\n```javascript\nlet tel = \"13122223333\";\n\nlet reg = /^(\\d{3})\\d{4}(\\d{4})$/;\n\ntel = tel.replace(reg, \"$1****$2\");\n```\n\n## 转换树形结构数据\n```javascript\nlet arr=[{\"departmentId\":\"2807369902638080\",\"departmentName\":\"四合院大数据有限公司\",\"departmentDesc\":\"四合院大数据有限公司是非常好的公司\",\"createTime\":null,\"hasChild\":false,\"parentId\":null},{\"departmentId\":\"2805950137730048\",\"departmentName\":\"产品策划部\",\"departmentDesc\":null,\"createTime\":null,\"hasChild\":true,\"parentId\":null},{\"departmentId\":\"2805949110338560\",\"departmentName\":\"研发中心\",\"departmentDesc\":null,\"createTime\":null,\"hasChild\":true,\"parentId\":null}];\n\nfunction fn(data, p_id) {\n  var result = [],\n    temp;\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].parentId == p_id) {\n      var obj = data[i];\n      obj.label = data[i].departmentName;\n      temp = fn(data, data[i].departmentId);\n      if (temp.length > 0) {\n        obj.children = temp;\n      }\n      result.push(obj);\n    }\n  }\n  return result;\n}\n\nlet treeData=fn(treeData,null) // 传入原始数据/parentId\n适用于ant design和element-ui等树形结构数据\n```\n\n## 浏览器返回上一页\n```javascript\n<a href=\"#\" onclick=\"javascript:history.back(-1);\">返回到上一页</a>\n\n<a href=\"#\" onClick=\"javascript:history.go(-1)\">返回上一页</a>\n\n// window.open(url,\"_blank\")\n// window.location.href=url\n// window.location.replace(url)\n```\n\n## 浏览器前进后退\n```javascript\nhistory.forward();//前进\nhistory.back();//后退+刷新\nhistory.back(-1)//后退,直接返回当前页的上一页，数据全部消息，是个新页面\nhistory.go(1);//前进\nhistory.go(-1);//后退也是返回当前页的上一页，不过表单里的数据全部还在\n```\n\n## 去重数组里对象相同值得key\n```javascript\nconst key = 'id'\nconst arr = [{ id: 1 }, { id: 1 }, { id: 2 }, { id: 3 }]\nconst filted = arr.reduce((finalList, obj) => {\n  if (!finalList.find(T => T[key] === obj[key])) {\n    finalList.push(obj)\n  }\n  return finalList\n}, [])\n// [{ id: 1 }, { id: 2 }, { id: 3 }]\n\nlet map =new Map()\nfor (let item of arr){\nmap.set(item[key],item)\n}\n[...map.values()]\n```\n\n## 变量声明\n```javascript\n(function() {\n      var a = b = 5; // var a=b;b=5 严格模式会报错\n  })();   \nconsole.log(b); // 5\nconsole.log(a); // Uncaught ReferenceError: a is not defined\n\nvar a=[]; a[0]=1; a[1]=2; a[2]=3; a[5]=4; \na.length // 6\nwhile不改变作用域链\n[]?true:false // true\n[]==false?true:false // true\n2==true //false\n2==false // false\n\n+new Array(017) // NaN\n\nnew Array(1,2,3) // [1,2,3]\nnew Array(1) // [empty]\nArray.of(7) // [7] Array.of解决掉了这个陷阱\n```\n\n## with语句\nwith语句的作用是将代码的作用域设置到一个特定的对象中。\n\n利：with语句可以在不造成性能损失的情况下，减少变量的长度。很多情况下，也可以不使用with语句，而是使用一个临时变量来保存指针，来达到同样的效果。\n\n弊：with语句使得程序在查找该语句块中的所有的变量值时，都是先在该with语句指定的对象下面先寻找一遍，然后再去外面的作用域去寻找。所以尽量不要在该语句块中去使用一些不属于该对象中的变量\n\n用法\n\n```javascript\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\nwith(x){\n  console.log(name+'的小名是'+nick_name);\n}\n```\n\n相当于\n\n```javascript\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\n/*\n *这里将x对象赋值到当前局部变量中，减少不必要的指针路径解析运算\n *一般用于在在方法中将this对象局部化，比如：var this_ = this;\n */\nvar x_ = x;\nconsole.log(x_.name+'的小名是'+x_nick_name);\n```\n\n## boolean类型在进行比较时会类型转换成number\n\n```javascript\n11==true // 11==1 false\n1==true  // 1==1 true\n```\n\n## RGB到十六进制\n使用按位左移运算符(<<)和toString(16)，然后padStart(6,'0')将给定的RGB参数转换为十六进制字符串以获得6位十六进制值。\n\n```javascript\nconst rgbToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');\n// ((1<<24) + (rgb.r<<16) + (rgb.g<<8) + rgb.b).toString(16).substr(1);\n// rgbToHex(255, 165, 1) -> 'ffa501'\n```\n\n## 滚动到顶部\n使用document.documentElement.scrollTop或document.body.scrollTop获取到顶部的距离。\n\n```javascript\nconst scrollToTop = _ => {\n\n    const c = document.documentElement.scrollTop || document.body.scrollTop;\n\n    if (c > 0) {\n\n    ​ window.requestAnimationFrame(scrollToTop);\n\n    ​ window.scrollTo(0, c - c / 8);\n\n    }\n};\n\n// scrollToTop()\n```\n\n## 求和\n```javascript\nconst sum = arr => arr.reduce((acc, val) => acc + val, 0);\n\n// sum([1,2,3,4]) -> 10 累加器\n// 平均数 sum([1,2,3,4])/4\n```\n\n## 大写每个单词的首字母\n使用replace()匹配每个单词的第一个字符，并使用toUpperCase()来将其大写。\n\n```javascript\nconst capitalizeEveryWord = str => str.replace(/[a-z]/g, char => char.toUpperCase());\n// capitalizeEveryWord('hello world!') -> 'HELLO WORLD!'\n\nfunction titleCase(s) {  \n    return s.toLowerCase().replace(/\\b([\\w|']+)\\b/g, function(word) {  \n        //return word.slice(0, 1).toUpperCase() + word.slice(1);  \n        return word.replace(word.charAt(0), word.charAt(0).toUpperCase());  \n    });  \n}\n// titleCase('hello world!') -> 'Hello World!'\n```\n\n## 计算数组中某值出现的次数\n每次遇到数组中的特定值时，使用reduce()来递增计数器。\n\n```javascript\nconst countOccurrences = (arr, value) => arr.reduce((a, v) => v === value ? a + 1 : a + 0, 0);\n\n// countOccurrences([1,1,2,1,2,3], 1) -> 3\n```\n\n## 数组间的区别\n从b创建一个Set，然后在a上使用Array.filter()，只保留b中不包含的值。\n\n```javascript\nconst difference = (a, b) => { const s = new Set(b); return a.filter(x => !s.has(x)); };\n\n// difference([1,2,3], [1,2]) -> [3]\n```\n\n## 阶乘\n使用递归。如果n小于或等于1，则返回1。否则返回n和n - 1的阶乘的乘积。\n\n```javascript\nconst factorial = n => n <= 1 ? 1 : n * factorial(n - 1);\n\n// factorial(6) -> 720\n```\n\n## 获取滚动位置\n如果已定义，请使用pageXOffset和pageYOffset，否则使用scrollLeft和scrollTop，可以省略el来使用window的默认值。\n\n```javascript\nconst getScrollPos = (el = window) =>\n\n({x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,\ny: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop});\n\n// getScrollPos() -> {x: 0, y: 200}\n```\n\n## 最大公约数\n```javascript\nconst gcd = (x, y) => !y ? x : gcd(y, x % y);\n\n// gcd (8, 36) -> 4\n1e3 // 1000\n1E3 // 1000\n```\n\n## UUID生成器\n使用crypto API生成符合RFC4122版本4的UUID。\n\n```javascript\nconst uuid = _ =>\n([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n\n// uuid() -> '7982fcfe-5721-4632-bede-6000885be57d'\n```\n\n## 检查变量是否声明\n如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个全局变量是否被声明。\n前二种写法有漏洞，如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。\n最好的方法是使用in\n\n```javascript\n// 假设变量x未定义\n\n// 写法一：报错\nif (x) { return 1; }\n\n// 写法二：不正确\nif (window.x) { return 1; }\n\n// 写法三：正确\nif ('x' in window) { return 1; }\n```\n\n## 使用对象结构代替 switch…case\nswitch…case不使用大括号，不利于代码形式的统一。此外，这种结构类似于goto语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。\n\n```javascript\n// 反模式\nfunction doAction(action) {\n    switch (action) {\n        case 'hack':\n            // ...\n            break;\n        case 'slash':\n            // ...\n            break;\n        default:\n            throw new Error('Invalid action.');\n    }\n}\n// 好模式\nfunction doAction(action) {\n    var actions = {\n        hack: function () {\n            // ...\n        },\n        slash: function () {\n            // ...\n        },\n    };\n\n    if (typeof actions[action] !== 'function') {\n        throw new Error('Invalid action.');\n    }\n\n    return actions[action]();\n}\n```\n\n## 隐藏console打印在哪一行的信息\n```javascript\nsetTimeout(console.log.bind(console, 'Hello world'), 2000)\n```\n\n## 手机震动\n```javascript\nwindow.navigator.vibrate(200); // vibrate for 200ms\n```\n\n## [1,2,11]用sort方法进行排序\n```javascript\n[1,2,11].sort() // [1,11,2] sort方法默认根据unicode进行排序\n\n[1,undefined,null].sort() // [1, null, undefined]\n\n[1,2,11].sort((a,b)=>a-b)  // [1,2,11]\n\n// bind是函数柯里化得一种实现\n```\n\n## [1,2,3].map(parseInt)\n```javascript\n[1,2,3].map(parseInt) // [1,NaN,NaN] 这里第二个参数是map的index，3对应下标2，3没有二进制的。\n\nparseInt(\"11\",2);\t\t//返回 3 (2+1)\n```\nparseInt第二个参数\t\n> 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。\n\n> 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。\n\n> 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。\n\n## 图片上传\n1. 传统的form表单上传\n```javascript\n<form action=\"\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"file\" name=\"img\">\n</form>\n```\n\n2. 隐藏iframe模拟Ajax上传\n```javascript\n// form的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded。\n// multipart/form-data是上传二进制数据;它告诉我们传输的数据要用到多媒体传输协议\n<iframe  name=\"ajaxUpload\" style=\"display:none\"></iframe>\n<form action=\"url\" method=\"post\" enctype=\"multipart/form-data\" target=\"ajaxUpload\">\n    <input type=\"file\" name=\"img\">\n</form>\n```\n\n3. h5 ajax上传\n```javascript\n// 使用已有的form表单，来实例化FormData对象\nvar form = document.getElementById('form');\nvar formData = new FormData(form);\n\n// 可以使用append来添加更多的信息\nvar img = document.getElementById('img').files[0];\nvar formData = new FormData();\nformData.append('img',img);\n\n// 获取 \n// formData.get('img') formData.getAll('img') [img]\n\n// 设置修改\n// formData.set('img',1) // 已存在则修改，不存在则新增\n\n// 判断是否存在\n// formData.has('img')\n\n// 删除\n// formData.delete('img')\n\n// 返回迭代器\n// formData.entries()\n// formData.append(\"k1\", \"v1\");\n// formData.append(\"k1\", \"v2\");\n// formData.append(\"k2\", \"v1\");\n\n// var i = formData.entries();\n\n// i.next(); // {done:false, value:[\"k1\", \"v1\"]}\n// i.next(); // {done:fase, value:[\"k1\", \"v2\"]}\n// i.next(); // {done:fase, value:[\"k2\", \"v1\"]}\n// i.next(); // {done:true, value:undefined}\n\n// 利用XHR上传图片\nvar xhr = new XMLHttpRequest();\nxhr.open('POST',url);\nxhr.onreadystatechange = function(){};\nxhr.send(formData);\n\n// 获取上传的进度\nxhr.upload.onprogress = function(evt){\n    console.log(evt);\n    var loaded = evt.loaded; //已经上传的大小\n    var total = evt.total;//附件总大小\n    var per = Math.floor(100 * loaded / total );//已经上传的百分比\n}\n```\n\n4. 检验图片信息\n```javascript\n<input type=\"file\" id=\"img\" name=\"img\"/>\n\n// 获取file对象\nvar img = document.getElementById('img');\nvar files = img.files;\nvar file = files[0];\n```\n\n## 实现JSONP\n```javascript\n// 对象存储\nconst JSONP = (url, jsonpObj) => {\n  let cbName = \"cb\" + JSONP.count++\n  let cbQuery = \"JSONP.\" + cbName\n  let paramsToQuery = obj => {\n    let query = '?'\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        query += `${k}=${obj[k]}&`\n      }      \n    }\n    return query\n  }\n  JSONP[cbName] = data => {\n    try {\n      jsonpObj.callback(data)\n    } finally {\n      delete JSONP[cbName]\n      document.body.removeChild(script)\n    }   \n  }\n  let queryStr = paramsToQuery(jsonpObj.data) + 'callback=' + cbQuery\n  let script = document.createElement('script')\n  script.src = url + encodeURIComponent(queryStr)\n  document.body.appendChild(script)\n}\nJSONP.count = 0\n\n// 数组存储\nvar JSONP = (url, descriptor) => {\n  var script = document.createElement('script')\n  var body = document.getElementsByTagName('body')[0]\n\n  var parseParam = (paramObj) => {\n    var paramStr = '?',\n        prop = ''\n    for (prop in paramObj) {\n      if(paramObj.hasOwnProperty(prop)) {\n        paramStr += (`${prop}=${encodeURIComponent(paramObj[prop])}&`)\n      }\n    }\n\n    return paramStr\n  }\n\n  var params = parseParam(descriptor.data)\n  var callback = (data) => {\n    descriptor.callback(data)\n    body.removeChild(script)\n    delete JSONP.cbs[index]\n  }\n  var index = JSONP.cbs.push(callback) - 1\n\n  script.src = url + params + 'callback=' + encodeURIComponent(`JSONP.cbs[${index}]`)\n  body.appendChild(script)\n}\n\nJSONP.cbs = []\n```\n\n## chrome浏览器拦截多次window.open\n```javascript\n // 遍历打开页面 chrome浏览器会拦截只允许一次的请求 这里模拟点击\n[1,2,3].forEach(()=>{\n        var aDom = document.createElement('a');\n        aDom.href = 'https://nodejs.org/dist/v10.13.0/node-v10.13.0-x64.msi';\n        aDom.target = '_blank';\n        aDom.click();\n});\n```\n\n## mixed\n```javascript\n1 << 31 // 1* 2^31 \n2 >> 1  // 2/2^1\n// ---------------\ndocument.getElementById(\"#app\")\ndocument.querySelector(\"#app\") // 第一个元素\ndocument.querySelectorAll(\"#app\") // 符合的所有元素\np.example // class \na[target] // 属性\nh1,h2 // 多个选择器按照文档中的位置设置\ndocument.querySelector(\"body\").contentEditable = true //设置内容是否可编辑 子元素继承父元素\nisContentEditable // 查看是否可编辑\n<div oncontextmenu=\"myFunction()\" contextmenu=\"mymenu\"/> // 右击菜单事件\nhtml \nobj.oncontextmenu= function(){}\nobj.addEventListener(\"contextmenu\",function(){})\nonabort // 用于img加载终止 alt title onerror发生错误\nonhashchange // 路由锚点变化\nonfocusin // 支持冒泡的onfocus\noninput // input onchange失去焦点触发 \nonpropertychange// input 会实时触发，会在元素的属性改变时就触发事件当元素disable=true时不会触发只在IE 下支持，其他浏览器不支持，用oninput来解决\nonreset // form表单被重置触发 input type=\"reset\"\nonsearch // input type search 搜索事件\nonsubmnit // form 提交 action\nonscroll // 元素滚动时触发\noncopy // 在元素上拷贝脚本\noncut // 剪切\nonpaste // 粘贴\nonafterprint // body 页面打印后触发 window.print() 对应onbeforeprint\noncanplay // 准备开始播放 设置或者返回\ndocument.getElementsByTagName() // 返回标签集合\ndocument.getElementsByClassName() // 返回类名集合\nobj.removeEventListener()\nremoveChild()\nremoveAttribute()\n```\n\n## 高度\n```javascript\nwindow.scrollY // 225\nwindow.pageYOffset // 225\nwindow.document.body.scrollTop // 0\nwindow.document.documentElement.scrollTop // 225\n// 特殊字符:~ ! @ # % ^ * - _ = + ?\n```\n\n## 自适应单位\n1. vw：1vw等于视口宽度的1%。\n\n2. vh：1vh等于视口高度的1%。\n\n3. vmin：选取vw和vh中最小的那个。\n\n4. vmax：选取vw和vh中最大的那个\n\nCSS百分比是相对于包含它的最近的父元素的高度和宽度\n\n## dom解绑事件\n\n1. attachEvent是IE有的方法，它不遵循W3C标准，而其他的主流浏览器如FF等遵循W3C标准的浏览器都使用addEventListener，所以实际开发中需分开处理。\n\n2. 多次绑定后执行的顺序是不一样的，attachEvent是后绑定先执行，addEventListener是先绑定先执行。\n\n### 为元素解绑事件\n注意:用什么方式绑定事件,就应该用对应的方式解绑事件\n* 1. 解绑事件\n* 对象.on事件名字=事件处理函数--->绑定事件\n* 对象.on事件名字=null;\n\n```javascript\n$(\"btn\").onclick=function () {\nconsole.log(\"我是绑定事件\");\n};\n$(\"btn\").onclick=null;\n};\n```\n\n* 2. 解绑事件\n* 对象.addEventListener(\"没有on的事件类型\",命名函数,false);---绑定事件 \n* 对象.removeEventListener(\"没有on的事件类型\",函数名字,false);\n\n```javascript\n$(\"btn\").addEventListener(\"click\",f1,false);\n$(\"btn\").removeEventListener(\"click\",f1,false);\n```\n\n* 3. 解绑事件(IE)\n* 对象.attachEvent(\"on事件类型\",命名函数);---绑定事件\n* 对象.detachEvent(\"on事件类型\",函数名字);\n```javascript\n$(\"btn\").attachEvent(\"onclick\",f2);\n$(\"btn\").detachEvent(\"onclick\",f1);\n```\n\n## 位运算符\n位运算符一般使用的很少，当他与数字一起使用的时候，比如~N => -(N+1),这个式子仅当 N == -1 的时候结果为0。位运算可以提高程序的运行效率。\n\n我们可以在indexof(...)函数前面加一个~来进行布尔检查，检查一个项是否存在于Array或者string中。\n```javascript\nlet userName = 'break jerry'\n\nif(~userName.indexOf(\"break\")) {\n    console.log('access denied');\n}else {\n    console.log('access granted');\n}\n\n// 奇偶性\nif(index & 1) {\n    // 1 奇数 odd \n}else{\n    // 0 偶数 even\n}\n```\n\n## 关闭当前页面\n- window.close()\n- window.open(\"about:blank\",\"_self\").close();\n\n## 字节节省写法\n```javascript\n//取整\nparseInt(a,10); \nMath.floor(a); \n~~a; //节省之后的写法\na|0; //节省之后的写法 \na<<0\n\n//四舍五入\nMath.round(a); \na+.5|0; //节省之后的写法\n\n//内置值未定义\nundefined; \nvoid 0; //节省之后的写法(快)\n0[0]; //节省之后的写法(略慢)\n\n//内置值 无穷\nInfinity;\n\n\n1/0; //节省之后的写法\n\n//布尔值短写法\ntrue; \n!0; //节省之后的写法\nfalse; \n!1; //节省之后的写法\n\n// 判断奇偶\nnum & 1 == 1 //奇数\nnum & 1 == 0 //偶数\n\nnum % 2 === 0 //偶数\n// 递归判断\nfunction isEven(num) {\n  if (num < 0 || num === 1) return false;\n  if (num == 0) return true;\n  return isEven(num - 2);\n}\n```\n\n## 简单计算页面FPS\n整体思路是一秒有一千毫秒，先记录当前时间作为最后一次记录fps的时间，通过 requestAnimationFrame 回调不断给累加fsp计数器，\n并且判断上次记录fps的时间是否达到1000毫秒以上，如果满足条件，就将fps累加器的值作为当前fps显示，并且重置fps累加器。\n\n```javascript\nvar showFPS = (function () {\n    // noinspection JSUnresolvedVariable, SpellCheckingInspection\n    // 函数式\n    var requestAnimationFrame =\n        window.requestAnimationFrame || //Chromium  \n        window.webkitRequestAnimationFrame || //Webkit \n        window.mozRequestAnimationFrame || //Mozilla Geko \n        window.oRequestAnimationFrame || //Opera Presto \n        window.msRequestAnimationFrame || //IE Trident? \n        function (callback) { //Fallback function \n            window.setTimeout(callback, 1000 / 60);\n        };\n    \n    var dialog;\n    var container;\n\n    var fps = 0;\n    var lastTime = Date.now(); // 时间戳\n    // 遍历修改style\n    function setStyle(el, styles) {\n        for (var key in styles) {\n            el.style[key] = styles[key];\n    }\n    }\n\nfunction init() {\n        dialog = document.createElement('dialog');\n        // 初始化赋值样式\n        setStyle(dialog, {\n            display: 'block',\n            border: 'none',\n            backgroundColor: 'rgba(0, 0, 0, 0.6)',\n            margin: 0,\n            padding: '4px',\n            position: 'fixed',\n            top: 0,\n            right: 'auto,',\n            bottom: 'auto',\n            left: 0,\n            color: '#fff',\n            fontSize: '12px',\n            textAlign: 'center',\n            borderRadius: '0 0 4px 0'\n        });\n        // container成了dom元素\n        container.appendChild(dialog);\n    }\n\n    function calcFPS() {\n        offset = Date.now() - lastTime;\n        fps += 1;\n    // 1s内的计数器\n    if (offset >= 1000) {\n            lastTime += offset; // Date.now();\n            displayFPS(fps);\n            fps = 0;\n        }\n\n        requestAnimationFrame(calcFPS);\n    };\n\n    function displayFPS(fps) {\n        var fpsStr = fps + ' FPS';\n\n        if (!dialog) {\n            init();\n        }\n\n    if (fpsStr !== dialog.textContent) {\n        // 重绘 \n        dialog.textContent = fpsStr;\n        }\n}\n\nreturn function (parent) {\n    container = parent;\n        calcFPS();\n    };\n})();\nshowFPS(document.body);\n```\n\n## 你不知道的new.target\nnew 是构造函数生成实例的命令, ES6为 new 命令引入了 new.target属性。这个属性用于确定构造函数是怎么调用的。\n用法：在构造函数中, 如果一个构造函数不是通过 new操作符调用的, new.target会返回 undefined。\n\n使用场景：\n### es5写法\n> 如果一个构造函数不通过 new 命令生成实例, 就报错提醒。\n```javascript\nfunction Shape(options) {\n    if (this instanceof Shape) {\n        this.options = options\n    } else {\n        // 要么手动给它创建一个实例并返回\n        // return new Shape(options)\n        \n        // 要么提醒\n        throw new Error('Shape 构造函数必须使用 new 操作符')\n    }\n}\n```\n\n###  es6写法\n> 子类继承父类, 那么父类构造函数中的 new.target 是子类构造函数的名称。\n```javascript\nclass Zoo {\n    constructor() {\n        if (new.target === Zoo) throw new Error('Zoo构造函数只能用于子类继承')\n    }\n}\n\nconst zoo = new Zoo()   // 报错\n\nclass Dog extends Zoo {\n    constructor() {\n        super()\n    } \n}\n\nconst dog = new Dog()  // 不报错\n```\n\n## 文件扩展名\n```javascript\nvar filePath = '21312321.mp3'\nfilePath.substring(filePath.lastIndexOf(\".\")+1,filePath.length) //'mp3'\n```\n\n## blur和click冲突\n> 场景：平时做表单验证的时候一般都有个input框和删除按钮，然后习惯性在失去焦点的时候> 去验证输入的内容是否正确，做验证，发请求等等。\n> 这个时候，那个点击删除按钮往往也就触发了input的失去焦点事件\n1. 给失去焦点的时间加上延迟时间，让blur时间在click事件后执行，这个方法固然能够解决问题，但是本人并不是很推荐，因为影响性能，不到最后不用这个方法；\n2. event.relatedTarget.id事件属性返回与事件的目标节点相关的节点。（非IE）\n3. mousedown事件替代处理click事件\n\n## object标签\nobject标签不在dom文档流里面，浏览器在解析的时候先把object放置在最上层，然后依次解析dom文档，放在下层。\n\n如果这样引用多媒体文件推荐还是不使用object，只有iframe的层级在它之上处理起来很麻烦。\n\n## escape、encodeURI、encodeURIComponent区别\n1. escape是对字符串进行编码，对URL使用不需要 encodeURI encodeURIComponent\n2. encodeURI方法不会对下列字符编码 ASCII字母、数字、!@#$&*()=:/,;?+'\n3. encodeURIComponent方法不会对下列字符编码 ASCII字母、数字、!*()'\n所以encodeURIComponent比encodeURI编码的范围更大。\n实际例子来说，encodeURIComponent会把 http:// 编码成 http%3A%2F%2F 而encodeURI却不会。\n当编码url时需要使用encodeURI，当需要编码参数时使用encodeURIComponent\n\n## 链式调用\n```javascript\n1.方法体内返回对象实例自身(this)\n\nvar Obj = {\n    a: 1,\n    func: function(){\n        this.a += 1;\n        return this\n    }\n}\nObj.func().func();\nconsole.log(Obj.a);    //3\n2.对象传入后每次调用返回函数自身\n    function show(str) {\n        console.log(str);\n        return show;\n    }\n    show(123)(456)(789);\n\n// 控制台打印结果\n// 123\n// 456\n// 789\n```\n\n## setTimeout 为不可执行的字符串时会造成内存泄漏\n```javascript\nsetTimeout(\"fn()\",100)\nfunction fn(){\nconsole.log(11111111)\n}\n```\n\n## JSON.parse和JSON.stringify其他参数\n```javascript\nvar obj ={name:'cosyer',age:15}\nvar newobj = JSON.stringify(obj)\n\nJSON.parse(newobj,(key,value)=>{\nconsole.log(1111111111111,key,value);\n});\n// name cosyer \n// age 15 \n// \"\" {}\n\n// 3个参数\n// JSON.stringify(jsonObj,repalce,space)\n// replace可以是数组或者回调函数\nconst testJSON = {\n   name: 'test',\n   cities: {\n      shanghai: 1,\n   },\n};\n\nJSON.stringify(testJSON, ['name']);\n\n// \"{\"name\": 'test'}\"\n\nJSON.stringify(testJSON, ['name', 'cities']);\n \n//  \"{\"name\": 'test', \"cities\": {}}\"\n\nJSON.stringify(testJSON, ['name', 'cities', 'shanghai']);\n\n// \"{\"name\": 'test', \"cities\": {\"shanghai\": 1}}\"\n\nJSON.stringify(testJSON, (key, value) => {\n    // 遍历对象\n    if (key === 'cities') {\n       return  'cities';\n    } \n    return value; // 确认value???\n});\n\n// \"{\"name\": 'test', \"cities\": 'cities'}\"\n\nJSON.stringify(testJSON, undefined, '...');\n\n// \"{\n//    ...\"name\": 'test',\n//    ...\"city\": 'shanghai',\n//   }\"\n\nJSON.stringify(testJSON, undefined, 7);\n\n// \"{\n//          \"name\": 'test',\n//          \"city\": 'shanghai',   // 缩进7个空格\n// }\"\n\nJSON.stringify({name:123,age:24},null,'\\t')\n// \"{\n// \t\"name\": 123,\n// \t\"age\": 21\n// }\"\n```\n\n## 随机数\n```javascript\n// [0,1) 左闭右开 min-max \nMath.floor(min+Math.random()*(max-min+1))\n// toString() this is object方法 toString() valueOf\n// 随机颜色\nitem.style.backgroundColor = '#' + Math.random().toString(16).slice(2, 8);\n// \"#\" + (\"00000\" + ((Math.random() * 0x1000000) << 0).toString(16)).slice(-6)\n```\n\n## chrome浏览器跳转调试\n问题描述：在chrome里调试接口的时候发现页面跳转之后会看不到之前的接口返回，即使你将Perserve log 勾上，能看到跳转之前的接口，但是看不到返回的内容\n\n问题解决：查了一些资料，chrome之所以这么做（看不到跳转之前的接口返回）是为了节省内存开销，但是这个给调试带来了困难，然后我参照stackoverflow的解决方案， 在控制台执行 window.onunload = function() { debugger; } 为了在页面unload之前进入debug，但是尝试了还是看不到跳转之前接口返回的内容，最后的解决方案是用firefix调试，在火狐里在调试中的网络中勾选持续日志可以看到跳转之前的接口，且可以看到接口返回内容。\n\n**参考资料** \n* [Chrome dev tools fails to show response ](https://stackoverflow.com/questions/38924798/chrome-dev-tools-fails-to-show-response-even-the-content-returned-has-header-con)\n* [Chrome 开发者工具里看不到完整的 HTTP request 回应？](https://ephrain.net/chrome-chrome-%E9%96%8B%E7%99%BC%E8%80%85%E5%B7%A5%E5%85%B7%E8%A3%A1%E7%9C%8B%E4%B8%8D%E5%88%B0%E5%AE%8C%E6%95%B4%E7%9A%84-http-request-%E5%9B%9E%E6%87%89%EF%BC%9F/)\n\n## 时间\n**UTC**：世界协调时间，是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修\n\n正后的新时标以及以秒为单位的国际原子时所综合精算而成的时间。UTC比GMT更\n\n加精准，其误差值必须保持在0.9秒以内。若大于0.9秒，则由位于巴黎的国际地\n\n球自转事务中央局发布闰秒，使UTC与地球自转周期一致，所以基本上UTC的本质\n\n强调的是比GMT更为精确的世界时间标准。\n\n**GMT**：格林尼治是位于英国南郊的原格林尼治天文台所在地，也是地理经度的起\n\n始点。这里所设定的时间就叫格林尼治时间，也是世界时间参考点，全世界都根\n\n据时区的不同以格林尼治的时间作为标准来设定时间。\n\n**夏令时**：因为夏天白天时间比较长，太阳会比较早出现，某些地区就将当地的时\n\n间提早一段时间（例如一小时），以达到利用阳光节约能源的目的。 通常秋季\n\n时，此地区会将当地时间推后一段时间（例如一小时），回复正常时间。\n\nUTC和本地时间的关系：本地时间=UTC+时区+夏令时偏移量。\n\n## uuid生成(Math.random)\n```javascript\nfunction uuid(len, radix) {\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n    var uuid = [], i;\n    var radix_new = radix || chars.length;\n\n    if (len) {\n        // Compact form\n        for (i = 0; i < len; i++) {\n            uuid[i] = chars[0 | Math.random() * radix_new];\n        }\n    } else {\n        // rfc4122, version 4 form\n        var r;\n\n        // rfc4122 requires these characters\n        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n        uuid[14] = '4';\n\n        // Fill in random data. At i==19 set the high bits of clock sequence as\n        // per rfc4122, sec. 4.1.5\n        for (i = 0; i < 36; i++) {\n            if (!uuid[i]) {\n                r = 0 | Math.random() * 16;\n                uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\n            }\n        }\n    }\n    return uuid.join('');\n};\n```\n\n```js\nfunction generateDynamic32UUID() {\n  return \"xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx\"\n    .replace(/[xy]/g, function(c) {\n      let r = (Math.random() * 16) | 0;\n      let v = c == \"x\" ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    })\n    .toUpperCase(); // \"8ED4E1FA-DA4B-5B40-B5AF-05AC386B2753\"\n  //   return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n  //     (\n  //       c ^\n  //       (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))\n  //     ).toString(16)\n  //   );\n}\n```\n\n```js\n// hash name\nfunction getHashName(prefix) {\n    var number = randomNum(1, 9);\n    var hash = parseInt(((new Date().getTime()) % 3839 + 256), 10).toString(16);\n    hash = prefix + '-' + hash + number;\n    return hash;\n}\n\nfunction randomNum(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n```\n\n## UUID(createObjectURL)\n```js\nfunction uuid() {\n  var temp_url = URL.createObjectURL(new Blob());\n  var uuid = temp_url.toString(); // blob:https://xxx.com/b250d159-e1b6-4a87-9002-885d90033be3\n  URL.revokeObjectURL(temp_url);\n  return uuid.substr(uuid.lastIndexOf(\"/\") + 1);\n}\n```\n\n## jq原生对照\n```javascript\n1、元素获取\n/*******************原生js**************************/\nvar ele = document.getElementById('idName');\nvar eleArr = document.getElementsByClassName('className');\nvar eleArr = document.getElementsByTagName('div');\nvar ele = document.querySelector('#idName');//('.className')//('tagName'); //取第一个满足条件的元素\nvar eleArr = document.querySelectorAll('.className');//('tagName');\n/*******************jQuery**************************/\nvar ele = $('#idName');\nvar ele = $('.className:eq(0)'); //取第一个元素\nvar eleArr = $('tagName');\n2、class选择器操作\n/*******************原生js**************************/\n//className 属性\nele.className = 'newClassName';\n//classList操作\nele.classList.contains('className'); //是否含有该类\nele.classList.add('newClassName1,newClassName2...'); //添加类\nele.classList.remove('oldClassName1,newClassName2...'); //删除类\nele.classList.toggle('className'); //如果元素中有该className，则删除并返回false，否则添加并返回true\n\n/*******************jQuery**************************/\nele.hasClass(className);\nele.addClass('newClassName1,newClassName2...');\nele.removeClass('newClassName1,newClassName2...'); // 元素本身remove()\nele.toggleClass('className');\n3、元素节点操作\n/*******************原生js**************************/\n//创建节点\n    var newNode = ele.createElement('<div>创建</div>');\n//插入节点\n    ele.appendChild(newNode); //在ele的子节点的末尾插入newNode\n    ele.insertBefore(newNode,targetNode); //在ele的子节点targetNode前面插入newNode\n//删除节点\n    ele.removeChild(ele.childNodes[i]); //删除ele第i+1个子节点\n//替换节点\n    ele.replaceChild(newNode, oldNode); //替换ele中的子节点\n//克隆节点\n    var copyNode = ele.cloneNode(deep); //deep为true时，深拷贝（包括其子孙节点），为false时只复制本身节点\n\n/*******************jQuery**************************/\n//创建节点\n    var newNode = $('<div>创建</div>');\n//插入节点\n    //在元素子节点末尾插入\n    ele.append(newNode); //在ele的子节点的末尾插入newNode\n    newNode.appendTo(ele); //在ele的子节点的末尾插入newNode\n    //在元素子节点前端插入\n    ele.prepend(newNode); //在ele的子节点的前端插入newNode\n    newNode.prependTo(ele); //在ele的子节点的前端插入newNode\n\n    //在元素后面添加\n    ele.after(newNode);\n    newNode.insertAfter(ele);\n    //在元素前面添加\n    ele.before(newNode);\n    newNode.insertBefore(ele);\n\n//删除节点\n    ele.remove(); //移除ele及其所有文本、子孙节点、数据和事件\n    ele.detach(); //移除ele及其所有文本、子孙节点，但是保留数据和事件\n    ele.empty(); //清除ele所有的内容和子孙元素，但是ele节点本身和其属性事件等还在\n\n//替换节点\n    ele.replaceWith(newNode); //替换ele为新的内容(可以是html元素，dom元素，jQuery元素)\n    newNode.replaceAll(ele); //替换ele为新的html元素\n//克隆节点\n    ele.clone(deep); //deep为true时，深拷贝（包括其事件处理函数），为false时只复制本身，默认false\n4、元素节点遍历\n/*******************原生js**************************/\n// 子节点\nvar eleArr = ele.childNodes; // 所有子节点\nvar eleArr = ele.children; //所有子节点数组，用得较多\n\nvar firstEle = ele.firstChild; //第一个子节点 低版本浏览器firstElementChild\nvar lastEle = ele.lastChild; //最后一个子节点 低版本浏览器lastElementChild\n// 父节点\nvar parentEle = ele.parentNode;\n// 兄弟节点\nvar nextEle = ele.nextSibling; //下一个节点\nvar previousEle = ele.previousSibling; //上一个节点\n\n/*******************jQuery**************************/\n// 子节点\nvar eleArr = ele.children(); //所有子节点数组\n\nvar firstEle = ele.first(); //第一个子节点\nvar lastEle = ele.last(); //最后一个子节点\n// 父节点\nvar parentEle = ele.parent(); //直接父元素\nvar parentEleArr = ele.parents(); //所有祖先元素\nvar parentEle = ele.offsetParent(); // 第一个有定位的父元素\nvar parentEleArr = ele.parentsUntil(stop, filter); // 满足条件之间的父节点\n\n// 兄弟节点\nvar nextEle = ele.next(); //下一个节点\nvar nextEleArr = ele.nextAll(); //ele后面所有同级节点\nvar previousEle = ele.prev(); //上一个节点\nvar previousEle = ele.prevAll(); //ele之前所有同级节点\nvar siblingsArr = ele.siblings(); //所有同级元素节点\n5、属性操作\n/*******************原生js**************************/\n// 属性数组\nvar attrArr = ele.attributes;\n// 判断属性\nvar bool = ele.hasAttribute('attrName'); //是否有指定属性\nvar bool = ele.hasAttributes(); //是否有属性\n// 获取属性值\nvar attrValue = ele.getAttribute('attrName');\n// 设置属性值\nele.setAttribute('attrName','attrValue');\n// 删除属性\nele.removeAttribute('attrName');\n/*******************jQuery**************************/\n//在设置disabled、selected、checked等这些Boolean类型自带属性时，我们需要用prop()方法；\n// 其他字符串类型自带属性时，我们使用attr()方法即可;DOM节点可见的自定义属性我们也使用attr()方法。\n// 获取属性值\nvar attrValue = ele.attr('attrName');\nvar propValue = ele.prop('propName');//\n// 设置属性值\nele.attr('attrName','attrValue'); //自定义的一些属性\nele.prop('propName','propValue'); //disabled等一些属性，HTML元素的固有属性\n// 删除属性\nele.removeAttr('attrName');\n6、事件\n/*******************原生js**************************/\n//事件绑定及解绑\nele.addEventListener('click',func,false);\nele.removeEventListener('click',func,false);\nele.onclick = func;\nele.onclick = null;\nele.attachEvent('onclick',func); //ie8以下\nele.detachEvent('onclick',func); //ie8以下\n/*******************jQuery**************************/\n/*多种事件绑定和解绑方法*/\n/**方法1\n * 1、直接绑定事件方法mouseenter()...等等\n * 2、这样的方式，下面两个事件不会被层叠，都会执行\n * 3、只能一个一个绑定\n */\n$(\"div:eq(0)\").click(function () {\n    alert(1);\n});\n$(\"div:eq(0)\").click(function () {\n    alert(2);\n});\n\n/**方法2\n * 1、bind(\"event1 event2 ... eventx\",fn)\n * 2、同时绑定多个事件触发条件，执行同一个函数\n */\n$(\"div:eq(1)\").bind(\"click mouseenter\",function () {\n    alert(\"bind绑定法\");\n});\n//解绑\n$(\"div:eq(1)\").unbind(\"click\"); //解绑指定的\n//$(\"div:eq(1)\").unbind();  //解绑所有的\n\n/**方法3\n * 1、delegate(\"selector\",\"event1 event2 ... eventx\",fn)\n * 2、可以绑定父盒子里的子盒子触发事件，执行函数\n */\n$(\"div:eq(2)\").delegate(\"button\",\"click mouseleave\",function () {\n    alert(\"delegate绑定法\");\n});\n//解绑\n$(\"div:eq(2)\").undelegate();\n/**方法4\n * 重点使用！！！\n * 1、on(\"event1 event2 ... eventx\",\"selector\",data,fn)\n * 2、可以绑定父盒子里的后代盒子触发事件，执行函数\n * 3、参数data由event.data带入函数中\n */\n\n$(\"div:eq(3)\").on(\"click mouseleave\",\"button\",{\"name\":\"mjm\",\"age\":24},function (event) {\n    alert(\"on绑定法\"+event.data.name);\n\n});\n//解绑\n$(\"div:eq(3)\").off();\n```\n\n## 实现复制tiny\n```javascript\n// 复制连接地址\nwindow.copyLink = function (str) {\n    if (window.clipboardData) {\n        // 兼容ie11以下浏览器\n        window.clipboardData.setData('Text', str);\n    } else {\n        var $input = document.createElement('input');\n        var body = document.querySelector(\"body\")\n        $input.value=str;\n        body.appendChild($input);\n        $input.select();\n        document.execCommand('copy');\n        // $input.remove();\n        body.remove($input)\n    }\n};\n```\n\n## scrollbar滚动条样式优化\n```css\n::-webkit-scrollbar-corner {\n  background-color: transparent;\n}\n\n::-webkit-scrollbar-button {\n  width: 0;\n  height: 0;\n  display: none;\n}\n\n::-webkit-scrollbar-thumb {\n  width: 7px;\n  background-color: #b4babf;\n  border-radius: 7px;\n}\n\n::-webkit-scrollbar {\n  width: 7px;\n  height: 7px;\n}\n\n::-webkit-scrollbar-track {\n  width: 15px;\n}\n\n::-webkit-scrollbar:hover {\n  background-color: transparent;\n}\n```\n\n##  内网ip段\n内网段10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—192.168.255.255\n\n## 获取当前鼠标坐标\n```javascript\nvar getCoordInDocumentExample = function () {\n  var coords = document.getElementById(\"colorPanel\");\n  coords.onmousemove = function (e) {\n    var pointer = getCoordInDocument(e);\n    var coord = document.getElementById(\"colorText\");\n    coord.innerHTML = \"X,Y=(\" + pointer.x + \", \" + pointer.y + \")\";\n  }\n}\n\nvar getCoordInDocument = function (e) {\n  e = e || window.event;\n  var x = e.pageX || (e.clientX +\n    (document.documentElement.scrollLeft ||\n      document.body.scrollLeft));\n  var y = e.pageY || (e.clientY +\n    (document.documentElement.scrollTop ||\n      document.body.scrollTop));\n  return {\n    'x': x,\n    'y': y\n  };\n}\n\nwindow.onload = function () {\n  getCoordInDocumentExample();\n};\n```\n\n## 类数组对象转数组\n```javascript\nfunction func(){\n    // 类数组对象转数组\n    console.log(arguments) // {0:1,1:2,2:3,length:3}\n    console.log([].slice.call(arguments))\n    console.log(Array.prototype.slice.call(arguments))\n    console.log(Array.from(arguments))\n    console.log([...arguments])\n\n    console.log(Array.from({length:0})); //[]\n    console.log(Array.from('')); //[]\n}\nfunc(1,2,3)\n```\n\n## 页面滚动条到底判断\n```javascript\n//获取网页的总高度，主要是考虑兼容性所以把Ie支持的documentElement也写了，这个方法至少支持IE8\nvar htmlHeight = document.body.scrollHeight || document.documentElement.scrollHeight;\n//clientHeight是网页在浏览器中的可视高度，\nvar clientHeight = document.body.clientHeight || document.documentElement.clientHeight;\n//scrollTop是浏览器滚动条的top位置，\nvar scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n//通过判断滚动条的top位置与可视网页之和与整个网页的高度是否相等来决定是否加载内容；\nif (scrollTop + clientHeight == htmlHeight) {\n    // 滚动条到底\n}\n// 没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同\n```\n\n```\n网页可见区域宽： document.body.clientWidth;\n网页可见区域高： document.body.clientHeight;\n网页可见区域宽： document.body.offsetWidth (包括边线的宽);\n网页可见区域高： document.body.offsetHeight (包括边线的宽);\n网页正文全文宽： document.body.scrollWidth;\n网页正文全文高： document.body.scrollHeight;\n网页被卷去的高： document.body.scrollTop;\n网页被卷去的左： document.body.scrollLeft;\n网页正文部分上： window.screenTop;\n网页正文部分左： window.screenLeft;\n屏幕分辨率的高： window.screen.height;\n屏幕分辨率的宽： window.screen.width;\n屏幕可用工作区高度： window.screen.availHeight;\n```\n\n## yield函数\n```javascript\n// 传入匿名函数\nfunction* fibonacci() {\n    let [prev, curr] = [0, 1];\n    while (true) {\n    [prev, curr] = [curr, prev + curr];\n    yield curr;\n    }\n}\n// 含有迭代器iterate\nfor (let n of fibonacci()) {\n    if (n >= 1000) {\n    break;\n    }\n    console.log(n);\n}\n// 1 2 3 5 8 \n```\n\n### 复制添加版权申明\n```javascript\nif (window.clipboardData) {\n    // IE\n    document.body.oncopy = function(){\n        event.returnValue = false;\n        var t=document.selection.createRange().text;\n        var s=\" 原文链接：\"+location.href;\n        clipboardData.setData('Text',t+'\\r\\n'+s);\n    };\n} else {\n    function addLink(){\n        var body_element = document.getElementsByTagName('body')[0];\n        var selection;\n        selection = window.getSelection();\n        var pagelink = \" 原文链接：\"+location.href;\n        var copytext = selection + pagelink;\n\n        var newdiv = document.createElement('div');\n        newdiv.style.position='absolute';\n        newdiv.style.left='-99999px';\n        body_element.appendChild(newdiv);\n        newdiv.innerHTML = copytext;\n        selection.selectAllChildren(newdiv);\n        window.setTimeout(function(){body_element.removeChild(newdiv);},0);\n    }\n    document.oncopy = addLink;\n}\n```\n\n## 包版本号\n一个包的版本号基本由三位数字构成 x.x.x, 它们分别是主版本号, 次版本号, 修订号。\n\n- *: 升级主版本号 + 次版本号 + 修订号;\n- ^: 升级次版本号 + 修订号;\n- ~: 升级修订号;\n\nnpm使用 a.b.c 的版本号来管理安装包，a大达版本号，有重大api改变，一般不向下兼容，b为小版本号，新增功能，向下兼容，c为补丁号，通常修复一些bug。\n\n## script标签关键字\n- defer 并发下载 顺序执行 渲染完再执行(延迟执行)\n- async 异步下载 异步执行谁先下载完 谁先执行\n\n## 防止对象篡改\n* Object.preventExtensions(obj): obj 不能添加属性\n* Object.seal(obj): obj 不能添加/删除属性\n* Object.freeze(obj): obj 不能添加/删除/修改属性\n\nObject.freeze工作方式与Object.preventExtensions相同，并且它使所有对象的属性不可写且不可配置。 唯一的缺点是`Object.freeze`仅适用于对象的第一级：嵌套对象不受操作的影响。\n\n## module.exports和exports\nmodule.exports才是真正的接口，exports只不过是它的一个辅助工具。　最终返回给调用的是module.exports而不是exports。\n所有的exports收集到的属性和方法，都赋值给了module.exports。当然，这有个前提，就是module.exports本身不具备任何属性和方法。\n\n1. 最好分别定义module.exports和exports\n\n2. 建议导出对象用module.exports,导出多个方法和变量用exports\n\n## meta自动跳转\n```javascript\n<meta http-equiv=\"Refresh\" content=\"1; url=http://www.baidu.com\"/>\n```\n\n## 前端生成文件并下载\nBlob对象简要介绍\n\nBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 Blob 的功能并将其扩展使其支持用户系统上的文件。生成Blob对象有两种方法：一种是使用Blob构造函数，另一种是对现有的Blob对象使用slice方法切出一部分。\n> const aBlob = new Blob( array, options );\n参数说明\n\n- array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。\n- options 是一个可选的BlobPropertyBag字典，它可能会指定如下两个属性：\ntype，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。\nendings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。 它是以下两个值中的一个： “native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持blob中保存的结束符不变\n\n```javascript\n// const debug = {hello: \"world\"};\n// const blob = new Blob([JSON.stringify(debug, null, 2)],{type : 'application/json'});\nfunction createAndDownloadFile(fileName, filePath) {\n    const aTag = document.createElement('a');\n    const blob = new Blob([filePath]);\n    aTag.download = `${fileName}.json`;\n    aTag.style.display = \"none\";\n    aTag.href = URL.createObjectURL(blob);\n    document.body.appendChild(aTag);\n    aTag.click();\n    document.body.removeChild(aTag)\n    URL.revokeObjectURL(blob);\n}\n```\n\n## 防止frame嵌套\n```javascript\nif(top != self){\n    location.href = ”about:blank”;\n}\n```\n\n## 取反运算简化indexOf判断\n```javascript\nif(~[1,2,3].indexOf(1)){\n    // 存在\n}else{\n    // 不存在\n}\n[(1,2,3)] // 3\n```\n\n## 已知年月，求当月多少天\n- 先判断该年份是否是闰年，来处理 2 月份情况，闰年 2 月共 29 天，非闰年 2 月共 28 天\n- 再判断其他月份，如 1 月共 31 天，4 月共 30 天\n\n**更简便的方法**\n```javascript\n// Date API 处理日期溢出时，会自动往后推延响应时间\nfunction getMonthCountDay (year, month) {\n  return 32 - new Date(year, month-1, 32).getDate();\n  // 32 - (32-当月天数) = 当月天数\n}\n// better\nfunction getMonthCountDay (year, month) {\n  return new Date(year, month , 0).getDate();\n}\n```\n\n## 日期格式转化 2019/3/19 => 2019-3-19\n1. 正则\n```js\nlet date = new Date()\nlet dateStr = date.toLocaleDateString().replace(/\\//g,'-')\n```\n\n2. 数组计算\n```js\nlet date = new Date()\nlet arr = date.toLocaleDateString().split('/')\narr = arr.map((item) => {\nreturn parseInt(item) < 10 ? '0' + item : item\n})\nlet dateStr = arr.join('-')\n```\n\n## 求数值的n次幂\n```js\nMath.pow(2,10); //1024\n2**10 // 1024 es7\n2<<9 //1024\n```\n\n## 分号的重要性\n```js\nconst luke = {}\nconst leia = {}\n[luke, leia].forEach(jedi => jedi.father = 'vader');\n\nfunction foo() {\n  return\n    'search your feelings, you know it to be foo'\n} // undefined\n```\n\n## 前端h5 download属性下载文件(appendChild兼容firefox)\n```js\nfunction downFile(content, filename) {\n    // 创建隐藏的可下载链接\n    var eleLink = document.createElement('a');\n    eleLink.download = filename;\n    eleLink.style.display = 'none';\n    // 字符内容转变成blob地址\n    var blob = new Blob([content]);\n    eleLink.href = URL.createObjectURL(blob);\n    // 触发点击\n    document.body.appendChild(eleLink);\n    eleLink.click();\n    // 然后移除\n    document.body.removeChild(eleLink);\n};\n```\n\n## 禁止滚动条滚动\n```js\nvar keys = [37, 38, 39, 40];\n\nfunction preventDefault(e) {\n  e = e || window.event;\n  if (e.preventDefault)\n      e.preventDefault();\n  e.returnValue = false;  \n}\n\nfunction keydown(e) {\n    for (var i = keys.length; i--;) {\n        if (e.keyCode === keys[i]) {\n            preventDefault(e);\n            return;\n        }\n    }\n}\n\nfunction wheel(e) {\n  preventDefault(e);\n}\n\nfunction disable_scroll() {\n  if (window.addEventListener) {\n      window.addEventListener('DOMMouseScroll', wheel, false);\n  }\n  window.onmousewheel = document.onmousewheel = wheel;\n  document.onkeydown = keydown;\n}\n\nfunction enable_scroll() {\n    if (window.removeEventListener) {\n        window.removeEventListener('DOMMouseScroll', wheel, false);\n    }\n    window.onmousewheel = document.onmousewheel = document.onkeydown = null;  \n}\n```\n\n## map等遍历注意事项\n```js\nvar it = []\nit.map((item)=>{\n    console.log(111111111111)\n})\n// 压根就不会执行\n```\n\n## 符合密码学要求的随机值\n```js\nfunction getRandomNumbers(min, max) {\n    var minValue = min || '';\n    var maxValue = max || '';\n    var cryptoObj = window.crypto || window.msCrypto;\n    var array = new Uint32Array(1);\n    cryptoObj && cryptoObj.getRandomValues(array);\n    var result = 0;\n    if (minValue || maxValue) {\n        if (!maxValue) {\n            minValue = 0;\n            maxValue = min;\n        }\n        result = parseInt(minValue, 10) + (array[0] % (parseInt(maxValue, 10) - parseInt(minValue, 10)));\n    } else {\n        result = array[0];\n    }\n    return result;\n}\n```\n\n## 字符串反转\n如果需要支持UTF-16或其他多字节字符的解决方案，请注意此函数将给出无效的Unicode字符串或看起来很有趣的有效字符串。[需要注意](https://stackoverflow.com/questions/958908/how-do-you-reverse-a-string-in-place-in-javascript/16776621#16776621)\n\n![有意思的图](http://cdn.mydearest.cn/blog/images/reverse.jpg)\n\n```js\nfunction reverse(str) {\n    return str.split('').reverse().join('');\n    // Array.from(str).reverse().join('')\n}\n\n// 使用递归\nfunction reverseString(str) {\n  return (str === '') ? '' : reverseString(str.substr(1)) + str.charAt(0);\n}\n\nfunction reverse([h, ...t]) {\n    return h ? reverse(t) + h : '';\n}\n\nfunction reverse(str){\n    var s ='';\n    for (let i = str.length;i > 0; i--) {\n        s += str[i-1]; // charAt substring substr\n    }\n    return s;\n}\n```\n\n## delete varible\n```js\ndelete xxx // true\ndelete window //false\n```\n\n## jquery指定元素滚动到视图中间\n```js\nfunction scrollToViewCenter($element) {\n    if (!$element) {\n        return;\n    }\n    var winOffsetHeight = document.body.offsetHeight; // 浏览器窗口可视区域高度\n    var eleOffsetTop = $element.offset().top;\n    var top = eleOffsetTop - (winOffsetHeight / 2);\n    window.scrollTo(0, top);\n}\n```\n\n## new Array()\n```js\nvar myArray = Array();\nmyArray['A'] = \"Athens\";\nmyArray['B'] = \"Berlin\";\nmyArray['0'] = 1;\n// length 1 只统计数字索引\n// length范围 0~2**32-1\n```\n\n## 构造函数scope-safe模式\n```js\nfunction Book(name){\n    console.log(1111,this)\n    if(!(this instanceof Book)){\n        return new Book(name);\n    }\n    this.name=name;\n}\nvar bookone = Book('harry-potter');\n\nfunction a(b){\n  alert(b);\n  function b(){\n    alert(b);\n  }\n  b();\n}\na();\n```\n\n## jquery设置!important\n```js\n$(\"#container\").css(\"top\");\n$(\"#container\").css(\"top\",\"15px\");\n$(\"#container\").css(\"cssText\",\"overflow:auto !important;\")\n```\n\n## :empty 选择器区分样式\n> :empty 选择器匹配没有子元素（包括文本节点）的每个元素。\n\n这里举个小红点的例子：\n![empty](http://cdn.mydearest.cn/blog/images/empty.png)\n\n如图所示，小红点有内容以及无内容的样式差异，按照常规的处理方式，我们一般是通过类名区分，但是我们可以简单通过:empty选择器区分开。\n```html\n<div class=\"jd\"><i>3</i></div>\n```\n\n```css\n.jd i:empty {\n    // 无内容的小红点样式\n}\n.jd i:not(:empty) {\n    // 有内容的小红点样式\n}\n```\n\n## arr.reduce(callback[, initialValue])\n- reduce接受两个参数, 一个回调, 一个初始值\n- 回调函数接受四个参数 previousValue, currentValue, currentIndex, array\n\n> 第一个表达式等价于 Math.pow(3, 2) => 9; Math.pow(9, 1) =>9\n\n> 第二个表达式异常 Uncaught TypeError: Reduce of empty array with no initial value\n\n## 变量提升\n在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。\n```js\nvar name = 'World!';\n(function () {\n    if (typeof name === 'undefined') {\n        var name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n// Goodbye Jack\n```\n\n## 最大安全数 + 1值没有变化 会导致循环\n```js\nvar END = Math.pow(2, 53);\nvar START = END - 100;\nvar count = 0;\nfor (var i = START; i <= END; i++) {\n    count++;\n}\nconsole.log(count); // 循环\n```\n\n## 稀疏数组\n没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.\n```js\nvar ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) { return x === undefined;});\n// []\n\nvar ary = Array(3);\nary[0]=2\nary.map(function(elem) { return '1'; });\n// [\"1\", undefined × 2]\n```\n\n## 一个鲜为人知的实事: Array.prototype => []\n```js\t\nArray.isArray( Array.prototype )\n// true\n```\n\n## arguments在es6有初始值时不同\n```js\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n// 10 + 1 + 10 = 21\n\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c=3) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n// 1 + 1 + 10 = 12\n```\n\n## reverse返回调用者\n```js\nvar x = [].reverse;\nx();\n// window\n```\n\n## Number.MIN_VALUE > 0\n```js\nNumber.MIN_VALUE > 0\n// 5e-324 true\n```\n\n## 抽象相等\n```js\nvar a = [0];\nif ([0]) {\n  console.log(a == true);\n} else {\n  console.log(\"wut\");\n}\n// false\n```\n![equality](http://cdn.mydearest.cn/blog/images/equality.png)\n\n## 隐式类型转换\n```js\n-、*、/、% ：一律转换成数值后计算\n+：\n\n数字 + 字符串 = 字符串， 运算顺序是从左到右\n数字 + 对象， 优先调用对象的valueOf -> toString\n数字 + boolean/null -> 数字\n数字 + undefined -> NaN\n\n[1].toString() === '1'\n{}.toString() === '[object object]'\nNaN !== NaN 、+undefined 为 NaN\n```\n\n```js\n[1 < 2 < 3, 3 < 2 < 1]\n\n// 1 < 2 => true < 3 => 1 < 3 true\n// 3 < 2 => false < 1 => 0 < 1 true\n// [true,true]\n\n2 == [[[2]]] // true\n```\n\n## number + .\n```js\n3.toString() // error (3).toString()\n3..toString() // '3'\n3...toString() // error\n```\n\n## automatic global\n```js\n(function(){\n  var x = y = 1;\n})();\nconsole.log(y); // 1\nconsole.log(x); // x is not defined\n```\n\n## regexp expression\n```js\nvar a = /123/,\n    b = /123/;\na == b\na === b\n// false false\n```\n\n## function name is readonly\n```js\nfunction foo() { }\nvar oldName = foo.name;\nfoo.name = \"bar\";\n[oldName, foo.name]\n// 'foo' 'foo'\n```\n\n## parseInt 坑\n```js\n\"1 2 3\".replace(/\\d/g, parseInt)\n// [1, 0], [2, 2], [3, 4]\n// \"1 NaN 3\"\n\nparseInt(3, 8) // 3\nparseInt(3, 2) // NaN\nparseInt(3, 0) // 3\n```\n\n## function prototype\n```js\nfunction f() {}\nvar parent = Object.getPrototypeOf(f);\nf.name // f\nparent.name // empty\ntypeof eval(f.name) // function\ntypeof eval(parent.name) //  error\n```\n\n## regexp translate\n```js\nvar lowerCaseOnly =  /^[a-z]+$/;\n[lowerCaseOnly.test(null), lowerCaseOnly.test()]\n// 转化成'null' 'undefined'\n// true true\n```\n\n## [,,,].join(\", \")\n```js\n[,,,].join(\", \")\n// \", , \"\n```\n\n## function length\n```js\nvar a = Function.length,\n    b = new Function().length\na === b\n// 1 === 0 false\n```\n\n## Date equal\n```js\nvar a = Date(0);\nvar b = new Date(0);\nvar c = new Date();\n[a === b, b === c, a === c]\n// false false false\n```\n\n## function scope param\n```js\nfunction foo(a) {\n    var a;\n    return a;\n}\nfunction bar(a) {\n    var a = 'bye';\n    return a;\n}\n[foo('hello'), bar('hello')]\n// [\"hello\", \"bye\"]\n```\n\n## nodejs Event模块的简单实现\n```js\nfunction Event() {\n    this.on = function (eventName, callback) {\n        if (!this.handlers) {\n            this.handlers = {};\n        }\n        if (!this.handlers[eventName]){\n            this.handlers[eventName] = [];\n        }\n        this.handlers[eventName].push(callback);\n    }\n\n    this.emit = function (eventName, data) {\n        if (this.handlers[eventName]) {\n            this.handlers[eventName].forEach((item)=>{\n                item(data);\n            });\n        }\n    }\n    return this;\n}\n```\n\n## 实现超链接显示A网站实际跳转B网站\n```html\n<a href=\"//www.tmall.com\" onclick=\"host='jd.com'\">tmall</a>\n```\n\n## nodejs 恶作剧：给系统创建一个叫 node_modules 的用户，然后 npm install 就无法使用了\n\n## 最简单的方式实现`console.log(1)`返回0\n```js\nconsole = Math;\nconsole.log(1); // 0\n```\n\n## 如何将整个网站页面变成黑白色?(灰阶)\n对于一些需要悼念的日子，很多人也都想把自己的网站弄成全站黑白来表示自己的哀悼之情。还有其他特殊原因（比如公祭日）对部分事件表示哀悼，所以需要把整个网站设置为灰色或者黑白方格。\n\n```css\nhtml {\n-webkit-filter: grayscale(100%);\n-moz-filter: grayscale(100%);\n-ms-filter: grayscale(100%);\n-o-filter: grayscale(100%);\nfilter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n_filter:none;\n}\n```\nfilter 是滤镜的意思，filter:gray 的意思就是说给页面加上一个灰度的滤镜，所以 html 里面的所有内容都会变成黑白的了。\n![黑白色](http://cdn.mydearest.cn/blog/images/grayFilter.png)\n\n\n## 黑幕效果\n```css\n.heimu, .heimu a, a .heimu, .heimu a.new {\n    background-color: #252525;\n    color: #252525;\n    text-shadow: none;\n}\n.heimu:hover, .heimu:active,\n.heimu:hover .heimu, .heimu:active .heimu {\n    color: white !important;\n}\n.heimu:hover a, a:hover .heimu,\n.heimu:active a, a:active .heimu {\n    color: lightblue !important;\n}\n.heimu:hover .new, .heimu .new:hover, .new:hover .heimu,\n.heimu:active .new, .heimu .new:active, .new:active .heimu {\n    color: #BA0000 !important;\n}\n```\n<span class=\"heimu\">太对了哥，哥太对</span>\n\n## 字符串和base64相互转换(编码、解码)\n```js\n// 字符串转base64\nfunction encode(str){\n    // 对字符串进行编码\n    var encode = encodeURI(str);\n    // 对编码的字符串转化base64\n    var base64 = btoa(encode);\n    return base64;\n}\n \n// base64转字符串\nfunction decode(base64){\n    // 对base64转编码\n    var decode = atob(base64);\n    // 编码转字符串\n    var str = decodeURI(decode);\n    return str;\n}\n```\n\n```shell\necho test|base64 #加密\necho dGVzdAo= |base64 -d #解密\n```\n\n## 随机名称\n```js\nfunction getRandomName() {\n    let number = getRandomNum(1, 9);\n    let hash = parseInt(\n        ((new Date().getTime() % 3839) + 256).toString(),\n        10\n    ).toString(16);\n    let randomName = 'prefix' + hash + number;\n    return randomName;\n}\n\nfunction getRandomNum(max, min) {\n    var range = max - min;\n    var rand = Math.random();\n    return min + Math.round(rand * range);\n}\n```\n\n## IDEA连接Github时出现：Failed to connect to github.com port 443: Connection refused的解决方法\n本地hosts文件中配置不正确导致的。\n\n```\ngit config --global http.proxy http://127.0.0.1:1080\n\ngit config --global https.proxy http://127.0.0.1:1080\n```\n\n但创建完仓库后 push 不上去，这个时候就需要取消代理\n```\ngit config --global --unset http.proxy\n\ngit config --global --unset https.proxy\n```\n\n## counter \n\n[FlagCounter](https://flagcounter.com/)\n\n[不蒜子访问统计](http://busuanzi.ibruce.info)\n\n```html\n<script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n\n<span id=\"busuanzi_container_site_pv\">\n    总访问次数:<span id=\"busuanzi_value_site_pv\"></span>\n</span>\n\n<span id=\"busuanzi_container_site_uv\">\n  访问次数:<span id=\"busuanzi_value_site_uv\"></span>\n</span>\n```\n\n## i18n语料替换\n```js\nfunction i18nReplace(s, o) {\n  if (!s || !o) {\n    return;\n  }\n  return s.replace\n    ? s.replace(/\\{\\s*([^\\|\\}]+?)\\s*(?:\\|([^\\}]*))?\\s*\\}/g, function(\n        match,\n        key\n      ) {\n        return o[key] !== undefined ? o[key] : match;\n      })\n    : s;\n}\n\ni18nReplace('123{0}开始了',{0:'奇怪'})\n// \"123奇怪开始了\"\n```\n\n## 一行代码实现简单模版引擎\n```js\nfunction template(tpl, data) {\n  return tpl.replace(/{{(.*?)}}/g, (match, key) => data[key.trim()]);\n}\n\n// 使用：\ntemplate('我是{{name}}，年龄{{age}}，性别{{sex}}', {name: '陈宇', age: 25, sex: '男'}); \n// \"我是陈宇，年龄25，性别男\"\n```\n\n## 快速生成包含26个字母的数组\n```js\nArray.from({length: 26}, (_, i) => String.fromCharCode(65 + i));\n```\n\n## 单行文本的省略号\n```css\n.single-ellipsis{\n  width: 500px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n```\n\n## 多行元素的文本省略号\n```css\n.multiline-ellipsis {\n  display: -webkit-box;\n  word-break: break-all;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 4; // 需要显示的行数\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n```\n\n## 如何实现sleep效果\n### while\n```js\nfunction sleep(ms) {\n    var start = Date.now(), expires = start + ms;\n    while(Date.now()<expires);\n    console.log('醒了');\n}\n\nsleep(2000);\n```\n\n### promise\n```js\nfunction sleep(ms) {\n    return new Promise((resolve,reject)=>{\n        setTimeout(resolve,ms);\n    });\n}\n\nsleep(2000).then(()=>{\n    console.log('醒了');\n});\n```\n\n### generate\n```js\nfunction* sleep(ms){\n   yield new Promise(function(resolve,reject){\n             setTimeout(resolve,ms);\n        })  \n}\nsleep(500).next().value.then(function(){console.log(111)})\n```\n\n### async/await\n```js\nfunction sleep(ms){\n  return new Promise((resolve)=>setTimeout(resolve,ms));\n}\nasync function test(){\n  var temple=await sleep(1000);\n  console.log(1111)\n  return temple\n}\ntest();\n//延迟1000ms输出了1111\n```\n\n## 实现一些主流框架的循环渲染\n### 问题\n```js\nvar items = [\n  { name: 'item1' },\n  { name: 'item2' }\n];\nvar str = '<div ali-for=\"item in items\">{{item.name}}<div>';\n\n// 对应生成的dom  \nParseDom(str);\n// <div>item1</div>  \n// <div>item2</div>  \n```\n\n```js\nvar items = [\n  { name: 'item1' },\n  { name: 'item2' }\n];\n\n// ***********\nconst s = {}\ns.items = items\nfunction ParseDom(str) {\n\t// 借助dom子节点使用dom方法\n\tconst mid = document.createElement('div')\n\tmid.innerHTML = str\n\tconst { children } = mid\n\tlet res = ''\n\t// 遍历子节点\n\t;[...children].forEach(c => {\n\t\t// 找属性节点\n\t\tconst attrs = [...c.attributes]\n\t\tconst targetAttr = attrs.find(x => x.name === 'ali-for');\n\t\tconst nodename = c.nodeName.toLocaleLowerCase();\n\t\t// 属性全部写进去\n\t\tconst attrsStr = attrs.reduce((r, c) => {\n\t\t\tif (c.name !== 'ali-for') {\n\t\t\t\tr += ` ${c.name}=\"${c.value}\"`\n\t\t\t}\n\t\t\treturn r\n\t\t}, '')\n\t\tif (!targetAttr) {\n\t\t\t// 没有循环渲染标记\n\t\t\tres += `<${nodename}${attrsStr}>${c.innerHTML}</${nodename}>`\n\t\t\treturn\n\t\t}\n\t\t// 循环渲染\n\t\tconst vfor = targetAttr.nodeValue\n\t\tconst o = vfor.split(' in ')[1]\n\t\tconst k = c.innerText.match(/\\{\\{(.*)\\}\\}/)[1].split('.')[1]\n\t\t;s[o].forEach(x => {\n\t\t\tres += `<${nodename}${attrsStr}>${x[k]}</${nodename}>`\n\t\t})\n\t})\n\treturn res\n}\n// ***********\n\nvar str = '<div ali-for=\"item in items\">{{item.name}}</div>';\n// 对应生成的dom  \nParseDom(str);\n```\n\n## 思考：如何实现 npm install ？\n- 假如老板给你 一个 npm 包的列表 ，要你找出这些 npm 包的所有依赖包名，简述一下实现思路\n\n- 对包和包的依赖列表进行缓存 -> A 和 B 都依赖了 C，从 A 分析一次后，B 还需要再分析吗？\n\n- 使用并发，但要控制并发量 -> 一个包一个包的查会不会太慢？请求这么频繁 npm 会不会封你的 ip\n\n- 找依赖的时候使用循环，而不是递归 -> 如果一个包的依赖非常非常复杂，内存爆了怎么办\n具有失败重试和离线缓存 -> 中途网络挂掉怎么处理？失败的一直失败怎么办？\n\n\n## Github无法访问 hosts 配置\n```shell\n# GitHub Start\n192.30.253.112 github.com\n192.30.253.118 gist.github.com\n151.101.112.133 assets-cdn.github.com\n151.101.184.133 raw.githubusercontent.com\n151.101.112.133 gist.githubusercontent.com\n151.101.112.133 avatars0.githubusercontent.com\n151.101.112.133 avatars1.githubusercontent.com\n151.101.184.133 avatars2.githubusercontent.com\n151.101.12.133 avatars3.githubusercontent.com\n151.101.12.133 avatars4.githubusercontent.com\n151.101.184.133 avatars5.githubusercontent.com\n151.101.184.133 avatars6.githubusercontent.com\n151.101.184.133 avatars7.githubusercontent.com\n151.101.12.133 avatars8.githubusercontent.com\n151.101.184.133 cloud.githubusercontent.com\n151.101.112.133 camo.githubusercontent.com\n# GitHub End\n```\n修改方法：\n- Windows:\n修改文件 C:/Windows/system32/drivers/etc/hosts\n\n- Linux系:\n修改文件 /etc/hosts\n\n- Android:\n修改文件 /system/etc/hosts （需要Root）\n\n## 保留两位小数\n1. toFixed()方法\n```js\nvar num =2.446242342;  \nnum = num.toFixed(2); \nconsole.log(num); //2.45\n```\n详见[toFixed方法注意点]('https://mydearest.cn/toFixed%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9.html')\n\n2. Math.floor()\n```js\nnum = Math.floor(num * 100) / 100;\nconsole.log(num); //2.44\n```\n\n3. 字符串匹配\n```js\nnum = Number(num.toString().match(/^\\d+(?:\\.\\d{0,2})?/));\nconsole.log(num); //2.44\n```\n\n4. 保留两位小数 浮点数四舍五入 位数不够 不补0\n```js\nfunction fomatFloat(src,pos){    \n    return Math.round(src*Math.pow(10, pos))/Math.pow(10, pos);    \n} \nconsole.log(fomatFloat(3.12645,2)); // 3.13\n```\n\n## H5 语音合成 SpeechSynthesisUtterance API\n```js\nvar utterance = new SpeechSynthesisUtterance('cosyer');\nwindow.speechSynthesis.speak(utterance);\n```\n\n## instanceof测试练习\n```js\nObject instanceof Function\nFunction instanceof Object\n\nObject instanceof Object\nFunction instanceof Function\n// true\n```\n\n## 掘金头像旋转\n```css\n#pic:hover {\n    transform: rotate(666turn);\n    transition-delay: 1s;\n    transition-property: all;\n    transition-duration: 59s;\n    transition-timing-function: cubic-bezier(.34,0,.84,1);\n}\n```\n1. transform: rotate(666turn); 常见的用来旋转元素角度的css，这里用到的是turn，1turn = 360°\n2. transition-delay：1s; 这个属性的作用就是效果执行前的等待时间\n3. transition-property: all; 这个属性是指明效果变换的位置，比如width，height等，all是所有属性。\n4. transition-duration: 59s; 过渡效果的持续时间。\n5. transition-timing-function: cubic-bezier(.34,0,.84,1); 过渡效果的速度曲线 四个值的范围都是0-1 代表整个过程。\n\n## 时间轴\n```html\n<div class=\"timeline-content\">\n  <div v-for='(item, index) in timeLine' :key='index' class=\"time-line\">\n    <div :class=\"`state-${item.state} state-icon`\"></div>\n    <div class=\"timeline-title\">{{item.title}}</div>\n  </div>\n</div>\n```\n\n```css\n/** 时间轴 */\n.timeline-content{\n  display: flex;\n  .time-line{\n    padding: 10px 10px 10px 20px;\n    position: relative;\n    &::before{\n      content: '';\n      height: 1px;\n      width: calc(100% - 34px);\n      background: #EBEBEB;\n      position: absolute;\n      left: 24px;\n      top: 0;\n    }\n  }\n  .state-icon{\n    width: 20px;\n    height: 20px;\n    position: absolute;\n    top: -12px;\n    left: 0;\n  }\n  .state-1{\n    background: url('https://static.daojia.com/assets/project/tosimple-pic/fen-zu-7-copy-6bei-fen_1589266208621.png') no-repeat;\n    background-size: cover;\n  }\n  .state-2{\n    background: url('https://static.daojia.com/assets/project/tosimple-pic/12_1589266226040.png') no-repeat;\n    background-size: cover;\n  }\n  .state-3{\n    background: url('https://static.daojia.com/assets/project/tosimple-pic/fen-zu-7-copy-3_1589266140087.png') no-repeat;\n    background-size: cover;\n  }\n}\n```\n\n## 卡券效果\n```css\n.coupon{\n  width: 300px;\n  height: 100px;\n  position: relative;\n  background: radial-gradient(circle at right bottom, transparent 10px, #ffffff 0) top right /50% 51px no-repeat,\n    radial-gradient(circle at left bottom, transparent 10px, #ffffff 0) top left / 50% 51px no-repeat,\n    radial-gradient(circle at right top, transparent 10px, #ffffff 0) bottom right / 50% 51px no-repeat,\n    radial-gradient(circle at left top, transparent 10px, #ffffff 0) bottom left / 50% 51px no-repeat;\n  filter: drop-shadow(2px 2px 2px rgba(0,0,0,.2));\n}\n```\n\n## css禁用鼠标事件\n```css\n.disabled {\n    pointer-events: none;\n    cursor: default;\n    opacity: 0.6;\n}\n```\n\n## css禁止用户选择\n```css\nbody{\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n```\n\n## jquery添加扩展方法\n```js\n$.fn.stringifyArray = function(array) {\n  return JSON.stringify(array)\n}\n```\n\n- jquery.extend 与 jquery.fn.extend的区别？\n> jquery.extend 为jquery类添加类方法，可以理解为添加静态方法\n> 源码中jquery.fn = jquery.prototype所以jquery.fn.extend扩展，所有jquery实例都可以直接调用。\n\n```js\n// 多个事件同一个函数：\n$(\"div\").on(\"click mouseover\", function(){});\n// 多个事件不同函数\n$(\"div\").on({\n  click: function(){},\n  mouseover: function(){}\n});\n```\n\n## 万物转换(oﾟ▽ﾟ)o  \n```js\n'vue'.split('').sort().join('') // euv\n\n'node'.split('').sort().join('') // deno\n```\n\n## require.context实现自动化导入\n一个webpack的api,通过执行require.context函数获取一个特定的上下文,主要用来实现自动化导入模块,在前端工程中,如果遇到从一个文件夹引入很多模块的情况,可以使用这个api,它会遍历文件夹中的指定文件,然后自动导入,使得不需要每次显式的调用import导入模块\n\n\nrequire.context函数接受三个参数\n\n1. directory {String} -读取文件的路径\n\n2. useSubdirectories {Boolean} -是否遍历文件的子目录\n\n3. regExp {RegExp} -匹配文件的正则\n\n```js\n// 遍历当前目录下的test文件夹的所有.test.js结尾的文件,不遍历子目录\nrequire.context('./test', false, /.test.js$/);\n\n(r => {\nr.keys().forEach(r);\n})(require.context('./', true, /reducer.js/));\n```\n\n## img标签之间的间距问题原理\n众所周知，多个img并列显示时会有几像素间距，但是这并不是img标签特有的特性。\n\n### 原理\n> 实际上，所有display属性为inline ， inline-block 的盒模型都会有文字特性，间距就是由于两个标签之间的空白引起的。\n\n### 常用方案\n- 删除标签之间的空格\n```html\n<img src=\"img/test.jpg\" alt=\"\"><img src=\"img/test.jpg\" alt=\"\"><img src=\"img/test.jpg\" alt=\"\">\n```\n\n- 将父级设置为font-size: 0px：\n```html\n<div style=\"font-size: 0px\">\n  <img src=\"img/test.jpg\" alt=\"\">\n  <img src=\"img/test.jpg\" alt=\"\">\n  <img src=\"img/test.jpg\" alt=\"\">\n  <img src=\"img/test.jpg\" alt=\"\">\n  <img src=\"img/test.jpg\" alt=\"\">\n</div>\n```\n\n-  将父级设置为使用负margin去除边距\n```css\nimg {\n    margin-left: -8px;\n}\n```\n\n- 设置浮动\n```css\nimg {\n    float: left;\n}\n```\n\n## prettier script\n```js\n\"jsformat\": \"prettier --write \\\"./**/*.js\\\"\"\n\n{\n\"editor.formatOnSave\": true,\n\"files.autoSave\": \"off\",\n\"git.ignoreMissingGitWarning\": true,\n\"git.enableSmartCommit\": true,\n\"fileheader.Author\": \"chenyu\",\n\"fileheader.LastModifiedBy\": \"chenyu\",\n\"powermode.enabled\": false, // 屏振\n\"git.autofetch\": true,\n// tsconfig.json 文件会覆盖此设置。要求 TypeScript >=2.3.1。\n\"javascript.implicitProjectConfig.experimentalDecorators\": true,\n\"prettier.disableLanguages\": [\n\"vue\",\n\"markdown\"\n],\n\"vetur.format.defaultFormatter.html\": \"js-beautify-html\",\n\"javascript.updateImportsOnFileMove.enabled\": \"never\",\n\"files.associations\": {\n\".cjson\": \"jsonc\",\n\".wxss\": \"css\",\n\"*.wxs\": \"javascript\"\n},\n\"emmet.includeLanguages\": {\n\"wxml\": \"html\"\n},\n\"minapp-vscode.disableAutoConfig\": true\n}\n```\n\n## HTML - 输入框 Input 按回车 Enter 自动刷新页面解决方案\n\n### 原因\n在一个 form 表单中，若只有一个 input，按回车键表单会自动提交，但是当表单中存在多个 input 时，按回车键不会执行任何操作，这是 form 表单的一个特性。\n\n### 解决\n1. 直接去除掉 form 表单，当然这是最简单粗暴的方法。\n\n2. 如果一个 input 会自动提交，那么比较容易想到的是再加一个 input。值得注意的是 这里的 input 不能设置 type 为 hidden，这样一样是不生效的，form 一样会认为只有一个 input。需要设置成 <input type=\"text\" class=\"form-control\" style=\"display:none\"> 。\n\n3. 给 input 加上回车事件直接 return false。在 input 加上 οnkeydοwn=\"if(event.keyCode==13){return false;} 。\n\n4. 直接阻止 form 表单的提交，在 form 表单加入 οnsubmit=\"return false;\"。\n\n\n## 为什么ES模块比CommonJS更好?\n> ES模块是官方标准，也是JavaScript语言明确的发展方向，而CommonJS模块是一种特殊的传统格式，在ES模块被提出之前做为暂时的解决方案。 ES模块允许进行静态分析，从而实现像 tree-shaking 的优化，并提供诸如循环引用和动态绑定等高级功能。\n\n## 什么是 `tree-shaking`（树摇）\nTree-shaking, 也被称为 \"live code inclusion,\" 通常用于打包时移除js中未引用的代码(dead-code)，它依赖于ES6模块系统中的import 和 export 的**静态结构特性**\n\n- 虽然生产模式下默认开启，但是由于经过babel编译全部模块被封装成IIFE\n\n- IIFE存在副作用无法被tree-shaking掉，需要配置 { module: false } 和 sideEffects: false\n\n- rollup和webpack的shaking程度不同，以一个class为例子\n\n## scope hoisting\n> Scope hositing 作用:是将模块之间的关系进行结果推测，可以让webpack文件打包出来的代码文件更小、运行的更快\nscope hositing实现原理:分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中，但是前提是不能造成代码冗余， 因此只有哪些被引用了一次的模块可能被合并\n由于scope hositing 需要分析出模块之间的依赖关系，因此源码必须使用ES6模块化语句，不然就不能生效，原因和 tree shaking一样。\n\n## webpack优化\n### production模式自带优化\n- tree shaking\n- scope hoisting\n- 代码压缩混淆(UglifyJsPlugin)\n### css优化\n- css提取到独立文件(mini-css-extract-plugin)\n- postcss添加前缀\n- css压缩(optimize-css-assets-webpack-plugin)\n### js优化\n- 代码分离(code splitting)\n1. 入口起点：使用entry配置，手动的分离代码（配置多入口）\n```js\nentry:{\n main: './src/main.js',\n other: './src/other.js'\n},\n```\n2. 放置重复：使用 SplitChunksPlugin 去重和分离 chunk（抽取公共代码）\n```js\noptimization:{\n  splitChunks:{\n    chunks: \"all\"\n  }\n}\n```\n3. 动态导入：通过模块的内联函数调用来分离代码（懒加载）\nwebpack4默认是允许import语法动态导入的，但是需要babel的插件支持，最新版babel的插件包为:@babel/plugin-syntax-dynamic-import,需要注意动态\n导入最大的好处就是实现了懒加载，用到那个模块才会加载那个模块，可以提高SPA应用程序的首屏加载速度，三大框架的路由懒加载原理一样。\n\n### noParse(缩小文件搜索范围)\n在引入一些第三方模块时，如jq等，我们知道其内部肯定不会依赖其他模块，因为我们用到的只是一个单独的js或者css文件，所以此时如果webpack再去解析他们的内部依赖关系，其实是非常浪费时间的，就需要阻\n止webpack浪费精力去解析这些明知道没有依赖的库，可以在webpack的配置文件的module节点下加上noParse，并配置正则来确定不需要解析依赖关系的模块\n```js\nmodule:{\n noParse: /jquery|bootstrap/  // jquery|bootstrap 之间不能加空格变成 jquery | bootstrap， 会无效\n}\n```\n- 通过 include 和 exclude 缩小命中范围\n- 优化 resolve.modules 配置，指明存放第三方模块的绝对路径，减少寻找时间。\n- 优化 resolve.alias/extensions配置\n\n### DLLPlugin、DllReferencePlugin(预编译资源模块提高打包速度)\n在引入一些第三方模块时，例如Vue、React等，这些框架的文件一般都是不会修改的，而每次打包都需要去解析他们，也会影响打包速度，就算是做了拆分，也只是提高了上线后的用户访问速度，并不会提高构建速度，所以如果需要提高构建速度，应该使用动态链接库的方式，类似windows的dll文件借助DLLPlugin插件实现将这些框架作为一个个的动态链接库，只构建一次，以后的每次构建都只会生成自己的业务代码，可以很好的提高构建效率。\n\n> 将库和项目代码分离打包需要 dll 映射文件\n\n主要思想在于，将一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这些代码进行打包，从而节省了打包时间，主要使用两个插件: DLLPlugin和DLLReferencePlugin\n需要注意的是，若是使用的DLLPlugin，CleanWebpackPlugin插件会存在冲突，需要移除CleanWebpackPlugin插件\n\n### 配置缓存（提高打包速度，插件自带 babel-loader开启，不支持的可以用 cache-loader）\n\n### 使用 HappyPack 开启多进程 Loader 转换（webpack4推荐thread-loader）\n```js\nrules: [\n  {\n    test: /\\.js$/,\n    include: path.resolve(\"src\"),\n    use: [\n      \"thread-loader\",\n      // your expensive loader (e.g babel-loader)\n    ]\n  }\n]\n```\n\n```js\nrules: [\n  {\n    test: /.js$/,\n    use: 'happypack/loader',\n  }\n],\nplugins: [\n  new HappyPack({\n    loaders: [ 'babel-loader?presets[]=es2015' ]\n  })\n];\n```\n\n### 使用 include 或 exclude 加快文件查找速度\n\n### IgnorePlugin\n在引入一些第三方模块时，例如momentJS、dayJS，其内部会做i18n处理，所以会包含很多语言包，而语言包打包时会比较占用空间，如果项目只需要用到中文或者少数语言，可以忽略掉所有的语言包，然后按需引\n入语言包，从而使得构建效率更高，打包生成的文件更小\n\n## 分析优化\n在打包时，合理使用插件speed-measure-webpack-plugin和webpack-bundle-analyzer，可以对项目构建过程中的每个loader、plugin等进行耗时统计，并针对耗时的操作进行优化，打包结果可以进行体积的大\n小的控制和优化。\n\n## windows更新计算机策略\n```bash\ngpupdate /force\n```\n\n## 有一个数字字符串，它所代表的数字远大于js所能表示的最大数，可能有两万位，这样的数字你怎么判断它能不能被6整除\n1. 调接口放到后台处理\n2. 最后一位被2整除 && 所有位加起来被3整除\n```js\nfunction isValid(str) {\n  const arr = str.split('')\n  return Number(arr[arr.length -1]) %2 === 0 && arr.reduce((total, num) => total + num, 0) % 3 === 0\n}\n```\n\n3. 高位判断\n最大安全数 2**53 -1 // 9007199254740991\n因为js用的是IEEE754标准，小数有效位为52位，加上默认的1一共是53位，超过这个就无法保持精确了。\n```js\nfunction isValid(str) {\n  const arr = str.split('')\n  let temp = 0\n  for (let i of arr) {\n    temp = i * temp + parseInt(i , 10)\n    temp = temp % 6\n  }\n  if (temp === 0) {\n    return true\n  } else {\n    return false\n  }\n}\n```\n\n## 什么时候适合使用 Map 而不是 Object\n「Map」映射是一种经典的数据结构类型，其中数据以 「key/value」 的键值对形式存在\n||Map|Object|\n|:--|:--:|--:|\n|默认值|默认不包含任何值，只包含显式插入的键|一个 Object 有一个原型，原型上的键名有可能和自己对象上设置的键名冲突|\n|类型|任意|String 或 Symbol|\n|长度|键值对个数通过 size 属性获取|键值对个数只能手动计算|\n|性能|频繁增删键值对的场景下表现更好|频繁添加和删除键值对的场景下未作出优化|\n\n>「Map」 是可迭代的，可以直接进行迭代，例如forEach循环或者for...of...循环\n\n### 遍历Object\n```js\nfor(const key of Object.keys(object)) {\n  console.log(key);\n}\n// key1\n// key2\n// key3\n\nfor(const value of Object.values(object)) {\n  console.log(value);\n}\n// value1\n// value2\n// value3\n\nfor(const entry of Object.entries(object)) {\n  console.log(entry);\n}\n// [\"key1\", \"value1\"]\n// [\"key2\", \"value2\"]\n// [\"key3\", \"value3\"]\n\nfor(const [key,value] of Object.entries(object)) {\n  console.log(key,value);\n}\n//\"key1\", \"value1\"\n//\"key2\", \"value2\"\n//\"key3\", \"value3\"\n\n// for in遍历\nfor(const key in object) {\n  console.log(key);\n}\n// key1\n// key2\n// key3\n```\n\n## JS中的宿主对象与原生对象有何不同？\n宿主对象:这些是运行环境提供的对象。这意味着它们在不同的环境下是不同的。例如，浏览器包含像windows这样的对象，但是Node.js环境提供像Node List这样的\n对象。 \n\n原生对象:这些是JS中的内置对象。它们也被称为全局对象，因为如果使用JS，内置对象不受是运行环境影响。\n\n## maven配置环境变量\n> path配置需要具体的路径\n\n## 个人使用觉得最好的word转pdf在线网站\n- https://www.addpdf.cn/word-to-pdf\n\n- http://www.ilovepdf.com/zh_cn\n\n- https://smallpdf.com/\n\n## knife4j 增强swagger的UI\n正则就是有限的状态机\n\n## mysql迁移postgresql问题记录：\n\n1. jdbc连接字符串需要指定当前schema jdbc:postgresql://193.160.26.65:5432/engine?useUnicode=true&characterEncoding=utf-8&currentSchema=faker_vmware\n\n2. postgresql列名是区分大小写的，大写的列名需要加上双引号\n\n3. mysql没有bool数据类型，用的tinyint(1)，sql语句中where flag = false迁移报错，pg用的int(2)\n\n4. ON DUPLICATE KEY UPDATE 重复插入约束 => on conflict (id) do update set\n\n5. 在pg中的sql，单引号用来标识实际的值，双引号用来标识表名（table name）或列名（column name）等数据库中存在的值\n\n## Typed Arrays \n一个TypedArray 对象描述一个底层的二进制数据缓存区的一个类似数组(array-like)视图\n\n## markdown github stats\n- ![my github stats](https://github-readme-stats.vercel.app/api?username=cosyer&show_icons=true&hide_border=true&hide=contribs,prs)\n\n- ![主要使用语言](https://github-readme-stats.vercel.app/api/top-langs/?username=cosyer)\n\n## 微信分享 hash 路由填坑记录\n```js\nencodeURIComponent(window.location.href.split('#')[0])\n```\n\n## simple-icons\n\n![github](https://cdn.jsdelivr.net/npm/simple-icons@3.1.0/icons/github.svg)\n\n![github](http://simpleicons.p2hp.com/icons/github.svg)\n\n## Promise题目\n```js\nPromise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log)\n// 1 then的参数为回调函数 then(2)就断掉了 链式调用\n// 可选链\na?.b?.c \n```\n\n## mock总结\n### json-server\nmock文件夹配置db.json\n```js\n{\n  \"rankList\": []\n}\n// 访问localhost:port/api/rankList\n```\n\n## 点击input事件触发的顺序\n```js\nconst text = document.getElementById('text');\ntext.onclick = function (e) {\n  console.log('onclick')\n}\ntext.onfocus = function (e) {\n  console.log('onfocus')\n}\ntext.onmousedown = function (e) {\n  console.log('onmousedown')\n}\ntext.onmouseenter = function (e) {\n  console.log('onmouseenter')\n}\n// onmouseenter\n// onmousedown\n// onfocus\n// onclick\n```\n\n## 计算页面停留时间\n1. websocket，前端开个长连接，后台统计长连接时间。\n2. ajax轮询，隔几秒发一个查询，后台记录第一与最后一个查询间隔时间。\n3. 关闭窗口或者跳转的时候会触发window.onbeforeunload函数，可以在该函数中做处理（有兼容性问题）；统计完数据记录到本地cookies中，一段时间后统一发送\n\n## 二维码如何工作\n1. pc端随机生成一个含有唯一uid的二维码，并与服务器建立一个长连接；\n2. 手机扫描二维码，解析出二维码中的uid，并把这个uid和手机端的用户密码进行绑定，上传给服务器；\n3. 服务器获得客户端信息之后，pc端的长连接轮询操作会获得该消息，显示该账号的信息；\n4. pc端会再开一个长连接与手机端保持通信，等待手机端确认登陆后，获得服务器授权的token，就可以在pc端登陆进行正常通信了\n","tags":["知识"],"categories":["知识"]},{"title":"快速了解React 16新特性","url":"%2Freact16.html","content":"\n## Error Boundary\n\nError Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）\n\n---\n<!-- more -->\n\n```javascript\n//最佳实践：将ErrorBoundary抽象为一个公用的组件类\n \nimport React, { Component } from 'react'\n \nexport default class ErrorBoundary extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  componentDidCatch(err, info) {\n    this.setState({ hasError: true })\n    //sendErrorReport(err,info)\n  }\n  render(){\n    if(this.state.hasError){\n      return <div>Something went wrong!</div>\n    }\n    return this.props.children\n  }\n}\n```\n\n```javascript\n// 使用方式 包裹容易出错的组件\nrender(){\n  return (\n    <div>\n      <ErrorBoundary>\n        <Profile user={this.state.user} />\n      </ErrorBoundary>\n      <button onClick={this.onClick}>Update</button>\n    </div>\n  )\n}\n```\n## render方法新增返回类型\n在React 16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。\n\n```javascript\n//string\nrender(){\n  return 'hello,world'\n}\n \n//number\nrender(){\n  return 12345\n}\n \n//boolean\nrender(){\n  return isTrue?true:false\n}\n \n//null\nrender(){\n  return null\n}\n \n//fragments，未加key标识符，控制台会出现warning\nrender(){\n  return [\n    <div>hello</div>,\n    <span>world</span>,\n    <p>oh</p>\n  ]\n}\n```\n以上各种类型现在均可以直接在render中返回，不需要再在外层包裹一层容器元素，不过在返回的数组类型中，需要在每个元素上加一个唯一且不变的key值，否则控制台会报一个warning。\n\n## 16.2 增加 Fragment 组件，其作用是将一些子元素添加到 DOM tree 上且不需要为这些元素提供额外的父节点，相当于 render 返回数组元素\n\n## 增加 React.memo() API，它只能作用在简单的函数组件上，本质是一个高阶函数，可以自动帮助组件执行\n\n## 增加 React.lazy() API，它提供了动态 import 组件的能力，实现代码分割\n\n## 使用createPortal将组件渲染到当前组件树之外\n\n## 支持自定义DOM属性\n在之前的版本中，React会忽略无法识别的HTML和SVG属性，自定义属性只能通过data-*形式添加，现在它会把这些属性直接传递给DOM（这个改动让React可以去掉属性白名单，从而减少了文件大小）。\n\n## setState传入null时不会再触发更新\n\n## 更好的服务器端渲染\nReact 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。\n\n## 新的打包策略\n新的打包策略中去掉了process.env检查。\nReact 16的体积比上个版本减小了32%（30% post-gzip），文件尺寸的减小一部分要归功于打包方法的改变。\n\n## React 16采用了新的核心架构React Fiber。官方解释是“React Fiber是对核心算法的一次重新实现”\n\n- 时间切片\n\n- 任务调度\n","tags":["react"],"categories":["React"]},{"title":"React 16新特性context api","url":"%2Fcontextapi.html","content":"\nReact 16.3带来了正式版的context API。让我们来看看有哪些改变，在那些地方可以取代redux吧！\n\n--- \n<!-- more -->\n\n我当前依赖的版本\n\n```javascript\n\"dependencies\": {\n    \"react\": \"^16.4.0\",\n    \"react-dom\": \"^16.4.0\"\n}\n```\n## 创建context实例\n```javascript\n// 创建context实例\nconst ThemeContext = React.createContext({\n  background: 'red',\n  color: 'white'\n});\n\nconst {Provider,Consumer} = ThemeContext\n```\n\n## Provider 组件 \n**Provider组件用于将context数据传给该组件树下的所有组件 value属性是context的内容。**\n\n```javascript\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider value={{ text: 'hello react!' }}>\n        <Comp1 />\n        <Comp2 />\n      </Provider>\n    );\n  }\n}\n```\n## Consumer 组件\n**Consumer消费Provider传递的数据**\n\n```javascript\n// 函数式\nconst Comp1 = () => (\n  <Consumer>\n    {context => <p>{context.text}</p>}\n  </Consumer>\n);\n// 类\nclass Comp2 extends React.Component {\n  render() {\n    return (\n      <Consumer>\n        {context => <p>{context.text}</p>}\n      </Consumer>\n    );\n  }\n}\n```\n如果你没有将Consumer作为Provider的子组件，那么Consumer将使用创建context时的参数作为context。","tags":["react"],"categories":["JS"]},{"title":"如何理解JS闭包","url":"%2Fclosure.html","content":"\n{% centerquote %} \nJavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。\n{% endcenterquote %} \n\n在JS中函数作为普通对象进行传递\n\n--- \n<!-- more -->\n## 什么是闭包?(属于一种特殊的作用域，称为 静态作用域)\n简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。(函数和声明该函数的词法环境的组合)子函数所在的父函数的作用域不会被释放。\n\n## 为什么需要闭包？\n使用闭包主要是为了设计私有的变量和方法。闭包的优点可以避免全局变量的污染，让变量始终保存在内存中，缺点是会常驻内存，增大内存的使用\n量，使用不当会造成内存泄漏。\n\n## 特点\n1. 定义外层函数，封装被保护的局部变量。 \n2. 定义内层函数，执行对外部函数变量的操作。 \n3. 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。\n\n## 特性\n1. 函数嵌套函数，内层函数被返回。\n2. 函数内部可以引用外部的参数和变量，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。\n3. 参数和变量不会被垃圾回收机制回收。\n\n## 实例\n```javascript\nvar add = (function () {\n    var counter = 0;\n    return function () {return counter += 1;}\n})();\nadd();\nadd();\nadd();\n// add()调用过后应当销毁其变量，但其内层函数被返回了，并且还保留着对变量的引用，所以没有销毁还保留在内存当中。\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(i)\n},i*1000)\n}\n// 打印3次3 执行setTimeout时for循环已经结束此时的i的值为3\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\n// 匿名闭包 封闭每个变量\n(function(index){\n  setTimeout(function(){\n  console.log(arr[index])\n},index*1000)\n})(i)\n} \n// one two three\n```\n\n避免使用过多的闭包，可以用let关键词，每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。\n\n```javascript\nvar arr=['one','two','three']\nfor(let i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(arr[i])\n},i*1000)\n}\n```\n\n```javascript\n// setTimeout(code, milliseconds, param1, param2, ...)\n// setTimeout(function, milliseconds, param1, param2, ...)\nvar i = 0\nwhile (i++ < 3) {\n  setTimeout(console.log, 0, i)\n}\n// 1 2 3 这个也是闭包\n```\n\n## 经典问题\n多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。\n\n解决:\n- 变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找\n- 使用setTimeout包裹，通过第三个参数传入\n- 使用 块级作用域，让变量成为自己上下文的属性，避免共享\n","tags":["闭包"],"categories":["JS"]},{"title":"使用 Async/Await 让你的代码更简洁","url":"%2Fes7async.html","content":"\nAsync/Await是一种允许我们像构建没有回调函数的普通函数一样构建Promise的新语法。以往的异步方法无外乎回调函数和`Promise`。但是Async/Await建立于[Promise](https://mydearest.cn/createPromise.html)之上。\n\n---\n<!-- more -->\n\n## Async/Await语法\n### async关键字(放置在一个函数前面)。\n\n```javascript\nasync function f() {\n    return 1\n    // return Promise.resolve(1)\n}\nf().then(value) // 1\n```\n\nasync修饰过的函数总是返回一个promise，如果代码中有return <非promise>语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。\n### await关键字(只能在async函数内部使用)\n关键词await可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行。\n\n```javascript\nfunction timeout(ms) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n### 错误处理(使用try-catch捕获)可以给每个 await 后的 Promise 增加 catch 方法；也可以将 await 的代码放在 try...catch 中\n```javascript\nasync function f() {\n    try {\n        let response = await fetch('http://no-such-url')\n    } catch (err) {\n        alet(err) // TypeError: failed to fetch 也能捕获多行语句 类似链式Promise最后的单个catch函数\n    }\n}\nf()\n```\n\n如果我们不使用try-catch，然后async函数f()的调用产生的promise变成reject状态的话，我们可以添加.catch去处理它：\n\n```javascript\nasync function f() {\n    let response = await fetch('http://no-such-url')\n}\n// f()变成了一个rejected的promise\nf().catch(alert) // TypeError: failed to fetch\n```\n\n```js\nasync function getData() {\n  try {\n    if (true) {\n      throw Error(\"Catch me if you can\");\n    }\n  } catch (err) {\n    console.log(err.message);\n  }\n}\ngetData()\n  .then(() => console.log(\"I will run no matter what!\"))\n  .catch(() => console.log(\"Catching err\"));\n```\nthrow 抛出的错误永远不会触发**getData()**的catch方法。\n\n```js\nasync function getData() {\n  try {\n    if (true) {\n      return Promise.reject(\"Catch me if you can\");\n    }\n  } catch (err) {\n    console.log(err.message);\n  }\n}\n```\n\n### 结合Promise.all\nasync/await能够与Promise.all友好的协作，当我们需要等待多个promise时，我们可以将他们包装在Promise.all中然后使用await：\n\n```javascript\n// 直到数组全部返回结果\nlet results = await Promise.all([\n   fetch(url1),\n   fetch(url2),\n   ...\n])\n```\n\n## 简单实现async函数\n```js\nfunction spawn(genF) {\n    return new Promise(function(resolve, reject) {\n        const gen = genF();\n        function step(nextF) {\n            let next;\n            try {\n                next = nextF();\n            } catch (e) {\n                return reject(e);\n            }\n            if (next.done) {\n                return resolve(next.value);\n            }\n            Promise.resolve(next.value).then(\n                function(v) {\n                    step(function() {\n                        return gen.next(v);\n                    });\n                },\n                function(e) {\n                    step(function() {\n                        return gen.throw(e);\n                    });\n                }\n            );\n        }\n        step(function() {\n            return gen.next(undefined);\n        });\n    });\n}\n```\n\n## Promises 组合：Promise.all，Promise.allSettled， Promise.any\n- Promise API 提供了许多将Promise组合在一起的方法。 其中最有用的是Promise.all，它接受一个Promises数组并返回一个Promise。 如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。\n\n- Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。\n\n- 较新版本的V8也将实现两个新的组合：Promise.allSettled和Promise.any。 Promise.any仍然处于提案的早期阶段：在撰写本文时，仍然没有浏览器支持它。\n\nPromise.any可以表明任何Promise是否fulfilled。 与 Promise.race的区别在于Promise.any不会拒绝即使其中一个Promise被拒绝。\n\n无论如何，两者中最有趣的是 Promise.allSettled，它也是 Promise 数组，但如果其中一个Promise拒绝，它不会短路。 当你想要检查Promise数组是否全部已解决时，它是有用的，无论最终是否拒绝，可以把它想象成Promise.all 的反对者。\n\n## 总结\n\n随着单页JavaScript web程序的兴起和对NodeJS的广泛采用，如何优雅的处理并发对于JavaScript开发人员来说比任何以往的时候都显得更为重要。\n\nJS引擎是单线程的，这意味着运行函数只有一个调用堆栈。这一限制是JS异步本质的基础:所有需要时间的操作都必须由外部实体(例如浏览器)或回调函数负责。\n\n`Async/Await`缓解了许多因为控制流问题而导致bug遍地的这个困扰着JavaScript代码库数十年的问题，并且几乎可以保证让任何异步代码块变的更精炼，更简单，更自信。","tags":["promise"],"categories":["JS"]},{"title":"从 for 循环入手优化性能","url":"%2Fforloop.html","content":"\n今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？\n\n---\n<!-- more -->\n\n从最简单的遍历数组说起。\n\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet i = 0;\nlet arr = [];\nwhile (i < 50) {\n    arr.push(i);\n    i++;\n}\n```\n\n如果我们想从数组 arr 中取出数据，就必须要进行遍历，普遍的做法是：\n\n```javascript\nfor (let i = 0; i < arr.length; i++) {\n    // arr[i]\n}\n```\n\n但其实这样的写法遍历是最慢的，他要经过两次迭代，第一次是 i 的迭代，每次都要判断 i 是否小于 arr.length，第二次是 arr 的迭代，每次循环 arr 都会调用底层的迭代器，对长度进行计算，这样循环的效率非常低，时间空间复杂度为 O[n^2]。\n\n下面进行优化，看看两者到底有什么区别：\n\n```javascript\nfor (let i = 0, len = arr.length; i < len; i++) {\n    // arr[i]\n}\n```\n\n区别就是，整个循环当中，我们预存了 len 来保存数组的长度，这样不需要每次循环都调用底层迭代器，调用一次即可，这样的时间空间复杂度为 O[n+1]。\n\n但是这并不是最完美的，因为会多了一次迭代操作，那么该如何进行优化呢？\n\n```javascript\nfor (let i = 0, item; item = arr[i++];) {\n    // item\n}\n```\n这次迭代的时间空间复杂度为 O[n] ，完美做到了每次一迭代没有通过长度进行判断，而是直接通过下标进行取值的方式映射到了循环体内部。\n\n最后用5万条数据进行测试各种方式的循环时间：\n\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet index = 0;\nlet arr = [];\nwhile (index < 50000) {\n    arr.push(index);\n    index++;\n}\n\nconsole.time('one');\nfor (let i = 0; i < arr.length; i++) {\n\n}\nconsole.timeEnd('one');\n\nconsole.time('two');\nfor (let i = 0, len = arr.length; i < len; i++) {\n\n}\nconsole.timeEnd('two');\n\nconsole.time('three');\nfor (let i = 0, item; item = arr[i++];) {\n\n}\nconsole.timeEnd('three');\n\n// es6的数组遍历\nconsole.time('four');\nfor (let i of arr) {\n\n}\nconsole.timeEnd('four');\n// 会访问可枚举属性和原型的遍历，数组不推荐使用\nconsole.time('five');\nfor (let i in arr) {\n\n}\nconsole.timeEnd('five');\n// one: 0.711ms\n// two: 4.508ms\n// three: 0.006ms\n// four: 3.255ms\n// five: 11.144ms\n```\n在数据量大的情况下，第三种循环方式效果显而易见。\n\n## 为什么普通 for 循环的性能远远高于 forEach 的性能\n\n- 区别：\n\n一个按顺序遍历，一个使用iterator迭代器遍历；\n\n- 从数据结构来说：\n\nfor循环是随机访问元素，foreach是顺序链表访问元素；\n\n- 性能上：\n\n对于arraylist，是顺序表，使用for循环可以顺序访问，速度较快；使用foreach会比for循环稍慢一些。\n对于linkedlist，是单链表，使用for循环每次都要从第一个元素读取next域来读取，速度非常慢；使用foreach可以直接读取当前结点，数据较快；\n","tags":["性能优化"],"categories":["JS"]},{"title":"es6函数新特性","url":"%2Fes6function.html","content":"\n1. 设置函数默认值 \n2. 结合解构赋值默认值使用\n3. 利用rest(...变量名)传入任意参数\n\n---\n<!-- more -->\n\n## ...rest和扩展运算符\nrest参数（…变量名），用于获取函数的多余参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入其中。\n```javascript\nfunction foo(...y){\n    console.log(y)  // [1,2,3,4]\n}\nfoo(1,2,3,4)\n```\n## 利用扩展运算符（…数组）替代数组的apply方法\n在es5中，需要用apply将数组转化为函数参数，在es6中就不需要这种方式了，可以使用…来代替\n```javascript\nfunction f(x, y, z) {\n    console.log(x + ' ' + y + ' ' + z);\n}\nvar args = [1, 2, 3];\n// f.apply(null, args)\nf(...args)\n```\n\n数组push的例子：\n```javascript\nvar arr1 = [0, 1, 2]\nvar arr2 = [3, 4, 5]\nvar arr3 = arr1.concat(arr2)\nconsole.log(arr3) //[ 0, 1, 2, 3, 4, 5 ]\n\nvar arr4 = arr1.push(arr2)\nconsole.log(arr1) //[ 0, 1, 2, [ 3, 4, 5 ] ]\n```\n\n如果想使用arr1.push方法的话，就需要用apply传arr2了\n```javascript\nvar arr4 = Array.prototype.push.apply(arr1, arr2) //[ 0, 1, 2, 3, 4, 5 ]\n```\n\n如果使用扩展运算符的话，就简单一些了\n```javascript\nvar arr4 = arr1.push(...arr2)\n```\n\n## name属性\n函数的name属性可以返回函数名\n```javasctrpt\nfunction abc(){\n    console.log(abc.name)\n}\nabc() // 'abc'\n```\n\n## 函数的静态变量和函数\n```javascript\nfunction Box(){}\n\nBox.num = 12;  //静态变量\nBox.fn = function(){};  //静态函数\n\nconsole.log(Box.num);  //12\nconsole.log(Box.fn);  //function(){}\nconsole.log(typeof Box.fn);  //function\n\nvar t = new Box();\nconsole.log(t.num);  //undefined\nconsole.log(t.fn);  //undefined\nconsole.log(typeof t.fn);//undefined\n```\n\n静态变量和静态函数是Box对象的属性和方法，不属于实例。\n\n## 函数的实例函数和变量\n```javascript\nfunction Box(){\n  this.a = [];  //实例变量\n  this.fn = function(){};  //实例方法\n}\n\nconsole.log(Box.a);  //undefined\nconsole.log(Box.fn);  //undefined\nconsole.log(typeof Box.fn);  //undefined\n\nvar t = new Box();\nvar t2 = new Box();\n\nconsole.log(t.a);  //[]\nconsole.log(t2.a);  //[]\nt.a.push(1);   // t.a [1]\nconsole.log(t2.a);  //[]\n\nconsole.log(typeof t.fn);\n```\n每个实例都有一套实例属性和实例方法，互不影响。\n\n原型上的属性和方法，是实例共用的。\n\n## 函数传参\n\n### 基本类型 (基本类型的变量复制)\n```javascript\nvar count = 10;\nfunction num(num1){\n   num1 = 1;\n   return num1;\n}\nvar result = num(count);\nconsole.log(result);//1\nconsole.log(count);//10，并未变成1\n```\n### 引用类型\n```javascript\nvar person  = {\n    name : \"Tom\"\n};\nfunction obj(peo){\n    peo.name = \"Jerry\";\n    return peo;\n}\nvar result = obj(person);\nconsole.log(result.name);// Jerry\nconsole.log(person.name);// Jerry\n```\n\n```javascript\nvar person = {\n    name : \"Tom\"\n}; \nfunction obj(peo){\n    peo = {\n       name : \"Jerry\"\n    };\n    return peo;\n}\nvar result = obj(person);\nconsole.log(result.name);// Jerry\nconsole.log(person.name);// Tom\n```\nperson传递给函数中的peo，但在函数内部peo又指向了一个新对象，所以result.name是新对象的值，person还是指向原对象，所以并没有改变。\n\nECMAScript中所有函数的参数都是按值传递的。 ——《JS高程》\n\n我们可以把ECMAScript函数的参数想象成局部变量，在向参数传递基本类型的值时，被传递的值被复制给一个局部变量。\n\n在向函数传递引用类型时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。\n\n即使在函数内部修改了参数的值，但原始的引用仍然保持未变。\n\n## 尾调用优化\n\n### 介绍\n尾调用指某个函数的最后一步是调用另一个函数。\n### demo\n```javascript\nfunction f(x) {\n    let y = g(x);\n    return y\n}//不是尾调用，因为最后一步返回了y，不是调用函数\n\nfunction f(x) {\n    return g(x) + 1\n}//不是尾调用，因为最后一步是加一，不是调用函数\n\nfunction f(x) {\n    g(x)\n}//不是尾调用，因为函数的最后一步是一个默认的return undefined；\n\nfunction f(x) {\n    return g(x)\n}//是尾调用\n```\n\n### 为什么尾调用\n函数调用会在内存形成一个“调用记录”，又称“调用帧”。每形成一个调用帧就会占用一定的内存，假如有一个函数A里面调用了函数B，函数B里面又调用了函数C，以此类推。\n\n在不是尾调用的情况下，因为js是单线程同步的，所以只有当函数B执行完毕才会执行函数A的return语句（函数没写return会有一个默认的return undefiend；），此时函数B的调用帧才会消失。但事实上，只有当函数B执行到return语句时才会执行完毕，而在函数B执行return之前会先调用函数C，所以当这种函数调用越来越多的时候，形成的调用帧也会越来越多占用的内存就会越来越大。俗话说精满自溢，内存也会有溢出的时候是吧，这就不行了！所以要用尾调用！\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\n比如在执行递归的时候就可以利用尾调用达到优化内存的目的。函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n```javascript\n// 递归 计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) \nfunction factorial(n) {\n    if (n === 1) return 1;\n    return n * factorial(n - 1)\n}\nfactorial(5) //120\n\n// 改成尾递归，只保留一个调用记录，复杂度 O(1) \nfunction factorial(n, total) {\n    if (n === 1) return total;\n    return factorial(n - 1, n * total)\n}\nfactorial(5, 1) //120\n```\n\n## 函数声明覆盖\n```javascript\nfunction foo(){\nconsole.log(\"foo\");\n}\n\nvar foo = 1;\n// 1 如果foo不赋值 则打印函数\n```","tags":["es6"],"categories":["JS"]},{"title":"JavaScript 中 this 的详解","url":"%2Fjsthis.html","content":"\n## this 的指向\n\n`this` 是 js 中定义的关键字， 它的指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。在实际应用中，`this`的指向大致可以分为以下四种情况。\n\n> this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁(取决于函数的调用位置)，实际上this的最终指向的是那个调用它的对象(函数的直接调用者);\n\n---\n<!-- more -->\n### 作为普通函数调用(直接调用)：函数名()\n当函数作为一个普通函数被调用，`this`指向全局对象。在浏览器里，全局对象就是 window。\n\n```javascript\nwindow.name = 'cosyer';\nfunction getName(){\n    console.log(this.name);\n}\ngetName();                   // cosyer\n```\n可以看出，此时`this`指向了全局对象 window。(NodeJS的全部对象是global)\n在ECMAScript5的严格模式下，这种情况`this`已经被规定不会指向全局对象了，而是undefined。\n\n```javascript\n'use strict';\nfunction fun(){\n    console.log(this);\n}\nfun();                      // undefined\n```\n### 作为对象的方法调用\n当函数作为一个对象里的方法被调用，`this`指向该对象\n\n```javascript\nvar obj = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\n\nobj.getName();              // cosyer\n```\n如果把对象的方法赋值给一个变量，再调用这个变量：\n\n```javascript\nvar obj = {\n    fun1 : function(){\n        console.log(this);\n    }\n}\nvar fun2 = obj.fun1;\nfun2();                     // window\n```\n此时调用 fun2 方法 输出了 window 对象，说明此时`this`指向了全局对象。给 fun2 赋值，其实是相当于：\n\n```javascript\nvar fun2 = function(){\n    console.log(this);\n}\n```\n可以看出，此时的`this`已经跟 obj 没有任何关系了。这时 fun2 是作为普通函数调用。\n\n### 作为构造函数调用\njs中没有类，但是可以从构造器中创建对象，并提供了`new`运算符来进行调用该构造器。构造器的外表跟普通函数一样，大部分的函数都可以当做构造器使用。当构造函数被调用时，`this`指向了该构造函数实例化出来的对象。\n\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n}\nvar obj = new Person();\nconsole.log(obj.name);      // cosyer\n```\n如果构造函数显式的返回一个对象(function或者object)，那么`this`则会指向该对象。\n\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n    return {\n        name : 'chenyu'\n    }\n}\nvar obj = new Person();\nconsole.log(obj.name);      // chenyu\n```\n如果该函数不用`new`调用，当作普通函数执行，那么`this`依然指向全局对象。\n\n### call() 或 apply() 调用 Function.prototype.bind()将当前函数绑定到指定对象绑定返回新函数之后再进行调用(间接调用、显示绑定)\n通过调用函数的 call() 或 apply() 方法可动态的改变`this`的指向。\n\n```javascript\nvar obj1 = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\nvar obj2 = {\n    name : 'chenyu'\n}\n\nobj1.getName();             // cosyer\nobj1.getName.call(obj2);    // chenyu\nobj1.getName.apply(obj2);   // chenyu\n```\n**简单的实现bind方法**\n\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 自定义的函数，模拟 bind() 对 this 的影响\nfunction myBind(func, target) {\n    return function() {\n        return func.apply(target, arguments); // 第一个参数为函数运行的this指向\n    };\n}\n\nconst testObj = myBind(test, obj);\ntest();     // false\ntestObj();  // true\n```\n从上面的示例可以看到，首先，通过闭包，保持了 target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this。\n\n不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行\n\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 绑定到一个新对象，而不是 obj\nconst testObj = test.bind({});\ntest.apply(obj);    // true\n\n// 期望 this 是 obj，即输出 true\n// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\ntestObj.apply(obj); // false\n```\n\n## 一道this练习题\n```javascript\nvar length = 10;\nfunction fn() {\n    console.log(this.length)\n};\nvar obj = {\n    length: 5, \n    method: function (fn) {\n        fn();\n        arguments[0](); // this被绑定到arguments上，而arguments确实存在一个length属性，并且值为2\n        fn.call(obj, 12);\n    }\n};\nobj.method(fn, 1);\n// 10 2 5\n```\n\n1. 默认绑定\n2. 隐式绑定\n3. 显示绑定\n4. new绑定\n> 默认绑定就是什么都匹配不到的情况下，非严格模式this绑定到全局对象window或者global,严格模式绑定到undefined;\n> 隐式绑定就是函数作为对象的属性，通过对象属性的方式调用，这个时候this绑定到对象;\n> 显示绑定就是通过bind、apply和call调用的方式;\n> new绑定就是通过new操作符时将this绑定到当前新创建的对象中\n\n优先级： new>显示>隐式>默认\n\n## 箭头函数 \n{% note info %}\n箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对`this`的词法解析。\n在箭头函数出现之前，每个新定义的函数都有其自己的`this`值（例如，构造函数的`this`指向了一个新的对象；严格模式下的函数的`this`值为 undefined；如果函数是作为对象的方法被调用的，则其`this`指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。\n{% endnote %}\n\n### ES6 的箭头函数 ()=>，指向与一般function定义的函数不同，比较容易绕晕，箭头函数`this`的定义：箭头函数中的`this`是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的`this`，它的`this`是派生而来的。箭头函数会捕获其所在上下文的`this`值，作为自己的`this`值，即它会根据外层(函数或者全局)作用域继承 this(直接外层函数)。\n\n箭头函数将this指向其封闭的环境(也称“词法作用域”)。\n\n### 基础语法\n```javascript\n// 等价于: => { return expression; } \n(param1, param2, …, paramN) => { statements }\n(param1, param2, …, paramN) => expression\n\n// 如果只有一个参数，圆括号是可选的:\n(singleParam) => { statements }\nsingleParam => { statements }\n\n// 无参数或者多参数的箭头函数需要使用圆括号或者下划线:\n() => { statements } _ => { statements }\n```\n### 高级语法\n```javascript\n// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:\nparams => ({foo: bar})\n\n// 支持 Rest parameters 和 default parameters:\n(param1, param2, ...rest) => { statements }\n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }\n\n// 支持参数列表中的解构赋值\nvar f = ([a, b] = [1, 2], c=3 ) => a + b + c;\nf(); // 6\n```\n\n### 箭头函数不可以使用arguments对象，super或new.target\narguments对象在函数体内不存在，如果要用的话，可以用rest参数代替\n\n### 箭头函数没有原型\n```javascript\nvar Foo = () => {};\n\nconsole.log(Foo.prototype); // undefined\n```\n### 箭头函数无法构造函数\n```javascript\nvar Foo = () => {};\n\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n### 箭头函数无法使用yield\nyield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。\n\n### 箭头函数或者组件上绑定事件的时候this.xxx.bind(this)，这样会生成新函数，推荐constructor里bind() garbage collection(垃圾回收机制)，除非使用purecomponent只进行浅比较。\n","tags":["es6"],"categories":["JS"]},{"title":"react面试题记录","url":"%2FreactInterview.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/reactInterview.jpeg , reactInterview, React%}\n---\n<!-- more -->\n\n## React面试问题\n下面是一个常用的关于 React 的面试问题列表：\n\n### React 的响应式原理\nReact 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diff\" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用`diff`的结果来更新真实DOM。虚拟\nDOM作为一种缓存机制优化了UI渲染减少昂贵的DOM变化的数量。\n\n1. 开发者只需关注状态转移（数据），当状态发生变化，React框架会自动根据新的状态重新构建UI。\n2. React框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。状态变化后\nReact框架并不会立即去计算并渲染DOM树的变化部分，相反，React会在DOM的基础上建立一个抽象层，即虚拟DOM树，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到真实DOM\n中，而不是每次改变都去操作一下DOM。\n\n为什么不能每次改变都直接去操作DOM树？\n这是因为在浏览器中每一次DOM操作都有可能引起浏览器的重绘或回流：\n* 如果DOM只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。\n* 如果DOM树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。\n而浏览器的重绘和回流都是比较昂贵的操作，如果每一次改变都直接对DOM进行操作，这会带来性能问题，而批量操作只会触发一次DOM更新。\n\n### 使用 React 有何优点\n* 只需查看 `render` 函数就会很容易知道一个组件是如何被渲染的\n* JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的\n* 支持服务端渲染，这可以改进 SEO 和性能\n* 易于测试\n* React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用\n\n### 展示组件(Presentational component)和容器组件(Container component)之间有何不同\n展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\n\n容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 `Flux actions`，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。\n\n### 类组件(Class component)和函数式组件(Functional component)之间有何不同\n* 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 `store` 并维持状态\n* 当组件仅是接收 `props`，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n\n### (组件的)状态(state)和属性(props)之间有何不同\n`State` 是一种数据结构，用于组件挂载时所需数据的默认值。`State` 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\n\n`Props`(properties 的简写)则是组件的配置。`props` 由父组件传递给子组件，并且就子组件而言，`props` 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\n\n### 指出(组件)生命周期方法的不同\n* `componentWillMount` -- 多用于根组件中的应用程序配置\n* `componentDidMount` -- 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成\n* `componentWillReceiveProps` -- 这个周期函数作用于特定的 prop 改变导致的 state 转换\n* `shouldComponentUpdate` -- 如果你担心组件过度渲染，`shouldComponentUpdate` 是一个改善性能的地方，因为如果组件接收了新的 `prop`， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染\n* `componentWillUpdate` -- 很少使用。它可以用于代替组件的 `componentWillReceiveProps` 和 `shouldComponentUpdate`(但不能访问之前的 props)\n* `componentDidUpdate` -- 常用于更新 DOM，响应 prop 或 state 的改变\n* `componentWillUnmount` -- 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器\n\n### 应该在 React 组件的何处发起 Ajax 请求\n在 React 组件中，应该在 `componentDidMount` 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 `componentDidMount` 中发起网络请求将保证这有一个组件可以更新了。\n\n### 何为受控组件(controlled component)\n在 HTML 中，类似 `<input>`, `<textarea>` 和 `<select>` 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 `onChange` 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。\n\n### 在 React 中，refs 的作用是什么\nRefs 可以用于获取一个 DOM 节点或者 React 组件(组件实例)的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。\n\n### 三种ref方式\n1. string类型绑定\n类似于vue中的ref绑定方式，可以通过this.refs.绑定的ref的名字获取到节点dom，注意的是这种方式已经不被最新版的react推荐使用，有可能会在未来版本中遗弃。\n```js\nfocus = () => {\n  this.refs.inputRef.focus()\n}\n<input ref=\"inputRef\"/>\n\n// 获取子组件的div\n// 父组件\n<Child myRef={this.state.myDiv}/>\n// 子组件\n <div ref={this.props.myRef}>我是子组件</div>\n```\n\n2. react.CreateRef()\n通过在class中使用React.createRef()方法创建一些变量，可以将这些变量绑定到标签的ref中，该变量的current则指向绑定的标签dom。\n```js\ninputRef = React.createRef()\nfocus = () => {\n  this.inputRef.current.focus()\n}\n<input ref={this.inputRef}/>\n```\n\n3. 函数形式\n在class中声明函数，在函数中绑定ref使用这种方法可以将子组件暴露给父组件以使得父组件能够调用子组件的方法\n```js\ninputRef = null\nfocus = () => {\n  this.inputRef.focus()\n}\n<input ref={(el)=>this.inputRef=el}/>\n```\n\n4. useRef\n```js\nfunction UseRefDemo() {\n  const inputRef = useRef(null as any)\n\n  const handleFocusInput = () => {\n    inputRef.current.focus()\n  }\n\n  return (\n    <div>\n      <input ref={inputRef} />\n      <button onClick={handleFocusInput}>click focus</button>\n    </div>\n  )\n}\n```\n\n5. forwardRef(获取组件内的引用)\n```js\n// 子组件\nconst Child = forwardRef((props, ref)=>{\n  return (\n  \t<div ref={ref}>{props.txt}</div>\n  )\n})\n\n// 父组件\n<Child ref={this.state.myDiv} txt=\"parent props txt\"/>\n```\n\n注意: react并不推荐过度使用ref，如果能通过state做到的事情，就不应该使用 refs 在你的 app 中“让事情发生”。过度使用ref并不符合数据驱动的思想。\n\n### 何为高阶组件(higher order component)\n高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 `connect` 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\n装饰器@decoration\n优点:\n- 逻辑复用\n- 不影响被包裹组件的逻辑\n\n缺点:\n- 传递的props和包裹组件的props发生重名会覆盖\n- 组件嵌套导致层级过深\n\n### 渲染属性(render props)\nRender prop 是一个告知组件需要渲染什么内容的函数 prop\n优点:\n- 逻辑复用\n- 数据共享\n\n缺点:\n- 嵌套\n- 无法在return语句外访问数据\n\n### 使用箭头函数(arrow functions)的优点是什么\n* 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 `this` 值(在构造函数中是新对象；在严格模式下，函数调用中的 `this` 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 `this` 值。\n* 简单：箭头函数易于阅读和书写\n* 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 `this` 的值\n\n### 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象\n因为 `this.props` 和 `this.state` 的更新可能是异步的，不能依赖它们的值去计算下一个 state。setState在生命周期里是异步的，第二个参数是组件重新渲染完成后的回调。\n\n### 除了在构造函数中绑定 `this`，还有其它方式吗\n在 constructor 里使用 bind。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\n\n### 怎么阻止组件的渲染\n在组件的 `render` 方法中返回 `null` 并不会影响触发组件的生命周期方法\n\n### react 与 vue 数组中 key 的作用是什么\ndiff算法需要比对虚拟dom的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode会首先判断key和标签名是否一致，如果一致再去判断子节点一致，使用key可以帮助diff算法提升判断的速度，在页面\n重新渲染时更快消耗更少。\n\n### (在构造函数中)调用 super(props) 的目的是什么\n在 `super()` 被调用之前，子类是不能使用 `this` 的，在 ES2015 中，子类必须在 `constructor` 中调用 `super()`。传递 `props` 给 `super()` 的原因则是便于(在子类中)能在 `constructor` 访问 `this.props`。\n\n### 何为 JSX\nJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。\n\n缺点：b&& 强转成boolean类型 否则如果b=0渲染出0\n\n### 怎么用 React.createElement 重写下面的代码\n\nQuestion：\n\n```js\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n\nAnswer：\n\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n### 何为 `Children`\n在JSX表达式中，一个开始标签(比如`<a>`)和一个关闭标签(比如`</a>`)之间的内容会作为一个特殊的属性`props.children`被自动传递给包含着它的组件。\n\n这个属性有许多可用的方法，包括 `React.Children.map`，`React.Children.forEach`， `React.Children.count`， `React.Children.only`，`React.Children.toArray`。\n\n### 在 React 中，何为 state\nState 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。\n\n### 你为何排斥 create-react-app\n在你排斥之前，你并不能去配置 webpack 或 babel presets。\n\n### 何为 redux\nRedux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。\n\n### 在 Redux 中，何为 store\nStore 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：\n\n* 允许通过 `getState()` 访问 state\n* 运行通过 `dispatch(action)` 改变 state\n* 通过 `subscribe(listener)` 注册 listeners\n* 通过 `subscribe(listener)` 返回的函数处理 listeners 的注销\n\n### 何为 action\nActions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。\n\n### 何为 reducer\n一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。\n\n### Redux Thunk 的作用是什么\nRedux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。\n\n### 何为纯函数(pure function)\n一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。\n- 同输入同输出\n- 无副作用(函数内部的操作不会对外部产生影响(如修改全局变量的值、修改 dom 节点等))\n\n### redux有哪些中间件，作用？\n中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。\n\nredux-logger：提供日志输出\n\nredux-thunk：处理异步操作\n\nredux-promise：处理异步操作，actionCreator的返回值是promise\n\n### 示例项目\n* [React Spotify](https://github.com/Pau1fitz/react-spotify)\n* [React Soundcloud](https://github.com/andrewngu/sound-redux)\n\n### 虚拟dom(虚拟节点)是用JS对象来模拟真实DOM中的节点\n虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。具体实现步骤如下：用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。插入新组件有了key可以帮助react找到映射。\n\n- 真实的元素节点\n```html\n<div id=\"wrap\">\n    <p class=\"title\">Hello world!</p>\n</div>\n```\n\n- vnode\n```js\n{\n    tag:'div',\n    attrs:{\n        id:'wrap'\n    },\n    children:[\n        {\n            tag:'p',\n            text:'Hello world!',\n            attrs:{\n                class:'title',\n            }\n        }\n    ]\n}\n```\n\n### 为什么使用虚拟dom\n起初我们在使用JS/JQuery时，不可避免的会大量操作DOM，而DOM的变化又会引发回流或重绘，从而降低页面渲染性能。那么怎样来减少对DOM的操作呢？此时虚拟DOM\n应用而生，所以虚拟DOM出现的主要目的就是`为了减少频繁操作DOM而引起回流重绘所引发的性能问题的`\n\n### 虚拟dom的作用\n兼容性好。因为Vnode本质是JS对象，所以不管Node还是浏览器环境，都可以操作；\n减少了对Dom的操作。页面中的数据和状态变化，都通过Vnode对比，只需要在比对完之后更新DOM，不需要频繁操作，提高了页面性能。\n\n每个setState重新渲染整个子树标记为dirty。 如果要压缩性能，请尽可能调用 setState，并使用shouldComponentUpdate 来防止重新渲染大型子树。把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的key属性，方便比较。pureComponent(浅比较)+immutable 替换成preact\n\n### diff算法 \n> 一开始会根据真实DOM生成虚拟DOM，当虚拟DOM某个节点的数据改变后会生成一个新的Vnode，然后VNode和oldVnode对比，把不同的地方修改在真实DOM上，最后再使得oldVnode的值为Vnode。\n\n`diff过程就是调用patch函数，比较新老节点，一边比较一边给真实DOM打补丁(patch)；`\n\n![patch](http://cdn.mydearest.cn/blog/images/patch.png)\n\n把树形结构按照层级分解，只比较同级元素。\n\n给列表结构的每个单元添加唯一的key属性，方便比较。\n\nReact 只会匹配相同 class 的 component（这里面的class指的是组件的名字）\n\n合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\n\n选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。\n\ndiff的只是html tag，并没有diff数据。\n\n### setState的理解\n- setState 只在`合成事件`和`钩子函数(除了componentDidUpdate)`中是“异步”的，在原生事件和 setTimeout 中都是同步的。\n- setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。\n- setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。\n\n- 异步与同步: setState并不是单纯的异步或同步，这其实与调用时的环境相关:\n  - 在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState是\"异步\"的；\n    - 原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；\n\n  - 在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；\n  在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；\n    - 问题: 无法在setState后马上从this.state上获取更新后的值。\n    - 解决: 如果需要马上同步去获取新值，setState其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；\n\n  - 在 原生事件 和 setTimeout 中，setState是同步的，可以马上获取更新后的值；\n    - 原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而setTimeout是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；\n\n- 批量更新\n  - 在 合成事件 和 生命周期钩子 中，setState更新队列时，存储的是`合并状态(Object.assign)`。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；\n\n- 函数式\n  - 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在fn中返回新的state对象即可，例如this.setState((state, props) => newState)；\n  - 使用函数式，可以用于避免setState的批量更新的逻辑，传入的函数将会被顺序调用；\n\n- 注意点\n  - 当组件已被销毁，如果再次调用setState，React 会报错警告，通常有两种解决办法:\n    - 将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；\n    - 在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount中标记为 true，在setState前进行判断；\n\n### 替换的属性\n\n- class/className for/htmlFor\n\n### 插入html文本\n```javascript\ndangerouslySetInnerHTML={{__html: content}}\n```\n\n### 15版本的生命周期如下：\n1. 初始化阶段\n- constructor\n- getDefaultProps\n- getInitialState\n\n2. 挂载阶段\n- componentWillMount\n- render\n- componentDidMount\n\n3. 更新阶段\nprops：\n- componentWillReceiveProps\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\nstate：\n- shouldComponentUpdate\n- componentWillUpdate\n- render\n- componentDidUpdate\n\n4. 卸载阶段\n- componentWillUnmount\n\n### 16版本生命周期如下：\n1. 初始化阶段\n- constructor\n- getDefaultProps\n- getInitialState\n\n2. 挂载阶段\n```js\n组件实例化。\n组件的props发生变化。\n父组件重新渲染。\nthis.setState()不会触发getDerivedStateFromProps()，但是this.forceUpdate()会。\n```\n- getDerivedStateFromProps:传入nextProps和prevState，根据需要将props映射到state，否则返回null\n- render\n- componentDidMount\n\n3. 更新阶段\n- getDerivedStateFromProps\n- shouldComponentUpdate\n- render\n- getSnapshotBeforeUpdate：render之后dom渲染之前会发生，返回一个值作为componentDidUpdate的第三个参数使用\n- componentDidUpdate\n\n4. 卸载阶段\n- componentWillUnmount\n\n5. 错误处理\n- componentDidCatch\n\n### 事件机制\nreact事件并没有绑定到真实的dom节点上，而是通过事件代理，在最外层的document上对事件进行统一分发。\n\n### 为什么react事件要自己绑定this\n在react中事件处理函数是直接调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的this是不准确的，所以我们需要手动将当前组件绑定到this上。\n\n### react和原生事件的执行顺序是什么，可以混用吗\nreact的所有事件都通过document进行统一分发，当真实dom触发事件后冒泡到document后才会对react事件进行处理\n\n所以原生事件会先执行，然后执行react合成事件，最后执行真正在document上挂载的事件两者最好不要混用，原生事件中如果执行了stopPropagation方法，则会导致其他react事件失效。\n\n### 虚拟dom比普通dom更快吗\n首次渲染时vdom不具有任何优势甚至要进行更多的计算，消耗更多的内存。\n\nvdom的优势在于react的diff算法和批处理策略，react在页面更新之前，提前计算好了如何进行更新和渲染dom。vdom主要是能在重复渲染时帮助我们计算如何实现更高效的更新，而不是说它比dom操作快。\n\n### 虚拟dom中的$$typeof属性的作用是什么\n它被赋值为REACT_ELEMENT_TYPE，是一个symbol类型的变量，这个变量可以防止XSS。react渲染时会把没有$$typeof标识以及规则校验不通过的组件全都过滤掉。当你的环境不支持Symbol时，$$typeof被赋值为0xeac7，为什么采用0xeac7？\n> 0xeac7看起来有点像React。\n\n### HOC在业务场景中有哪些实际的应用\n\n- 组合渲染(属性代理)\n```js\n// 更改 props\nfunction proxyHoc(Comp) {\n\treturn class extends React.Component {\n\t\trender() {\n\t\t\tconst newProps = {\n\t\t\t\tname: 'tayde',\n\t\t\t\tage: 1,\n\t\t\t}\n\t\t\treturn <Comp {...this.props} {...newProps} />\n\t\t}\n\t}\n}\n```\n很方便将`Input`组件转化为受控组件\n- 条件渲染\n```js\n// 反向继承传递过来的组件\nfunction withLoading(Comp) {\n    return class extends Comp {\n        render() {\n            if(this.props.isLoading) {\n                return <Loading />\n            } else {\n                return super.render()\n            }\n        }\n    };\n}\n```\n- 操作props\n- 获取refs\n- 操作state\n可以直接通过 this.state 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。\n- 渲染劫持\n\n实际应用场景：\n- 日志打点\n```js\n// 性能监控埋点\nfunction withTiming(Comp)\u0010 {\n    return class extends Comp {\n        constructor(props) {\n            super(props);\n            this.start = Date.now();\n            this.end = 0;\n        }\n        componentDidMount() {\n            super.componentDidMount && super.componentDidMount();\n            this.end = Date.now();\n            console.log(`${WrappedComponent.name} 组件渲染时间为 ${this.end - this.start} ms`);\n        }\n        render() {\n            return super.render();\n        }\n    };\n}\n```\n- 权限控制\n```js\nfunction withAdminAuth(WrappedComponent) {\n    return class extends React.Component {\n\t\tconstructor(props){\n\t\t\tsuper(props)\n\t\t\tthis.state = {\n\t\t    \tisAdmin: false,\n\t\t\t}\n\t\t} \n\t\tasync componentWillMount() {\n\t\t    const currentRole = await getCurrentUserRole();\n\t\t    this.setState({\n\t\t        isAdmin: currentRole === 'Admin',\n\t\t    });\n\t\t}\n\t\trender() {\n\t\t    if (this.state.isAdmin) {\n\t\t        return <Comp {...this.props} />;\n\t\t    } else {\n\t\t        return (<div>您没有权限查看该页面，请联系管理员！</div>);\n\t\t    }\n\t\t}\n    };\n}\n```\n- 双向绑定\n- 表单校验\n- 代码复用\n\n### HOC和mixin的异同点是什么\n- mixin可能会互相依赖，互相耦合，不利于代码维护\n\n- 不同的mixin中的方法可能会相互冲突\n\n- mixin非常多的时候组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性\n\n- 而HOC的出现则可以解决这些问题\n\n - hoc是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合\n - 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些情况\n - 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担\n\n#### hooks有哪些优势(react提供的api,hoc和render props开发模式)\n- 组件逻辑越来越复杂(componentDidMount, componentDidUpdate)\n尤其是生命周期函数中常常包含一些不相关的逻辑，完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。\n\n- 组件之间复用状态逻辑很难，避免地狱嵌套\nhook和mixin在用法上有一定的相似之处，但是mixin引入的逻辑状态是可以互相覆盖的，而多个hooks之间互不影响，hoc也可能带来一定冲突，比如props覆盖等等，使用hooks则可以避免这些问题。大量使用hoc让我们的代码变得嵌套层级非常深，使用hooks我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。\n\n- 让组件变得更加容易理解 class组件this钩子函数\n相比函数，编写一个class可能需要更多的知识，hooks让你可以在class之外使用更多的react的新特性\n\n后续中展示组件需要改造成类组件需要有自己的状态管理和生命周期方法将复用逻辑提升到代码顶部。\n\n### Fiber\nReact 的核心流程可以分为两个部分:\n- reconciliation (调度算法，也可称为 render):\n  - 更新 state 与 props；\n  - 调用生命周期钩子；\n  - 生成 virtual dom；\n    - 这里应该称为 Fiber Tree 更为符合；\n  - 通过新旧 vdom 进行 diff 算法，获取 vdom change；\n  - 确定是否需要重新渲染\n\n- commit:\n  - 如需要，则操作 dom 节点更新；\n\n- 问题: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。\n\n\n- 解决方案: 解决同步阻塞的方法，通常有两种: 异步与任务分割。而 React Fiber 便是为了实现任务分割而诞生的。\n\n  - 在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的`单链表树遍历算法`。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。\n  - 这里我理解为是一种`任务分割调度算法`，主要是将原先同步更新渲染的任务分割成一个个独立的`小任务单位`，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。\n\n```js\nclass Fiber {\n\tconstructor(instance) {\n\t\tthis.instance = instance\n\t\t// 指向第一个 child 节点\n\t\tthis.child = child\n\t\t// 指向父节点\n\t\tthis.return = parent\n\t\t// 指向第一个兄弟节点\n\t\tthis.sibling = previous\n\t}\t\n}\n```\n\n> 核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。\n> 当遇到进程阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。\n\n### 为什么生命周期有了变动\n在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被`多次调用`的情况，产生一些意外错误。\n\n```js\nclass Component extends React.Component {\n  // 替换 `componentWillReceiveProps` ，\n  // 初始化和 update 时被调用\n  // 静态函数，无法使用 this\n  static getDerivedStateFromProps(nextProps, prevState) {}\n  \n  // 判断是否需要更新组件\n  // 可以用于组件性能优化\n  shouldComponentUpdate(nextProps, nextState) {}\n  \n  // 组件被挂载后触发\n  componentDidMount() {}\n  \n  // 替换 componentWillUpdate\n  // 可以在更新之前获取最新 dom 数据\n  getSnapshotBeforeUpdate() {}\n  \n  // 组件更新后调用\n  componentDidUpdate() {}\n  \n  // 组件即将销毁\n  componentWillUnmount() {}\n  \n  // 组件已销毁\n  componentDidUnMount() {}\n\n  // 错误边界捕获全局异常\n  componentDidCatch() {}\n}\n```\n\n- 在constructor初始化 state；\n- 在componentDidMount中进行事件监听，并在componentWillUnmount中解绑事件；\n- 在componentDidMount中进行数据的请求，而不是在componentWillMount；\n- 需要根据 props 更新 state 时，使用getDerivedStateFromProps(nextProps, prevState)；\n  - 旧 props 需要自己存储，以便比较；\n```js\npublic static getDerivedStateFromProps(nextProps, prevState) {\n\t// 当新 props 中的 data 发生变化时，同步更新到 state 上\n\tif (nextProps.data !== prevState.data) {\n\t\treturn {\n\t\t\tdata: nextProps.data\n\t\t}\n\t} else {\n\t\treturn null\n\t}\n}\n```\n\n- 可以在componentDidUpdate监听 props 或者 state 的变化，例如:\n```js\ncomponentDidUpdate(prevProps) {\n\t// 当 id 发生变化时，重新获取数据\n\tif (this.props.id !== prevProps.id) {\n\t\tthis.fetchData(this.props.id);\n\t}\n}\n```\n\n- 在componentDidUpdate使用setState时，必须加条件，否则将进入死循环；\n- getSnapshotBeforeUpdate(prevProps, prevState)可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前；\n- shouldComponentUpdate: 默认每次调用setState，一定会最终走到 diff 阶段，但可以通过shouldComponentUpdate的生命钩子返回false来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。\n\n废弃的原因主要是因为 react 在 16 版本重构了调度算法，新的调度可能会导致一些生命周期被反复调用，所以在 16 中就不建议使用了，而改在其他时机中暴露出其\n他生命周期钩子用来替代。\n\n### SSR\nSSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。\n前后端分离: 前端与服务端隔离，前端动态获取数据，渲染页面。\n- 痛点:\n  - 首屏渲染性能瓶颈:\n  - 空白延迟: HTML下载时间 + JS下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。\n  - SEO 问题: 由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好。\n    - 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜索引擎仍然是没有实现。\n\n#### 原理\n- Node 服务: 让前后端运行同一套代码成为可能。\n- Virtual Dom: 让前端代码脱离浏览器运行。\n\n![ssr](http://cdn.mydearest.cn/blog/images/ssr.png)\n\n\n### 为什么react没有双向绑定\nReact的设计思想是单向数据流，我觉得可以这样理解为什么没有双向数据绑定：\n\n首先，React是纯粹的View层；然后，对于React来说双向数据绑定是什么需求? -- 明显是业务需求。因为单向数据流已经满足了 View 层渲染的要求并且更易测试与控制（来自 Props 或 State），更加的清晰可控，所以在纯粹的 React 中怎么会需要双向数据绑定这种功能呢。\n\n如果需要解决双向数据绑定问题，可以借助第三方库如 Ant Design 的 rc-form 之类，你也可以存在 State 里甚至是 Redux 里，根据需求来吧。所以 React 没有双向数据绑定不是功能的缺失或冲突问题，而是 React 只关注解决纯粹的问题： View 层。\n\n### 单向数据流\n\n单向数据流是指数据的流向只能由父组件通过props将数据传递给子组件，不能由子组件向父组件传递数据，要想实现数据的双向绑定，只能由子组件接收父组件props传过来的方法去改变父组件的数据，而不是直接将\n子组件的数据传递给父组件。\n\n### react和vue的对比\nreact 函数式思想 纯组件传入状态和逻辑，所以单项数据流结合immutable setState 触发重新render 单项数据流设计成不可变数据 purecomponent对shouldconponentupdate是否触发重新渲染。不可变数据返回新的state，计算虚拟dom的差异。数据流props/callback，context\n\nvue 响应式的思想 监听数据的变化 初始化时对数据的每一个属性添加watcher基于数据可变 数据变化时触发watcher回调 更新虚拟dom。可变数据直接修改，setter能精确监听数据变化。数据流props/event，inject/provide\n\nreact的性能优化需要手动去判断 vue是自动的应为要给每个属性添加 watcher所以大型项目state不比较多的时候watcher也会比较多容易造成卡顿的情况。redux不能直接调用reducer进行修改。而vuex有dispatch和commit\n\n### React 中，cloneElement 与 createElement 各是什么，有什么区别\n```js\nReact.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n\nReact.createElement(\n  type,\n  [props],\n  [...children]\n)\n```\n\n### React Portal 有哪些使用场景\n在以前， react 中所有的组件都会位于 #app 下，而使用 Portals 提供了一种脱离 #app 的组件。\n因此 Portals 适合脱离文档流(out of flow) 的组件，特别是 position: absolute 与 position: fixed 的组件。比如模态框，通知，警告，goTop 等。\n\n```js\nconst modalRoot = document.getElementById('modal');\n\nclass Modal extends React.Component {\n  constructor(props) {\n    super(props);\n    this.el = document.createElement('div');\n  }\n\n  componentDidMount() {\n    modalRoot.appendChild(this.el);\n  }\n\n  componentWillUnmount() {\n    modalRoot.removeChild(this.el);\n  }\n\n  render() {\n    return ReactDOM.createPortal(\n      this.props.children,\n      this.el,\n    );\n  }\n}\n```\n\n### 路由传参\n1. params传参(刷新页面后参数不消失，参数会在地址栏显示)\n```\n路由页面：<Route path='/demo/:id' component={Demo}></Route>  //注意要配置 /:id\n路由跳转并传递参数：\n    链接方式：<Link to={'/demo/'+'6'}>XX</Link>\n        或：<Link to={{pathname:'/demo/'+'6'}}>XX</Link>\n\n    js方式：this.props.history.push('/demo/'+'6')  \n        或：this.props.history.push({pathname:'/demo/'+'6'})\n获取参数：this.props.match.params.id    //注意这里是match而非history\n```\n\n2. query传参(刷新页面后参数消失)\n```\n路由页面：<Route path='/demo' component={Demo}></Route>  //无需配置\n路由跳转并传递参数：\n    链接方式：<Link to={{pathname:'/demo',query:{id:22,name:'dahuang'}}}>XX</Link>\n    js方式：this.props.history.push({pathname:'/demo',query:{id:22,name:'dahuang'}})\n获取参数： this.props.location.query.name\n```\n\n3. state传参(刷新页面后参数不消失，state传的参数是加密的，比query传参好用)\n```\n路由页面：<Route path='/demo' component={Demo}></Route>  //无需配置\n路由跳转并传递参数：\n    链接方式： <Link to={{pathname:'/demo',state:{id:12,name:'dahuang'}}}>XX</Link> \n    js方式：this.props.history.push({pathname:'/demo',state:{id:12,name:'dahuang'}})\n获取参数： this.props.location.state.name\n```\n\n### create-react-app配置文件修改\n\n- 通过package.json或引用第三方的库增加配置\n- react构建时通过webpack，关于webpack配置查看node_modules/react-scripts/config/webpack*\n- npm run eject暴露所有配置文件、(安装react-app-rewired包)建立新的配置文件覆盖部分默认的配置\n- HashRouter支持配置package-json homepage: '.'修改根目录路径，BrowerRouter修改无效还得修改服务端配置\n\n### react diff和vue diff的区别\n- vnode作为数据和视图的一种映射关系\n- 相同点：都是同层比较、不同点：vue使用双指针比较，react是key集合级比较\n\n### react StrictMode严格模式\nStrictMode是一种辅助组件，可以帮助编写更好的组件。\n1. 验证是否遵循推荐写法\n2. 验证是否使用了已经废弃的写法\n3. 通过识别一些潜在的风险预防副作用\n\n### react事件的合成机制\n1. div 或其他元素触发事件，该事件会冒泡到 document，然后被 React 的事件处理程序捕获\n2. 事件处理程序随后将事件传递给 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。\n3. SyntheticEvent 触发 dispatchEvent，将 event 对象交由对应的处理器执行。\n\n- 为什么要合成事件机制\n  - 更好的兼容性和跨平台\n  - react事件机制采用了事件池，大大节省内存\n  - 方便事件的统一管理\n\n- react处理阻止冒泡\n```js\n// 阻止事件冒泡，（阻止这个合成事件，往document上冒泡，因此不会触发click方法）\ne.stopPropagation();\n// 阻止合成事件间的冒泡，不会往最外层冒了\ne.nativeEvent.stopImmediatePropagation();\n```\n\n### redux存在的问题 => 重\n- 一份store树，离开页面再次进入，数据不会初始化\n- reducer拆分造成汇总困难\n- action的type管理混乱，重复问题\n- 繁杂的使用规则，index页面action和store引入，纯函数reducer大量case仅仅为了改变一个值\n\n### 常用UI库\n\n- 移动端\n[ant design mobile](https://mobile.ant.design/index-cn)\n\n- pc端\n[ant design](https://ant.design/)\n\n[reactstrap](https://reactstrap.github.io/)\n\n[patternfly-react](https://patternfly-react.surge.sh/)\n\n[semantic-ui](https://react.semantic-ui.com/)\n\n[material-ui](https://material-ui.com/)\n\n[elemental-ui](http://elemental-ui.com/home)\n","tags":["面试"],"categories":["React"]},{"title":"不能说的秘密","url":"%2FscienceInternet.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/shadowsocks.jpg, Shadowsocks, Shadowsocks %}\n---\n<!-- more -->\n\n{% note info %}\n\n快速搭建Shadowsocks\n\n{% endnote %}\n\n## [购买Vultr服务器](https://www.vultr.com/)\n\n### Vultr服务器价格\n\nVultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题。\n\n最低价格的服务器是512M的内存，每个月500G的流量，只能说99%的情况下完全够用了！\n\n![introduce](http://cdn.mydearest.cn/blog/images/vultr.png)\n\n## 买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令\n\n```javascript\n\nwget --no-check-certificate -O shadowsocks.sh\nhttps://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n \nchmod +x shadowsocks.sh\n \n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n\n```\n\n接着按照提示输入密码，端口和加密方式，如下图：\n\n![ss1](http://cdn.mydearest.cn/blog/images/ss1.png)\n\n![ss2](http://cdn.mydearest.cn/blog/images/ss1.png)\n\n选择加密方式7(aes-256-cfb)。\n\n然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息。\n\n## 安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。\n\nWindows客户端(代理端口默认1080)\nhttps://github.com/shadowsocks/shadowsocks-windows/releases\n\nUbuntu \nsudo add-apt-repository ppa:hzwhuang/ss-qt5 \nsudo apt-get update \nsudo apt-get install shadowsocks-qt5\n\nMac客户端(代理端口默认1086)\n\nhttps://github.com/shadowsocks/ShadowsocksX-NG/releases\n\nAndroid客户端\n\nhttps://github.com/shadowsocks/shadowsocks-android/releases","tags":["未知"],"categories":["工具"]},{"title":"Promise诞生记","url":"%2FcreatePromise.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/promise.png, Promise, Promise %}\n\n前端近年的兴起，有大部分是因为 `NodeJS` 的诞生，而 `NodeJS` 是个适用于 **异步IO** 密集型的语言，一些基于 `NodeJS` 的框架，比如 *KOA2、Adonis* 就有大量的 `async` 和 `await` 语法，`async`的函数的返回值就是 `Promise` 对象，我们可以用 `async` 和 `await` 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。\n\n## Promise 概念(JS的 Promise是未来事件的表示)\n`Promise`是一种对异步操作的封装，主流的规范是Promise/A+。\n`Promise`可以使得异步代码层次清晰，便于理解，且更加容易维护。 Promise 可以以成功结束：用行话说我们已经解决了resolved(fulfilled)。 但如果 Promise 出错，我们会说它处于**拒绝(rejected )状态。 Promise 也有一个默认状态：每个新的 Promise 都以挂起(pending)**状态开始。\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n生成实例时回执信作为参数的函数；<Br/> \n`resolve`函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n`reject`函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n---\n<!-- more -->\n\n```javascript\n// 执行顺序\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise'); // 新建后立即执行\n  resolve();\n  console.log(111)\n  return 0\n});\npromise.then(function() {\n  console.log('resolved.'); // 同步任务执行完成后才会执行\n});\nconsole.log('Hi!');\n// Promise\n// 111\n// Hi!\n// resolved\n```\n接下来我们就用`Promise`结合ajax来使用\n\n```javascript\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.responseText);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n  });\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n这里我们会渐进式的来创建一个 `Promise` 的实现，如果，你还不了解 `Promise` ，赶快移步 [Promise](http://es6.ruanyifeng.com/#docs/promise) 了解学习，当然这个实现会符合 [Promise/A+](https://promisesaplus.com) 规范，`JavaScript` 中有很多第三方的 `Promise` 库，[bluebird](http://bluebirdjs.com/docs/getting-started.html) 就是一个第三方 `Promise` 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。\n\n---\n\n废话不多说，直接开干。。。 😠\n\n## 定义 Promise 类型\n\n一个简单 `Promise` 语法，如下\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... doSomething\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure 第二个函数可选\n});\n```\n\n### 实现 resolve 和 then\n\n首先我们以上 👆 的语法，自己定义一个 `Promise` 实例\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    callback(value);\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n一个简单的实例写好了，然后，来用一下，看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n\n```\n{% note info %}\n\n执行结果是：`callback is not a function`\n\n{% endnote %}\n\n### 改进1：延时resolve，修改 callback 为异步\n\n**这里就遇到一个问题： **  \n\n** 目前的Promise有一个bug，假如fn中所包含的是同步代码，则resolve会立即执行，`callback` 还是 `null` ，我们的代码是同步的，而不是异步的。</br> 如是，想办法解决掉这个问题，就是利用 `setTimeout` , 把 `callback` 加入异步队列** \n\n代码如下 👇\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    // 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法\n    setTimeout(function(){\n      callback(value);\n    },0)\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n\n### 改进2：注册多个回调函数，并实现then的链式调用\n\n```javascript\nfunction Promise(fn) {\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    callbackList.push(cb);\n    // 实现链式调用\n    return this\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       // 遍历callbackList数组依次执行\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n### 改进3：引入状态\n\n```javascript\nfunction Promise(fn) {\n  let state='pending'\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    if(state=='pending'){\n      // pending加入队列\n      callbackList.push(cb);\n      return this\n    }\n    if(state=='fulfilled'){\n      // fulfilled立即执行\n      cb(value)\n      return this\n    }\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n\n**手动实现一个Promise：**\n\n```javascript\nclass Promise(){\n  construtor(fn){\n       // 执行队列\n       this._wathcList=[]\n       // 成功\n       this._success_res=null\n       // 失败\n       this._error_res=null\n       this._status=\"success\"\n       fn((...args))=>{\n          // 保存成功数据\n          this._success_res=args\n          this._status='success'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn1(...args);\n          });\n       },(...args)=>{\n          // 保存失败数据\n          this._error_res=args\n          this._status='error'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn2(...args);\n          });\n       }\n  }\n  // then 函数\n  then(fn1, fn2) {\n      if (this._status === \"success\") {\n          fn1(...this._success_res);\n      } else if (this._status === \"error\") {\n          fn2(...this._error_res);\n      } else {\n          this._watchList.push({\n              fn1,\n              fn2\n          })\n      }\n  }\n}\n```\n**实现Promise.all 以及 race**\n\n```javascript\n// 实现Promise.all 以及 race\nPromise.myall = function (arr) {\n    return new Promise((resolve, reject) => {\n        if (arr.length === 0) {\n            return resolve([])\n        } else {\n            let res = [],\n                count = 0\n            for (let i = 0; i < arr.length; i++) {\n                // 同时也能处理arr数组中非Promise对象\n                if (!(arr[i] instanceof Promise)) {\n                    res[i] = arr[i]\n                    if (++count === arr.length)\n                        resolve(res)\n                } else {\n                    arr[i].then(data => {\n                        res[i] = data\n                        if (++count === arr.length)\n                            resolve(res)\n                    }, err => {\n                        reject(err)\n                    })\n                }\n            }\n        }\n    })\n}\n\nPromise.prototype.race = function (arr) {\n    return new Promise((resolve, reject) => {\n        for (let i = 0; i < arr.length; i++) {\n            // 同时也能处理arr数组中非Promise对象\n            if (!(arr[i] instanceof Promise)) {\n                Promise.resolve(arr[i]).then(resolve, reject)\n            } else {\n                arr[i].then(resolve, reject)\n            }\n\n        }\n    })\n}\n\nPromise.prototype.finally = function (callback) {\n    return this.then((value) => {\n        return Promise.resolve(callback()).then(() => {\n            return value;\n        });\n    }, (err) => {\n        return Promise.resolve(callback()).then(() => {\n            throw err;\n        });\n    });\n}\n```\n### 嵌套使用\nPromise可以嵌套使用，这样可以是多个任务有条不紊地进行，假设p1是一个Promise对象而p2、p3都是能够产生Promise对象的方法(如果直接new那么Promise将会被直接执行)，那么你可以这样写，使得他们按照顺序执行，并且可以一次性处理他们产生的错误。\n\n```javascript\nlet p1 = new Promise((resolve, reject) => {\n    console.log('p1');\n    setTimeout(() => {\n        resolve('p2');\n    }, 1000)\n});\n\nlet p2 = (result) => new Promise((resolve, reject) => {\n    console.log(result);\n    setTimeout(() => {\n        resolve('p3');\n    }, 2000);\n});\n\nlet p3 = (result) => new Promise((resolve, reject) => {\n    console.log(result);\n    setTimeout(() => {\n        resolve('over');\n    }, 3000);\n});\n\np1\n    .then(p2)\n    .then(p3)\n    .then((result) => {\n        console.log(result);\n    })\n    .catch((error) => {\n        console.log(error);\n    });\n```\n\n## lite Promise\n```js\nfunction isFunction(target) {\n  return Object.prototype.toString.call(target) === \"[object Function]\";\n}\n\nclass _Promise {\n  constructor(executor) {\n    this.status = \"pending\";\n    this.onResolveCallbacks = [];\n    this.onRejectCallbacks = [];\n\n    let handlerGenerator = status => data => {\n      this.data = data;\n      this.status = status;\n\n      let dict = {\n        resolve: \"onResolveCallbacks\",\n        reject: \"onRejectCallbacks\"\n      };\n\n      executeCallback(this[dict[status]]);\n    };\n\n    let executeCallback = cbs => {\n      for (let cb of cbs) {\n        cb(this.data);\n      }\n    };\n\n    let resolve = handlerGenerator(\"resolve\").bind(this);\n    let reject = handlerGenerator(\"reject\").bind(this);\n\n    executor(resolve, reject);\n  }\n\n  _funcPoly(data) {\n    return data;\n  }\n\n  _PromiseGenerator(onResolved, onRejected) {\n    let self = this;\n\n    return new _Promise((resolve, reject) => {\n      let body = () => {\n        let status = self.status;\n\n        try {\n          let result =\n            status === \"resolve\"\n              ? onResolved(self.data)\n              : status === \"reject\"\n              ? onRejected(self.data)\n              : undefined;\n\n          if (result instanceof _Promise) {\n            return resolvedResult.then(resolve, reject);\n          }\n\n          if (status === \"resolve\") {\n            resolve(result);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      if (self.status === \"pending\") {\n        self.onResolveCallbacks.push(body);\n        self.onRejectCallbacks.push(body);\n      } else {\n        body(self.status);\n      }\n    });\n  }\n\n  then(onResolved = this._funcPoly, onRejected = this._funcPoly) {\n    return this._PromiseGenerator(onResolved, onRejected);\n  }\n\n  catch(onRejected) {\n    this.then(null, onRejected);\n  }\n}\n\nnew _Promise(function(resolve){\n  console.log(1)\n  resolve()\n}).then(console.log(2))\nconsole.log(3)\n```\n\n## 如何取消 `promise`\n1. Promise.race方法\n```js\n// 方法一 取消promise方法   promise.race方法\nfunction wrap(p) {\n  let obj = {};\n  let p1 = new Promise((resolve, reject) => {\n    obj.resolve = resolve;\n    obj.reject = reject;\n  });\n  obj.promise = Promise.race([p1, p]);\n  return obj;\n}\n\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(123);\n  }, 1000);\n});\nlet obj = wrap(promise);\nobj.promise.then(res => {\n  console.log(res);\n});\nobj.resolve(\"请求被拦截了\");\n\nobj.reject(\"请求被拒绝了\");\n```\n\n2. 新包装一个可操控的promise\n```js\nfunction wrap(p) {\n  let res = null;\n  let abort = null;\n\n  let p1 = new Promise((resolve, reject) => {\n    res = resolve;\n    abort = reject;\n  });\n\n  p1.abort = abort;\n  p.then(res, abort);\n\n  return p1;\n}\n\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(123);\n  }, 1000);\n});\nlet obj = wrap(promise);\nobj.then(res => {\n  console.log(res);\n});\nobj.abort(\"请求被拦截\");\n```\n\n## Promise使用注意点\n1. 一般来说，调用`resolve`或`reject`以后，`Promise`的使命就完成了，后继操作应该放到`then`方法里面，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。\n\n2. `Promise`实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为`Promise`实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即then方法后面再调用另一个`then`方法。\n\n3. `Promise.prototype.catch`方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。`getJSON`方法返回一个`Promise`对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n4. 一般来说，不要在then方法里面定义`reject`状态的回调函数（即then的第二个参数），总是使用`catch`方法。\n\n5. 跟传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应，`Promise`会吃掉错误。\n\n6. Promise 构造函数是同步执行，then方法是异步执行。`.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值透传。\n\n7. Promise.all中如果有一个抛出异常了会如何处理?\n> all和race传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中\n其它的异步任务的执行。\n\n8. promise.all并发还是串行\n并发的。不过Promise.all().then()结果中数组的顺序和Promise.all()接收到的数组顺序一致。\n","tags":["promise"],"categories":["JS"]},{"title":"如何使用 markdown 语法写博客","url":"%2FmarkdownGrammar.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/markdown.png, Markdown, Markdown %}\n\n{% note info %}\n\n{% endnote %}\n\n{% centerquote %} \n\n{% endcenterquote %}\n\n# 标题1\n## 标题2\n*斜体*\n**粗体**\n***粗斜体***<br/>\n~~删除线~~\n<u>下划线文本</u>\n\n1. I\n2. Love \n3. You\n\n- 点\n\n+ Foo\n+ Bar\n---\n<!-- more -->\n\n分隔线\n***\n--- \n___\n\n* * *\n>一级引用\n>>二级引用\n\n`#include<iostream>`\n```\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n```\n~~~\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n~~~\n|标题|标题|标题|\n|:---|:---:|---:|\n|居左测试文本|居中测试文本|居右测试文本|\n|居左测试文本1|居中测试文本2|居右测试文本3|\n|居左测试文本11|居中测试文本22|居右测试文本33|\n|居左测试文本111|居中测试文本222|居右测试文本333|\n\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n### 反斜杠\n\n`Markdown` 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n```\n\\*literal asterisks\\*\n```\n效果如下：\n\n\\*literal asterisks\\*\n\n`Markdown` 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```\n  \\   反斜线\n  `   反引号\n  *   星号\n  _   底线\n  {}  花括号\n  []  方括号\n  ()  括弧\n  #   井字号\n  +   加号\n  -   减号\n  .   英文句点\n  !   惊叹号\n```\n登录[百度](http://www.baidu.com)\n![Teddy Bear](http://img2.everychina.com/img/d7/f7/1b580dfa9315111397ef93fd24ea-250x250c1-77f7/love_valentine_plush_teddy_bear.jpg)\n\n### 徽章\n\n![](https://img.shields.io/badge/github-cosyer-brightgreen.svg)\n\n### 折叠\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n","tags":["markdown"],"categories":["工具"]},{"title":"Hello World - 热爱编程的普通人，顺便以此为生。","url":"%2Fhello-world.html","content":"\n之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n---\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n如果说人生是自我编写的程序，\n\n那么青春就是其中意味深长的代码。\n\n或简单，\n\n分解成彼此独立的字符；\n\n或复杂，\n\n拼凑一连串神秘的语句。\n\n我们尝试着不断调试，\n\n不断优化，\n\n无论编译的结果如何，\n\n过程才是最美。\n\n如果说这段代码不能复制，\n\n那么我愿意用一生去续写….\n\n           —— 献给我们那可以肆意挥洒的青春，一直青春下去。","tags":["吐槽"],"categories":["杂谈"]}]