<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>cosyer&#39;s Blog</title>
    <link>http://mydearest.cn/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>陈宇的博客</description>
    <pubDate>Sat, 09 Jun 2018 05:52:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>从 for 循环入手优化性能</title>
      <link>http://mydearest.cn/forloop.html</link>
      <guid>http://mydearest.cn/forloop.html</guid>
      <pubDate>Fri, 08 Jun 2018 12:32:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？</p><hr><a id="more"></a><p>从最简单的遍历数组说起。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数组arr（假设是从后台返回的数据）</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想从数组 arr 中取出数据，就必须要进行遍历，普遍的做法是：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但其实这样的写法遍历是最慢的，他要经过两次迭代，第一次是 i 的迭代，每次都要判断 i 是否小于 arr.length，第二次是 arr 的迭代，每次循环 arr 都会调用底层的迭代器，对长度进行计算，这样循环的效率非常低，时间空间复杂度为 O[n^2]。</p><p>下面进行优化，看看两者到底有什么区别：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>区别就是，整个循环当中，我们预存了 len 来保存数组的长度，这样不需要每次循环都调用底层迭代器，调用一次即可，这样的时间空间复杂度为 O[n+1]。</p><p>但是这并不是最完美的，因为会多了一次迭代操作，那么该如何进行优化呢？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, item; item = arr[i++];) &#123;</span><br><span class="line">    <span class="comment">// item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这次迭代的时间空间复杂度为 O[n] ，完美做到了每次一迭代没有通过长度进行判断，而是直接通过下标进行取值的方式映射到了循环体内部。</p><p>最后用5万条数据进行测试各种方式的循环时间：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数组arr（假设是从后台返回的数据）</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">while</span> (index &lt; <span class="number">50000</span>) &#123;</span><br><span class="line">    arr.push(index);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'two'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'two'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'three'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, item; item = arr[i++];) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'three'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6的数组遍历</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'four'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'four'</span>);</span><br><span class="line"><span class="comment">// 会访问可枚举属性和原型的遍历，数组不推荐使用</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'five'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'five'</span>);</span><br><span class="line"><span class="comment">// one: 0.711ms</span></span><br><span class="line"><span class="comment">// two: 4.508ms</span></span><br><span class="line"><span class="comment">// three: 0.006ms</span></span><br><span class="line"><span class="comment">// four: 3.255ms</span></span><br><span class="line"><span class="comment">// five: 11.144ms</span></span><br></pre></td></tr></table></figure></p><p>在数据量大的情况下，第三种循环方式效果显而易见。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/forloop.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>es6函数新特性</title>
      <link>http://mydearest.cn/es6function.html</link>
      <guid>http://mydearest.cn/es6function.html</guid>
      <pubDate>Fri, 08 Jun 2018 11:35:58 GMT</pubDate>
      <description>
      
        &lt;ol&gt;
&lt;li&gt;设置函数默认值 &lt;/li&gt;
&lt;li&gt;结合解构赋值默认值使用&lt;/li&gt;
&lt;li&gt;利用rest(…变量名)传入任意参数&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<ol><li>设置函数默认值 </li><li>结合解构赋值默认值使用</li><li>利用rest(…变量名)传入任意参数</li></ol><hr><a id="more"></a><h2 id="…rest和扩展运算符"><a href="#…rest和扩展运算符" class="headerlink" title="…rest和扩展运算符"></a>…rest和扩展运算符</h2><p>rest参数（…变量名），用于获取函数的多余参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入其中。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(y)  <span class="comment">// [1,2,3,4]</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><h2 id="利用扩展运算符（…数组）替代数组的apply方法"><a href="#利用扩展运算符（…数组）替代数组的apply方法" class="headerlink" title="利用扩展运算符（…数组）替代数组的apply方法"></a>利用扩展运算符（…数组）替代数组的apply方法</h2><p>在es5中，需要用apply将数组转化为函数参数，在es6中就不需要这种方式了，可以使用…来代替<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + <span class="string">' '</span> + y + <span class="string">' '</span> + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// f.apply(null, args)</span></span><br><span class="line">f(...args)</span><br></pre></td></tr></table></figure></p><p>数组push的例子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.concat(arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">//[ 0, 1, 2, 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.push(arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">//[ 0, 1, 2, [ 3, 4, 5 ] ]</span></span><br></pre></td></tr></table></figure></p><p>如果想使用arr1.push方法的话，就需要用apply传arr2了<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = <span class="built_in">Array</span>.prototype.push.apply(arr1, arr2) <span class="comment">//[ 0, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure></p><p>如果使用扩展运算符的话，就简单一些了<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = arr1.push(...arr2)</span><br></pre></td></tr></table></figure></p><h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>函数的name属性可以返回函数名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function abc()&#123;</span><br><span class="line">    console.log(abc.name)</span><br><span class="line">&#125;</span><br><span class="line">abc() // &apos;abc&apos;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/es6function.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 中 this 的详解</title>
      <link>http://mydearest.cn/jsthis.html</link>
      <guid>http://mydearest.cn/jsthis.html</guid>
      <pubDate>Fri, 08 Jun 2018 08:58:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;this-的指向&quot;&gt;&lt;a href=&quot;#this-的指向&quot; class=&quot;headerlink&quot; title=&quot;this 的指向&quot;&gt;&lt;/a&gt;this 的指向&lt;/h2&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 是 js 中定义的关键字，它自动定义于每一个函数域内。在实际应用中，&lt;code&gt;this&lt;/code&gt;的指向大致可以分为以下四种情况。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p><code>this</code> 是 js 中定义的关键字，它自动定义于每一个函数域内。在实际应用中，<code>this</code>的指向大致可以分为以下四种情况。</p><hr><a id="more"></a><h3 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用"></a>作为普通函数调用</h3><p>当函数作为一个普通函数被调用，<code>this</code>指向全局对象。在浏览器里，全局对象就是 window。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'cosyer'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">getName();                   <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure></p><p>可以看出，此时<code>this</code>指向了全局对象 window。在ECMAScript5的严格模式下，这种情况<code>this</code>已经被规定不会指向全局对象了，而是undefined。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fun();                      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h3><p>当函数作为一个对象里的方法被调用，<code>this</code>指向该对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'cosyer'</span>,</span><br><span class="line">    getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getName();              <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure></p><p>如果把对象的方法赋值给一个变量，再调用这个变量：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fun1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun2 = obj.fun1;</span><br><span class="line">fun2();                     <span class="comment">// window</span></span><br></pre></td></tr></table></figure></p><p>此时调用 fun2 方法 输出了 window 对象，说明此时<code>this</code>指向了全局对象。给 fun2 赋值，其实是相当于：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，此时的<code>this</code>已经跟 obj 没有任何关系了。这时 fun2 是作为普通函数调用。</p><h3 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h3><p>js中没有类，但是可以从构造器中创建对象，并提供了<code>new</code>运算符来进行调用该构造器。构造器的外表跟普通函数一样，大部分的函数都可以当做构造器使用。当构造函数被调用时，<code>this</code>指向了该构造函数实例化出来的对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cosyer'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);      <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure></p><p>如果构造函数显式的返回一个对象，那么<code>this</code>则会指向该对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cosyer'</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name : <span class="string">'chenyu'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);      <span class="comment">// chenyu</span></span><br></pre></td></tr></table></figure></p><p>如果该函数不用<code>new</code>调用，当作普通函数执行，那么<code>this</code>依然指向全局对象。</p><h3 id="call-或-apply-调用"><a href="#call-或-apply-调用" class="headerlink" title="call() 或 apply() 调用"></a>call() 或 apply() 调用</h3><p>通过调用函数的 call() 或 apply() 方法可动态的改变<code>this</code>的指向。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">'cosyer'</span>,</span><br><span class="line">    getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name : <span class="string">'chenyu'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.getName();             <span class="comment">// cosyer</span></span><br><span class="line">obj1.getName.call(obj2);    <span class="comment">// chenyu</span></span><br><span class="line">obj1.getName.apply(obj2);   <span class="comment">// chenyu</span></span><br></pre></td></tr></table></figure></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><div class="note info"><p>箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对<code>this</code>的词法解析。在箭头函数出现之前，每个新定义的函数都有其自己的<code>this</code>值（例如，构造函数的<code>this</code>指向了一个新的对象；严格模式下的函数的<code>this</code>值为 undefined；如果函数是作为对象的方法被调用的，则其<code>this</code>指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。</p></div><h3 id="ES6-的箭头函数-gt-，指向与一般function定义的函数不同，比较容易绕晕，箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的this，它的this是派生而来的。箭头函数会捕获其所在上下文的this值，作为自己的this值，即指向所在上下文的执行环境-当前定义时的对象-。"><a href="#ES6-的箭头函数-gt-，指向与一般function定义的函数不同，比较容易绕晕，箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的this，它的this是派生而来的。箭头函数会捕获其所在上下文的this值，作为自己的this值，即指向所在上下文的执行环境-当前定义时的对象-。" class="headerlink" title="ES6 的箭头函数 ()=&gt;，指向与一般function定义的函数不同，比较容易绕晕，箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的this，它的this是派生而来的。箭头函数会捕获其所在上下文的this值，作为自己的this值，即指向所在上下文的执行环境(当前定义时的对象)。"></a>ES6 的箭头函数 ()=&gt;，指向与一般function定义的函数不同，比较容易绕晕，箭头函数<code>this</code>的定义：箭头函数中的<code>this</code>是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的<code>this</code>，它的<code>this</code>是派生而来的。箭头函数会捕获其所在上下文的<code>this</code>值，作为自己的<code>this</code>值，即指向所在上下文的执行环境(当前定义时的对象)。</h3><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于: =&gt; &#123; return expression; &#125; </span></span><br><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个参数，圆括号是可选的:</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数或者多参数的箭头函数需要使用圆括号或者下划线:</span></span><br><span class="line">() =&gt; &#123; statements &#125; _ =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持 Rest parameters 和 default parameters:</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持参数列表中的解构赋值</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], = </span>) =&gt;</span> a + b + c;</span><br><span class="line">f(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数不可以使用arguments对象，"><a href="#箭头函数不可以使用arguments对象，" class="headerlink" title="箭头函数不可以使用arguments对象，"></a>箭头函数不可以使用arguments对象，</h3><p>arguments对象在函数体内不存在，如果要用的话，可以用rest参数代替</p><h3 id="箭头函数没有原型"><a href="#箭头函数没有原型" class="headerlink" title="箭头函数没有原型"></a>箭头函数没有原型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数无法构造函数"><a href="#箭头函数无法构造函数" class="headerlink" title="箭头函数无法构造函数"></a>箭头函数无法构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数无法使用yield"><a href="#箭头函数无法使用yield" class="headerlink" title="箭头函数无法使用yield"></a>箭头函数无法使用yield</h3><p>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。</p><p>let index = 0;let arr = [];while (index &lt; 50000) {    arr.push(index);    index++;}</p><p>console.time(‘one’);for (let i = 0; i &lt; arr.length; i++) {</p><p>}console.timeEnd(‘one’);</p><p>console.time(‘two’);for (let i = 0, len = arr.length; i &lt; len; i++) {</p><p>}console.timeEnd(‘two’);</p><p>console.time(‘three’);for (let i = 0, item; item = arr[i++];) {</p><p>}console.timeEnd(‘three’);</p><p>console.time(‘four’);for (let i of arr) {</p><p>}console.timeEnd(‘four’);console.time(‘five’);for (let i in arr) {</p><p>}console.timeEnd(‘five’);</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/jsthis.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>react面试题记录</title>
      <link>http://mydearest.cn/reactInterview.html</link>
      <guid>http://mydearest.cn/reactInterview.html</guid>
      <pubDate>Thu, 07 Jun 2018 06:47:09 GMT</pubDate>
      <description>
      
        &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://p33v4b0bc.bkt.clouddn.com/reactInterview.jpeg &quot; class=&quot;full-image&quot; alt=&quot;reactInterview&quot; title=&quot;React&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://p33v4b0bc.bkt.clouddn.com/reactInterview.jpeg " class="full-image" alt="reactInterview" title="React"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><hr><a id="more"></a><h2 id="React面试问题"><a href="#React面试问题" class="headerlink" title="React面试问题"></a>React面试问题</h2><p>下面是一个常用的关于 React 的面试问题列表：</p><ul><li><a href="#react-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">React 的工作原理</a>?</li><li><a href="#%E4%BD%BF%E7%94%A8-react-%E6%9C%89%E4%BD%95%E4%BC%98%E7%82%B9">使用 React 有何优点</a>？</li><li><a href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6presentational-component%E5%92%8C%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6container-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">展示组件(Presentational component)和容器组件(Container component)之间有何不同</a>？</li><li><a href="#%E7%B1%BB%E7%BB%84%E4%BB%B6class-component%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6functional-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">类组件(Class component)和函数式组件(Functional component)之间有何不同</a>？</li><li><a href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81state%E5%92%8C%E5%B1%9E%E6%80%A7props%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">(组件的)状态(state)和属性(props)之间有何不同</a>？</li><li><a href="#%E6%8C%87%E5%87%BA%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C">指出(组件)生命周期方法的不同</a>？</li><li><a href="#%E5%BA%94%E8%AF%A5%E5%9C%A8-react-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%95%E5%A4%84%E5%8F%91%E8%B5%B7-ajax-%E8%AF%B7%E6%B1%82">应该在 React 组件的何处发起 Ajax 请求</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6controlled-component">何为受控组件(controlled component)</a>？</li><li><a href="#%E5%9C%A8-react-%E4%B8%ADrefs-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">在 React 中，refs 的作用是什么</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6higher-order-component">何为高阶组件(higher order component)</a>？</li><li><a href="#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0arrow-functions%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88">使用箭头函数(arrow functions)的优点是什么</a>？</li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BC%A0%E9%80%92%E7%BB%99-setstate-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA-callback-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</a>？</li><li><a href="#%E9%99%A4%E4%BA%86%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%91%E5%AE%9A-this%E8%BF%98%E6%9C%89%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E5%90%97">除了在构造函数中绑定 <code>this</code>，还有其它方式吗</a>？</li><li><a href="#%E6%80%8E%E4%B9%88%E9%98%BB%E6%AD%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93">怎么阻止组件的渲染</a>？</li><li><a href="#%E5%BD%93%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E6%97%B6%E4%BD%95%E4%B8%BA-key%E8%AE%BE%E7%BD%AE-key-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88">当渲染一个列表时，何为 key？设置 key 的目的是什么</a>？</li><li><a href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-superprops-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88">(在构造函数中)调用 super(props) 的目的是什么</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-jsx">何为 JSX</a>？</li><li><a href="#%E6%80%8E%E4%B9%88%E7%94%A8%20React.createElement%20%E9%87%8D%E5%86%99%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81">怎么用 React.createElement 重写下面的代码</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-children">何为 <code>Children</code></a>？</li><li><a href="#%E5%9C%A8-react-%E4%B8%AD%E4%BD%95%E4%B8%BA-state">在 React 中，何为 state</a>？</li><li><a href="#%E4%BD%A0%E4%B8%BA%E4%BD%95%E6%8E%92%E6%96%A5-create-react-app">你为何排斥 create-react-app</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-redux">何为 redux</a>？</li><li><a href="#%E5%9C%A8-redux-%E4%B8%AD%E4%BD%95%E4%B8%BA-store">在 Redux 中，何为 store</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-action">何为 action</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-reducer">何为 reducer</a>？</li><li><a href="#redux-thunk-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">Redux Thunk 的作用是什么</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA%E7%BA%AF%E5%87%BD%E6%95%B0pure-function">何为纯函数(pure function)</a>？</li><li><a href="#%E4%BD%A0%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2">你喜欢 React 的哪些方面</a>？</li><li><a href="#%E4%BD%A0%E4%B8%8D%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2">你不喜欢 React 的哪些方面</a>？</li><li><a href="#%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE">示例项目</a></li></ul><h4 id="React-的工作原理"><a href="#React-的工作原理" class="headerlink" title="React 的工作原理"></a>React 的工作原理</h4><p>React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diff” 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。</p><h4 id="使用-React-有何优点"><a href="#使用-React-有何优点" class="headerlink" title="使用 React 有何优点"></a>使用 React 有何优点</h4><ul><li>只需查看 <code>render</code> 函数就会很容易知道一个组件是如何被渲染的</li><li>JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的</li><li>支持服务端渲染，这可以改进 SEO 和性能</li><li>易于测试</li><li>React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用</li></ul><h4 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何不同"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同</h4><p>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</p><p>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 <code>Flux actions</code>，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</p><h4 id="类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><a href="#类组件-Class-component-和函数式组件-Functional-component-之间有何不同" class="headerlink" title="类组件(Class component)和函数式组件(Functional component)之间有何不同"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同</h4><ul><li>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 <code>store</code> 并维持状态</li><li>当组件仅是接收 <code>props</code>，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</li></ul><h4 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同"></a>(组件的)状态(state)和属性(props)之间有何不同</h4><p><code>State</code> 是一种数据结构，用于组件挂载时所需数据的默认值。<code>State</code> 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</p><p><code>Props</code>(properties 的简写)则是组件的配置。<code>props</code> 由父组件传递给子组件，并且就子组件而言，<code>props</code> 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p><h4 id="指出-组件-生命周期方法的不同"><a href="#指出-组件-生命周期方法的不同" class="headerlink" title="指出(组件)生命周期方法的不同"></a>指出(组件)生命周期方法的不同</h4><ul><li><code>componentWillMount</code> – 多用于根组件中的应用程序配置</li><li><code>componentDidMount</code> – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成</li><li><code>componentWillReceiveProps</code> – 这个周期函数作用于特定的 prop 改变导致的 state 转换</li><li><code>shouldComponentUpdate</code> – 如果你担心组件过度渲染，<code>shouldComponentUpdate</code> 是一个改善性能的地方，因为如果组件接收了新的 <code>prop</code>， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染</li><li><code>componentWillUpdate</code> – 很少使用。它可以用于代替组件的 <code>componentWillReceiveProps</code> 和 <code>shouldComponentUpdate</code>(但不能访问之前的 props)</li><li><code>componentDidUpdate</code> – 常用于更新 DOM，响应 prop 或 state 的改变</li><li><code>componentWillUnmount</code> – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</li></ul><h4 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 Ajax 请求"></a>应该在 React 组件的何处发起 Ajax 请求</h4><p>在 React 组件中，应该在 <code>componentDidMount</code> 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 <code>componentDidMount</code> 中发起网络请求将保证这有一个组件可以更新了。</p><h4 id="何为受控组件-controlled-component"><a href="#何为受控组件-controlled-component" class="headerlink" title="何为受控组件(controlled component)"></a>何为受控组件(controlled component)</h4><p>在 HTML 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 <code>onChange</code> 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p><h4 id="在-React-中，refs-的作用是什么"><a href="#在-React-中，refs-的作用是什么" class="headerlink" title="在 React 中，refs 的作用是什么"></a>在 React 中，refs 的作用是什么</h4><p>Refs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。</p><h4 id="何为高阶组件-higher-order-component"><a href="#何为高阶组件-higher-order-component" class="headerlink" title="何为高阶组件(higher order component)"></a>何为高阶组件(higher order component)</h4><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 <code>connect</code> 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。装饰器@decoration练习</p><hr><ul><li>写一个反转其输入的 HOC</li><li>写一个从 API 提供数据给传入的组件的 HOC</li><li>写一个实现 shouldComponentUpdate 来避免 reconciliation 的 HOC</li><li>写一个通过 <code>React.Children.toArray</code> 对传入组件的子组件进行排序的 HOC</li></ul><h4 id="使用箭头函数-arrow-functions-的优点是什么"><a href="#使用箭头函数-arrow-functions-的优点是什么" class="headerlink" title="使用箭头函数(arrow functions)的优点是什么"></a>使用箭头函数(arrow functions)的优点是什么</h4><ul><li>作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 <code>this</code> 值(在构造函数中是新对象；在严格模式下，函数调用中的 <code>this</code> 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 <code>this</code> 值。</li><li>简单：箭头函数易于阅读和书写</li><li>清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 <code>this</code> 的值</li></ul><h4 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h4><p>因为 <code>this.props</code> 和 <code>this.state</code> 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p><h4 id="除了在构造函数中绑定-this，还有其它方式吗"><a href="#除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗"></a>除了在构造函数中绑定 <code>this</code>，还有其它方式吗</h4><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p><h4 id="怎么阻止组件的渲染"><a href="#怎么阻止组件的渲染" class="headerlink" title="怎么阻止组件的渲染"></a>怎么阻止组件的渲染</h4><p>在组件的 <code>render</code> 方法中返回 <code>null</code> 并不会影响触发组件的生命周期方法</p><h4 id="当渲染一个列表时，何为-key？设置-key-的目的是什么"><a href="#当渲染一个列表时，何为-key？设置-key-的目的是什么" class="headerlink" title="当渲染一个列表时，何为 key？设置 key 的目的是什么"></a>当渲染一个列表时，何为 key？设置 key 的目的是什么</h4><p>Keys 会有助于 React 识别哪些 <code>items</code> 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 <code>items</code> 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 <code>items</code> 可以重新排序，就会导致 <code>re-render</code> 变慢。</p><h4 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么"></a>(在构造函数中)调用 super(props) 的目的是什么</h4><p>在 <code>super()</code> 被调用之前，子类是不能使用 <code>this</code> 的，在 ES2015 中，子类必须在 <code>constructor</code> 中调用 <code>super()</code>。传递 <code>props</code> 给 <code>super()</code> 的原因则是便于(在子类中)能在 <code>constructor</code> 访问 <code>this.props</code>。</p><h4 id="何为-JSX"><a href="#何为-JSX" class="headerlink" title="何为 JSX"></a>何为 JSX</h4><p>JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React “元素”，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就编程了常规的 JavaScript 对象，这意味着你可以在 <code>if</code> 语句和 <code>for</code> 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。</p><h4 id="怎么用-React-createElement-重写下面的代码"><a href="#怎么用-React-createElement-重写下面的代码" class="headerlink" title="怎么用 React.createElement 重写下面的代码"></a>怎么用 React.createElement 重写下面的代码</h4><p>Question：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>Answer：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="何为-Children"><a href="#何为-Children" class="headerlink" title="何为 Children"></a>何为 <code>Children</code></h4><p>在JSX表达式中，一个开始标签(比如<code>&lt;a&gt;</code>)和一个关闭标签(比如<code>&lt;/a&gt;</code>)之间的内容会作为一个特殊的属性<code>props.children</code>被自动传递给包含着它的组件。</p><p>这个属性有许多可用的方法，包括 <code>React.Children.map</code>，<code>React.Children.forEach</code>， <code>React.Children.count</code>， <code>React.Children.only</code>，<code>React.Children.toArray</code>。</p><h4 id="在-React-中，何为-state"><a href="#在-React-中，何为-state" class="headerlink" title="在 React 中，何为 state"></a>在 React 中，何为 state</h4><p>State 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。</p><h4 id="你为何排斥-create-react-app"><a href="#你为何排斥-create-react-app" class="headerlink" title="你为何排斥 create-react-app"></a>你为何排斥 create-react-app</h4><p>在你排斥之前，你并不能去配置 webpack 或 babel presets。</p><h4 id="何为-redux"><a href="#何为-redux" class="headerlink" title="何为 redux"></a>何为 redux</h4><p>Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。</p><h4 id="在-Redux-中，何为-store"><a href="#在-Redux-中，何为-store" class="headerlink" title="在 Redux 中，何为 store"></a>在 Redux 中，何为 store</h4><p>Store 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：</p><ul><li>允许通过 <code>getState()</code> 访问 state</li><li>运行通过 <code>dispatch(action)</code> 改变 state</li><li>通过 <code>subscribe(listener)</code> 注册 listeners</li><li>通过 <code>subscribe(listener)</code> 返回的函数处理 listeners 的注销</li></ul><h4 id="何为-action"><a href="#何为-action" class="headerlink" title="何为 action"></a>何为 action</h4><p>Actions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。</p><h4 id="何为-reducer"><a href="#何为-reducer" class="headerlink" title="何为 reducer"></a>何为 reducer</h4><p>一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。</p><h4 id="Redux-Thunk-的作用是什么"><a href="#Redux-Thunk-的作用是什么" class="headerlink" title="Redux Thunk 的作用是什么"></a>Redux Thunk 的作用是什么</h4><p>Redux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。</p><h4 id="何为纯函数-pure-function"><a href="#何为纯函数-pure-function" class="headerlink" title="何为纯函数(pure function)"></a>何为纯函数(pure function)</h4><p>一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。</p><h4 id="你喜欢-React-的哪些方面"><a href="#你喜欢-React-的哪些方面" class="headerlink" title="你喜欢 React 的哪些方面"></a>你喜欢 React 的哪些方面</h4><p>…</p><h4 id="你不喜欢-React-的哪些方面"><a href="#你不喜欢-React-的哪些方面" class="headerlink" title="你不喜欢 React 的哪些方面"></a>你不喜欢 React 的哪些方面</h4><p>…</p><h4 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h4><ul><li><a href="https://github.com/Pau1fitz/react-spotify" target="_blank" rel="noopener">React Spotify</a></li><li><a href="https://github.com/andrewngu/sound-redux" target="_blank" rel="noopener">React Soundcloud</a></li></ul><h4 id="虚拟dom-普通的js对象"><a href="#虚拟dom-普通的js对象" class="headerlink" title="虚拟dom 普通的js对象"></a>虚拟dom 普通的js对象</h4><p>插入新组件有了key可以帮助react找到映射</p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>每个setState重新渲染整个子树。 如果要压缩性能，请尽可能调用 setState，并使用shouldComponentUpdate 来防止重新渲染大型子树。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/reactInterview.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>搭建VPS科学上网</title>
      <link>http://mydearest.cn/scienceInternet.html</link>
      <guid>http://mydearest.cn/scienceInternet.html</guid>
      <pubDate>Thu, 07 Jun 2018 02:21:24 GMT</pubDate>
      <description>
      
        &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://p33v4b0bc.bkt.clouddn.com/shadowsocks.jpg&quot; class=&quot;full-image&quot; alt=&quot;Shadowsocks&quot; title=&quot;Shadowsocks&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://p33v4b0bc.bkt.clouddn.com/shadowsocks.jpg" class="full-image" alt="Shadowsocks" title="Shadowsocks"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><hr><a id="more"></a><div class="note info"><p>快速搭建Shadowsocks</p></div><h2 id="购买Vultr服务器"><a href="#购买Vultr服务器" class="headerlink" title="购买Vultr服务器"></a><a href="https://www.vultr.com/" target="_blank" rel="noopener">购买Vultr服务器</a></h2><h3 id="Vultr服务器价格"><a href="#Vultr服务器价格" class="headerlink" title="Vultr服务器价格"></a>Vultr服务器价格</h3><p>Vultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题。</p><p>最低价格的服务器是512M的内存，每个月500G的流量，只能说99%的情况下完全够用了！</p><p><img src="http://p33v4b0bc.bkt.clouddn.com/vultr.png" alt="introduce"></p><h2 id="买好中意的地区节点服务器之后，windows系统可以用Xshell-ssh连接到服务器，并执行以下搭建ss脚本命令"><a href="#买好中意的地区节点服务器之后，windows系统可以用Xshell-ssh连接到服务器，并执行以下搭建ss脚本命令" class="headerlink" title="买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令"></a>买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">wget --no-check-certificate -O shadowsocks.sh</span><br><span class="line">https:<span class="comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span></span><br><span class="line"> </span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"> </span><br><span class="line">./shadowsocks.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>接着按照提示输入密码，端口和加密方式，如下图：</p><p><img src="http://p33v4b0bc.bkt.clouddn.com/ss1.png" alt="ss1"></p><p><img src="http://p33v4b0bc.bkt.clouddn.com/ss1.png" alt="ss2"></p><p>然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息。</p><h2 id="安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy-SwitchySharp来管理和切换代理配置非常好用。"><a href="#安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy-SwitchySharp来管理和切换代理配置非常好用。" class="headerlink" title="安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。"></a>安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。</h2><p>Windows客户端(代理端口默认1080)<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>Ubuntu sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5</p><p>Mac客户端(代理端口默认1086)</p><p><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a></p><p>Android客户端</p><p><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-android/releases</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/scienceInternet.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Promise诞生记</title>
      <link>http://mydearest.cn/createPromise.html</link>
      <guid>http://mydearest.cn/createPromise.html</guid>
      <pubDate>Mon, 04 Jun 2018 17:34:09 GMT</pubDate>
      <description>
      
        &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://p33v4b0bc.bkt.clouddn.com/promise.png&quot; class=&quot;full-image&quot; alt=&quot;Promise&quot; title=&quot;Promise&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;p&gt;前端近年的兴起，有大部分是因为 &lt;code&gt;NodeJS&lt;/code&gt; 的诞生，而 &lt;code&gt;NodeJS&lt;/code&gt; 是个适用于 &lt;strong&gt;异步IO&lt;/strong&gt; 密集型的语言，一些基于 &lt;code&gt;NodeJS&lt;/code&gt; 的框架，比喻 &lt;em&gt;KOA2、Adonis&lt;/em&gt; 就有大量的 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 语法，&lt;code&gt;async&lt;/code&gt;的函数的返回值就是 &lt;code&gt;Promise&lt;/code&gt; 对象，我们可以用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。&lt;/p&gt;
&lt;h2 id=&quot;Promise-概念&quot;&gt;&lt;a href=&quot;#Promise-概念&quot; class=&quot;headerlink&quot; title=&quot;Promise 概念&quot;&gt;&lt;/a&gt;Promise 概念&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是一种对异步操作的封装，主流的规范是Promise/A+。
&lt;code&gt;Promise&lt;/code&gt;可以使得异步代码层次清晰，便于理解，且更加容易维护。
&lt;code&gt;Promise&lt;/code&gt;构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
生成实例时回执信作为参数的函数；&lt;br&gt; 
&lt;code&gt;resolve&lt;/code&gt;函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
&lt;code&gt;reject&lt;/code&gt;函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://p33v4b0bc.bkt.clouddn.com/promise.png" class="full-image" alt="Promise" title="Promise"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>前端近年的兴起，有大部分是因为 <code>NodeJS</code> 的诞生，而 <code>NodeJS</code> 是个适用于 <strong>异步IO</strong> 密集型的语言，一些基于 <code>NodeJS</code> 的框架，比喻 <em>KOA2、Adonis</em> 就有大量的 <code>async</code> 和 <code>await</code> 语法，<code>async</code>的函数的返回值就是 <code>Promise</code> 对象，我们可以用 <code>async</code> 和 <code>await</code> 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。</p><h2 id="Promise-概念"><a href="#Promise-概念" class="headerlink" title="Promise 概念"></a>Promise 概念</h2><p><code>Promise</code>是一种对异步操作的封装，主流的规范是Promise/A+。<code>Promise</code>可以使得异步代码层次清晰，便于理解，且更加容易维护。<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。生成实例时回执信作为参数的函数；<br> <code>resolve</code>函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><hr><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行顺序</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>); <span class="comment">// 新建后立即执行</span></span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>); <span class="comment">// 同步任务执行完成后才会执行</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>接下来我们就用<code>Promise</code>结合ajax来使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const getJSON = function(url) &#123;</span><br><span class="line">  const promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    const handler = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const client = new XMLHttpRequest();</span><br><span class="line">    client.open(&quot;GET&quot;, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = &quot;json&quot;;</span><br><span class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    client.send(params);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  console.log(&apos;Contents: &apos; + json);</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  console.error(&apos;出错了&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我们会渐进式的来创建一个 <code>Promise</code> 的实现，如果，你还不了解 <code>Promise</code> ，赶快移步 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise</a> 了解学习，当然这个实现会符合 <a href="https://promisesaplus.com" target="_blank" rel="noopener">Promise/A+</a> 规范，<code>JavaScript</code> 中有很多第三方的 <code>Promise</code> 库，<a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="noopener">bluebird</a> 就是一个第三方 <code>Promise</code> 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。</p><hr><p>废话不多说，直接开干。。。 😠</p><h2 id="定义-Promise-类型"><a href="#定义-Promise-类型" class="headerlink" title="定义 Promise 类型"></a>定义 Promise 类型</h2><p>一个简单 <code>Promise</code> 语法，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... doSomething</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure 第二个函数可选</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现-resolve-和-then"><a href="#实现-resolve-和-then" class="headerlink" title="实现 resolve 和 then"></a>实现 resolve 和 then</h3><p>首先我们以上 👆 的语法，自己定义一个 <code>Promise</code> 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve</span></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callback = cb;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现 resolve , value:异步操作的最终值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    callback(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//执行 function 参数</span></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的实例写好了，然后，来用一下，看看 👀 结果如何</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><div class="note info"><p>执行结果是：<code>callback is not a function</code></p></div><h3 id="改进1：延时resolve，修改-callback-为异步"><a href="#改进1：延时resolve，修改-callback-为异步" class="headerlink" title="改进1：延时resolve，修改 callback 为异步"></a>改进1：延时resolve，修改 callback 为异步</h3><p><strong>这里就遇到一个问题： </strong>  </p><p><strong> 目前的Promise有一个bug，假如fn中所包含的是同步代码，则resolve会立即执行，<code>callback</code> 还是 <code>null</code> ，我们的代码是同步的，而不是异步的。<br> 如是，想办法解决掉这个问题，就是利用 <code>setTimeout</code> , 把 <code>callback</code> 加入异步队列</strong> </p><p>代码如下 👇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve</span></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callback = cb;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现 resolve , value:异步操作的最终值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      callback(value);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//执行 function 参数</span></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进2：注册多个回调函数，并实现then的链式调用"><a href="#改进2：注册多个回调函数，并实现then的链式调用" class="headerlink" title="改进2：注册多个回调函数，并实现then的链式调用"></a>改进2：注册多个回调函数，并实现then的链式调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> callbackList = [];</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callbackList.push(cb);</span><br><span class="line">    <span class="comment">// 实现链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">// 遍历callbackList数组依次执行</span></span><br><span class="line">       callbackList.forEach(<span class="function">(<span class="params">callback</span>)=&gt;</span>&#123;</span><br><span class="line">         callback(value)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进3：引入状态"><a href="#改进3：引入状态" class="headerlink" title="改进3：引入状态"></a>改进3：引入状态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state=<span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> callbackList = [];</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state==<span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// pending加入队列</span></span><br><span class="line">      callbackList.push(cb);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(state==<span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">      <span class="comment">// fulfilled立即执行</span></span><br><span class="line">      cb(value)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       callbackList.forEach(<span class="function">(<span class="params">callback</span>)=&gt;</span>&#123;</span><br><span class="line">         callback(value)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动实现一个Promise：</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span>()</span>&#123;</span><br><span class="line">  construtor(fn)&#123;</span><br><span class="line">       <span class="comment">// 执行队列</span></span><br><span class="line">       <span class="keyword">this</span>._wathcList=[]</span><br><span class="line">       <span class="comment">// 成功</span></span><br><span class="line">       <span class="keyword">this</span>._success_res=<span class="literal">null</span></span><br><span class="line">       <span class="comment">// 失败</span></span><br><span class="line">       <span class="keyword">this</span>._error_res=<span class="literal">null</span></span><br><span class="line">       <span class="keyword">this</span>._status=<span class="string">"success"</span></span><br><span class="line">       fn(<span class="function">(<span class="params">...args</span>))=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">// 保存成功数据</span></span><br><span class="line">          <span class="keyword">this</span>._success_res=args</span><br><span class="line">          <span class="keyword">this</span>._status=<span class="string">'success'</span></span><br><span class="line">          <span class="comment">// 若为异步则回头执行then成功方法</span></span><br><span class="line">          <span class="keyword">this</span>._watchList.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">              element.fn1(...args);</span><br><span class="line">          &#125;);</span><br><span class="line">       &#125;,(...args)=&gt;&#123;</span><br><span class="line">          <span class="comment">// 保存失败数据</span></span><br><span class="line">          <span class="keyword">this</span>._error_res=args</span><br><span class="line">          <span class="keyword">this</span>._status=<span class="string">'error'</span></span><br><span class="line">          <span class="comment">// 若为异步则回头执行then成功方法</span></span><br><span class="line">          <span class="keyword">this</span>._watchList.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">              element.fn2(...args);</span><br><span class="line">          &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then 函数</span></span><br><span class="line">  then(fn1, fn2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._status === <span class="string">"success"</span>) &#123;</span><br><span class="line">          fn1(...this._success_res);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._status === <span class="string">"error"</span>) &#123;</span><br><span class="line">          fn2(...this._error_res);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>._watchList.push(&#123;</span><br><span class="line">              fn1,</span><br><span class="line">              fn2</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实现Promise.all</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Promise1.all = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存放结果集</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">return</span> Promise1(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 进行迭代执行</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            arr[i].then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 存放每个方法的返回值</span></span><br><span class="line">                result.push(res);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 若全部执行完</span></span><br><span class="line">                <span class="keyword">if</span> (i === result.length) &#123;</span><br><span class="line">                    <span class="comment">// 执行then回调</span></span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 继续迭代</span></span><br><span class="line">                    next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Promise使用注意点"><a href="#Promise使用注意点" class="headerlink" title="Promise使用注意点"></a>Promise使用注意点</h2><ol><li><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，<code>Promise</code>的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p></li><li><p><code>Promise</code>实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为<code>Promise</code>实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。<code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即then方法后面再调用另一个<code>then</code>方法。</p></li><li><p><code>Promise.prototype.catch</code>方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<code>getJSON</code>方法返回一个<code>Promise</code>对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p></li><li><p>一般来说，不要在then方法里面定义<code>reject</code>状态的回调函数（即then的第二个参数），总是使用<code>catch</code>方法。</p></li><li><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，<code>Promise</code>对象抛出的错误不会传递到外层代码，即不会有任何反应，<code>Promise</code>会吃掉错误。</p></li></ol>]]></content:encoded>
      
      <comments>http://mydearest.cn/createPromise.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何使用 markdown 语法写博客</title>
      <link>http://mydearest.cn/markdownGrammar.html</link>
      <guid>http://mydearest.cn/markdownGrammar.html</guid>
      <pubDate>Fri, 06 Apr 2018 23:25:19 GMT</pubDate>
      <description>
      
        &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://p33v4b0bc.bkt.clouddn.com/markdown.png&quot; class=&quot;full-image&quot; alt=&quot;Markdown&quot; title=&quot;Markdown&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;h1 id=&quot;标题1&quot;&gt;&lt;a href=&quot;#标题1&quot; class=&quot;headerlink&quot; title=&quot;标题1&quot;&gt;&lt;/a&gt;标题1&lt;/h1&gt;&lt;h2 id=&quot;标题2&quot;&gt;&lt;a href=&quot;#标题2&quot; class=&quot;headerlink&quot; title=&quot;标题2&quot;&gt;&lt;/a&gt;标题2&lt;/h2&gt;&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;
&lt;strong&gt;粗体&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;粗斜体&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
&lt;del&gt;删除线&lt;/del&gt;
&lt;u&gt;下划线文本&lt;/u&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I&lt;/li&gt;
&lt;li&gt;Love &lt;/li&gt;
&lt;li&gt;You&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;点&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Foo&lt;/li&gt;
&lt;li&gt;Bar&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://p33v4b0bc.bkt.clouddn.com/markdown.png" class="full-image" alt="Markdown" title="Markdown"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><p><em>斜体</em><strong>粗体</strong><strong><em>粗斜体</em></strong><br><del>删除线</del><u>下划线文本</u></p><ol><li>I</li><li>Love </li><li>You</li></ol><ul><li>点</li></ul><ul><li>Foo</li><li>Bar</li></ul><hr><a id="more"></a><p>分隔线</p><hr><hr><hr><hr><blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote></blockquote><p><code>#include&lt;iostream&gt;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">标题</th><th style="text-align:center">标题</th><th style="text-align:right">标题</th></tr></thead><tbody><tr><td style="text-align:left">居左测试文本</td><td style="text-align:center">居中测试文本</td><td style="text-align:right">居右测试文本</td></tr><tr><td style="text-align:left">居左测试文本1</td><td style="text-align:center">居中测试文本2</td><td style="text-align:right">居右测试文本3</td></tr><tr><td style="text-align:left">居左测试文本11</td><td style="text-align:center">居中测试文本22</td><td style="text-align:right">居右测试文本33</td></tr><tr><td style="text-align:left">居左测试文本111</td><td style="text-align:center">居中测试文本222</td><td style="text-align:right">居右测试文本333</td></tr></tbody></table><ul><li style="list-style: none"><input type="checkbox" checked> 已完成事项</li><li style="list-style: none"><input type="checkbox"> 待办事项1</li><li style="list-style: none"><input type="checkbox"> 待办事项2</li></ul><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p><code>Markdown</code> 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*literal asterisks\*</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><p>*literal asterisks*</p><p><code>Markdown</code> 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><p>登录<a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a><img src="http://img2.everychina.com/img/d7/f7/1b580dfa9315111397ef93fd24ea-250x250c1-77f7/love_valentine_plush_teddy_bear.jpg" alt="Teddy Bear"></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/markdownGrammar.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World - 热爱编程的普通人，顺便以此为生。</title>
      <link>http://mydearest.cn/hello-world.html</link>
      <guid>http://mydearest.cn/hello-world.html</guid>
      <pubDate>Sat, 31 Mar 2018 17:34:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。&lt;/p&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><hr><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/hello-world.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
