[{"title":"Sass学习笔记","url":"%2Fsass.html","content":"\n### 简介\nSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。\n\n### 导入\n```javascript\n@import \"reset.css\"; // css\n@import \"index\"; // sass\n```\n\n### 变量\n```javascript\n// 普通变量\n$fontSize:16px;\n\n// 默认变量\n$baseLineHeight: 1.5 !default;\n\n// 覆盖默认变量，需要写在 !default 前面\n$baseLineHeight: 1.7;\n$baseLineHeight: 1.5 !default;\n\n// 一维 list\n$px: (5px 10px 20px 30px);\n\n// 二维 list\n$px: (5px 10px)\n     (20px 30px);\n// 或者\n$pxs: 5px 10px, 20px 30px;\n\n// Map 类似对象\n$heading: (\n    h1: 2em,\n    h2: 1.5em,\n    h3: 1.2em\n);\n```\n\n### 插值\n插值使用 #{}\n```javascript\n// Variables\n$mySelector: banner;\n\n// .banner\n.#{mySelector} {\n    font-weight: bold;\n    line-height: 40px;\n    margin: 0 auto;\n}\n```\n\n### 跳出嵌套\n@at-root (without: rule| all | media)\n```javascript\n// 跳出普通的嵌套\n.demo {\n    animation: motion 3s infinite;\n\n    @at-root {\n        @keyframes motion {\n          ...\n        }\n    }\n}\n\n// 跳出 media 嵌套\n@media print {\n    .parent2{\n        color:#f00;\n\n        @at-root (without: media) {\n            .child2 {\n                width:200px;\n            }\n        }\n    }\n}\n```\n\n### 混合(mixin)\n使用 @mixin 声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。\n@mixin 通过 @include 来调用。\n混合器中不仅可以包含属性，也可以包含 css 规则，包含选择器和选择器中的属性，也可以使用 & 上下文。\n\n为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示\n```javascript\n// 无参数\n@mixin block {\n    display: block;\n}\n\n// css 规则，注意上下文\n@mixin no-bullets {\n    list-style: none;\n    li {\n        list-style-image: none;\n        list-style-type: none;\n        margin-left: 0px;\n    }\n}\n\n// 带参数\n@mixin opacity($opacity: 50) {\n    opacity: $opacity / 100;\n    filter: alpha(opacity=$opacity);\n}\n\n// 多个参数\n@mixin horizontal-line($border: 1px dashed #ccc, $padding: 10px){\n    border-bottom: $border;\n    padding-top: $padding;\n    padding-bottom: $padding;\n}\n\n@include horizontal-line($padding: 15px);\n\n// 多组值参数\n@mixin box-shadow($shadow...) {\n    -webkit-box-shadow:$shadow;\n    box-shadow:$shadow;\n}\n\n@include box-shadow(\n    0 2px 2px rgba(0, 0, 0, 0.3),\n    0 3px 3px rgba(0, 0, 0, 0.2)\n);\n```\n\n#### @Content\n@content 它可以使 @mixin 接受一整块样式，接受的样式从 @content 开始。\n```javascript\n@mixin max-screen($res) {\n    @media only screen and ( max-width: $res ) {\n        @content; // body { color: red }\n    }\n}\n\n@include max-screen(480px) {\n    body { color: red } // 这里就i @content 引用的内容\n}\n```\n\n## 继承\n选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend，后面紧跟需要继承的选择器。\n继承可以继承默认的元素属性，比如让一个div继承a，那么这 div 看起来就好像 a 一样。\n```javascript\n// 继承现有的标签，或类\nh1{\n    border: 4px solid #ff9aa9;\n}\n.speaker{\n    @extend h1;\n    border-width: 2px;\n}\n```\n\n## 占位选择器%\n可以定义占位选择器 %，如果不调用则不会有任何多余的 css 代码。\n```javascript\n%block {\n    display: block;\n}\n\n.box {\n    @extend %block;\n}\n```\n\n## 函数\nsass定义了很多函数可供使用，当然你也可以自己定义函数，以@fuction开始。\n\n使用最多的是颜色函数：\n颜色函数中又以 lighten 减淡和 darken 加深为最，\n其调用方法为 lighten($color, $amount) 和 darken($color, $amount)\n它们的第一个参数都是颜色值，第二个参数都是百分比。\n\n```javascript\n@function pxToRem($px) {\n    @return $px / $baseFontSize * 1rem;\n}\nbody {\n    color: lighten($gray, 10%); // 直接使用\n}\ndiv {\n    font-size: pxToRem(16px);\n    color: darken($gray, 10%);\n}\n```\n\n## @if判断\n@if 可一个条件单独使用，也可以和 @else 结合多条件使用\n```javascript\n$big: false;\np {\n    @if $big == false {\n        margin: 10px;\n    }\n    @else {\n        margin: 10px auto;\n    }\n}\n```\n\n## 三目判断\n语法为：if($condition, $if_true, $if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值。\n```javascript\n$min: 20;\np {\n    color: if($min > 10, red, blue); // blue\n}\n```\n\n## for循环\nfor 循环有两种形式，分别为：@for $var from [start] through [end] 和 @for $var from [start] to [end]。\n关键字through表示包括end这个数，而to则不包括end这个数。\n```javascript\n@for $i from 1 through 3 {\n    .item-#{$i} { width: 2em * $i; }\n}\n```\n\n## @each 循环\n语法为：@each $var in [list or map]\n```javascript\n$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);\n@each $header, $size in $headings {\n    #{$header} {\n        font-size: $size;\n    }\n}\n```\n","tags":["Sass"],"categories":["CSS"]},{"title":"如何练就超强的学习能力","url":"%2F%E5%A6%82%E4%BD%95%E7%BB%83%E5%B0%B1%E8%B6%85%E5%BC%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B.html","content":"\n### 学习开始前的准备\n\n心态我认为世界上没有“困难”的内容，只有“简单但是不完整”的内容。爱因斯坦说：“如果你不能让一个五岁小孩理解你的概念，那就意味着你对这个概念不够了解。”这句话的含义很丰富。首先，为什么一个五岁小孩具备可以理解所有概念的能力？因为所有概念本质上都是一个逻辑链条，一环接一环。只要把每一个环节的逻辑理解了，那你对这个概念本身就理解透了。这个逻辑链条上的每一环都不困难，所以一个五岁小孩都能理解。理解一个概念最困难的地方在于填补一个断裂的逻辑链条。很多时候，教科书里会说：“因为A，所以C。” 然而那个概念其实是“因为A，所以B，所以C。”在这个时候我们就会头大：看不懂A和C之间的联系啊，难道是因为A所以D所以C？还是因为A所以E所以C？困难就是在这个过程中出现的。我们都曾有过这个经历：自己苦苦思索了许久的难题，在别人一两句话的点拨下就豁然开朗。这种经历的本质就是对方告诉了你：“A和C之间缺失的那个部分是B。”从A到B到C的逻辑不难，难的是修补A和C之间断裂的逻辑链条。因此，我再次重复：世界上没有“困难”的内容，只有“简单但是不完整”的内容。当你在学习上感到气馁时，记住上面这句话，它将会给你继续探索的信心和勇气。\n\n---\n<!-- more -->\n\n### 痴迷（obsession）\n\n“痴迷”是我用过的最有效的方法。当我学到一个新概念时，如果我不能马上理解它，我就会一整天反复在脑中思索这个概念：走路时、吃饭时、坐车时都在思考。其实就是把别人看手机的时间拿来思考概念了。但是“痴迷”和常见的“利用碎片时间”有一个根本性的不同。利用碎片时间是被动的，是“因为我有这些时间，所以我要利用好它”；而痴迷是主动的，是“我对这个内容很好奇，所以我要弄懂它。”换句话说，利用碎片时间的重点在于“利用时间”，而痴迷的重点在于“你很好奇”。当你用“痴迷”的方法想通一个概念时，你就会把这个概念记得特别牢固，因为1）你花了很多时间反复思考它，这本身就是一个记忆的过程；2）你对这个概念会有自己的理解，知其然并知其所以然，而不是单纯把教科书背了下来。“知其然并知其所以然”意味着当你对这个概念的记忆变得模糊时，你脑里将有更多关于这个概念的内容来“提示”你将其记起来。\n\n### 有效率的学习策略\n\n当你遇到一道数学难题时，你会怎么做？查答案？自己苦苦思索？开始玩手机逃避？我的做法是在有答案的情况下先查答案，不浪费时间在解题过程上，而是把时间都花在理解概念上。这样才可以把时间的效用最大化，因为难题都是树的叶子，而题目考察的概念是树的主干。一棵树只有一个主干，但是可以有茫茫多的叶子。如果你每个难题都自己思索的话，你大概率得学到猴年马月了。因此，应对难题最好的方法不是硬刚，而是找答案。","tags":["杂谈"],"categories":["杂谈"]},{"title":"选择","url":"%2F%E9%80%89%E6%8B%A9.html","content":"\n{% centerquote %} \n没有方向的船，任何方向都是逆风。\n{% endcenterquote %} \n\n选择比努力更加重要。在中国这个有着特殊国情的国家里，个人的位置是很难找准定位的。混的差了，被人鄙夷。混的好了招人记恨。人就是喜欢互相比较，每个人的学习产出比是不一样的。不满足于现状，总想着明天一定比今天的自己强。\n\n--- \n<!--more-->\n\n每个人的格局和所谓的幸福度都是不一样的，nj1年10k看上去已经不错了，比上不足比下有余。有很多老家的年轻人拿着微薄的薪水过着随遇而安的生活，而有自尊心希望受到别人的肯定，努力地活下去。去外包就去外包吧，钱给足也是可以的。福利待遇有不错。就是估计要上sn和tn的黑名单了，发了offer都不去。。。也有需要重新租房等一系列问题。就是技术单一，工作环境差，内网环境。不管怎样都不能懈怠，不会这么一直干下去。","tags":["杂谈"],"categories":["杂谈"]},{"title":"console控制台优化","url":"%2Fconsole%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.html","content":"\n熟悉前端的不会对console和alert陌生，两者在调试的时候可谓是法宝级别的工具，但是关于console，其实远远不止于console.log这一个简单的命令，它能做的事情有很多，那么让我们来一起了解一下，它有哪些冷门功能吧。\n\n---\n<!--more-->\n### 显示信息的命令\n```javascript\nconsole.log('hello world');\nconsole.info('信息');\nconsole.error('错误');\nconsole.warn('警告');\n```\n\n### 占位符\n​ console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）\n```javascript\nconsole.log(\"%d年%d月%d日\",2016,11,11);\n```\n\n### 信息分组\n```javascript\nconsole.group(\"第一组信息\");\nconsole.log(\"第一组第一条:何问起(http://hovertree.com)\");\nconsole.log(\"第一组第二条:柯乐义(http://keleyi.com)\");\nconsole.groupEnd();\nconsole.group(\"第二组信息\");\nconsole.log(\"第二组第一条:HoverClock 一个jQuery时钟插件\");\nconsole.log(\"第二组第二条:欢迎使用\");\nconsole.groupEnd();\n```\n\n### 对象信息\n```javascript\nvar obj={\n    id:1,\n    name:123\n}\nconsole.dir(obj)\n```\n\n### 显示网页节点\n```javascript\nconsole.dirxml()用来显示网页的某个节点（node）所包含的html/xml代码\nvar info = document.getElementById('info');\nconsole.dirxml(info);\n```\n\n### 判断变量是否为真\n​console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。\n```javascript\nconsole.assert(1 == 1); \nconsole.assert(1 == 2); // Assertion failed: console.assert\n```\n\n### 追踪函数的调用踪迹\n```javascript\nfunction add(a,b){\nconsole.trace();\nreturn a+b;\n}\nvar x = add3(1,1);\nfunction add3(a,b){return add2(a,b);}\nfunction add2(a,b){return add1(a,b);}\nfunction add1(a,b){return add(a,b);}\n// add add1 add2 add3\n```\n\n### 计时功能\nconsole.time()和console.timeEnd()，用来显示代码的运行时间。\n```javascript\nconsole.time(\"控制台计时器一\");\nfor(var i=0;i<10000;i++){\nfor(var j=0;j<1000;j++){}\n}\nconsole.timeEnd(\"控制台计时器一\");\n```","tags":["优化"],"categories":["知识"]},{"title":"JavaScript性能优化","url":"%2Fjs%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html","content":"\n### 评估局部变量\n主要针对IE而言，由于局部变量的查找是从最特定作用域到最大作用域，且可以通过多个域\n层级，所以这种查找会导致查询到通用的结果。在定义函数作用域的时候，如果一个局部变\n量在之前没有进行过var变量声明， 那么此处一定要在变量名前加上var关键字以定义其当\n前的作用域和防止查询，从而提高代码的速度。\n\n---\n<!--more-->\n\n### 除非必要，否则不要使用嵌套循环\n减少不必要的循环，例如 for 和 while 循环，以保持 JavaScript 的线性，并避免需要遍历数千个对象。无用的循环可能会导致浏览器处理代码时更困难，从而减缓速度。\n\n### 缓存对象以提高性能\n很多时候，会重复使用脚本来访问某个对象。 将重复访问的对象存储在用户定义的变量中，并且之后在引用该对象时使用此变量，可以立刻实现性能提升。\n\n### 使用.js文件来缓存脚本\n使用这种技术可以实现性能提升，因为它允许浏览器只加载脚本一次，当页面被重新加载或重新访问时只需要从缓存中调用脚本即可。\n\n### 使用Gzip压缩文件\n使用 GZip 可以明显地降低 JavaScript 文件的大小，节省带宽，并加快响应时间。 有时 JavaScript 文件非常大，如果没有经过压缩，它可能会造成网站瘫痪。较小的文件能提供更快、更令人满意的网页体验。\n\n### 尽量减少对HTTP的请求\n通过结合外部文件和直接在 XHTML 页面中嵌入 JavaScript 来尽量减少对 HTTP 返回页面的请求。 每一个特定的 HTTP 请求传输至服务器端都会导致大量的时延。\n\n### 不要重复使用相同的脚本\n复的脚本对性能会造成显著的影响。重复的脚本会创建不需要的HTTP请求，尤其是在IE浏览器中。在HTML页面中使用脚本标签，可以帮助避免意外地生成重复的脚本。\n\n### 缩短作用域链\n全局作用域通常较慢，因为每次执行函数的时候，它会引发创建一个临时的调用作用域，JavaScript 会在作用域链中搜索第一个对象，如果找不到该变量，则会遍历链直到搜索到全局对象。\n\n### 使用函数内联\n函数内联有助于减少函数调用的成本，并用被调用的函数体替换函数调用。 在 JavaScript 中执行函数调用是一个高成本的操作，因为需要执行几个准备步骤：为参数分配空间，复制参数以及解析函数名称。\n\n### 尽量不要使用全局变量\n由于脚本引擎需要搜索作用域，所以当从函数内部或其他作用域内引用全局变量时，如果局部作用域丢失，全局变量将被销毁。如果全局作用域中的变量并不一直存在于脚本的生命周期，则可以提升性能。\n\n### 不要一直保留对其他文档的引用\n当脚本结束后不再保留对其他文档的引用可以实现更快的性能。因为对其他文档中的对象进行的任何引用不会被保存在整个 DOM 树中，并且脚本环境也不会一直保留在内存中。 因此文档本身不用再被加载。\n\n### 不要误用 for-in Object.hasOwnProperty()只遍历当前对象\n由于“for-in”循环需要脚本引擎构建包含所有可枚举属性的列表，因此 for 循环内的代码是不会修改这个列表的。 在 for 循环内部，预先计算出列表的长度并赋给变量 len，然后进行迭代。\n","tags":["性能优化"],"categories":["JS"]},{"title":"classNames在react上的应用","url":"%2FclassNames%E5%9C%A8react%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8.html","content":"\n### 前言\n\n在 Vue 里有一个动态的 class 语法，很好的根据条件动态设置 class。例如：\n```javascript\n<div class=\"button\" :class=\"{ active: show }\"></div>\n```\n就是当 show 为 true 时，此标签被赋予 active 样式。\n\n在 React 要实现这样功能，可能会这样做：\n```javascript\n<div className={`button ${show ? 'active' : ''}`}></div>\n```\n注意到，这里只有一个属性判断，如果有多个时会显得非常麻烦，那么现在使用 [ClassNames](https://github.com/JedWatson/classnames) 这个库来解决这个问题。\n\n---\n<!-- more -->\n\n### 基本使用\n`ClassNames` 是一个高性能、简便的用户根据条件动态设置 `className` 的 `Javascript` 库。\n\n它的使用非常简单，来看看下面的几种使用方式。（自己也可以开发一个类似的库，不过没必要再造轮子）\n```javascript\nimport classNames from 'classnames';\n\nclassNames('foo', 'bar');                   // => 'foo bar'\nclassNames('foo', { bar: true });           // => 'foo bar'\nclassNames({ 'foo-bar': true });            // => 'foo-bar'\nclassNames({ 'foo-bar': false });           // => ''\nclassNames({ foo: true }, { bar: true });   // => 'foo bar'\nclassNames({ foo: true, bar: true });       // => 'foo bar'\n\n// 多级嵌套，多参数\nclassNames('foo', { bar: true, duck: false }, 'baz', { quux: true });\n// => 'foo bar baz quux'\n\n// !! 为 false 的将被忽略\nclassNames(null, false, 'bar', undefined, 0, 1, { baz: null }, '');\n// => 'bar 1'\n```\n\n### 动态属性名\n在 ES6 下，可以使用模板语法，来设置跟强大的动态 `className`。\n```javascript\nconst buttonType = 'primary';\nclassNames({ [`btn-${buttonType}`]: true });\n```\n\n### 去重功能dedupe\n使用 dedupe 版本的 classNames 可以正确地对类进行重复数据删除，并确保在后面的参数中指定的错误类从结果集中排除。dedupe 会慢（约5倍），因此它是作为选择提供的（在默认是不会去重的）。\n```javascript\nimport classNames from 'classnames/dedupe';\n\nclassNames('foo', 'foo', 'bar');                // => 'foo bar'\nclassNames('foo', { foo: false, bar: true });   // => 'bar'\n```\n### 映射bind\n如果您使用 css-modules 或类似的方法来抽象类“名称”以及 className 实际输出到 DOM 的真实值，那么要使用 bind 版本。\n```javascript\nimport classNames from 'classnames/bind';\n// 映射关系\nconst styles = {\n    foo: 'abc',\n    bar: 'def',\n    baz: 'xyz'\n};\n\nconst cx = classNames.bind(styles);\nconst className = cx('foo', ['bar'], { baz: true });  //（1） => \"abc def xyz\"\n// const className = cx('abc', ['def'], { xyz: true }); （2）\n```\n这里什么意思呢？实际上就是把 foo 与 abc 产生映射，也就是说 （1） 和 （2） 两条语句是等效的，好处就像是定义一些常量一样。\n\n### 在React上使用\n如antd上的源码，prefix定义class\n```javascript\nconst prefixCls = 'alter';\n\nconst classs = classNames(prefixCls, {\n    [`${prefixCls}-${type}`]: true,\n    [`${prefixCls}-close`]: !this.state.closing,\n    [`${prefixCls}-with-description`]: !!description,\n    [`${prefixCls}-no-icon`]: !showIcon,\n    [`${prefixCls}-banner`]: !!banner,\n}, className);\n```\n\n### 参考资料\n- https://github.com/JedWatson/classnames\n- https://www.npmjs.com/package/classcat","tags":["react"],"categories":["JS"]},{"title":"generator生成器","url":"%2Fes6generator.html","content":"\n生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字，有意思的是函数会在每个yield后暂停。\n\n这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。\n\n--- \n<!-- more -->\n\nOK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。\n\n```javascript\n// 生成器\nfunction *createGenerator(){\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\n// 迭代器\nlet iterator=createGenerator()\nconsole.log(iterator.next().value) // 1\nconsole.log(iterator.next().value) // 2\nconsole.log(iterator.next().value) // 3\n```\n\n那生成器和迭代器又有什么用处呢？\n\n围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。\n\n生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。\n\n那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的：\n```javascript\nfunction run(taskDef){\n  // 创建迭代器，让它在别处可用\n  let task=taskDef();\n\n  // 启动任务\n  let result=task.next();\n\n  // 递归使用函数来保持对next()的调用\n  function step(){\n      // 如果还有更多要做的\n      if(!result.done){\n        result=task.next();\n        step();\n      }\n  }\n\n  // 开始处理过程\n  step();\n}\n```\n生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。可以不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 `yield` 来等待异步操作结束。\n\n\nes6引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n```javascript\nfunction timeout(ms){\n  return new Promise((resolve)=>{\n      setTimeout(resolve,ms)\n  });\n}\n\nasync function asyncPrint(value,ms){\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world',50)\n```\n\n一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\nasync函数对 Generator 函数的改进，体现在以下四点：\n- 内置执行器\n- 更好的语义\n- 更广的适用性\n- 返回值是Promise\n","tags":["es6"],"categories":["JS"]},{"title":"移动端web问题总结（长期更新）","url":"%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html","content":"\n### meta基础知识\n#### H5页面窗口自动调整到设备宽度，并禁止用户缩放页面\n```javascript\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```","tags":["知识"],"categories":["知识"]},{"title":"react组件实现按需加载","url":"%2Freact%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD.html","content":"\n第一种：ReactTraining/react-router 介绍的基于 webpack, babel-plugin-syntax-dynamic-import, 和 react-loadable.\n\n主要是利用了react-loadable这个高级组件，他是专门用来异步加载（也可以预加载）组件的。\n\nhttps://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/docs/guides/code-splitting.md\n\n ---\n <!-- more --> \n\n第二种：SF网友介绍的Bundle组件配合webpack组件bundle-loader\n\nbundle-loader效用其实和require.ensure()一样，把组件分片成单独的chunk，在Bundle组件中引入\n\nhttps://segmentfault.com/a/1190000009539836\n\n \n\n但是我尝试的时候发现总是报错说不要在import中引入webpack的loader。。。\n\n然后我继续查，发现第三种实现\n\n \n\n第三种：简书AlienZHOU介绍的同样基于create-react-app的方式，在Bundle组件中props入一个()=>import('path')函数\n\nhttp://www.jianshu.com/p/547aa7b92d8c\n\n \n\n第四种，create-react-app文档给的react-router按需加载实现：用一个类Bundle组件的异步函数\n\nhttps://serverless-stack.com/chapters/code-splitting-in-create-react-app.html\n\n这种方式我试了下，确实能分片，但是讨论里有人指出性能上不如Bundle组件，那个人好像还是Create-react-app的主要贡献者\n\n \n\n四种方式我都试过，期间。。这个过程略痛苦。。。不过结论是：第三种是目前我认为最好的，基于create-react-app，且实现最简单。\n\n但是较大的项目，一般我们都会eject出来自己配置webpack啦，其实影响也不大。\n\n","tags":["react"],"categories":["JS"]},{"title":"css绘制几何图形","url":"%2Fcss%E7%BB%98%E5%88%B6%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2.html","content":"\n### 圆\n```css\ndiv {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50px; \n/* 注意宽高相同圆角为一半 */\n}\n```\n\n### 四个不同方向的半圆\n```css\n.top\n{\n  width: 100px;\n  height: 50px;\n  border-radius: 50px 50px 0 0;\n}\n.right {\n  width: 50px;\n  height: 100px;\n  border-radius: 0 50px 50px 0;\n}\n.bottom {\n  width: 100px;\n  height: 50px;\n  border-radius: 0 0 50px 50px;\n}\n.left {\n  width: 50px;\n  height: 100px;\n  border-radius: 50px 0 0 50px;\n}\n```\n\n--- \n<!-- more -->\n\n### 四分之一圆\n```css\n{\n  width:50px;\n  height:50px;\n  border-radius:50px 0 0 0;\n}\n```\n\n### 菱形\n```css\n.quarter-ellipse{\n    width: 200px;\n    height: 150px;\n    border-radius: 100% 0 0 0;\n    background: black;\n}\n/*将菱形里的字转成正着的方向*/\n.paralle p{\n    transform: skew(20deg);\n}\n```\n\n### 三角形\n```css\n#triangle-up {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid lightblue;\n}\n#triangle-down {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-top: 100px solid lightblue;\n}\n\n#triangle-left {\n    width: 0;\n    height: 0;\n    border-top: 50px solid transparent;\n    border-right: 100px solid lightblue;\n    border-bottom: 50px solid transparent;\n}\n#triangle-right {\n    width: 0;\n    height: 0;\n    border-top: 50px solid transparent;\n    border-left: 100px solid lightblue;\n    border-bottom: 50px solid transparent;\n}\n#triangle-topleft {\n    width: 0;\n    height: 0;\n    border-top: 100px solid lightblue;\n    border-right: 100px solid transparent;\n}\n#triangle-topright {\n    width: 0;\n    height: 0;\n    border-top: 100px solid lightblue;\n    border-left: 100px solid transparent; \n}\n#triangle-bottomleft {\n    width: 0;\n    height: 0;\n    border-bottom: 100px solid lightblue;\n    border-right: 100px solid transparent;\n}\n#triangle-bottomright {\n    width: 0;\n    height: 0;\n    border-bottom: 100px solid lightblue;\n    border-left: 100px solid transparent;\n}\n```","tags":["布局"],"categories":["CSS"]},{"title":"Http请求概述","url":"%2Fhttp%E8%AF%B7%E6%B1%82%E6%A6%82%E8%BF%B0.html","content":"\n超文本传输协议（HTTP, HyperText Transfer Protocol）是一种无状态的协议，它位于OSI七层模型的传输层。HTTP客户端会根据需要构建合适的HTTP请求方法，而HTTP服务器会根据不同的HTTP请求方法做出不同的响应。\n\n--- \n<!-- more -->\n\n## HTTP版本\n在HTTP的发展过程中，出现了很多HTTP版本，其中的大部分协议都是向下兼容的。在进行HTTP请求时，客户端在请求时会告诉服务器它采用的协议版本号，而服务器则会在使用相同或者更早的协议版本进行响应。\n- HTTP/0.9\n这是HTTP最早大规模使用的版本，现已过时。在这个版本中 只有GET一种请求方法，在HTTP通讯也没有指定版本号，也不支持请求头信息。该版本不支持POST等方法，因此客户端向服务器传递信息的能力非常有限。HTTP/0.9的请求只有如下一行：\nGET www.baidu.com\n\n- HTTP/1.0\n这个版本是第一个在HTTP通讯中指定版本号的协议版本，HTTP/1.0至今仍被广泛采用，特别是在代理服务器中。该版本支持：GET、POST、HEAD三种HTTP请求方法。\n- HTTP/1.1\n\nHTTP/1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。\n\n- HTTP/2\n这个版本是最新发布的版本，于今年5月（2015年5月）做HTTP标准正式发布。HTTP/2通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。\n\n## HTTP请求方法\n\n### HTTP/1.1\n协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。\n\n#### GET\nGET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。\n\n#### HEAD\nHEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。\n\n#### POST\nPOST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被 包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。\n\n#### PUT\nPUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。\n\n#### DELETE\nDELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。\n\n#### CONNECT\nCONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。\n\n#### OPTIONS\nOPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用 * 来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。\n\n#### TRACE\nTRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。\n\n### HTTP/1.1之后增加的方法\n在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是PATCH 方法:\n\n#### PATCH\nPATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：\n1.PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。\n2.当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。\n\n### 请求头和响应头\n\n1)请求(客户端->服务端[request]) \n    GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) \n    Accept: */*(客户端能接收的资源类型) \n    Accept-Language: en-us(客户端接收的语言类型) \n    Connection: Keep-Alive(维护客户端和服务端的连接关系) \n    Host: localhost:8080(连接的目标主机和端口号) \n    Referer: http://localhost/links.asp(告诉服务器我来自于哪里) \n    User-Agent: Mozilla/4.0(客户端版本号的名字) \n    Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) \n    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  \n    Cookie(客户端暂存服务端的信息) \n    Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)\n\n\n2)响应(服务端->客户端[response])\n    HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)\n    Location: http://www.baidu.com(服务端需要客户端访问的页面路径) \n    Server:apache tomcat(服务端的Web服务端名)\n    Content-Encoding: gzip(服务端能够发送压缩编码类型) \n    Content-Length: 80(服务端发送的压缩数据的长度) \n    Content-Language: zh-cn(服务端发送的语言类型) \n    Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)\n    Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)\n    Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)\n    Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)\n    Transfer-Encoding: chunked(分块传递数据到客户端）  \n    Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)\n    Expires: -1//3种(服务端禁止客户端缓存页面数据)\n    Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  \n    Pragma: no-cache(服务端禁止客户端缓存页面数据)   \n    Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  \n    Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)\n在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。","tags":["http"],"categories":["知识"]},{"title":"获取浏览器url参数方法总结","url":"%2F%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html","content":" \n1. 正则(xxx?typeId=1)\n```javascript\nfunction getQueryString(name) {\n    var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');\n    var r = window.location.search.substr(1).match(reg);\n    if (r != null) {\n        // return unescape(r[2]); // 中文会乱码\n        return decodeURI(r[2]);\n    }\n    return null;\n}\ngetQueryString(\"typeId\") // \"2\"\n\n```\n\n---\n<!-- more -->\n\n2. split拆分\n```javascript\nfunction getQueryString() {\n    var url = location.search; //获取url中\"?\"符后的字串\n    var theRequest = new Object();\n    if (url.indexOf(\"?\") != -1) {\n        var str = url.substr(1);\n        strs = str.split(\"&\");\n        for(var i = 0; i < strs.length; i ++) {\n            theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]);\n        }\n    }\n    return theRequest;\n}\ngetQueryString(\"typeId\") // {typeId:\"2}\n```\n\n3. 正则获值 和1一样\n```javascript\nfunction getQueryString(name) {  \n    var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");  \n    var r = window.location.search.substr(1).match(reg);  //获取url中\"?\"符后的字符串并正则匹配\n    var context = \"\";  \n    if (r != null)  \n         context = r[2];  \n    reg = null;  \n    r = null;  \n    return context == null || context == \"\" || context == \"undefined\" ? \"\" : context;  \n}\n```\n\n4. 单参数获取(?1)获取？后面的数据\n```javascript\nvar url=window.location.href\nurl.substring(url.indexOf('?') + 1)\n// url.substr(url.indexOf('?') + 1)\n\nvar url=window.location.search\nurl.substring(1)\n// url.substr(1)\n```\n\n","tags":["知识"],"categories":["知识"]},{"title":"单页应用优缺点分析","url":"%2Fspa.html","content":"\n单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。\n\n--- \n<!--more-->\n\n## 优点：\n1、分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；前后台分离开发模式。\n\n2、减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；\n\n3、同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；\n\n4. 服务器压力变小，后台不需要负责模板渲染，输出页面工作。ajax实现页面刷新，不需要重新加载整个页面。\n\n## 缺点：\n1、SEO问题，现在可以通过Prerender等技术解决一部分；\n\n2、前进、后退、地址栏等，需要自行实现；\n\n3、初次加载时间较多；\n","tags":["知识"],"categories":["知识"]},{"title":"https加密通信流程解析","url":"%2Fhttps%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1.html","content":"\nhttps其实是有两部分组成：http + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。\n\nhttps比http要占用更多的资源，http使用TCP 三次握手建立连接，客户端和服务器需要交换3个包，https除了 TCP 的三个包，还要加上 ssl握手需要的9个包，所以一共是12个包。\n\n---\n\n<!-- more -->\n\n## 流程解析\n\n### 客户端发起HTTPS请求\n\n用户在浏览器里输入一个https网址，然后连接到server的443端口。\n\n### 服务端的配置\n\n采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。\n\n### 传送证书\n\n这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。\n\n### 传送加密信息\n\n这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。\n\n### 服务端解密信息\n\n服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。\n\n### 传输加密后的信息\n\n这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。\n\n### 客户端解密信息\n\n客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。","tags":["http"],"categories":["知识"]},{"title":"网页埋点相关知识","url":"%2F%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF.html","content":"\n埋点的需求：一个网站上线,开发者除了保证网站功能正常,体验优好之外,还有一项重要的工作是数据收集,通过收集用户的行为数据可以帮助了解网站的功能是否满足用户的需求,导流方式是否有效,新功能上线后是否效果是否达到设计初衷,根据数据指引有效优化产品体验以及发现新的产品方向是产品经理的必备技能,而如何采集准确并且足够的网站数据则应该是开发者的责任.在大数据处理能力越来越强下,以及机器学习等依赖数据哺育的工具进化下,采集足够多的数据往往是网站向着良性方向进化的必备条件\n\n---\n\n<!-- more -->\n\n## 常见工具\n\n网站的数据采集有很多现成的工具,如google Analytics, 百度统计, 友盟+等,往往通过在页面上接入js SDK代码。\n\n而在实际采集过程中,数据是如何传递过去的呢,,我们随便打开一个埋有百度统计的网站, 打开chrome的开发者工具,勾选Preserve log,\n可以发现在页面点击一个链接或者做一些其他操作,在Networking tab下可以看到hm.gif的网络请求, 这里由于统计的数据发送涉及到第三方网址,涉及跨域问题,而图片请求天然是跨域的,所以业界的通用做法是构造一个空的gif用于向第三方网站, 而真正需要统计的参数往往是通过url进行传递。\n\n## 数据采集(生成图片Url参数挂在?上)\n\n- 基本的发送函数，创建Img发送统计请求导数据采集后台。\n```javascript\nfunction sendUrl(url) {\n    let img = new Image();  // 创建一个img对象\n    let key = 'project_log_' // 为本次数据请求创建一个唯一id\n        + Math.floor(Math.random() * 2147483648).toString(36); \n \n    window[key] = img;   // 用一个数组维护img对象\n \n    img.onload = img.onerror = img.onabort = function () {\n        img.onload = img.onerror = img.onabort = null;  // 清除img元素\n        window[key] = null;\n        img = null;  \n    };\n    img.src = url;  // img对象赋值url后自动发送请求,无需插入到页面元素中去\n}\n```\n\n- 数据格式约定\n```javascript\n数据格式规则,如:1.gif?q=xxx&fr=xxx&refer=xxx&p=xxxx&xxxxx\nq表示页面搜索词; fr表示页面的上游页面时什么, refer是指从来源页面, p表示事件类型等;\n```\n\n## 访问时长的计算\n```javascript\nvar st = new Date().getTime();  // 在页面加载运行js时记录当前时间\n\n$(window).on('beforeunload', function () {\n    var et = new Date().getTime();\n    var stayTime = et - st;\n    \n}); // 在页面要unload触发'beforeunload'事件时进行时间差计算得到访问时长\n```\n\n## 关键指标\n### PV pageview\n\n传统意义上每次页面刷新代表着一次新的pv, 也就是每次统计js执行时都+1, 而现在页面很多都用到了ajax技术来进行无刷新获取展现页面来替代翻页,如瀑布流页面通过下来加载新的页面,这时候页面不重新刷新,因此可以在ajax请求接口处进行埋点进行pv累加;\n\n### 单项PV\n\n页面上部分元素有单独统计pv的需要,有些页面元素不是页面展现都展现,或者需要统计类似于某一广告的展现次数,这种需要需要在url里单独定义参数来标识;\n\n### 聚焦时间\n\n与访问时长不同,由于页面可以通过tab切换导致虽然页面没有unload但实际处于失去焦点状态, 因此需要订阅focusIn与focusOut两个事件,在focusIn时开始计时, 在focusOut时停止计时,在页面unload时将focus时间进行累加得到聚焦时间;","tags":["知识"],"categories":["知识"]},{"title":"export/export default/import的区别以及用法","url":"%2Fes6export.html","content":"\nES6模块主要有两个功能：export和import\n\nexport用于对外输出本模块（一个文件可以理解为一个模块）变量的接口\n\nimport用于在一个模块中加载另一个含有export接口的模块。\n\n也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。\n\n---\n<!-- more -->\n\n## export和import（一个导出一个导入）\n```javascript\n// a 文件 \nexport var name=\"cosyer\" // 导出单个变量\n\n// 引用a文件 \nimport {name} from './a'\nexport default {\n    data(){\n\n    },\n    howl:function (){\n    console.log(name) // cosyer\n    }\n}\n\n// 导出多个变量 \nlet name1='张三';\nlet name2='李四';\nexport {name1,name2}\n\n// 引用多个变量\nimport {name1,name2} from './a'\n\n// 导出函数\nfunction mini(num){\n    console.log(num)\n}\n\nexport {mini}\n\n// 引用函数\nimport {mini} from './a'\nexport default{\n    howl:function(){\n        mini(1) // 1\n    }\n}\n```\n\n## export和export default\n\n1. export与export default均可用于导出常量、函数、文件、模块等。\n\n2. 你可以在其它文件或模块中通过import + (常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用。\n\n3. 在一个文件或模块中，export、import可以有多个，export default仅有一个。\n\n```javascript\nexport name1;\nexport name2;\n```\n\n4. 通过export方式导出，在导入时要加{}，export default则不需要。\n\n其实很多时候export与export default可以实现同样的目的，但使用export default命令，为模块指定默认输出，这样就不需要知道加载模块的变量名。\n\n```javascript\nexport default name\nimport name from './a'\n```\n\n- 当用export default people导出时，就用 import people 导入（不带大括号）。\n- 一个文件里，有且只能有一个export default。但可以有多个export。\n- 当用export name 时，就用 import{name} 导入（记得带上大括号）。\n- 当一个文件里，既有一个export default people, 又有多个export name 或者 - export age时，导入就用 importpeople,{name,age}。\n- 当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用 import * as example。","tags":["es6"],"categories":["JS"]},{"title":"mobx -- 走进观察者模式","url":"%2Fmobx.html","content":"\n#### React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。\n#### React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。\n#### MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。\n#### redux缓存机制 时间回溯适用于撤销操作 操作状态\n\n1. 安装\n~~~\nnpm install --save mobx mobx-react\n~~~\n2. 核心概念\n- state(状态) \n状态是驱动应用的数据。\n- observable(value) && @observable \nObservable 值可以是JS基本数据类型、引用类型、普通对象、类实例、数组和映射。其修饰的state会暴露出来供观察者使用。\n- observer(观察者)\n被observer修饰的组件，将会根据组件内使用到的被observable修饰的state的变化而自动重新渲染。\n- action(动作)\n只有在 actions 中，才可以修改 Mobx 中 state 的值。\naction-->state-->view\n- computed \n计算值(computed values)是可以根据现有的状态或其它计算值衍生出的值。(可以看成公式)\ngetter：获得计算得到的新state并返回。\nsetter： 不能用来直接改变计算属性的值，但是它们可以用来作\"逆向\"衍生。\n- autorun\n这通常是当你需要从反应式代码桥接到命令式代码的情况，例如打印日志、持久化或者更新UI的代码。\n- 如果你有一个函数应该自动运行，但不会产生一个新的值，请使用autorun。 其余情况都应该使用 computed。\n- reactions\nReactions 和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新 React 组件树以修补DOM、等等。 简而言之，reactions 在 响应式编程和命令式编程之间建立沟通的桥梁。\n\n~~~\n// component\nimport {inject, observer} from \"mobx-react\";\n\n// 观察者 注入store添加到属性上\n@inject(\"store\") @observer\n\nthis.props.store.xxStore.num\nthis.props.store.xxStore.plus() // num+=1\nthis.props.store.xxStore.total\n\n// homeStore\n\n@observable num;\nconstrutor(){\n    this.name=''\n    this.items=[]\n}\n\n@computed get total() {\n    return this.items.length;\n }\n  \n@action plus=()=>{\n    this.num+=1\n}\n\nautorun((e)=>{})\n\nconst homeStore =new HomeStore()\nexport {homeStore}\n~~~\n\n~~~\nswitch\nrouter render={(props)=><Item {...props}/>}\nrouter component={Index}\nreact-route-dom\nwithRouter\nLinking\n// Provider 传递stores\nPrivider store={stores}\ncreate-react-app react-scripts\n~~~\n基本就这两种方法:immutable/observable\nmobx: oop\nredux: 函数式\n\nssr:流模式、字符串\n\n[demo地址](https://github.com/cosyer/mobx-demo)\n\n","tags":["状态管理"],"categories":["JS"]},{"title":"主流浏览器的内核和渲染方式解读","url":"%2F%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E8%A7%A3%E8%AF%BB.html","content":"\n## 浏览器内核\n- Trident:IE，360，搜狗\n\n- Gecko：firefox\n\n- webkit:safari，旧版chrome\n\n- presto：旧版opera\n\n- blink：新版chrome，新版opera\n\n## 浏览器的渲染方式\n\n1. 构建DOM树\n浏览器请求到html代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求。\n\n2. 构建CSSOM\ncss文件加载完成，开始构建CSSOM\n\n3. 生成渲染树（Render Tree）\nCSSOM构建结束后，和DOM一起生成Render Tree\n\n4. 布局（Layout）\n有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义以及他们的从属关系。开始布局，计算出各个节点在屏幕中的位置。\n\n5. Paint绘制\n布局之后，浏览器知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置。所以接下来按照算出来的规则，通过显卡，把内容画在屏幕上。","tags":["知识"],"categories":["知识"]},{"title":"flex布局","url":"%2Fflex.html","content":"\n芮 rui 四声\n\n浏览器前缀 -webkit/chrome、safari -moz/firefox -ms/ie -o/opera\n\n弹性伸缩flexbox布局 \n\n任何一个容器都可设为display:flex\n\n行内元素 display:inline-flex\n\nwebkit内核浏览器（Safari） display:-webkit-flex; display:flex\n\n设为flex布局以后，子元素的float、clear、vertival-align属性将失效。\n\n--- \n<!-- more -->\n## 容器的属性\n### flex-direction 决定主轴的方向\n\nflex-direction:row;  /*默认：从左到右*/\n\nflex-direction:row-reverse;  /*从右到左*/\n\nflex-direction:column;  /*从上到下*/\n\nflex-direction:column-reverse;  /*从下到上*/\n\n### flex-wrap:一条轴排列不下，如何换行\n\nflex-wrap:nowrap;  /*默认:不换行*/\n\nflex-wrap:wrap;  /*换行，第一行在上方*/\n\nflex-wrap:wrap-reverse;  /*换行，第一行在下方*/\n\n### flex-flow：上面两个的简写\nflex-flow:fiex-direction flex-wrap;  /*默认 row no-wrap*/\n\n### justify-content:主轴上的对齐方式\n\njustify-content:flex-start;  /*默认：左对齐*/\n\njustify-content:flex-end;  /*右对齐*/\n\njustify-content:center;  /*居中*/\n\njustify-content:space-between;  /*两端对齐，项目之间的间隔相同，边缘项目紧贴边框*/\n\njustify-content:space-around;  /*项目两侧的间隔相同，所以，项目之间的间隔比项目与边框的间隔大一倍*/\n\n### align-items:交叉轴上如何对齐\n\nalign-items:flex-start;  /*起点对齐*/\n\nalign-items:flex-end;  /*终点对齐*/\n\nalign-items:center;  /*中点对齐*/\n\nalign-items:baseline;  /*项目的第一行文字的基线对齐*/\n\nalign-items:stretch;  /*默认：项目未设高度或auto，占满整个容器高度*/\n\n### align-content：多根轴线的对齐方式，只有一根轴线时，不起作用。\n\naling-content:flex-start;  /*与交叉轴的起点对齐*/\n\naling-content:flex-end;  /*与交叉轴的终点对齐*/\n\naling-content:center;  /*与交叉轴的中点对齐*/\n\naling-content:space-between;  /*与交叉轴两端对齐，轴线之间的间隔平均分布。*/\n\naling-content:space-around;  /*每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍*/\n\naling-content:stretch;  /*默认：轴线占满整个交叉轴*/\n\n## 项目的属性\n\n### order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\norder:1;\n\norder:99;\n\norder:-1;   \n\n/*-1 1 99的顺序排列*/\n\n### flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n\nflex-grow: <number>; /* default 0 */\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。\n\n如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### flex-shrink:定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\nflex-shrink: <number>; /* default 1 */\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。\n\n如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### flex-basis:定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\nflex-basis: <length> | auto; /* default auto */\n\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n### flex:是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\nflex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n\n### align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\nalign-self: auto | flex-start | flex-end | center | baseline | stretch;\n\n## react-native使用flex布局注意点\n\n- 样式对象需要驼峰式写法\n- React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。\n\n首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。\n\n## 扩展阅读：\n[w3cplus指南](http://www.w3cplus.com/css3/a-guide-to-flexbox-new.html)\n[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n[思维图](http://blog.csdn.net/magneto7/article/details/70854472)","tags":["布局"],"categories":["CSS"]},{"title":"前端工程化","url":"%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html","content":"\n前端的工程化、模块化、组件化。\n\n1. 广义的前端工程化\n\n前端工程是软件工程的一个子类，指的是将软件工程的方法和原理运用在前端开发中, 目的是实现高效开发，有效协同，质量可控。\n\n2. 狭义的前端工程化\n\n前端工程是指将开发阶段代码转变成生产环境的代码的一系列步骤。主要包括构建，分支管理，自动化测试，部署等。\n\n前端工程化的具体内容\n\n1. 代码规范：保证团队所有成员以同样的规范开发代码。\n\n2. 分支管理：不同的开发人员开发不同的功能或组件，按照统一的流程合并到主干。\n\n3. 模块管理：一方面，团队引用的模块应该是规范的；另一方面，必须保证这些模块可以正确的加入到最终编译好的包文件中。\n\n4. 自动化测试：为了保证和并进主干的代码达到质量标准，必须有测试，而且测试应该是自动化的，可以回归的。\n\n5. 构建：主干更新以后，自动将代码编译为最终的目标格式，并且准备好各种静态资源，\n\n6. 部署：将构建好的代码部署到生产环境。","tags":["知识"],"categories":["知识"]},{"title":"服务器推技术","url":"%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E6%8A%80%E6%9C%AF.html","content":"\n在做前端页面渲染时，经常会遇到有的组件需要跟随数据的变化而实时的变化，例如：一个线上报名系统，总人数有一定限制，所以要实时的展现已经报名的人数，应该怎么实现呢？最基本有如下3种方案：\n\n- Ajax轮询\n- Ajax长轮询(comet)\n- websocket长连接\n\n--- \n<!-- more -->\n\n## Ajax轮询\n\n### 优点\n实现简单，利用XHR,通过setInterval定时向后端发送请求。\n\n### 缺点\n会造成数据在一小段时间内不同步和大量无效的请求，增加后端处理压力.\n\n```javascript\nsetInterval(function() {\n    $.ajax({\n        url: 'https://www.baidu.com/',\n        success: function() {\n            //success code\n        }\n    });\n}, 3000);\n```\n\n## Ajax长轮询(comet)\n\n在Ajax轮询的基础上做的一点改进，在后端数据没有更新的时候不再返回空响应，而且后端一直保存连接，直到后端有数据变化，则相应请求并且关闭连接，前端收到数据，马上再次向后端发起请求，并处理刚刚收到的数据。\n\n通常的做法是，在服务器的程序中加入一个死循环，在循环中监测数据的变动。当发现新数据时，立即将其输出给浏览器并断开连接，浏览器在收到数据后，再次发起请求以进入下一个周期。\n\n```javascript\nfunction async() {\n    $.ajax({\n        url: 'http://api.3g.qq.com',\n        success: function() {\n            async();\n            //success code\n        }\n    });\n}\n```\n\n## websocket长连接\n\nWebSocket是html5出来的东西(协议)，也就是说和http协议没关系，但http是不支持长链接的，WebSocket其实是一个新协议，跟http协议基本没有关系，只是为了兼容现有浏览器的握手规范而已。\n\nWebSocket通信协议包含两个部分，一是开放性HTTP握手连接协商连接参数，二是二进制消息分帧机制（接收消息的文本和二进制数据传输）。它是一个独立完善的协议，也可以在浏览器之外实现。\n\n### HTTP升级协商\n\nWebSocket协议提供了很多强大的特性：基于消息的通信、自定义的二进制分帧层、子协议协商、可选的协议扩展，等等。即在交换数据之前，客户端必须与服务器协商适当的参数以建立连接。\n\n利用HTTP完成握手有几个好处。首先，让WebSockets与现有HTTP基础设施兼容：WebSocket服务器可以运行在80和443 端口上，这通常是对客户端唯一开放的端口。其次，让我们可以重用并扩展HTTP的Upgrade流，为其添加自定义的WebSocket首部，以完成协商。\n\n### 请求头信息\n\nConnection:Upgrade Sec-WebSocket-Key:eDCPPyPQZq7PiwRcx8SPog== Sec-WebSocket-Version:13 Upgrade:websocket \n\n### 响应头信息\n\nHTTP/1.1 101 Switching Protocols Connection:Upgrade Sec-WebSocket-Accept:/ZVAP3n6XuqDUoDp416PYUO+ZJc= Upgrade:websocket\n\n\n最后，前述握手完成后，如果握手成功，该连接就可以用作双向通信信道交换WebSocket消息。到此，客户端与服务器之间不会再发生HTTP通信，一切由WebSocket 协议接管。\n\n### 具体使用方法，本文采用node.js中的Socket.IO来进行说明：\n\n1. 服务端创建socket.io的实例\n\n```javascript\nvar app = require('express')(); \nvar http = require('http').Server(app); \nvar io = require('socket.io')(http);//创建实例 \n\napp.get('/', function(req, res){ res.sendfile('index.html'); });\n\nio.on('connection', function(socket){ \n    console.log('a user connected'); \n});// 监听前端连接 \n\nhttp.listen(3000, function(){ console.log('listening on *:3000'); });  \n```\n\n2. 数据传输\n\n```javascript\n// 前端客户端向后端发送数据：\nsocket.emit('chat message', $('#m').val()); \n\n// 后端接收数据：\n\nio.on('connection', function(socket){ socket.on('chat message', function(msg){ \n    console.log('message: ' + msg); }); \n}); \n\n// 后端向前端发送数据：\n\nio.on('connection', function(socket){ socket.on('chat message', function(msg){ \n    io.emit('chat message', msg); }); }); \n\n// 前端接收数据：\n\nsocket.on('chat message', function(msg){ console.log(msg); });\n```","tags":["知识"],"categories":["知识"]},{"title":"函数的防抖和节流","url":"%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html","content":"\n场景：事件频繁被触发，频繁执行DOM操作、资源加载等重复行为，导致UI停顿甚至浏览器崩溃。\n\n函数防抖和节流用于限制函数的执行。是优化高频率执行js代码的一种手段。\n\n---\n<!--more-->\n\n## 函数防抖\n\n函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。\n\n```javascript\nvar debounce = function(idle,action){\n  var last;\n  return function(){\n    var ctx = this,\n        args = arguments;\n    clearTimeout(last);\n    last = setTimeout(function(){\n      action.apply(ctx,args);\n    },idle);\n  }\n}\n\n// 返回函数连续调用时，空闲时间必须大于或等于idle，action才会执行。\n```\n\n### 实际例子\n\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n```javascript\nfunction debounce(fn, wait) {\n    var timeout = null;\n    return function() {\n        if(timeout !== null) \n                clearTimeout(timeout);\n        timeout = setTimeout(fn, wait);\n    }\n}\n// 处理函数\nfunction handle() {\n    console.log(Math.random()); \n}\n// 滚动事件\nwindow.addEventListener('scroll', debounce(handle, 1000));\n```\n\n当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。\n\n函数防抖适用于连续调用函数，但只在延时后调用一次。定时器存在则销毁，第一次一定会创建并调用函数。\n\n## 函数节流\n\n每隔某个时间去执行某函数，避免函数的过多执行。\n\n如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是说会先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。\n\n```javascript\nvar throttle = function(delay,action){\n  var last ;\n  return function(){\n    var cur = +new Date();  //返回毫秒数\n    if(cur - last > = delay){\n      action.apply(this,arguments);\n      last = cur;\n    }\n  }\n}\n```\n\n### 实际例子\n函数节流主要有两种实现方法：时间戳和定时器。\n```javascript\nvar throttle = function(func, delay) {\n    var prev = Date.now();\n    return function() {\n        var context = this;\n        var args = arguments;\n        var now = Date.now();\n        if (now - prev >= delay) {\n            func.apply(context, args);\n            prev = Date.now();\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    return function() {\n        var context = this;\n        var args = arguments;\n        if (!timer) {\n            timer = setTimeout(function() {\n                func.apply(context, args);\n                timer = null;\n            }, delay);\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n函数节流适用于间接性调用函数。定时器不存在则创建调用函数，定时销毁。","tags":["知识"],"categories":["JS"]},{"title":"在去上海前的一些想法","url":"%2Fbeforehz.html","content":"\n怯懦的我终于和领导提出了离职，从8月11号入职以来，jenkins打包管理、bugatti自动化部署等等惊艳到了在上家公司还是用手动发包javac的我，学到了更正规的软件开发流程体系和产品线的迭代，KA项目的定制化。从1月开始一直用RN做相关的微应用，期间虽然也做过小程序、mui的H5、antd的中后台系统，但大多数时间还是用RN写业务应用。经过几个应用的锻炼、改造，已经封出了一些较能应付业务需求的组件。复杂的集成调用框架那边都做了，其他部分做起来没有什么技术含量了。我知道已经毕业1年的我该做出些改变了。\n\n---\n<!-- more -->\n\n面对领导们的挽留，我也只能笑着婉拒。我想在大前端的道路上迈的更远，本来就没打算活很长的时间，在短暂还算充满干劲的人生中多做点自己感到快乐的事。说来也是好笑，来了南京这么久也没出去逛过，只对公司和公寓周边熟悉一些，真是符合我的作风啊o(*￣︶￣*)o。\n\n依稀还记得刚追被去南京发展是我的内心也是非常慌乱的，陌生的城市、环境和人不停地在劝退着我，投递的简历有了回复，我不断预演这面试的场景，竟可能多的将自己的优势展现出来。将近2个小时的长途客车旅途，我到了南京南站，摸着黑上了地铁到了软件大道。9点半又误打误撞地摸到了目的地，不好意思随便进入，随即打电话确认（有人来引下路多好）。等待的过程忐忑不安，人生第一次经历三轮面试，和技术聊真的开心啊O(∩_∩)O哈哈~面试完后立即又买了车票回了家汗~~\n\n自从工作以来就没请过假，没迟过到。自尊心强烈的我很在意别人对我的看法。去年买了房，房贷没什么压力。房子让父母住，我在工作的地方租房住，这是我的规划。不想去相亲，不想被各种绑架。\n\n作为熟练的api caller，高中之前的学习是多么快乐啊，是的，做题(除了语文)学习很快乐。新思维解题都是带来很多不同的思路，课堂上有选择地去学习自己喜欢的事物。虽然被老师骂的惨，但暗地里还是支持的。没压力地考上了重点高中，进城上高中了，才感觉到差距是巨大的。城里的小孩终究是不一样的，读过的书也好，培养的兴趣爱好也好，上过的兴趣班都远超过你。学的东西都是套路化的解题，枯燥乏味。渲染了xx的气氛，表达了xx什么的情感。各种烦心、倒霉的事也接踵而来，小小的幸福被扼杀。好奇心和脖子的扭，知道的越多，越觉得绝望。见过的所谓的'真实'，都是为了利益。永远不要去试探人性。现在看来都只是可笑的借口罢了，压力抑郁到自残。人与人之间最公平的就是时间了，每个人一天都是24小时，谁也不多，谁也不少。特别佩服那些活的独立、认真的人们。他们年轻、强大、充满个性，差距真的差到天差地别，是我前进的目标和憧憬的对象。我不会再迷茫了，毕竟~~~\n\n{% centerquote %} \n不去做的话永远也做不到。\n{% endcenterquote %} \n\ns(优势):互联网氛围、大牛、技术提升\nw(劣势):房租、10m2的地下室、消费、离家远、通勤时间、异地恋\no(机会):更高的待遇天花板、未来发展\nt(威胁):陌生的城市、重新整理技术体系、面试\n\n---\n\ns:门面做的不错、近10k（南京1年经验）、双休（有时间做自己项目学习、接外包）、雨花台区（离老婆近）\nw:不融资、官网low、没核心产品（说在招人明年做、说呆1年能到13-14 0^0？？？）、着急招人（目前人数较少？）、外包园、1-3年9-12k？？？常见都是10-15k。\n\n南京这边的工资待遇真的很低，感觉像命运一样，留了最后一张简历，偏偏扇贝又在这个时候叫我去面试。面试居然还提供饮品。这边催着入职，前面的还没消息，说到底还是自己太懦弱了，如果有联系或者果断点，就不会有这样的情况出现了。不去试一试怎么会知道呢，担当起自己的responsibility。\n\n2周前投的现在认识才提醒面试是不是太迟了；虽然很想去，技术氛围浓厚。大公司就会比较选人，不会立即给你答复。可这边的工作急着让你给答复。唉就这样形成了现在的处境。努力沉淀一点再跳槽到新公司吧！！！\n\n半杯水，懂了么。自身的强大很重要，more experience 成年人 卧薪尝胆\n\n办公环境、补贴、五险一金、工资、福利待遇、氛围、大公司镀金、自身的强大。选择比努力更重要，实力和机遇。看看别人的评分98，6周年dlun这种自研的能跟着一起成长。大格局，这样会越来越迷茫找不到自己的定位，半杯水的思想。真正的效率。","tags":["杂谈"],"categories":["杂谈"]},{"title":"常见排序的JS实现","url":"%2Fsort.html","content":"\nhttps://github.com/damonare/Sorts 这位大兄弟♂总结的很好，快去看看吧！\n---\n<!-- more -->\n\n```javascript\n/**\n * 常见排序的JS实现\n */\n\nvar Sort = {\n    //快速排序(递归)\n    quick: function(arr) {\n\n        var nLength = arr.length,\n            pivotIndex = Math.floor(nLength / 2),\n            pivot = arr.splice(pivotIndex, 1)[0],\n            left = [],\n            right = [];\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] < pivot) {\n                left.push(arr[i]);\n            } else {\n                right.push(arr[i]);\n            }\n        }\n\n        return arguments.callee(left).concat([pivot], arguments.callee(right));\n    },\n\n    //冒泡排序\n    bubble: function(arr) {\n        var nLength = arr.length;\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var i = nLength - 1; i > 0; --i) {\n            for (var j = 0; j < i; ++j) {\n                if (arr[j] > arr[j + 1]) {\n                    var temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n        return arr;\n    },\n\n    //选择排序\n    selection: function(arr) {\n        var nLength = arr.length;\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var i = 0; i < nLength; i++) {\n            var index = i;\n            for (var j = i + 1; j < nLength; j++) {\n                if (arr[j] < arr[index]) {\n                    index = j;\n                }\n            }\n\n            if (i !== index) {\n                var temp = arr[i];\n                arr[i] = arr[index];\n                arr[index] = temp;\n            }\n        }\n\n        return arr;\n    },\n\n    //插入排序\n    insertion: function(arr) {\n        var nLength = arr.length;\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var i = 1; i < nLength; ++i) {\n            var j = i,\n                value = arr[i];\n\n            while (j > 0 && arr[j - 1] > value) {\n                arr[j] = arr[j - 1];\n                --j;\n            }\n\n            if (j !== i) {\n                arr[j] = value;\n            }\n        }\n\n        return arr;\n    },\n\n    //希尔排序\n    shell: function(arr) {\n        var nLength = arr.length;\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var step = nLength >> 1; step > 0; step >>= 1) {\n            for (var i = 0; i < step; ++i) {\n                for (var j = i + step; j < nLength; j += step) {\n                    var k = j,\n                        value = arr[j];\n                    while (k >= step && arr[k - step] > value) {\n                        arr[k] = arr[k - step];\n                        k -= step;\n                    }\n                    arr[k] = value;\n                }\n            }\n        }\n        return arr;\n    }\n};\n```","tags":["排序"],"categories":["JS"]},{"title":"详解 Cookie、 LocalStorage 与 SessionStorage","url":"%2Fstorage.html","content":"\n## Cookie\n\nCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n## localStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。\n\n缺点：\n1. 存储容量限制，大部分浏览器应该最多5M。\n2. 仅支持字符串，如果是存对象还需要将使用JSON.stringify和JSON.parse方法互相转换，有些啰嗦。\n3. 读取都是同步的。大多数情况下，还挺好使的。但如果存储数据比较大，例如一张重要图片base64格式存储了，读取可能会有可感知的延迟时间。\n\n## sessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n--- \n<!-- more -->\n\n## 三者的异同\n\n|特性|Cookie|localstorage|sessionstorage|\n|:---:|:---:|:---:|\n|生命周期|一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效|除非被清除，否则永久保存|仅在当前会话下有效，关闭页面或浏览器后被清除|\n|数据大小|4K|5M|5M|\n|与服务器端通信|每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题|仅在客户端（即浏览器）中保存，不参与和服务器的通信|同上|\n|易用性|需要自己封装，原生的Cookie接口不友好|可以封装来对Object和Array有更好的支持|同上|\n\n## 安全性的考虑\n\n需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。\n\n## cookie用法\nJavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。\ndocument.cookie=\"username=John Doe\";\n\n您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：\ndocument.cookie=\"username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT\";\n\n您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。\ndocument.cookie=\"username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/\";\n\n```javascript\n// 设置cookie\nfunction setCookie(cname,cvalue,exdays)\n{\n  var d = new Date();\n  d.setTime(d.getTime()+(exdays*24*60*60*1000));\n  var expires = \"expires=\"+d.toGMTString();\n  document.cookie = cname + \"=\" + cvalue + \"; \" + expires;\n}\n\n// 获取指定cookie\nfunction getCookie(cname)\n{\n  var name = cname + \"=\";\n  var ca = document.cookie.split(';');\n  for(var i=0; i<ca.length; i++) \n  {\n    var c = ca[i].trim();\n    if (c.indexOf(name)==0) return c.substring(name.length,c.length);\n  }\n  return \"\";\n}\n\n// 检测cookie函数\nfunction checkCookie()\n{\n  var username=getCookie(\"username\");\n  if (username!=\"\")\n  {\n    alert(\"Welcome again \" + username);\n  }\n  else \n  {\n    username = prompt(\"Please enter your name:\",\"\");\n    if (username!=\"\" && username!=null)\n    {\n      setCookie(\"username\",username,365);\n    }\n  }\n}\n```\n## localStorage和sessionStorage用法\nlocalStorage和sessionStorage类似(也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储)\n```javascript\n    static setStorage(name, data) {\n        if (typeof data === 'object') {\n            window.localStorage.setItem(name, JSON.stringify(data))\n        } else if (typeof data === 'number' || typeof data === 'string' || typeof data === 'boolean') {\n            window.localStorage.setItem(name, data)\n        } else {\n            alert('该类型不能用于本地存储~')\n        }\n    }\n\n    /**\n     * 获取localstorage\n     */\n    static getStorage(name) {\n        let data = window.localStorage.getItem(name)\n        if (data) {\n            return JSON.parse(data)\n        } else {\n            return ''\n        }\n    }\n\n    /**\n     * 删除localstorage\n     */\n    static removeStorage(name) {\n        window.localStorage.removeItem(name)\n    }\n\n    /**\n     * 清空localstorage\n     */\n    static clearStorage() {\n        window.localStorage.clear()\n    }\n```\n\n## 规避localStorage缺点---localforage\n\nlocalforage的逻辑是这样的：优先使用IndexedDB存储数据，如果浏览器不支持，使用WebSQL，浏览器再不支持，使用localStorage。\n\nlocalforage的API名称和localStorage一样，但是，在同步还是异步上却不同，localforage是异步执行的，用法示意如下。\n```javascript\nlocalforage.getItem('key', function (err, value) {\n    // 如果err不是null，则出错。否则value就是我们想要的值\n});\n```","tags":["存储"],"categories":["JS"]},{"title":"面试题整理归纳","url":"%2Finterview.html","content":"字符串扩展的方法\n- includes()：返回布尔值，表示是否找到了参数字符串。数组也可以 a[1]=1 且能判断undefined\n```javascript\nvar a=[1,2,3]\na[4]=5 // [1, 2, 3, undefined × 1, 5] empty\n// a[3]=undefined [1, 2, 3, undefined, 5] \n\na.indexOf(undefined) // -1\na.includes(undefined) // true \n```\n- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\nstr | index\n- repeat()：返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整(不四舍五入)。参数是负数或者Infinity，会报错。0/Nan返回空字符串,参数是字符串，则会先转换成数字，不传则为空字符串。\n- padStart()：头部补全。\n- padEnd()：尾部补全\n~~~\n'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n~~~\n如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。默认使用空格\n\n---\n\n<!-- more -->\n\n- 模板字符串（template string）是增强版的字符串，用反引号\\`标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\\`${表达式、变量}\\`\n- commonjs 服务器端 amd 浏览器端\n- const 必须赋值定义 let 在同一作用于无法重复命名 无法变量提升\n- split(字符串或者正则,设置长度) 字符串=>数组\n- substr(开始的索引//splice可以为负数-1则为字符串最后一个字符,length字符数)方法不同的是,substring(开始索引，结束索引+1)负的参数有区别\n只有单参数时到字符串结尾\nString exd=filePath.subString(filePath.lastIndexOf(\".\")+1,filePath.length)\n\n1. 声明函数作用提升?声明变量和声明函数的提升有什么区别?\n\n(1) 变量声明提升：变量申明在进入执行上下文就完成了。\n只要变量在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；\n\n(2) 函数声明提升：执行代码之前会先读取函数声明，意味着可以把函数申明放在调用它的语句后面。\n只要函数在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；\n\n(3) 变量or函数声明：函数声明会覆盖变量声明，但不会覆盖变量赋值。\n同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。注意：如果在变量声明的同时初始化a，或是之后对a进行赋值，此时a的值变量的值。\n```javascript\neg: var a; var c = 1; a = 1; function a() { return true; } console.log(a);\n```\n\n2. 如何判断数据类型？\ntypeof返回的类型都是字符串形式，可以判断function的类型；在判断除Object类型的对象时比较方便。\n判断已知对象类型的方法： instanceof，后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。\n```javascript\ntypeof null // object null instanceof object // error\n```\n\n3. 异步编程？\n- 方法1：回调函数，优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。\n\n- 方法2：事件监听，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n- 方法3：发布/订阅，性质与“事件监听”类似，但是明显优于后者。\n\n- 方法4：Promises对象，是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。\n\n4. 事件流？事件捕获？事件冒泡？\n    事件流：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。\n\n    IE中的事件流叫事件冒泡；事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。对于html来说，就是当一个元素产生了一个事件，它会把这个事件传递给它的父元素，父元素接收到了之后，还要继续传递给它的上一级元素，就这样一直传播到document对象（亲测现在的浏览器到window对象，只有IE8及以下不这样。\n\n    事件捕获是不太具体的元素应该更早接受到事件，而最具体的节点应该最后接收到事件。他们的用意是在事件到达目标之前就捕获它；也就是跟冒泡的过程正好相反，以html的click事件为例，document对象（DOM级规范要求从document开始传播，但是现在的浏览器是从window对象开始的）最先接收到click事件的然后事件沿着DOM树依次向下传播，一直传播到事件的实际目标；\n\n5. 如何添加一个dom对象到body中?innerHTML和innerText区别?\n    body.appendChild(dom元素)；  \n    innerHTML:从对象的起始位置到终止位置的全部内容,包括Html标签。\n    innerText:从起始位置到终止位置的内容, 但它去除Html标签 \n    window.clearInterval()\n    window.clearTimeout()\n\n6. 简述ajax流程  \n1)客户端产生触发js的事件  \n2)创建XMLHttpRequest对象  \n```javascript \nvar client=null\n  if(window.XMLHttpRequest){\n       client = new XMLHttpRequest();\n  }else{\n        client = new ActiveXObject(\"Microsoft.XMLHTTP\");\n  }\n```\n3)对XMLHttpRequest进行配置 \n```javascript   \n  client.open(\"GET\", url);\n  client.onreadystatechange = function(e) {\n      if (request.readyState !== 4) { // client状态\n        return;\n      }\n      if (request.status === 200) { // HTTP状态码\n        console.log('success', request.responseText);\n      } else {\n        console.warn('error');\n      }\n  }; // 指定回调函数\n  client.responseType = \"json\";\n  client.setRequestHeader(\"Accept\", \"application/json;\");\n  client.setRequestHeader(\"Content-Type\", \"application/json;charset=utf-8\");\n```\n4)通过AJAX引擎发送异步请求 \n```javascript\n  client.send()\n```\n5)服务器端接收请求并且处理请求，返回html或者xml内容  \n6)XML调用一个callback()处理响应回来的内容  \n7)使用JS和DOM实现局部刷新\n\n7. 自执行函数？用于什么场景？好处？  \n    1、声明一个匿名函数  \n    2、马上调用这个匿名函数。  \n    作用：创建一个独立的作用域。  \n\n    好处：防止变量弥散到全局，以免各种js库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理。\n\n    场景：一般用于框架、插件等场景，设计私有变量和方法，封闭私有作用域。\n\n8. 回调函数？（传递地址，由非实现方调用）  \n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\n\n9. 什么是闭包?堆栈溢出有什么区别？ 内存泄漏? 那些操作会造成内存泄漏？怎么样防止内存泄漏？impression  \n    闭包：就是能够读取其他函数内部变量的函数。一般是指内层函数。(子函数在外调用，子函数所在的父函数的作用域不会被释放。) \n\n    堆栈溢出：就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。经常会在递归中发生。\n\n    内存泄露是指：用动态存储分配函数内存空间，在使用完毕后未释放，导致一直占据该内存单元。直到程序结束。指任何对象在您不再拥有或需要它之后仍然存在。\n\n    造成内存泄漏：\n    setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n    闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n    防止内存泄露：  \n    1、不要动态绑定事件；      \n    2、不要在动态添加，或者会被动态移除的dom上绑事件，用事件冒泡在父容器监听事件；  \n    3、如果要违反上面的原则，必须提供destroy方法，保证移除dom后事件也被移除，这点可以参考Backbone的源代码，做的比较好；  \n    4、单例化，少创建dom，少绑事件。  \n\n10. html和xhtml有什么区别?\n    HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的标记语言。\n\n    1.XHTML 元素必须被正确地嵌套。\n\n    2.XHTML 元素必须被关闭。\n\n    3.标签名必须用小写字母。\n\n    4.空标签也必须被关闭。\n\n    5.XHTML 文档必须拥有根元素。\n\n11. 什么是构造函数？与普通函数有什么区别?\n\n    构造函数：是一种特殊的方法(函数、对象)、主要用来创建对象时初始化对象，总与new运算符一起使用，创建对象的语句中构造函数的函数名必须与类名完全相同。\n\n    与普通函数相比只能由new关键字调用，构造函数是类的标识。\n\n12. 通过new创建一个对象的时候，函数内部有哪些改变？\n    ```javascript\n    function Person(){}\n    Person.prototype.friend = [];\n    Person.prototype.age = 18;\n     var a = new Person();\n     a.friend[0] = '王琦'; // a.friend=['123'] 指向新对象 b.friend // []\n     a.age = 18;\n     var b = new Person();\n     b.friend // ['王琦'] \n     b.age   // 18\n    ```\n    >1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。   \n    >2、属性和方法被加入到 this 引用的对象中。  \n    >3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n\n`new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。`\n\n13. 事件委托的好处都有啥？说对了都给它=3=\n- 利用冒泡的原理，把事件加到父级上，触发执行效果  \n\n- 好处：新添加的元素还会有之前的事件；提高性能。\n\n14. 节点类型?判断当前节点类型?\n- 元素节点 \n- 属性节点 \n- 文本节点 \n- 注释节点 \n- 文档节点\n\n通过nodeObject.nodeType判断节点类型：其中，nodeObject 为DOM节点（节点对象）。该属性返回以数字表示的节点类型，例如，元素节点返回 1，属性节点返回 2 。\n\n15. 数组合并的方法？\n```javascript\n// 四种方法。\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\narr1 = arr1.concat(arr2);\nconsole.log(arr1); \n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\nArray.prototype.push.apply(arr1,arr2);\nconsole.log(arr1);\n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\nfor (var i=0; i < arr2.length; i++) {\narr1.push( arr2[i] );\n}\nconsole.log(arr1); \n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\n\narr1.push(...arr2)\n```\n\n16. jquery和zepto有什么区别?\n- 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。\n\n- Dom操作的区别：添加id时jQuery不会生效而Zepto会生效。\n\n- zepto主要用在移动设备上，只支持较新的浏览器，好处是代码量比较小，性能也较好。\njquery主要是兼容性好，可以跑在各种pc，移动上，好处是兼容各种浏览器，缺点是代码量大，同时考虑兼容，性能也不够好。\n\n17. $(function(){})和window.onload 和 $(document).ready(function(){})\n\n- window.onload:用于当页面的所有元素，包括外部引用文件，图片等都加载完毕时运行函数内的函数。load方法只能执行一次，如果在js文件里写了多个，只能执行最后一个。\n\n- $(document).ready(function(){})和$(function(){})都是用于当页面的标准DOM元素被解析成DOM树后就执行内部函数。这个函数是可以在js文件里多次编写的，对于多人共同编写的js就有很大的优势，因为所有行为函数都会执行到。而且$(document).ready()函数在HMTL结构加载完后就可以执行，不需要等大型文件加载或者不存在的连接等耗时工作完成才执行，效率高。\n\n18. 简述下 this 和定义属性和方法的时候有什么区别?Prototype？\n\n- this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向。\n\n- prototype本质上还是一个JavaScript对象。 并且每个函数都有一个默认的prototype属性。\n\n- 在prototype上定义的属性方法为所有实例共享，所有实例皆引用到同一个对象，单一实例对原型上的属性进行修改，也会影响到所有其他实例。\n\n19. ajax和jsonp的区别？\n- 相同点：都是请求一个url\n- 不同点：ajax的核心是通过XMLHttpRequest获取内容，jsonp只能get请求\n- jsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。\n\n20. 常见的http协议状态码？\n\n```javascript\n200：请求成功\n201：请求成功并且服务器创建了新的资源\n302：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。\n304：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。\n400：服务器不理解请求的语法。\n404：请求的资源（网页等）不存在\n403：该状态表示服务器理解了本次请求但是拒绝执行该任务\n405：方法不被允许\n500：内部服务器错误\n```\n\n21. sessionStorage和localstroage与cookie之间有什么关联, cookie最大存放多少字节？\n```javascript\n三者共同点：都是保存在浏览器端，且同源的。\n\n区别:\n1、cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n\n2、存储大小限制也不同，cookie数据不能超过4k，sessionStorage和localStorage 但比cookie大得多，可以达到5M\n\n3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面(即数据不共享)；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的( 即数据共享 )。\n```\n\n22. ajax的get与post区别？\n- get和post都是数据提交的方式。\n- get的数据是通过网址问号后边拼接的字符串进行传递的。post是通过一个HTTP包体进行传递数据的。\n- get的传输量是有限制的，post是没有限制的。(实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度)\n- get的安全性可能没有post高，所以我们一般用get来获取数据，post一般用来修改数据。\n- get就是将货品放在车顶，post放在车内\n\n23. GC机制？为什么闭包不会被回收变量和函数？\n- GC：垃圾回收机制;  \n- 外部变量没释放仍然保持着引用，所以指向的大函数内的小函数也释放不了。\n\n24. 面向对象？\n```javascript\n万物皆对象，把一个对象抽象成类，具体上就是把一个对象的静态特征和动态特征抽象成属性（属性名、属性值）和方法，也就是把一类事物的算法和数据结构封装在一个类之中，程序就是多个对象和互相之间的通信组成的。\n\n面向对象具有封装性，继承性，多态性。\n封装：隐蔽了对象内部不需要暴露的细节，使得内部细节的变动跟外界脱离，只依靠接口进行通信。封装性降低了编程的复杂性。通过继承，使得新建一个类变得容易，一个类从派生类那里获得其非私有的方法和公用属性的繁琐工作交给了编译器。而继承和实现接口和运行时的类型绑定机制所产生的多态，使得不同的类所产生的对象能够对相同的消息作出不同的反应，极大地提高了代码的通用性。\n\n总之，面向对象的特性提高了大型程序的重用性和可维护性。\n```\n\n25. jsonp的原理和缺点？\n- 原理：使用script标签实现跨域访问，可在url中指定回调函数，获取JSON数据并在指定的回调函数中执行jquery实现jsop。\n- 缺点：只支持GET方式的jsonp实现，是一种脚本注入行为存在一定的安全隐患。如果返回的数据格式有问题或者返回失败了，并不会报错。\n\n26. call和apply两者的区别和好处？\n- call和apply都是改变this指向的方法，区别在于call可以写多个参数，而apply只能写两个参数，第二个参数是一个数组，用于存放要传的参数。\n- 用call和apply实现更好的继承和扩展，更安全。\n\n27. 压缩合并目的？http请求的优化方式？\n- Web性能优化最佳实践中最重要的一条是减少HTTP请求。而减少HTTP请求的最主要的方式就是，合并并压缩JavaScript和CSS文件。 \n\n- CSS Sprites（CSS精灵）：把全站的图标都放在一个图像文件中，然后用CSS的background-image和background-position属性定位来显示其中的一小部分。 \n\n- 合并脚本和样式表; 图片地图：利用image map标签定义一个客户端图像映射，（图像映射指带有可点击区域的一幅图像）具体看：http://club.topsage.com/thread-2527479-1-1.html \n\n- 图片js/css等静态资源放在静态服务器或CDN服时，尽量采用不用的域名，这样能防止cookie不会互相污染，减少每次请求的往返数据。 \n\n- css替代图片, 缓存一些数据 \n\n- 少用location.reload()：使用location.reload() 会刷新页面，刷新页面时页面所有资源 (css，js，img等) 会重新请求服务器。建议使用location.href=\"当前页url\" 代替location.reload() ，使用location.href 浏览器会读取本地缓存资源。\n\n-图片懒加载 \n\n\n28. commonjs?requirejs?AMD|CMD|UMD?\n- CommonJS就是为JS的表现来制定规范，NodeJS是这种规范的实现，webpack 也是以CommonJS的形式来书写。因为js没有模块的功能，所以CommonJS应运而生。但它不能在浏览器中运行。 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)} \n\n- RequireJS 是一个JavaScript模块加载器。 RequireJS有两个主要方法(method): define()和require()。这两个方法基本上拥有相同的定义(declaration) 并且它们都知道如何加载的依赖关系，然后执行一个回调函数(callback function)。与require()不同的是， define()用来存储代码作为一个已命名的模块。 因此define()的回调函数需要有一个返回值作为这个模块定义。这些类似被定义的模块叫作AMD (Asynchronous Module Definition，异步模块定义)。 \n\n- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出 AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。 适用AMD规范适用define方法定义模块。\n\n- CMD是SeaJS 在推广过程中对模块定义的规范化产出\nAMD与CMD的区别：\n（1）对于于依赖的模块，AMD 是提前执行(好像现在也可以延迟执行了)，CMD 是延迟执行。\n（2）AMD 推崇依赖前置，CMD 推崇依赖就近。\n（3）AMD 推崇复用接口，CMD 推崇单用接口。\n（4）书写规范的差异。\n\n- umd是AMD和CommonJS的糅合。\nAMD 浏览器第一的原则发展 异步加载模块。\nCommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD ( Universal Module Definition ), 希望解决跨平台的解决方案。UMD先判断是否支持Node.js的模块( exports )是否存在，存在则使用Node.js模块模式。\n\n29. js的几种继承方式？\n- 使用对象冒充实现继承\n- call、apply改变函数上下文实现继承\n- 原型链方式实现继承\n\n30. js原型、原型链，有什么特点？\n```javascript\n在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性[[prototype]],我们通常称之为原型.原型的值可以是一个对象,也可以是null.如果它的值是一个对象,则这个对象也一定有自己的原型.这样就形成了一条线性的链,我们称之为原型链. \n\n访问一个对象的原型可以使用ES5中的Object.getPrototypeOf方法,或者ES6中的__proto__属性. 原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的。\n\n类的继承\n特点：基于原型链，既是父类的实例，也是子类的实例\n缺点：无法实现多继承\n\n构造继承、组合继承、实例继承和拷贝继承...\n```\n\n31. eval是做什么的？\n- 将把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。\n\n32. null和undefined\n- undefined表示变量声明未初始化的，null表示对象的空值（空对象指针）。\n\n33. json的理解？\n- JSON（轻量级的数据交换格式），基于JS的子集，数据格式简单，易于读写，占用带宽小。\n```javascript\nJSON.parse() // 解析成JSON对象\n\nJSON.strinify() // 解析成JSON字符串\n```\n\n34. js延时加载的方式？\n- defer(仅ie支持)和async\n- 动态创建DOM\n- 按需异步加载JS\n\n35. ajax（异步的js和xml）\n- ajax是指一种创建交互式网页应用的网页开发技术。通过后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n36. 同异步的区别？\n- 同步(sync)：按顺序执行。\n- 异步(async)：不按顺序执行，可以跳过执行下面的代码。\n\n37. ajax的缺点？\n- 不支持浏览器的back按钮(事件由浏览器内核控制)\n- ajax暴露了与服务器的交互\n- 对搜索引擎的支持较弱\n- 破坏了程序的异常机制\n- 不容易调试\n\n38. 跨域问题？\n- 协议不同\n- 端口不同\n- 域名不同\n- 常用解决方案：jsonp、iframe、window.name、window.postMessage、document.domain、服务器设置代理页面/响应header配置cors access-control-allow-origin\n\n39. 解决异步回调地狱有哪些方案？\npromise、generator、async/await\n\n40. 图片的预加载和懒加载？\n- 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。\n- 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。\n\n两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n41. mouseover和mouseenter的区别？\n- mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout\n\n- mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave\n\n42. 改变函数内部this指针的指向函数（bind，apply，call的区别）？\n- 通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2...这种形式。\n\n- 通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。\n\n43.  说说前端中的事件流\nHTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。\n什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。\n\n事件捕获阶段\n处于目标阶段\n事件冒泡阶段\n\naddEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\nIE只支持事件冒泡。\n\n44. 如何让事件先冒泡后执行？\n在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。\n\n45. 什么是事件委托？\n简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。\n\n举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。\n\n好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。\n\n45. 垂直居中\n- margin:auto法 relative -> absolute -> marin:0 auto\n- margin负值法 relative -> absolute -> top:50% left:50% marin-top:height的一半 margin-left:width的一半或者transform：translateX(-50%)和transform：translateY(-50%)\n- table-cell未脱离文档流 设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。\n- flex布局\n- text-align:center 块级元素\n\n46. visibility=hidden, opacity=0，display:none\n- opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的\n- visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件。\n- display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。\n\n47. 块元素和行内元素\n- 块元素：独占一行，并且有自动填满父元素，可以设置margin和padding以及高度和宽度。\n- 行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。  \n\n48. 深拷贝\n- 深拷贝的方法 1-2适用于一般的对象和数组 4-5适用于数组 3通用\nlet obj = {\n    a: 1,\n    arr: [1, 2]\n};\nlet obj2 = deepCopy(obj);\nobj2.a = 2\nconsole.log(obj) // { a:1, arr: [1,2] };\n2.es6\nObject.assign()方法(深复制只有一层，之后为浅复制（除非再次使用Object.assign嵌套方式赋值）)\nlet obj = {\n    a: 1,\n    arr: [1, 2]\n};\nlet obj1 = Object.assign({}, obj);\nobj1.a = 2\n//不变\nconsole.log(obj) // { a:1, arr: [1,2] };\n3.immutable\n4.arr1=arr.slice(0) slice() 返回新数组\n5.arr1=arr.concat()\nvar deepCopy= function(source) { \n    var result={};\n    for (var key in source) {\n        result[key] = typeof source[key]==='object'? deepCoypy(source[key]): source[key];\n     } \n   return result; \n}\n\n49. 判断一个变量是否是数组\n```javascript\nvar a = []; \n// 1.基于instanceof \na instanceof Array; \n// 2.基于constructor \na.constructor === Array; \n// 3.基于Object.prototype.isPrototypeOf \nArray.prototype.isPrototypeOf(a); \n// 4.基于getPrototypeOf \nObject.getPrototypeOf(a) === Array.prototype; \n// 5.基于Object.prototype.toString \nObject.prototype.toString.apply(a) === '[object Array]';\n// 6.Array.isArray\nArray.isArray([]); // true\n```\n以上，除了Object.prototype.toString外，其它方法都不能正确判断变量的类型。\n\n49. 优化\n- 按需加载（懒加载）路由\n- 业务代码拆分\n- 第三方库提取vendor\n\n- 压缩文件图片，合并文件 减少http请求\n- 网络图、字体图标\n- 上cdn\n\n50. 行内、块级、空元素 \n- 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n- 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n- 空元素：即没有内容的HTML元素，例如：br、meta、hr、link、input、img\n\n51. px、em、rem的区别\npx和em都是长度单位,px的只是固定的,em的值是相对的继承父类元素的字体大小。浏览器的默认字体高位16px。1em=16px;\nrem单位基于html元素的字体大小。\n\n52. 路由权限管理\n- route render方法里进行判断 redirect or return null\n- 组件内部判断\n- 高阶组件\n- dva监听url subscription\n\n53. node中的事件循环是什么样子的?\n- event loop其实就是一个事件队列，先加入先执行，执行完一次队列，再次循环遍历看有没有新事件加入队列．执行中的叫IO events, setImmediate是在当前队列立即执行,setTimout/setInterval是把执行定时到下一个队列，process.nextTick是在当前执行完，下次遍历前执行．所以总体顺序是: IO events >> setImmediate >> setTimeout/setInterval >> process.nextTick\n\n54. 清空数组\n- 直接赋值空数组\n- splice(0,数组length)清空\n- 设置数组length=0\n\n55. 判断数组中出现次数最多的元素\n1. 临时对象数组，原数组sort排序，判断前后位是否相等。临时对象数组排序\n```javascript\nfunction f(arr){\n    var temp=[];//对象数组\n    var i;\n    temp[0]={value:arr[0],index:1};//保存数组元素出现的次数和值\n    arr.sort();\n    for(i=1;i<arr.length;i++){\n        if(arr[i]==arr[i-1]){\n            temp[temp.length-1].index++;\n        }else{//不相同则新增一个对象元素\n            temp.push({index:1,value:arr[i]});\n        }\n    }\n    temp.sort(function(a,b){//按照出现次数从大到小排列\n        return a.index<b.index;\n    })\n    var max=temp[0].index;\n    var maxV=temp[0].value;\n    var second=temp[1].index;\n    var secondV=temp[1].value;\n\n    return {max,maxV,second,secondV};\n}\nvar arr=[2,2,3,4,5,100,100,,3,1,4,4,100,100];\nvar {max,maxV,second,secondV}=f(arr);\nconsole.log(max,maxV,second,secondV); // 4 100 3 4\n```\n2. 临时对象 判断属性名存不存在 2次遍历\n```javascript\nvar arr = [1,1,2,2,2,2,2,3,3,3,4,4];\n    var obj = {};\n    for(var i = 0; i<arr.length; i++){\n        if(!obj[arr[i]]){\n            obj[arr[i]] = 1;\n        }else {\n            obj[arr[i]]++;\n        }\n    }\n    /*\n        此时的obj对象包含了所有元素出现次数的信息\n        然后再遍历obj对象就可以查询出出现次数最多/最少的元素了\n    */\n    var maxNum = 0;\n    var minNum = obj[arr[0]];  //先随意给最少的变量赋值（但保证是数组中的元素出现的次数）\n    var maxEleArr = [],minEleArr = [];\n    //第一次遍历找出出现次数最多和最少的值\n    for(var key in obj){\n        if(obj[key] > maxNum){\n            maxNum = obj[key];\n        }\n        if(obj[key] < maxNum){\n            minNum = obj[key];\n        }\n    }\n    //第二次遍历找出所有出现次数最多和最少的元素\n    for(var key in obj){\n        if(obj[key] == maxNum){\n            maxEleArr.push(key);\n        }\n        if(obj[key] == minNum){\n            minEleArr.push(key);\n        }\n    }\n    console.log(maxEleArr + \":\" + maxNum );  // 2:5\n    console.log(minEleArr + \":\" + minNum );  // 1,4:2\n```\n\n3. reduce简写\n```javascript\nvar arr = 'abcdaabc';\n\nvar info = arr\n    .split('')\n    .reduce((p, k) => (p[k]++ || (p[k] = 1), p), {});\n\nconsole.log(info); //{ a: 3, b: 2, c: 2, d: 1 }\n```\n\n56. 清除浮动","tags":["面试"],"categories":["知识"]},{"title":"正确设置网站title、keywords、description","url":"%2Fseo.html","content":"\n---\n<!--more-->\n\nSEO：搜索引擎优化，提高网站浏览量\n\nSEM：搜索引擎营销\n\nIP：独立IP访问的用户\n\nPV：页面浏览量或点击量\n\nUV：独立访客数\n\n## title（网站标题）\n\ntitle，就是浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。\n\n```html\n用法：<title>网站标题</title>\n```\n\n1. 首页title写法，一般是“网站名称-主关键词或一句含有主关键词的描述”。在做优化时习惯把主关键词放最前面，网站名称放后面，因为搜索引擎给予标题最前面的词比后面的高。比如，做“招聘”这个词，就这样写“企业招聘-创业公司招聘技巧-xx招聘”。\n\n2. 栏目页title写法，一般有2种：“栏目名称-网站名称”、“栏目名称栏目关键词-网站名称”。建议用“栏目名称-网站名称”。而且栏目名称最好用关键词来确定，比如企业招聘栏目最好就用企业招聘，而不要起个让人无法识别的名字如企业来人，企业看看，或企业加上一些特殊符号，这种写法虽然很有个性，但会让你的网站在优化上占了下风。\n\n3. 分类列表页title写法，一般是“分类列表页名称-栏目名称-网站名称”，这个和栏目页差不多。\n\n4. 文章页title写法，一般有3种：“文章标题-网站名称”、“内容标题-栏目名称”、“内容标题-栏目名称-网站名称”。其中，“内容标题-栏目名称-网站名称”的写法最为规范，但也相对复杂，它能给用户很好的提示，让用户知道他在访问哪篇文章，并且是在哪个网站的哪个栏目下。\n\n \n\n## keywords（关键词）\n\nkeywords，是用户不查看源代码看不到的。主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此keywords的每个词都要能在内容中找到相应匹配，才有利于排名。keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。为什么用英文上文已经说过。而且，尽量将重要的关键字靠前放，因为靠后的关键字排名较差，除非你站有很高的权重。\n\n小道消息称keywords曾被百度、谷歌、雅虎等搜索引擎剔除，将不会再影响搜索引擎的排序结果，设置一下总没坏处，还是有一些搜索引擎比较重视keywords标签的。\n\n```html\n用法：<meta name=”Keywords” Content=”关键词1,关键词2,关键词3,关键词4″>\n```\n\n1. 首页keywords写法，一般是“网站名称,主要栏目名,主要关键词”。\n\n2. 栏目页keywords写法，一般是“栏目名称,栏目关键字,栏目分类列表名称”。\n\n3. 分类列表页keywords写法，这个就比较简单了，只要将你这个栏目中的主要关键字写入即可。\n\n4. 文章页keywords写法，建议大家提取文章中的关键词，比如我的文章主要是讲SEO优化的，那么我关键词肯定是SEO优化，如果你觉得你提取关键词的能力较差，也可以选择文章中出现比较多的词来作为关键词，比如我现在写的内容是关于title、keywords、description的，那我的文章页关键词就是这3个。\n\n## description（内容摘要）\n\ndescription，和上面的keywords一样，是用户不查看源代码看不到的，而且也是对于一个网页的简要内容概况。不同的是，keywords是由几个词语的组成的，而description则是完整的一句话。description一般不超过150个字符，描述内容要和页面内容相关。\n\n```html\n用法：<meta name=”Description” Content=”你网页的简述”>\n```\n\n1. 首页description写法，一般是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍。\n\n2. 栏目页description写法，一般是将栏目的标题、关键字、分类列表名称融合到里面，写成简单的介绍。\n\n3. 分类列表页description，这个就比较简单了，一般只需要把分类列表的标题、关键词融合在一起，写成简单的介绍。\n\n4. 文章页description写法，一般有2种写法，标准写法就和前面的一样，将文章标题、文章中的重要内容和关键词融合在一起，写成简单的介绍。这是最好最标准的写法。但是这样写比较麻烦，可以在文章首段和标题中加入关键词，比如我这篇文章是讲title、keywords、description的，那么在文章首段和标题中就加入这些内容，然后直接将文章首段的内容复制到description中即可。\n\n**PS：3个标签按重要性来分：title＞description＞keywords**\n\n## 其他优化技巧\n\n1）标签语义化 \n2）一个页面中的H1标签只能使用一次 \n3）img标签都要设置 alt 属性，在这个属性中声明当前图片的信息（spider不能收录图片，但是可以抓取到图片alt属性的值） \n4）HTML的层级不要太深的层级，蜘蛛可能不会抓取和收录 \n5）把需要推广的关键词尽可能的在页面中曝光（最好都写在H（2~6）标签中） ","tags":["优化"],"categories":["知识"]},{"title":"JavaScript整理总结","url":"%2Fjssummary.html","content":"\nJS的相关知识点比较繁杂，特此开篇整理一波，方便回顾总结查阅。\n\n--- \n<!--more -->\n\n## 概念\nJavaScript 是一门跨平台、面向对象、基于原型的轻量级动态脚本语言。\n\n与java的对比：\n\n|JavaScript|Java|\n|:---|:---|\n|面向对象。不区分对象类型。通过原型机制继承，任何对象的属性和方法均可以被动态添加。|基于类系统。分为类和实例，通过类层级的定义实现继承。不能动态增加对象或类的属性或方法。|\n|变量类型不需要提前声明(动态类型)。|变量类型必须提前声明(静态类型)。|\n|不能直接自动写入硬盘。|可以直接自动写入硬盘。|\n\n## 变量声明\n### var(存在变量提升)\n声明一个变量，可赋一个初始化值。\n\n### let(let 同一变量在同一作用域不能同时声明)\n声明一个块作用域的局部变量，可赋一个初始化值。\n\n### const(const 声明时必须赋初始值,也不可以在脚本运行时重新声明)\n声明一个块作用域的只读的命名常量。\nconst声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。\n如const a=[1,2,3] a[1]=4; const b={} b.name=\"1\" 数组元素和对象属性不受保护。\n\n## 变量的作用域\n在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的任何其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。全区变量是全局对象的属性，在浏览器中可以用window.xx或xx来访问。\n```javascript\nif(true){\n    var a=5\n}\nconsole.log(a) // 5 使用let声明块级则是undefined\n```\n## 变量提升\nJavaScript 变量的另一特别之处是，你可以引用稍后声明的变量而不会引发异常。这一概念称为变量声明提升(hoisting)；\nvar ok ; let 和 const 则不会存在变量提升\n\n```javascript\n1.\nconsole.log(x === undefined); // true\nvar x = 3;\n\n2.\nvar myvar = \"my value\";\n\n(function() {\n  console.log(myvar); // undefined\n  var myvar = \"local value\";\n})();\n\n1.1 也可写作\nvar x;\nconsole.log(x === undefined); // true\nx = 3;\n\n2.1\nvar myvar = \"my value\";\n \n(function() {\n  var myvar;\n  console.log(myvar); // undefined\n  myvar = \"local value\";\n})();\n```\n\n## 函数提升\n声明函数的两种方式：\n```javascript\nfunction foo(){} // 函数声明 存在函数提升且大于变量提升\nvar foo=function (){} // 函数表达式 var foo=function foo1(){} 函数名可写\n```\n此时的3种递归调用自身的方式 \n- foo()\n- foo1()\n- arguments.callee() \n\n现在已经不推荐使用arguments.callee()；\n原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。\n\n## 数据类型 7种\n### 原始类型\n- Boolean\n- null\n- undefined\n- String \n- Number 标识范围 -2^53~2^53-1 数字均为双精度浮点类型\n- Symbol(它的实例是唯一且不可改变)\n### 对象Object\n对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。\n\n只有null和undefined无法拥有方法\n```javascript\ntypeof null === 'object' // true\nnull instanceof Object // false \nnull instanceof null // error\n\n[]+[] // \"\"\n[]+{} // \"[object Object]\"\n{}+[] // 0\n\n!+[]+[]+![] // \"truefalse\"\n\nMath.max() // -Infinity\nMath.min() // Infinity\n\n```\n\n## 字面量\n字面量是由语法表达式定义的常量\n\n- 数组字面量(Array literals) []\n- 布尔字面量(Boolean literals) true/false\n- 浮点数字面量(Floating-point literals) 3.14\n- 整数(Intergers) 5 \n- 对象字面量(Object literals) {}\n- RegExp literals 一个正则表达式是字符被斜线（译注：正斜杠“/”）围成的表达式 /a+b/ \nRegExp.test() RegExp.exec() string.match() \n- 字符串字面量(String literals) \"1212\" '1212'\nJavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象。你也能用对字符串字面值使用类似\n\n```javascript\nString.length的属性：\nconsole.log(\"John's cat\".length)\n```\n\n```javascript\nvar obj={\n  say:funciton(){\n\n  },\n  // 简写\n  say(){\n\n  }\n}\n```\n十进制整数字面量由一串数字序列组成，且没有前缀0。\n八进制的整数以 0（或0O、0o）开头，只能包括数字0-7。\n十六进制整数以0x（或0X）开头，可以包含数字（0-9）和字母 a~f 或 A~F。\n二进制整数以0b（或0B）开头，只能包含数字0和1。\n\n## 模板字符串\n```javascript\nvar name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n\n## 布尔环境的假值\n* false\n* undefined\n* null\n* 0\n* NaN\n* 空字符串（\"\"）\n\n## try-catch \n如果finally块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：\n```javascript\nfunction f() {\n  try {\n    console.log(0);\n    throw \"bogus\";\n  } catch(e) {\n    console.log(1);\n    return true; // this return statement is suspended\n                 // until finally block has completed\n    console.log(2); // not reachable\n  } finally {\n    console.log(3);\n    return false; // overwrites the previous \"return\"\n    console.log(4); // not reachable\n  }\n  // \"return false\" is executed now  \n  console.log(5); // not reachable\n}\nf(); // console 0, 1, 3; returns false\n```\n\n## for of 和 for in循环\n```javascript\nlet arr = [3, 5, 7];\narr.foo = \"hello\";\n\nfor (let i in arr) {\n   console.log(i); // logs \"0\", \"1\", \"2\", \"foo\"\n}\n\n// 所有可枚举的属性名\nfor (let i of arr) {\n   console.log(i); // logs \"3\", \"5\", \"7\" // 注意这里没有 hello\n}\n```\n\n## 嵌套函数和闭包\n一个闭包是一个可以自己拥有独立的环境与变量的的表达式。\n- 内部函数包含外部函数的作用域。\n- 内部函数只可以在外部函数中访问。\n- 内部函数可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。\n\n## 多层嵌套函数\n函数可以被多层嵌套。例如，函数A可以包含函数B，函数B可以再包含函数C。B和C都形成了闭包，所以B可以访问A，C可以访问B和A。因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域。这个称之为作用域链。\n```javascript\nfunction A(x) {\n  function B(y) {\n    function C(z) {\n      console.log(x + y + z);\n    }\n    C(3);\n  }\n  B(2);\n}\nA(1); // logs 6 (1 + 2 + 3)\n```\n\n在这个例子里面，C可以访问B的y和A的x。这是因为：\n\n1. B形成了一个包含A的闭包，B可以访问A的参数和变量\n2. C形成了一个包含B的闭包\n3. B包含A，所以C也包含A，C可以访问B和A的参数和变量。换言之，C用这个顺序链接了B和A的作用域\n\n反过来却不是这样。A不能访问C，因为A看不到B中的参数和变量，C是B中的一个变量，所以C是B私有的。\n\n## 作用域链\n当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。\n```javascript\nfunction outside() {\n  var x = 5;\n  function inside(x) {\n    return x * 2;\n  }\n  return inside;\n}\n\noutside()(10); // returns 20 instead of 10\n```\n命名冲突发生在return x上，inside的参数x和outside变量x发生了冲突。这里的作用链域是{inside, outside, 全局对象}。因此inside的x具有最高优先权，返回了20（inside的x）而不是10（outside的x）。\n\n## 闭包\nJavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数将的生存周期比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。\n```javascript\nvar pet = function(name) {          //外部函数定义了一个变量\"name\"\n  var getName = function() {            \n    //内部函数可以访问 外部函数定义的\"name\"\n    return name; \n  }\n  //返回这个内部函数，从而将其暴露在外部函数作用域\n  return getName;               \n};\nmyPet = pet(\"Vivie\");\n    \nmyPet();                            // 返回结果 \"Vivie\"\n```\n\n## arguments 对象\n函数的实际参数会被保存在一个类似数组的arguments对象中。\n```javascript\narguments[i] // 访问\n```\narguments变量只是 ”类数组对象“，并不是一个数组。称其为类数组对象是说它有一个索引编号和length属性。尽管如此，它并不拥有全部的Array对象的操作方法。\n\n## 函数参数(默认参数、剩余参数(rest))\n剩余参数语法允许将不确定数量的参数表示为数组\n\n```javascript\nfunction multiply(a, b = 1,...[1,2,3]) {\n  return a*b;\n}\n```\n\n## 箭头函数\n箭头函数总是匿名的\n引入箭头函数的原因\n1. 更简洁的语法\n2. 捕捉闭包上下文的this值\n```javascript\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    this.age++; // |this| properly refers to the person object\n  }, 1000);\n}\n\nvar p = new Person();\n```\n\n## 扩展语句\n适用于对象，数组\n```javascript\nfunction f(x, y, z) { }\nvar args = [0, 1, 2];\nf(...args);\n```\n## 临时对象\n你可以在String字面值上使用String对象的任何方法—JavaScript自动把String字面值转换为一个临时的String对象, 然后调用其相应方法,最后丢弃销毁此临时对象.在String字面值上也可以使用String.length属性.\n```javascript\nvar s1 = \"2 + 2\"; // Creates a string literal value\nvar s2 = new String(\"2 + 2\"); // Creates a String object\neval(s1); // Returns the number 4\neval(s2); // Returns the string \"2 + 2\"\nNumber(null) // 0\n```\n\n## 数组方法\n\n### concat() 连接两个数组并返回一个新的数组。\n```javascript\nvar myArray = new Array(\"1\", \"2\", \"3\");\nmyArray = myArray.concat(\"a\", \"b\", \"c\"); \n// myArray is now [\"1\", \"2\", \"3\", \"a\", \"b\", \"c\"]\n```\n\n###  join() 将数组的所有元素连接成一个字符串。\n```javascript\nvar myArray = new Array(\"Wind\", \"Rain\", \"Fire\");\nvar list = myArray.join(\" - \"); // list is \"Wind - Rain - Fire\"\n```\n\n### push() 在数组末尾添加一个或多个元素，并返回数组操作后的长度。\n```javascript\nvar myArray = new Array(\"1\", \"2\");\nmyArray.push(\"3\"); // myArray is now [\"1\", \"2\", \"3\"]\n```\n\n### pop() 从数组移出最后一个元素，并返回该元素。\n```javascript\nvar myArray = new Array(\"1\", \"2\", \"3\");\nvar last = myArray.pop(); \n// myArray is now [\"1\", \"2\"], last = \"3\"\n```\n\n### shift() 从数组移出第一个元素，并返回该元素。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nvar first = myArray.shift(); \n// myArray is now [\"2\", \"3\"], first is \"1\"\n```\n\n### unshift()在数组开头添加一个或多个元素，并返回数组的新长度。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nmyArray.unshift(\"4\", \"5\"); \n// myArray becomes [\"4\", \"5\", \"1\", \"2\", \"3\"]\n```\n\n### slice(开始索引，结束索引) 从数组提取一个片段，并作为一个新数组返回。 \n```javascript\nvar myArray = new Array (\"a\", \"b\", \"c\", \"d\", \"e\");\nmyArray = myArray.slice(1, 4); // until index 3, returning [ \"b\", \"c\", \"d\"]\n```\n\n### splice(index, count_to_remove, addElement1, addElement2, ...)从数组移出一些元素，（可选）并替换它们。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\", \"4\", \"5\");\nmyArray.splice(1, 3, \"a\", \"b\", \"c\", \"d\"); \n// myArray is now [\"1\", \"a\", \"b\", \"c\", \"d\", \"5\"]\n```\n\n### reverse() 颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nmyArray.reverse(); \n// transposes the array so that myArray = [ \"3\", \"2\", \"1\" ]\n```\n\n### sort() 给数组元素排序。\n```javascript\nvar arr=[2,1,3]\narr.sort() // [1,2,3]\n```\nsort() 也可以带一个回调函数来决定怎么比较数组元素。这个回调函数比较两个值，并返回3个值中的一个：\n- 如果 a 小于 b ，返回 -1(或任何负数) 降序\n- 如果 a 大于 b ，返回 1 (或任何正数) 升序\n- 如果 a 和 b 相等，返回 0。\n\n### indexOf(searchElement[, fromIndex]) 在数组中搜索searchElement 并返回第一个匹配的索引。\n```javascript\nvar a = ['a', 'b', 'a', 'b', 'a'];\nconsole.log(a.indexOf('b')); // logs 1\n// Now try again, starting from after the last match\nconsole.log(a.indexOf('b', 2)); // logs 3\nconsole.log(a.indexOf('z')); // logs -1, because 'z' was not found\n```\n\n### lastIndexOf(searchElement[, fromIndex]) 和 indexOf 差不多，但这是从结尾开始，并且是反向搜索。\n\n### forEach() 循环数组 不定的顺序 不能用break,return false跳出循环遍历  \n\n### map() 循环数组返回新数组\n```javascript\nvar a1 = ['a', 'b', 'c'];\nvar a2 = a1.map(function(item) { return item.toUpperCase(); });\nconsole.log(a2); // logs A,B,C\n```\n\n### find() 找到满足条件的第一个元素\n\n### filter() 循环数组返回符合条件的元素\n```javascript\nvar a1 = ['a', 10, 'b', 20, 'c', 30];\nvar a2 = a1.filter(function(item) { return typeof item == 'number'; });\nconsole.log(a2); // logs 10,20,30\n```\n### every() 循环数组 如果全部元素满足条件则返回true 否则返回false\n\n### some() 循环数组 只要有一项满足条件则返回true 全部不满足返回false\n\n### reduce() 迭代 使用回调函数 callback(firstValue, secondValue) 把数组列表计算成一个单一值 reduceRight() 从右边开始\n```javascript\nvar a = [10, 20, 30];\nvar total = a.reduce(function(first, second) { return first + second; }, 0);\nconsole.log(total) // Prints 60\n```\n\n## Map简单的键值对集合\n```javascript\nvar sayings = new Map();\nsayings.set('dog', 'woof');\nsayings.set('cat', 'meow');\nsayings.set('elephant', 'toot');\nsayings.size; // 3\nsayings.get('fox'); // undefined\nsayings.has('bird'); // false\nsayings.delete('dog');\nsayings.has('dog'); // false\n\nfor (var [key, value] of sayings) {\n  console.log(key + ' goes ' + value);\n}\n// \"cat goes meow\"\n// \"elephant goes toot\"\n\nsayings.clear();\nsayings.size; // 0\n```\nnew Map() 参数可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。\n\n**Object和Map的比较**\n1. 一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。\n2. Object的键均为Strings类型，在Map里键可以是任意类型。\n3. 必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。\n4. Map的遍历遵循元素的插入顺序。\n5. Object有原型，所以映射中有一些缺省的键。（可以理解为map = Object.create(null)）。\n\n如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。\n如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。\n如果需要对个别元素进行操作，使用Object。\n\n## Set集合\n```javascript\nvar mySet = new Set();\nmySet.add(1);\nmySet.add(\"some text\");\nmySet.add(\"foo\");\n\nmySet.has(1); // true\nmySet.delete(\"foo\");\nmySet.size; // 2\n\nfor (let item of mySet) console.log(item);\n// 1\n// \"some text\"\n\nmySet2 = new Set([1,2,2,4]);\nArray.from(mySet2);  // [1,2,3] 常用来去重\n```\n\n**Array和Set的比较**\n1. 数组中用于判断元素是否存在的indexOf 函数效率低下。\n2. Set对象允许根据值删除元素，而数组中必须使用基于下标的 splice 方法。\n3. 数组的indexOf方法无法找到NaN值。\n4. Set对象存储不重复的值，所以不需要手动处理包含重复值的情况。\n5. 数组是特殊的对象,对象是关联数组 字符串是特殊的数组\n6. 方括弧取值为动态判定[]，数字非有效的js标识符   \n\n## setter和getter (get set修饰function)\n```javascript\nvar o = {\n  a: 7,\n  get b() { \n    return this.a + 1;\n  },\n  set c(x) {\n    this.a = x / 2\n  }\n};\n\nconsole.log(o.a); // 7\nconsole.log(o.b); // 8 取b值时调用\no.c = 50;         // 给c设置值调用\nconsole.log(o.a); // 25\n-----------------------\nvar o = {\n  a: 7,\n  b:function(){ \n    return this.a + 1;\n  }\n};\n\nconsole.log(o.b()); // 8\n```\n\n## 访问所有可枚举对象属性\n1. for in 无序\n2. Object.keys() 不包括原型的属性名数组\n3. Object.getOwnPropertyNames()\n\n## Symbol(原始数据类型) 不可枚举的 符号类型\n```javascript\nvar  myPrivateMethod  = Symbol(); // 不能使用new Symbol()创建，它是一个不完整的类\nthis[myPrivateMethod] = function() {...};\n```\nfor in 和 Object.getOwnPropertyNames()访问不到，只能通过myPrivateMethod或者Object.getOwnPropertySymbols()来访问\n```javascript\nSymbol(\"foo\") !== Symbol(\"foo\") // true\nconst foo = Symbol()\nconst bar = Symbol()\ntypeof foo === \"symbol\" // true\ntypeof bar === \"symbol\" // true\nlet obj = {}\nobj[foo] = \"foo\"\nobj[bar] = \"bar\"\nJSON.stringify(obj) // {}\nObject.keys(obj) // []\nObject.getOwnPropertyNames(obj) // []\nObject.getOwnPropertySymbols(obj) // [ foo, bar ]\n```\n\n## Proxy 代理\n`let p= new Proxy(target,handler)`\n- target\n用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n\n- handler\n一个对象，其属性是当执行一个操作时定义代理的行为的函数。\n```javascript\n// 设置缺省值\nlet handler = {\n    get: function(target, name){\n        return name in target ? target[name] : 37;\n    }\n};\n\nlet p = new Proxy({}, handler);\n\np.a = 1;\np.b = undefined;\n\nconsole.log(p.a, p.b);    // 1, undefined\n\nconsole.log('c' in p, p.c);    // false, 37\n\n// 转发代理\nlet target = {};\nlet p = new Proxy(target, {});\n\np.a = 37;   // 操作转发到目标\n\nconsole.log(target.a);    // 37. 操作已经被正确地转发\n\n// demo\nlet book  = {\"name\":\"《ES6基础系列》\",\"price\":56 };\nlet proxy = new Proxy(book,{\n    get:function(target,property){\n        if(property === \"name\"){\n            return \"《入门到懵逼》\";\n        }else{\n            return target[property];\n        }\n    },\n    set:function(target,property,value){\n        if(property === 'price'){\n            target[property] = 56;\n        }\n    }\n})\n```\n\n## 生成器 generator \nfunction* 来修饰GeneratorFunction函数\n```javascript\nfunction* idMaker() {\n  var index = 0;\n  while(true)\n    yield index++;\n}\n\nvar gen = idMaker();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n// ...\n```\n\n对象实现迭代行为\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n\nfor (let value of myIterable) { \n    console.log(value); \n}\n// 1\n// 2\n// 3\n\nor\n\n[...myIterable]; // [1, 2, 3]\n```","tags":["整理"],"categories":["JS"]},{"title":"redux状态传播","url":"%2Freduxstate.html","content":"\n要有内容不然搜索会挂\n\n","tags":["redux"],"categories":["JS"]},{"title":"响应式网页设计","url":"%2Fresponsive.html","content":"\n## 什么是响应式网站\n\n响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。\n\n--- \n<!--more -->\n\n## 优点\n\n- 面对不同分辨率设备灵活性强\n- 能够快捷解决多设备显示适应问题\n\n## 缺点\n\n- 兼容各种设备工作量大，效率低下\n- 代码累赘，会出现隐藏无用的元素，加载时间加长\n- 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果\n- 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况\n\n## 实战\n\n谷歌教程用HTML5以及CSS3的媒体查询完成了一个响应式布局的demo，大家可以用不同的尺寸的设备，查看不同分辨率下的表现。也可以在控制台模拟各种设备，欢迎大家提出意见。\n\n在线地址：[http://dir.mydearest.cn/responsive/](http://dir.mydearest.cn/responsive/)","tags":["响应式"],"categories":["CSS"]},{"title":"有趣的摧毁页面","url":"%2Fdestory.html","content":"\n食用方法\n\n使用【上下左右键】来控制飞行器的运动\n\n使用【空格键】来发射导弹\n\n<a href=\"javascript:var%20KICKASSVERSION='2.0'; var%20s%20=%20document.createElement('script'); s.type='text/javascript'; document.body.appendChild(s); s.src='//hi.kickassapp.com/kickass.js'; void(0);\"> 点击开始摧毁 </a>\n\n---\n<!--more -->\n\n引入JS代码\n```javascript\n<a href=\"javascript:var%20KICKASSVERSION='2.0'; \nvar%20s%20=%20document.createElement('script'); \ns.type='text/javascript'; document.body.appendChild(s); \ns.src='//hi.kickassapp.com/kickass.js'; void(0);\"> 点击开始摧毁 </a>\n```\n页面崩溃\n```javascript\nvar total = \"\"; \nfor (var i = 0; i < 10000; i++) { \n    total = total + i.toString(); \n    history.pushState(0, 0, total); \n}\n```\n转动吧，风扇！！！","tags":["优化"],"categories":["JS"]},{"title":"console控制台优化","url":"%2Fconsole.html","content":"\n谷歌开发者中心上面关于谷歌浏览器控制台console.log()的文档：\n\n|格式说明符|描述|\n|:---|---:|\n|%s|将值格式化为字符串。|\n|%d?or?%i|将值格式化为整数。|\n|%f|将值格式化为浮点值。|\n|%o|将值格式化为可扩展的DOM元素（如在元素面板中）。|\n|%O|将值格式化为可扩展的JavaScript对象。|\n|%c|根据您提供的CSS样式格式化输出字符串。|\n\n\\n是换行，可以将一个字符串设置成多行\n%c标记之后的内容使用对应样式，格式如 console.log(‘%c第一个样式%c第二个样式’,’css1′,’css2′); 如此对应\n样式和普通的css效果基本一致，可以设置文字颜色，背景颜色，字体大小，间距，边距等等。还支持部分css3高级效果。\n\n---\n<!-- more -->\n\n## 3D字体效果 Text\n\n```javascript\n<script>console.log(\"%c3D Text\",\" text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em\")</script>\n```\n\n## Colorful彩色背景 CSS\n\n```javascript\n<script>console.log(\"%cColorful CSS\",\"background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em\")</script>\n```\n\n## Rainbow彩虹字 Text\n\n```javascript\n<script>console.log('%cRainbow Text ', 'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;');</script>\n```\n\n## 在Chrome控制台输出图片\n```javascript\n<script>console.log(\"%c\", \"padding:50px 700px;line-height:120px;background:url('http://wx1.sinaimg.cn/large/ba098b64ly1fjz4j8pju5j20p002sgm4.jpg') no-repeat;\");</script>\n```\n\n## 示例\n```javascript\n<script>\nconsole.log(\"%c%c源码作者%ccosyer chenyu@mydearest.cn\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\nconsole.log(\"%c%c网站地址%chttps://mydearest.cn\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\nconsole.log(\"%c%cgithub%https://github.com/cosyer\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\n</script>\n```\n\n### 设计相关\n\n- https://icomoon.io/\n\n- https://zh-cn.cooltext.com/\n\n- https://www.logaster.cn/logo/#logos\n\n- http://www.logoko.com.cn/design\n\n- http://www.beipy.com/335.html","tags":["优化"],"categories":["JS"]},{"title":"微信小程序面试题","url":"%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98.html","content":"\n\n1、简单描述下微信小程序的相关文件类型？\n答：微信小程序项目结构主要有四个文件类型,如下：\n一、WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。\n二、WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，\n二、js 逻辑处理，网络请求\n三、json 小程序设置，如页面注册，页面标题及tabBar。\n四、app.json\n必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。\n五、app.js\n必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。\n六、app.wxss\n\n---\n<!-- more -->\n\n2、你是怎么封装微信小程序的数据请求的？\n答：\n一、将所有的接口放在统一的js文件中并导出\n二、在app.js中创建封装请求数据的方法\n三、在子页面中调用封装的方法请求数据\n3、有哪些参数传值的方法？\n答：\n一、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或onload的param参数获取。但data-名称不能有大写字母和不可以存放对象\n二、设置id 的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值\n三、在navigator中添加参数传值\n\n4、你使用过哪些方法，来提高微信小程序的应用速度？\n答：\n一、提高页面加载速度\n二、用户行为预测\n三、减少默认data的大小\n四、组件化方案\n\n5、小程序与原生App哪个好？ \n答： 小程序除了拥有公众号的低开发成本、低获客成本低以及无需下载等优势，在服务请求延时与用户使用体验是都得到了较大幅度  的提升，使得其能够承载跟复杂的服务功能以及使用户获得更好的用户体验。\n\n6、简述微信小程序原理？ \n答：微信小程序采用JavaScript、WXML、WXSS三种技术进行开发，从技术讲和现有的前端开发差不多，但深入挖掘的话却又有所不同。\n\nJavaScript：首先JavaScript的代码是运行在微信App中的，并不是运行在浏览器中，因此一些H5技术的应用，需要微信App提供对应的API支持，而这限制住了H5技术的应用，且其不能称为严格的H5，可以称其为伪H5，同理，微信提供的独有的某些API，H5也不支持或支持的不是特别好。\n\nWXML：WXML微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。\n\nWXSS：WXSS具有CSS的大部分特性，但并不是所有的都支持，而且支持哪些，不支持哪些并没有详细的文档。\n\n微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。\n\n小程序分为两个部分webview和appService。其中webview主要用来展现UI，appService有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理\n\n7、分析下微信小程序的优劣势？\n答：\n优势：\n1、无需下载，通过搜索和扫一扫就可以打开。\n2、良好的用户体验：打开速度快。\n3、开发成本要比App要低。\n4、安卓上可以添加到桌面，与原生App差不多。\n5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的。\n劣势：\n1、限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。\n2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。\n3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。\n4、依托于微信，无法开发后台管理功能。\n8、微信小程序与H5的区别？\n答：\n第一条是运行环境的不同\n传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。\n第二条是开发成本的不同\n只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG\n第三条是获取系统级权限的不同\n系统级权限都可以和微信小程序无缝衔接\n第四条便是应用在生产环境的运行流畅度\n长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立\n9、怎么解决小程序的异步请求问题？\n答：\n在回调函数中调用下一个组件的函数：\napp.js\n\nsuccess: function (info) {         \n             that.apirtnCallback(info)\n }\n\nindex.js\n\n onLoad: function () {\n    app.apirtnCallback = res => {\n     console.log(res) \n    }\n｝\n\n10、小程序的双向绑定和vue哪里不一样？\n答：\n小程序直接this.data的属性是不可以同步到视图的，必须调用：\n\nthis.setData({\n          noBind:true\n   })\n\n11、常用\n```javascript\n<form bindsubmit=\"formSubmit\">\n  <input value=\"{{address.name}}\" name=\"name\" placeholder=\"姓名\"/>\n  <input type=\"number\" name=\"phone\" value=\"{{address.phone}}\" placeholder=\"电话号码\"/>\n  <input name=\"detail\" value=\"{{address.detail}}\" placeholder=\"详细地址\"/>\n  <button form-type=\"submit\">保存</button>\n</form>\n // formData=e.detail.value value.name...\n // 诸如bindinput \n```\n\n12、生命周期\n### onLoad(Object query)\n页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。\n### onShow()\n页面显示/切入前台时触发。\n### onReady()\n页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。调用接口\n### onHide()\n页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。\n### onUnload()\n页面卸载时触发。如redirectTo或navigateBack到其他页面时。\n","tags":["小程序"],"categories":["知识"]},{"title":"JavaScript停止冒泡和阻止浏览器默认行为","url":"%2Fbubble.html","content":"\n## 防止冒泡\n\nw3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true\n\nstopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。\n\n---\n<!-- more -->\n\n## 阻止默认行为\n\nw3c的方法是e.preventDefault()，IE则是使用e.returnValue = false\n\npreventDefault它是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是说默认行为，当然是元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用当然就无效了。什么元素有默认行为呢？如链接`<a>`，提交按钮`<input type=”submit”>`等。当Event 对象的 cancelable为false时，表示没有默认行为，这时即使有默认行为，调用preventDefault也是不会起作用的。\n\n```javascript\n <!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n</head>\n<body>\n<div id=\"box\" style=\"width: 300px;height: 300px;background: pink;\">\n\t<input type=\"button\" name=\"按钮\" value=\"按钮\" id=\"btn\">\n</div>\n<script type=\"text/javascript\">\n\tvar box1=document.getElementById(\"box\");\n\tvar btn1=document.getElementById(\"btn\");\n\tbtn1.onclick=function(e){\n\t\talert(\"按钮\");\n\t\t//阻止冒泡；\n\t\tvar e=e|| window.event;\n\t\t//w3c取消冒泡\n\t\te.stopPropagation();\n\t\t//ie取消冒泡\n\t\t//判断他现在的状态，然后给他赋值true，\n\t\tif(typeof e.cancelBubble=='undefined'){\n\t\t\te.stopPropagation();\n\t\t}else{\n\t\t\te.cancelBubble=true;\n\t\t}\n\t}\n\tbox1.onclick=function(){\n\t\talert(\"div\");\n\t}\n\tdocument.body.onclick=function(){\n\t\talert(\"body\");\n\t}\n\tdocument.documentElement.onclick=function(){\n\t\talert(\"html\");\n\t}\n\tdocument.onclick=function(){\n\t\talert(\"document\");\n\t}\n</script>\n</body>\n</html>\n```","tags":["冒泡"],"categories":["JS"]},{"title":"侠之大者，为国接盘","url":"%2Fhouseprice.html","content":"\n{% centerquote %} \n炒房兴邦，实业误国\n{% endcenterquote %}\n\n---\n<!-- more -->\n\n近年来，房价成为了生活中重要的谈资和话题，几乎所有的聊天场合都会聊到房子，什么谁谁谁有几套房，不用工作每月靠房租过活。坐公交车上都是听到一些阿姨手里几套房，在手里在捂一会，转手卖给有刚需的年轻人，后悔没多买几套之类的话。\n\n房价的上涨，刚需不敢不买，等下去看不到希望，掏空了一家父母的过去和年轻人的未来，面对zf的货币超发引起的通货膨胀，却又无可奈何。房价再涨个3、4倍，分分钟GDP超过美国啊。现在基本的理财方式已经赶不上通货膨胀的速度了，眼看着手里的钱越来越不值钱，人人自危，都只能通过购房来保值。被zf逼的哪怕背上几十年的贷款也要坐上这趟车，给zf当几十年的免费劳动力来消化这巨大的泡沫。\n\n这个浮躁社会的高房价，让我们这些刚毕业工作几年的年轻人，要我们的青春和汗水给你们买单。现在的年轻人，怎么可能刚毕业就能积攒到买房的首付，被逼的去‘啃老’，掏空全家人的钱包，成为房奴。2017年前yz的房价大概7000/m2，恒大在年初当了一波地王2w/m2买了邗江中专那边的地后，各个楼盘开始疯长，在年底11月份购入1w/m2后，如今短短半年已经涨到了1.3w/m2。试想以100m2为例如果不早点买，就得平白无故多交20w的韭菜钱。房价降是不可能降的，这个牵扯到太多人和行业的利益，一旦崩盘了，其他行业也会受到影响，经济陷入低迷，zf不断地增发货币来救市。一线城市政府来主导市场看上去房价跌了，这也只是杯水车薪，高额的房价不断地在驱逐这所谓的低端人口，也是啊，毕竟要实现小康社会啊，让先富带动后富，实现共同小康，还是直接消灭低端人口容易些。房价的压力让现在的中国人充满着戾气、浮躁。上了车的人在嘲讽着没上车的人，一旦买了房，两者就成了对立面，高房价改变了人们的价值观。如今人们对于成功的标准定义有几辆车，几套房。现在各个城市推行的所谓吸引人才政策，不就是为了让人来接盘去库存么。\n\n房价带来了价值观的革命，中下层把买房当成了人生目标，中产把买房当成了支付手段，政府把卖地当作经济支柱，将企业债务转化成了居民债务。房价捆绑了经济、政治、户籍、教育、爱情、事业甚至社会地位，集万千宠爱于一身。随着房价越来越高，社会阶层出现固化趋势，多少年轻人的梦想倍房价无情碾压，多少家庭为了买房背上沉重的债务，多少爱情因为房价变得支离破碎，还有的夫妻为了多买套房选择离婚。而在房价面前我们崇尚的个人奋斗，不值一文。年轻人开始选择佛系，不再憧憬爱情，坚持和努力并没有什么卵用，开始相信投机的价值。金钱至上主义横行，勤劳致富成为了笑话，炒房的人成为了羡慕对象，所谓的梦想是多么的幼稚可笑。这个xx的时代，只要你买不起房救市没出息的男人。毕竟男生在婚姻当中是向下兼容，而女生是向上兼容的。现在的知乎上现在的男生为什么不追求女生、为什么现在的女孩子活得都很潇洒，男孩子确郁郁寡欢这类的问题比比皆是。毕竟女性才是消费的主力，那些商家们为了自己的利益，各种推出什么女神节等等之类的活动和营销号无底线地讨好女性发软文毒鸡汤，恶心至极。什么公主、女王、仙女，拜拜了您！大家又不是笨蛋，看透了资本主义生产方式，不想再沦为奴隶了，工作只会使自己越来越贫穷。劳动法就是个笑话，各种被所谓的企业文化所绑架，压榨干你的劳动力。员工和公司的关系很简单，你付给我钱，我帮你工作罢了，我们并不是一家人。永远不要试探人性的底线，没有完美的人。抱歉，中国特色社会主义的大饼我吃不下了。\n\n从古至今，中国还是没有发生什么大的变化，权利还是掌握在少部分人手里，层层剥削的金字塔结构，什么人民当家作主，到头来还不是被代表了。所谓的法律还不是为了维护阶级统治的利益。我国是领导人选举能全票通过的国家，神奇不神奇呵呵。一个个大腹便便的领导们，嘴上说着服务人民，背地里作者贪污腐败的行当。这年头都希望考公务员，公务员是什么，为人民服务。一个个都争着抢着去当人民的公仆，还不是为了铁饭碗、利益。在小城市里，都是靠关系，所谓的人情社会。有些人只是想听到他们想听到的话罢了，成年人的价值观一旦成型一般是很难改变的。国家开放二胎政策还不是为了拉动内需，劳动力不足，老龄化严重。现在地区间发展不平衡，中国就只有这北上广深等一线城市罢了，很多人背井离乡去这些大城市打工，这些人是去赚钱而不是来消费的，当地的zf是很讨厌的。春运很值得骄傲吗，你以为人人都愿意远离自己的家乡，在陌生的城市中打拼吗？这些繁华都与自己无关。很久之前被教导不乱扔垃圾，可现实是如果大家都不乱扔垃圾了，那些环卫工人们是真的会失业的，资本家会让人白白领一份工资么？答案当然是不会的，他们宁可把过剩的商品都愿意倒掉销毁，也不愿意救济贫民，扰乱消费市场。中国有着最大的局域网，保护本国的互联网产品的利益，没什么创新，都是对标国外的产品。除了抄袭还是抄袭，科研没有实际的成果都只是为了骗取国家的补贴。\n\n这年头的幼儿教育也是问题不断。应试教育也就算了，再怎么培养也是考试型人才。为了不让自己的孩子输在起跑线，给孩子报了大大小小的培训班。中国大多数父母都不希望自己的孩子是个“普通学生”，而是希望孩子能像别人家的孩子一样能考进名牌大学（被国家归为 211 或者 985 的大学），但事实上每年能挤过高考独木桥考取 211/985 的孩子有多少呢？ 全国平均下来大约是 7% 。对 93% 的学生和家长来说，十几年来他们承受着巨大的压力，最后却几乎可以说在“读书”上是失败的。我们的学校除了教学生读书还教他们什么呢？\n\n不论社会如何变化动荡，大家只想守护好自己的小小幸福罢了。\n\n","tags":["房价"],"categories":["杂谈"]},{"title":"JavaScript深入之执行上下文","url":"%2Fcontext.html","content":"\n## 变量/函数提升(函数及变量的声明都将被提升到函数的最顶部，且函数声明在变量声明上边)\n\n```javascript\nif(!\"a\" in window){ // false\n    var a=1;\n}\nconsole.log(a) // undefined\n```\n\n```javascript\nfunction foo() {\n    console.log('foo1');\n}\n\nfoo();  // foo2\n\nfunction foo() {\n    console.log('foo2');\n}\n\nfoo(); // foo2\n---\nvar getName = function () { alert (4);};\nfunction getName() { alert (5);}\ngetName(); // 4\n---\nfunction getName() { alert (5);}\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\ngetName(); // 4\n```\n函数表达式执行的优先级==!主要原因是函数声明都被提前了，所以函数表达式在最后会覆盖。\n\nJavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。插槽slot\n可执行代码的类型：全局代码、函数代码、eval代码。\nJavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文\n\n--- \n<!-- more -->\n\n为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：\n\n```javascript\nECStack = [];\n```\n\n试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：\n\n```javascript\nECStack = [\n    globalContext\n];\n```\n\n现在 JavaScript 遇到下面的这段代码了：\n\n```javascript\nfunction fun3() {\n    console.log('fun3')\n}\n\nfunction fun2() {\n    fun3();\n}\n\nfunction fun1() {\n    fun2();\n}\n\nfun1();\n```\n\n当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：\n\n```javascript\n// 伪代码\n\n// fun1()\nECStack.push(<fun1> functionContext);\n\n// fun1中竟然调用了fun2，还要创建fun2的执行上下文\nECStack.push(<fun2> functionContext);\n\n// 擦，fun2还调用了fun3！\nECStack.push(<fun3> functionContext);\n\n// fun3执行完毕\nECStack.pop();\n\n// fun2执行完毕\nECStack.pop();\n\n// fun1执行完毕\nECStack.pop();\n\n// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext\n```\n\n## 三大属性\n- 变量对象\n- 作用域链\n- this\n\n## 全局对象\n{% note info %}\n\n全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。\n\n{% endnote %}\n\n{% note info %}\n\n例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。\n\n{% endnote %}\n\n```javascript\n// 在浏览器客户端 全局对象就是window对象\n// 通过this引用\nthis === window  // true\nthis.window === window // true\nthis instanceof Object // true 是通过Object构造函数实例出来的对象\nMath.random() \nthis.Math.random() // 预定义了一些函数和属性\n\n// window指向自身\nvar a=1;\na // 1\nthis.a // 1\nwindow.a // 1 \nthis.window.a // 1\n```\n\n## 函数声明>变量声明\n\n```javascript\nconsole.log(foo); // 打印函数\n\nfunction foo(){\n    console.log(\"foo\");\n}\n\nvar foo = 1;\n```\n执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。","tags":["上下文"],"categories":["JS"]},{"title":"JS执行顺序-函数声明提升、匿名函数、函数表达式","url":"%2FexecutionOrder.html","content":"\n{% centerquote %} \n JS 是按照`代码块`进行 编译、执行 的。\n{% endcenterquote %}\n\n---\n<!-- more -->\n## script标签区分代码块\n```javascript\n<script>\n  alert('代码块一');\n</script>\n<script>\n  alert('代码块二');\n</script>\n```\n\n## 关于函数(声明式函数、赋值型（函数表达式）函数、匿名函数、自执行函数)\n### 函数提升\n`声明函数与赋值函数的区别在于： 在 JS 的预编译期间，声明式函数会被先提取出来，然后才按照顺序执行 JS代码。`\n\n```javascript\nA();  // 'A '\nfunction A() {\n  console.log('A');\n}\n\nB(); // error， B is not a function\nvar B = function() {\n  console.log('B');\n}\n```\n\n### 匿名函数（没有名字的函数）\n```javascript\nfunction() {} // 匿名函数\n```\n\n### 自执行函数\n```javascript\n(function() {\n  console.log(3);\n})();\n\n// 带参数\n(function(num){\n  console.log(num);\n})(3); // 3\n\n// 没有括号会报错 如下\nfunction() {\n  console.log(3);\n}();\n```\n原因如下：\n- function {}()其实这是一个函数声明。\n- JS运行的时候，会对函数声明进行预编译，然后在执行其他语句。\n- 也就是说function(){}先被预编译了。然后JS看见了()。JS一脸懵逼，这不得报错吗。\n- 而匿名函数实际上是一个语句，正常执行。\n\n自执行函数的标识也可以是\n```javascript\n!function(){}()      (function(){})()    \n~function(){}()      void function(){}()\n```\n\n## 预编译期和执行期\n{% note info %}\nJS的解析分为两个阶段：预编译 和 执行期。\n{% endnote %}\n- 预编译期间：对本代码块中的所有声明变量和函数进行处理(类似于C语言的编译) ，但需要注意，1.此时处理函数的只是 声明式函数2.变量也只是进行了声明但是没有进行初始化和赋值\n- 编译期间：从上到下编译代码块。\n\n### 函数声明提前且后来居上覆盖\n```javascript\ngetName(); // 6\nfunction getName() { alert (5);}\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\n\n---\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\ngetName(); // 4 函数声明都被提升了，表达式会覆盖掉\n```\n\n### 练习题\n```javascript\nfunction Foo() {\n    getName = function () { alert (1); };\n    return this;\n}\nFoo.getName = function () { alert (2);};\nFoo.prototype.getName = function () { alert (3);};\nvar getName = function () { alert (4);};\nfunction getName() { alert (5);}\n \n//请写出以下输出结果：\nFoo.getName(); // 2\ngetName();  // 4\nFoo().getName(); // 1\ngetName(); // 1\nnew Foo.getName(); // 2\nnew Foo().getName(); // 3\n```\n\n## ES6之前，JS没有变量作用域。只有 函数作用域 和 全局作用域。\n```javascript\n{\n  var a = 3;\n}\nconsole.log(a); // 3\n---\n{\n  let a = 3;\n}\nconsole.log(a); // error\n```","tags":["知识"],"categories":["JS"]},{"title":"JavaScript深入之作用域","url":"%2Fscope.html","content":"\n## 作用域\n\n作用域指的是程序源代码中定义变量的区域\n\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n\nJavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。\n\n**函数的作用域在函数定义的时候就决定了，函数的作用域基于函数创建的位置。**\n\n---\n<!-- more -->\n\n```javascript\nvar value=1\nfunction print(){\n  console.log(value)\n}\nfunction foo(){\n  var value=2\n  print()\n}\nfoo() // value 1 如果是动态作用域则是2\n```\n我们再来看两道题：\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n```\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n```\n两道题的执行结果都是 \"local scope\"\n\nJavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。\n\n```javascript\nvar name=\"999999\"\nvar b = {\nname :\"The Window\",\nobject:{\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n                return this.name\n              }\n　　　　}\n　　}\n}\nconsole.log(b.object.getNameFunc()()) // 999999\n---\nvar name=\"999999\"\nvar b = function(){\nvar name = \"The Window\";\n　　var object = {\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n \n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　console.log(object.getNameFunc()())\n}\nb() // 999999\n```","tags":["作用域"],"categories":["JS"]},{"title":"JavaScript深入之从原型到原型链","url":"%2Fprototype.html","content":"\n## 构造函数创建对象\n\n我们先使用构造函数创建一个对象：\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nperson.name = \"cosyer\";\nconsole.log(person.name); // cosyer\n```\n\n在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。\n\n---\n\n<!-- more -->\n\n很简单吧，接下来进入正题：\n\n### prototype\n\n每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：\n\n```javascript\nfunction Person() {}\n// prototype是函数才会有的属性\nPerson.prototype.name = \"cosyer\";\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name); // cosyer\nconsole.log(person2.name); // cosyer\n```\n\n那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？\n\n其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。\n\n那什么是原型呢？你可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\n\n让我们用一张图表示构造函数和实例原型之间的关系：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype1.png)\n\n在这张图中我们用 Object.prototype 表示实例原型。\n\n那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：\n\n### **proto**\n\n为了证明这一点,我们可以在火狐或者谷歌中输入：\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n于是我们更新下关系图：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype2.png)\n\n既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？\n\n### constructor\n\n指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。\n\n为了验证这一点，我们可以尝试：\n\n```javascript\nfunction Person() {}\nconsole.log(Person === Person.prototype.constructor); // true\n```\n\n所以再更新下关系图：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype3.png)\n综上我们可以得出：\n\n```javascript\nfunction Person() {}\n\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype); // true\nconsole.log(Person.prototype.constructor == Person); // true\n// 顺便学习一个ES5的方法,可以获得对象的原型 实例原型的constructor指向构造函数,构造函数的prototype指向实例原型,实例对象的__proto__指向实例原型,实例原型也是对象,它也有原型 最后的一个环节是null。访问实例对象的constructor时,也能从实例原型上去找,从而指向到构造函数。\nconsole.log(Object.getPrototypeOf(person) === Person.prototype); // true\n```\n\n## 实例与原型\n\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n举个例子：\n\n```javascript\nfunction Person() {}\n\nPerson.prototype.name = \"cosyer\";\n\nvar person = new Person();\n\nperson.name = \"Daisy\";\nconsole.log(person.name); // Daisy\n\ndelete person.name;\nconsole.log(person.name); // cosyer\n```\n\n在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。\n\n但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.\\_\\_proto\\_\\_ ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 cosyer。\n\n但是万一还没有找到呢？原型的原型又是什么呢？\n\n## 原型的原型\n\n在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```javascript\nvar obj = new Object();\nobj.name = \"cosyer\";\nconsole.log(obj.name); // cosyer\n```\n\n其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 **proto** 指向构造函数的 prototype ，所以我们再更新下关系图：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype4.png)\n\n## 原型链\n\n那 Object.prototype 的原型呢？\n\nnull，我们可以打印：\n\n```javascript\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n然而 null 究竟代表了什么呢？\n\n引用阮一峰老师的 《undefined 与 null 的区别》 就是：\n\nnull 表示“没有对象”，即该处不应该有值。\n\n所以 Object.prototype.**proto** 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n\n最后一张关系图也可以更新为：\n![prototype](http://p33v4b0bc.bkt.clouddn.com/prototype5.png)\n\n图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。\n\n## 补充\n\n### constructor\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nconsole.log(person.constructor === Person); // true\n```\n\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\n\n```javascript\nperson.constructor === Person.prototype.constructor;\n```\n\n### **proto**\n\n其次是 **proto** ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.**proto** 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n\n### 继承\n\n最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n\n- class 的引入只是语法糖本身还是基于原型的\n- 几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。\n\n```javascript\nvar p = Object.create(o);\n// p是一个继承自 o 的对象\n对象的原型链\no===>Object.prototype===>null\n数组的原型链\na===>Array.prototype===>Object.prototype===>null\n函数的原型链\nf===>Function.prototype===>Object.prototype===>null\n```\n\n### 原型对象的添加属性\n```javascript\nfunction Persion(){}\nPersion.prototype.sayName=function(){\n  console.log('darling')\n}\n// Persion.prototype={\n//   sayName:function(){\n//     console.log('darling')\n//   } \n// }\nlet persion =new Persion()\npersion.sayName() // darling\n\nfunction Persion(){}\nlet persion=new Persion()\n// 这里重写了原型对象，实例对象和最初的原型对象断开了联系\nPersion.prototype={\n  sayName:function(){\n    console.log('darling')\n  } \n}\npersion.sayName() // error\n```\n\n### new 操作符具体干了什么\n1.创建空对象，并且this变量引用该对象同时继承该函数的原型\n2.属性和方法加入到this引用的对象中\n3.新创建的对象用this引用，并且隐式地返回this\n```javascript\nfunction Base(){\n  this.id = \"base\";\n}\nvar obj = new Base();\n```\n**new干了什么？** \n\n1.var obj = {};\n\n2.obj.\\_\\_proto\\_\\_ = Base.protptype;\n\n3.Base.call(obj);\n\n- es5使用Object.create()来创建对象 new Object() 字面量写法{}\n使用Object.create()是将对象继承到__proto__属性上，\nObject.create(null)没有继承任何原型方法，也就是说它的原型链没有上一层。\n- es6使用class关键字\n\n- 构造器就是普通的函数,new来作用称为构造方法(构造函数)\n\n- 访问原型链会损耗性能,不存在的属性会遍历原型链直到最后一层\n\n- hasOwnProperty 是 JavaScript 中唯一处理属性并且不会遍历原型链的方法。通常在for in循环中使用。","tags":["原型链"],"categories":["JS"]},{"title":"你所不知道的前端冷门小知识(长期更新)","url":"%2Fsmallknowledge.html","content":"\n## void \nvoid其实是javascript中的一个函数，接受一个参数，返回值永远是undefined\nvoid expression\n```javascript\nvoid 0  \nvoid() // 报错\nvoid (0)  \nvoid \"hello\"  \nvoid (new Date())  \n// all will return undefined  \ncontext == void 666\n```\n\n---\n<!-- more -->\n\n## Element.scrollIntoViewIfNeeded\n Element.scrollIntoViewIfNeeded（）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。\n ```javascript\nelement.scrollIntoViewIfNeeded(); // 等同于element.scrollIntoViewIfNeeded(true) \nelement.scrollIntoViewIfNeeded(true); \nelement.scrollIntoViewIfNeeded(false);\n ```\n- 当元素已经在可视区域时，调用 Element.scrollIntoView()，无论设置什么参数，均发生滚动。\n- 当元素已经在可视区域时，调用 Element.scrollIntoViewIfNeeded()，无论设置什么参数，均不发生滚动。\n\n## JS取整\n```javascript\n~~2.5 // 2 按位取反 -2^31~2^31-1 -2147483648~2147483647\n0|3.123;// 3 或运算\n4.3|0; // 4\n4.3<<0; // 4\n```\n\n与Math.floor()的对比\n\n|区别|Math.floor|~~|\n|:---|:---:|---:|\n|NaN|NaN|0|\n|+0|+0|0|\n|-0|-0|0|\n|+Infinity|+Infinity|0|\n|-Infinity|-Infinity|0|\n|1.2|1.2|1.2|\n|-1.2|-1|-1|\n\n1. 位运算：~ 的结果是 int32 的有符号整数，所以肯定不可能是 NaN 和无穷，因此 1、4、5 两者不同。x|0  x<<0\n\n3. Math.floor 向 +∞ 取整。\n\n3. parseInt(string, radix);\n\nparseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。\n\nparseInt 解析字符串 '-0' 会得到 -0。如果参数是数字 -0，会得到 0。\n\n```javascript\nparseInt(0.0000000003) // 3\n\nparseInt('2017-07-04') // 2017\n```\n## 全等判断\njavascript 中 +0 完全等于 -0，那么怎么分区两者呢？\n```javascript\n1/0 === 1/-0 // false \n+0 === -0 // true\nObject.is(+0,-0) // false\n```\n区分NaN\n```javascript\nNaN !== NaN // true\nNaN === NaN // false \nObject.is(NaN,NaN) // true\n```\n\n## try-catch跳出forEach循环\nforEach遍历不能保证遍历的顺序，以及不能break;一般for循环的性能是forEach的20倍\n```javascript \ntry {\n    [1, 2, 3].forEach(v => {\n        if (v === 2) {\n            throw new Error('my err')\n        }\n    })\n} catch (e) {\n    if (e.message === 'my err') {\n        console.log('breaked') \n    } else {\n        throw e\n    }\n}\n\n// 用some也可以在遍历中跳出循环\n[1,2,3].some((item)=>{\n\tconsole.log(item)\n  return item === 2 // 如果item等于2就跳出循环\n})\n```\n\n## fetch模拟post进行api测试\n```javascript\nfetch(apiUrl, {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({q: 1})\n}).then(async res => console.log(await res.json()))\n```\n\n## 实现var a = add(2)(3)(4)\njs中console.log一个对象时，会对这个对象进行toString()操作，还有些情况会对对象进行valueOf()操作\nvauleOf优先于toString()被调用\n```javascript\nfunction add(num){\n    var _add = function(args){\n        num+=args;\n        return arguments.callee; //  return add(num+args);\n    }\n    _add.toString = _add.valueOf = function(){\n        return num;\n    }\n    return _add;\n}\nadd(2)(3)(4);// function 9\n```\n\n## Date相关 \n\n### Date构造函数\n```javascript\n4种表示时间戳的方式\n1. Date.now()\n2. new Date().getTime()\n3. +new Date() / +new Date +相当于.valueOf();\n4. new Date().valueOf()\n5. new Date*1 / new Date()*1 \n\n解释：JavaScript中可以在某个元素前使用'+'号，这个操作是将该元素转换秤Number类型，如果转换失败，那么将得到 NaN。\n所以 +new Date 将会调用 Date.prototype 上的 valueOf 方法，而根据MDN，Date.prototype.value 方法等同于 Date.prototype.getTime()\n\nDate.parse(\"2018-06-13\") === new Date(\"2018-06-13\").getTime()\n// 浏览器之间解析时间不同 safari 解析横杠 - 会出错所以尽量用斜杠 /\n```\n### 当前时间\n```javascript\nlet d = new Date()\nlet year=d.getFullYear();\nlet month=d.getMonth()+1; // 月份索引从0开始\nlet day=d.getDate(); // getDay()用于获取星期\nlet hour=d.getHours();\nlet minute=d.getMinutes();\nlet second=d.getSeconds();\nconsole.log(`${year}-${month}-${day} ${hour}:${minute}:${second}`) // 2018-6-13 21:20:48\n// 不足2位数补0\nconsole.log([year, month, day].map((item)=>{\n        item = item.toString();\n    return item[1] ? item : \"0\" + item;\n}).join(\"-\") +\" \" +[hour, minute, second].map((item)=>{\n        item = item.toString();\n    return item[1] ? item : \"0\" + item;\n}).join(\":\"))  // 2018-06-13 21:20:48\n```\n### Date计时\n以博客存活时间为例\n```javascript\nvar time = new Date(); \nvar t = \"博客存活了\"+Math.floor((+new Date - 1527868800000) / (1000 * 60 * 60 * 24)) + \"天\" + time.getHours() + \"小时\" \n+ time.getMinutes() + \"分\" + time.getSeconds() + \"秒\"; \n// 博客存活了11天 21小时28分51秒 1527868800000当时的时间转的时间戳\n```\n\n### Date原型扩展方法\n```javascript\nDate.prototype.format = function (format) {\n\t\t\tvar o = {\n\t\t\t\t\t\"M+\": this.getMonth() + 1,\n\t\t\t\t\t\"d+\": this.getDate(),\n\t\t\t\t\t\"h+\": this.getHours(),\n\t\t\t\t\t\"m+\": this.getMinutes(),\n\t\t\t\t\t\"s+\": this.getSeconds(),\n\t\t\t\t\t\"q+\": Math.floor((this.getMonth() + 3) / 3),\n\t\t\t\t\t\"S\": this.getMilliseconds()\n\t\t\t};\n\t\t\tif (/(y+)/.test(format)) {\n\t\t\t\t\tformat = format.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n\t\t\t}\n\t\t\tfor (var k in o) {\n\t\t\t\t\tif (new RegExp(\"(\" + k + \")\").test(format)) {\n\t\t\t\t\t\t\tformat = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn format;\n\t};\n\n\tDate.prototype.addDays = function (d) {\n\t\t\tthis.setDate(this.getDate() + d);\n\t};\n\n\tDate.prototype.addWeeks = function (w) {\n\t\t\tthis.addDays(w * 7);\n\t};\n\n\tDate.prototype.addMonths = function (m) {\n\t\t\tvar d = this.getDate();\n\t\t\tthis.setMonth(this.getMonth() + m);\n\t\t\t//if (this.getDate() < d)\n\t\t\t//  this.setDate(0);\n\t};\n```\n\n## 页面加载时间\n```javascript\nwindow.onload = function () {\n  var loadTime = window.performance.timing.domContentLoadedEventEnd-window.performance.timing.navigationStart; \n  console.log('Page load time is '+ loadTime);\n}\n```\nonload和onready的区别：\n1. 执行时间\n\n　　window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 \n\n　　$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。\n\n2. 编写个数不同\n\n　　window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。\n\n　　$(document).ready()可以同时编写多个，并且都可以得到执行。\n\n3. 简化写法\n\n　　window.onload没有简化写法。\n\n　　$(document).ready(function(){})可以简写成$(function(){});\n\n## 常用标签\n```javascript\n<meta charset=\"utf-8\">\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\">\n<link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" />\n// seo\n<title></title>\n<meta name=\"author\" name=\"cosyer\">\n<meta name=\"keywords\" name=\"cosyer\">\n<meta name=\"description\" name=\"cosyer\">\n<link rel=\"stylesheet\" href=\"\">\n<script src=\"\"></script>\n```\n\n## 获取url参数\n```javascript\nlet reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\")\nlet r = window.location.search.substr(1).match(reg)\nif (r != null) return decodeURIComponent(r[2]) // encodeURIComponent()\nreturn null\n```\n\n## String原型方法扩展\n```javascript\n// 连字符转驼峰\nString.prototype.hyphenToHump = function () {\n\t\treturn this.replace(/-(\\w)/g, function () {\n\t\t\t\treturn arguments[1].toUpperCase()\n\t\t})\n}\n\n// 驼峰转连字符\nString.prototype.humpToHyphen = function () {\n\t\treturn this.replace(/([A-Z])/g, \"-$1\").toLowerCase()\n}\n```\n\n## 拦截控制台、右键和F12\n```javascript\n\tdocument.onkeydown = function () {\n\t\t\tvar e = window.event || arguments[0];\n\t\t\t//屏蔽F12\n\t\t\tif (e.keyCode == 123) {\n\t\t\t\t\treturn false;\n\t\t\t\t\t//屏蔽Ctrl+Shift+I\n\t\t\t} else if ((e.ctrlKey) && (e.shiftKey) && (e.keyCode == 73)) {\n\t\t\t\t\treturn false;\n\t\t\t\t\t//屏蔽Shift+F10\n\t\t\t} else if ((e.shiftKey) && (e.keyCode == 121)) {\n\t\t\t\t\treturn false;\n\t\t\t}\n\t};\n\t//屏蔽右键单击\n\tdocument.oncontextmenu = function () {\n\t\t\treturn false;\n\t};\n```\n\n## 崩溃欺骗\n```javascript\nvar OriginTitle = document.title;\nvar titleTime;\ndocument.addEventListener('visibilitychange', function () {\n    if (document.hidden) {\n        $('[rel=\"icon\"]').attr('href', \"/img/TEP.ico\");\n        document.title = '╭(°A°`)╮ 页面崩溃啦 ~';\n        clearTimeout(titleTime);\n    }\n    else {\n        $('[rel=\"icon\"]').attr('href', \"/favicon.ico\");\n        document.title = '(ฅ>ω<*ฅ) 噫又好了~' + OriginTitle;\n        titleTime = setTimeout(function () {\n            document.title = OriginTitle;\n        }, 2000);\n    }\n});\n```\n\n## a标签\n```javascript\n    // 邮件\n\t<a href={'mailto:'+props.email}></a>\n\t// 下载只有 Firefox 和 Chrome 支持 download 属性。\n\t<a href=\"/images/myw3schoolimage.jpg\" download=\"w3logo\"></a>\n    // QQ\n\t<a href=\"tencent://message/?uin=535509852&Site=-&Menu=yes\" target=\"_blank\">QQ:535509852</a>\n```\n\n## 两数组去重合并\n```javascript\nfunction filter(a,b){\n\tfor(let m in a){ \n\tlet isExist=false;\n\tfor(let n in b ){\n\tif(b[n]==a[m]){\n\tisExist=true;\n\tbreak;\n\t}\n\t}\nif(!isExist){\n\tb.push(a[m]);\n}\n\t}\n\treturn b;\n}\n// filter([1,2,3,4],[2,3])\n// [2, 3, 1, 4]\n```\n\n##  `<script>`元素放在 HTML 文件底部\n\n我们将 `<script>`元素放在 HTML 文件底部的原因是，浏览器按照代码在文件中的顺序解析 HTML。如果 JavaScript在最前面被加载，HTML还未加载，JavaScript将无法作用于HTML，所以JavaScript无效，如果 JavaScript 代码出现问题则 HTML 不会被加载。所以将 JavaScript 代码放在底部是最好的选择。\n\n## 某个字符在字符串中的个数\n```javascript\nlet str=\"11112234241\"\nconsole.log(str.split(\"1\").length-1)\n```\n\n## 数组求最大值方法汇总\n```javascript\n1. es6拓展运算符...\nMath.max(...arr)\n2. es5 apply(与方法1原理相同)\nMath.max.apply(null,arr)\n3. for循环\nlet max = arr[0];\nfor (let i = 0; i < arr.length - 1; i++) {\n    max = max < arr[i+1] ? arr[i+1] : max\n}\n4. 数组sort\narr.sort((a,b)=>{\n\treturn a<b // 降序\n})\n5. 数组reduce\narr.reduce((a,b)=>{\n\treturn a>b?a:b\n})\n```\n\n```javascript\nfunction foo(p1,p2) {\nthis.val = p1 + p2;\n}\nvar bar = foo.bind( null, \"p1\" );\nvar baz = new bar( \"p2\" );\nbaz.val; // p1p2\n```\n\n## 回到顶部\n```javascript\nfunction goback() {\n// 1.回到顶部\n// scrollTo(0, 0); // 滚动条滚动 x y \n// 2.渐渐回到顶部 距离顶部高度\n//var iScrollTop = document.body.scrollTop; //360,Chrome,\n//var iScrollTop = document.documentElement.scrollTop;  //IE8,火狐\nvar iScrollTop = document.body.scrollTop || document.documentElement.scrollTop;\nvar timer = setInterval(function () {  //定时器\n\tscrollTo(0, iScrollTop -= 100);\n\tconsole.log(iScrollTop);\n\tif (iScrollTop <= 0) {\n\t\tclearInterval(timer);  //清除定时器\n\t}\n}, 100);\nreturn false;\n}\n```\n\n## 手机号处理中间4位替换成*\n\n### 方法1 substr方法\n```javascript\nlet phone=\"18883269663\"\nlet phone1=phone.substr(0,3)+\"****\"+phone.substr(7)\n```\n\n### 方法2 正则匹配分组\n```javascript\nlet tel = \"13122223333\";\n\nlet reg = /^(\\d{3})\\d{4}(\\d{4})$/;\n\ntel = tel.replace(reg, \"$1****$2\");\n```\n\n## 转换树形结构数据\n```javascript\nlet arr=[{\"departmentId\":\"2807369902638080\",\"departmentName\":\"四合院大数据有限公司\",\"departmentDesc\":\"四合院大数据有限公司是非常好的公司\",\"createTime\":null,\"hasChild\":false,\"parentId\":null},{\"departmentId\":\"2805950137730048\",\"departmentName\":\"产品策划部\",\"departmentDesc\":null,\"createTime\":null,\"hasChild\":true,\"parentId\":null},{\"departmentId\":\"2805949110338560\",\"departmentName\":\"研发中心\",\"departmentDesc\":null,\"createTime\":null,\"hasChild\":true,\"parentId\":null}];\n\nfunction fn(data, p_id) {\n  var result = [],\n    temp;\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].parentId == p_id) {\n      var obj = data[i];\n      obj.label = data[i].departmentName;\n      temp = fn(data, data[i].departmentId);\n      if (temp.length > 0) {\n        obj.children = temp;\n      }\n      result.push(obj);\n    }\n  }\n  return result;\n}\n\nlet treeData=fn(treeData,null) // 传入原始数据/parentId\n适用于ant design和element-ui等树形结构数据\n```\n\n## 浏览器返回上一页\n```javascript\n<a href=\"#\" onclick=\"javascript:history.back(-1);\">返回到上一页</a>\n\n<a href=\"#\" onClick=\"javaScript:history.go(-1)\">返回上一页</a>\n```\n\n## 去重数组里对象相同值得key\n```javascript\nconst key = 'id'\nconst arr = [{ id: 1 }, { id: 1 }, { id: 2 }, { id: 3 }]\nconst filted = arr.reduce((finalList, obj) => {\n  if (!finalList.find(T => T[key] === obj[key])) {\n    finalList.push(obj)\n  }\n  return finalList\n}, [])\n// [{ id: 1 }, { id: 2 }, { id: 3 }]\n\nlet map =new Map()\nfor (let item of arr){\nmap.set(item[key],item)\n}\n[...map.values()]\n```\n\n## 变量声明\n```javascript\n(function() {\n      var a = b = 5; // var a=b;b=5 严格模式会报错\n  })();   \nconsole.log(b); // 5\nconsole.log(a); // Uncaught ReferenceError: a is not defined\n\nvar a=[]; a[0]=1; a[1]=2; a[2]=3; a[5]=4; \na.length // 6\nwhile不改变作用域链\n[]?true:false // true\n[]==false?true:false // true\n2==true //false\n2==false // false\n\n+new Array(017) // NaN\n```\n\n## with语句\nwith语句的作用是将代码的作用域设置到一个特定的对象中。\n\n利：with语句可以在不造成性能损失的情况下，减少变量的长度。很多情况下，也可以不使用with语句，而是使用一个临时变量来保存指针，来达到同样的效果。\n\n弊：with语句使得程序在查找该语句块中的所有的变量值时，都是先在该with语句指定的对象下面先寻找一遍，然后再去外面的作用域去寻找。所以尽量不要在该语句块中去使用一些不属于该对象中的变量\n\n用法\n\n```javascript\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\nwith(x){\n  console.log(name+'的小名是'+nick_name);\n}\n```\n\n相当于\n```javascript\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\n/*\n *这里将x对象赋值到当前局部变量中，减少不必要的指针路径解析运算\n *一般用于在在方法中将this对象局部化，比如：var this_ = this;\n */\nvar x_ = x;\nconsole.log(x_.name+'的小名是'+x_nick_name);\n```\n\n## boolean类型在进行比较时会类型转换成number\n```javascript\n11==true // 11==1 false\n1==true  // 1==1 true\n```\n\n## RGB到十六进制\n使用按位左移运算符（<<）和toString（16），然后padStart（6，“0”）将给定的RGB参数转换为十六进制字符串以获得6位十六进制值。\n```javascript\nconst rgbToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, ‘0’);\n\n// rgbToHex(255, 165, 1) -> ‘ffa501’\n```\n\n## 滚动到顶部\n使用document.documentElement.scrollTop或document.body.scrollTop获取到顶部的距离。\n```javascript\nconst scrollToTop = _ => {\n\nconst c = document.documentElement.scrollTop || document.body.scrollTop;\n\nif (c > 0) {\n\n​ window.requestAnimationFrame(scrollToTop);\n\n​ window.scrollTo(0, c - c / 8);\n\n}\n\n};\n\n// scrollToTop()\n```\n\n## 求和\n```javascript\nconst sum = arr => arr.reduce((acc, val) => acc + val, 0);\n\n// sum([1,2,3,4]) -> 10 累加器\n// 平均数 sum([1,2,3,4])/4\n```\n\n## 大写每个单词的首字母\n使用replace（）匹配每个单词的第一个字符，并使用toUpperCase（）来将其大写。\n```javascript\nconst capitalizeEveryWord = str => str.replace(/[a-z]/g, char => char.toUpperCase());\n\n// capitalizeEveryWord(‘hello world!’) -> ‘Hello World!’\n```\n\n## 计算数组中某值出现的次数\n每次遇到数组中的特定值时，使用reduce（）来递增计数器。\n```javascript\nconst countOccurrences = (arr, value) => arr.reduce((a, v) => v === value ? a + 1 : a + 0, 0);\n\n// countOccurrences([1,1,2,1,2,3], 1) -> 3\n```\n\n## 数组间的区别\n从b创建一个Set，然后在a上使用Array.filter（），只保留b中不包含的值。\n```javascript\nconst difference = (a, b) => { const s = new Set(b); return a.filter(x => !s.has(x)); };\n\n// difference([1,2,3], [1,2]) -> [3]\n```\n\n## 阶乘\n使用递归。如果n小于或等于1，则返回1。否则返回n和n - 1的阶乘的乘积。\n```javascript\nconst factorial = n => n <= 1 ? 1 : n * factorial(n - 1);\n\n// factorial(6) -> 720\n```\n\n## 获取滚动位置\n如果已定义，请使用pageXOffset和pageYOffset，否则使用scrollLeft和scrollTop，可以省略el来使用window的默认值。\n```javascript\nconst getScrollPos = (el = window) =>\n\n({x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,\n\n​ y: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop});\n\n// getScrollPos() -> {x: 0, y: 200}\n```\n\n## 最大公约数\n```javascript\nconst gcd = (x, y) => !y ? x : gcd(y, x % y);\n\n// gcd (8, 36) -> 4\n```\n\n## UUID生成器\n使用crypto API生成符合RFC4122版本4的UUID。\n```javascript\nconst uuid = _ =>\n\n([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n\n​ (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n\n);\n\n// uuid() -> ‘7982fcfe-5721-4632-bede-6000885be57d’\n```\n\n## 检查变量是否声明\n如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个全局变量是否被声明。\n后二种写法有漏洞，如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。\n最好的方法是使用in\n```javascript\n// 假设变量x未定义\n\n// 写法一：报错\nif (x) { return 1; }\n\n// 写法二：不正确\nif (window.x) { return 1; }\n\n// 写法三：正确\nif ('x' in window) { return 1; }\n```\n\n## 使用对象结构代替 switch…case\nswitch…case不使用大括号，不利于代码形式的统一。此外，这种结构类似于goto语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。\n```javascript\n// 反模式\nfunction doAction(action) {\n    switch (action) {\n        case 'hack':\n            // ...\n            break;\n        case 'slash':\n            // ...\n            break;\n        default:\n            throw new Error('Invalid action.');\n    }\n}\n// 好模式\nfunction doAction(action) {\n    var actions = {\n        hack: function () {\n            // ...\n        },\n        slash: function () {\n            // ...\n        },\n    };\n\n    if (typeof actions[action] !== 'function') {\n        throw new Error('Invalid action.');\n    }\n\n    return actions[action]();\n}\n```","tags":["知识"],"categories":["知识"]},{"title":"快速了解React 16新特性","url":"%2Freact16.html","content":"\n## Error Boundary\n\nError Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）\n\n---\n<!-- more -->\n\n```javascript\n//最佳实践：将ErrorBoundary抽象为一个公用的组件类\n \nimport React, { Component } from 'react'\n \nexport default class ErrorBoundary extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  componentDidCatch(err, info) {\n    this.setState({ hasError: true })\n    //sendErrorReport(err,info)\n  }\n  render(){\n    if(this.state.hasError){\n      return <div>Something went wrong!</div>\n    }\n    return this.props.children\n  }\n}\n```\n\n```javascript\n// 使用方式 包裹容易出错的组件\nrender(){\n  return (\n    <div>\n      <ErrorBoundary>\n        <Profile user={this.state.user} />\n      </ErrorBoundary>\n      <button onClick={this.onClick}>Update</button>\n    </div>\n  )\n}\n```\n## render方法新增返回类型\n在React 16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。\n\n```javascript\n//string\nrender(){\n  return 'hello,world'\n}\n \n//number\nrender(){\n  return 12345\n}\n \n//boolean\nrender(){\n  return isTrue?true:false\n}\n \n//null\nrender(){\n  return null\n}\n \n//fragments，未加key标识符，控制台会出现warning\nrender(){\n  return [\n    <div>hello</div>,\n    <span>world</span>,\n    <p>oh</p>\n  ]\n}\n```\n以上各种类型现在均可以直接在render中返回，不需要再在外层包裹一层容器元素，不过在返回的数组类型中，需要在每个元素上加一个唯一且不变的key值，否则控制台会报一个warning。\n\n## 使用createPortal将组件渲染到当前组件树之外\n\n## 支持自定义DOM属性\n在之前的版本中，React会忽略无法识别的HTML和SVG属性，自定义属性只能通过data-*形式添加，现在它会把这些属性直接传递给DOM（这个改动让React可以去掉属性白名单，从而减少了文件大小）。\n\n## setState传入null时不会再触发更新\n\n## 更好的服务器端渲染\nReact 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。\n\n## 新的打包策略\n新的打包策略中去掉了process.env检查。\nReact 16的体积比上个版本减小了32%（30% post-gzip），文件尺寸的减小一部分要归功于打包方法的改变。\n\n## React 16采用了新的核心架构React Fiber。官方解释是“React Fiber是对核心算法的一次重新实现”","tags":["react"],"categories":["JS"]},{"title":"React 16新特性context api","url":"%2Fcontextapi.html","content":"\nReact 16.3带来了正式版的context API。让我们来看看有哪些改变，在那些地方可以取代redux吧！\n\n--- \n<!-- more -->\n\n我当前依赖的版本\n```javascript\n\"dependencies\": {\n    \"react\": \"^16.4.0\",\n    \"react-dom\": \"^16.4.0\"\n}\n```\n## 创建context实例\n```javascript\n// 创建context实例\nconst ThemeContext = React.createContext({\n  background: 'red',\n  color: 'white'\n});\n\nconst {Provider,Consumer} = ThemeContext\n```\n\n## Provider 组件 \n**Provider组件用于将context数据传给该组件树下的所有组件 value属性是context的内容。**\n```javascript\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider value={{ text: 'hello react!' }}>\n        <Comp1 />\n        <Comp2 />\n      </Provider>\n    );\n  }\n}\n```\n## Consumer 组件\n**Consumer消费Provider传递的数据**\n```javascript\n// 函数式\nconst Comp1 = () => (\n  <Consumer>\n    {context => <p>{context.text}</p>}\n  </Consumer>\n);\n// 类\nclass Comp2 extends React.Component {\n  render() {\n    return (\n      <Consumer>\n        {context => <p>{context.text}</p>}\n      </Consumer>\n    );\n  }\n}\n```\n如果你没有将Consumer作为Provider的子组件，那么Consumer将使用创建context时的参数作为context。","tags":["context api"],"categories":["JS"]},{"title":"如何理解JS闭包","url":"%2Fclosure.html","content":"\n{% centerquote %} \nJavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。\n{% endcenterquote %} \n\n在JS中函数作为普通对象进行传递\n\n--- \n<!-- more -->\n## 什么是闭包?\n简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。(函数和声明该函数的词法环境的组合)\n\n## 为什么需要闭包？\n使用闭包主要是为了设计私有的变量和方法。闭包的优点可以避免全局变量的污染，缺点是会常驻内存，增大内存的使用\n量，使用不当会造成内存泄漏。\n\n## 特点\n1. 定义外层函数，封装被保护的局部变量。 \n2. 定义内层函数，执行对外部函数变量的操作。 \n3. 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。\n\n## 特性\n1. 函数嵌套函数，内层函数被返回。\n2. 函数内部可以引用外部的参数和变量，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。\n3. 参数和变量不会被垃圾回收机制回收。\n\n## 实例\n```javascript\nvar add = (function () {\n    var counter = 0;\n    return function () {return counter += 1;}\n})();\nadd();\nadd();\nadd();\n// add()调用过后应当销毁其变量，但其内层函数被返回了，并且还保留着对变量的引用，所以没有销毁还保留在内存当中。\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(i)\n},i*1000)\n}\n// 打印3次3 执行setTimeout时for循环已经结束此时的i的值为3\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\n// 匿名闭包 封闭每个变量\n(function(index){\n  setTimeout(function(){\n  console.log(arr[index])\n},index*1000)\n})(i)\n} \n// one two three\n```\n\n避免使用过多的闭包，可以用let关键词，每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。\n```javascript\nvar arr=['one','two','three']\nfor(let i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(arr[i])\n},i*1000)\n}\n```\n","tags":["闭包"],"categories":["JS"]},{"title":"使用 Async/Await 让你的代码更简洁","url":"%2Fes7async.html","content":"\nAsync/Await是一种允许我们像构建没有回调函数的普通函数一样构建Promise的新语法。以往的异步方法无外乎回调函数和`Promise`。但是Async/Await建立于[Promise](https://mydearest.cn/createPromise.html)之上。\n\n---\n<!-- more -->\n\n## Async/Await语法\n### async关键字(放置在一个函数前面)。\n\n```javascript\nasync function f() {\n    return 1\n    // return Promise.resolve(1)\n}\nf().then(value) // 1\n```\n\nasync修饰过的函数总是返回一个promise，如果代码中有return <非promise>语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。\n### await关键字(只能在async函数内部使用)\n关键词await可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行。\n\n```javascript\nfunction timeout(ms) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n### 错误处理(使用try-catch捕获)\n```javascript\nasync function f() {\n    try {\n        let response = await fetch('http://no-such-url')\n    } catch (err) {\n        alet(err) // TypeError: failed to fetch 也能捕获多行语句 类似链式Promise最后的单个catch函数\n    }\n}\nf()\n```\n\n如果我们不使用try-catch，然后async函数f()的调用产生的promise变成reject状态的话，我们可以添加.catch去处理它：\n```javascript\nasync function f() {\n    let response = await fetch('http://no-such-url')\n}\n// f()变成了一个rejected的promise\nf().catch(alert) // TypeError: failed to fetch\n```\n\n### 结合Promise.all\nasync/await能够与Promise.all友好的协作，当我们需要等待多个promise时，我们可以将他们包装在Promise.all中然后使用await：\n\n```javascript\n\n// 直到数组全部返回结果\nlet results = await Promise.all([\n   fetch(url1),\n   fetch(url2),\n   ...\n])\n```\n## 总结\n\n随着单页JavaScript web程序的兴起和对NodeJS的广泛采用，如何优雅的处理并发对于JavaScript开发人员来说比任何以往的时候都显得更为重要。Async/Await缓解了许多因为控制流问题而导致bug遍地的这个困扰着JavaScript代码库数十年的问题，并且几乎可以保证让任何异步代码块变的更精炼，更简单，更自信。","tags":["Async/Await"],"categories":["JS"]},{"title":"从 for 循环入手优化性能","url":"%2Fforloop.html","content":"\n今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？\n\n---\n<!-- more -->\n\n从最简单的遍历数组说起。\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet i = 0;\nlet arr = [];\nwhile (i < 50) {\n    arr.push(i);\n    i++;\n}\n```\n\n如果我们想从数组 arr 中取出数据，就必须要进行遍历，普遍的做法是：\n```javascript\nfor (let i = 0; i < arr.length; i++) {\n    // arr[i]\n}\n```\n\n但其实这样的写法遍历是最慢的，他要经过两次迭代，第一次是 i 的迭代，每次都要判断 i 是否小于 arr.length，第二次是 arr 的迭代，每次循环 arr 都会调用底层的迭代器，对长度进行计算，这样循环的效率非常低，时间空间复杂度为 O[n^2]。\n\n下面进行优化，看看两者到底有什么区别：\n```javascript\nfor (let i = 0, len = arr.length; i < len; i++) {\n    // arr[i]\n}\n```\n\n区别就是，整个循环当中，我们预存了 len 来保存数组的长度，这样不需要每次循环都调用底层迭代器，调用一次即可，这样的时间空间复杂度为 O[n+1]。\n\n但是这并不是最完美的，因为会多了一次迭代操作，那么该如何进行优化呢？\n```javascript\nfor (let i = 0, item; item = arr[i++];) {\n    // item\n}\n```\n这次迭代的时间空间复杂度为 O[n] ，完美做到了每次一迭代没有通过长度进行判断，而是直接通过下标进行取值的方式映射到了循环体内部。\n\n最后用5万条数据进行测试各种方式的循环时间：\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet index = 0;\nlet arr = [];\nwhile (index < 50000) {\n    arr.push(index);\n    index++;\n}\n\nconsole.time('one');\nfor (let i = 0; i < arr.length; i++) {\n\n}\nconsole.timeEnd('one');\n\nconsole.time('two');\nfor (let i = 0, len = arr.length; i < len; i++) {\n\n}\nconsole.timeEnd('two');\n\nconsole.time('three');\nfor (let i = 0, item; item = arr[i++];) {\n\n}\nconsole.timeEnd('three');\n\n// es6的数组遍历\nconsole.time('four');\nfor (let i of arr) {\n\n}\nconsole.timeEnd('four');\n// 会访问可枚举属性和原型的遍历，数组不推荐使用\nconsole.time('five');\nfor (let i in arr) {\n\n}\nconsole.timeEnd('five');\n// one: 0.711ms\n// two: 4.508ms\n// three: 0.006ms\n// four: 3.255ms\n// five: 11.144ms\n```\n在数据量大的情况下，第三种循环方式效果显而易见。\n\n","tags":["性能优化"],"categories":["JS"]},{"title":"es6函数新特性","url":"%2Fes6function.html","content":"\n1. 设置函数默认值 \n2. 结合解构赋值默认值使用\n3. 利用rest(...变量名)传入任意参数\n\n---\n<!-- more -->\n\n## ...rest和扩展运算符\nrest参数（…变量名），用于获取函数的多余参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入其中。\n```javascript\nfunction foo(...y){\n    console.log(y)  // [1,2,3,4]\n}\nfoo(1,2,3,4)\n```\n## 利用扩展运算符（…数组）替代数组的apply方法\n在es5中，需要用apply将数组转化为函数参数，在es6中就不需要这种方式了，可以使用…来代替\n```javascript\nfunction f(x, y, z) {\n    console.log(x + ' ' + y + ' ' + z);\n}\nvar args = [1, 2, 3];\n// f.apply(null, args)\nf(...args)\n```\n\n数组push的例子：\n```javascript\nvar arr1 = [0, 1, 2]\nvar arr2 = [3, 4, 5]\nvar arr3 = arr1.concat(arr2)\nconsole.log(arr3) //[ 0, 1, 2, 3, 4, 5 ]\n\nvar arr4 = arr1.push(arr2)\nconsole.log(arr1) //[ 0, 1, 2, [ 3, 4, 5 ] ]\n```\n\n如果想使用arr1.push方法的话，就需要用apply传arr2了\n```javascript\nvar arr4 = Array.prototype.push.apply(arr1, arr2) //[ 0, 1, 2, 3, 4, 5 ]\n```\n\n如果使用扩展运算符的话，就简单一些了\n```javascript\nvar arr4 = arr1.push(...arr2)\n```\n\n## name属性\n函数的name属性可以返回函数名\n```javasctrpt\nfunction abc(){\n    console.log(abc.name)\n}\nabc() // 'abc'\n```\n\n## 函数的静态变量和函数\n```javascript\nfunction Box(){}\n\nBox.num = 12;  //静态变量\nBox.fn = function(){};  //静态函数\n\nconsole.log(Box.num);  //12\nconsole.log(Box.fn);  //function(){}\nconsole.log(typeof Box.fn);  //function\n\nvar t = new Box();\nconsole.log(t.num);  //undefined\nconsole.log(t.fn);  //undefined\nconsole.log(typeof t.fn);//undefined\n```\n\n静态变量和静态函数是Box对象的属性和方法，不属于实例。\n\n## 函数的实例函数和变量\n```javascript\nfunction Box(){\n  this.a = [];  //实例变量\n  this.fn = function(){};  //实例方法\n}\n\nconsole.log(Box.a);  //undefined\nconsole.log(Box.fn);  //undefined\nconsole.log(typeof Box.fn);  //undefined\n\nvar t = new Box();\nvar t2 = new Box();\n\nconsole.log(t.a);  //[]\nconsole.log(t2.a);  //[]\nt.a.push(1);   // t.a [1]\nconsole.log(t2.a);  //[]\n\nconsole.log(typeof t.fn);\n```\n每个实例都有一套实例属性和实例方法，互不影响。\n\n原型上的属性和方法，是实例共用的。\n\n## 函数传参\n\n### 基本类型 (基本类型的变量复制)\n```javascript\nvar count = 10;\nfunction num(num1){\n   num1 = 1;\n   return num1;\n}\nvar result = num(count);\nconsole.log(result);//1\nconsole.log(count);//10，并未变成1\n```\n### 引用类型\n```javascript\nvar person  = {\n    name : \"Tom\"\n};\nfunction obj(peo){\n    peo.name = \"Jerry\";\n    return peo;\n}\nvar result = obj(person);\nconsole.log(result.name);// Jerry\nconsole.log(person.name);// Jerry\n```\n\n```javascript\nvar person = {\n    name : \"Tom\"\n}; \nfunction obj(peo){\n    peo = {\n       name : \"Jerry\"\n    };\n    return peo;\n}\nvar result = obj(person);\nconsole.log(result.name);// Jerry\nconsole.log(person.name);// Tom\n```\nperson传递给函数中的peo，但在函数内部peo又指向了一个新对象，所以result.name是新对象的值，person还是指向原对象，所以并没有改变。\n\nECMAScript中所有函数的参数都是按值传递的。 ——《JS高程》\n\n我们可以把ECMAScript函数的参数想象成局部变量，在向参数传递基本类型的值时，被传递的值被复制给一个局部变量。\n\n在向函数传递引用类型时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。\n\n即使在函数内部修改了参数的值，但原始的引用仍然保持未变。","tags":["es6"],"categories":["JS"]},{"title":"JavaScript 中 this 的详解","url":"%2Fjsthis.html","content":"\n## this 的指向\n\n`this` 是 js 中定义的关键字， 它的指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。在实际应用中，`this`的指向大致可以分为以下四种情况。\n\n---\n<!-- more -->\n### 作为普通函数调用(直接调用)：函数名()\n当函数作为一个普通函数被调用，`this`指向全局对象。在浏览器里，全局对象就是 window。\n```javascript\nwindow.name = 'cosyer';\nfunction getName(){\n    console.log(this.name);\n}\ngetName();                   // cosyer\n```\n可以看出，此时`this`指向了全局对象 window。(NodeJS的全部对象是global)\n在ECMAScript5的严格模式下，这种情况`this`已经被规定不会指向全局对象了，而是undefined。\n```javascript\n'use strict';\nfunction fun(){\n    console.log(this);\n}\nfun();                      // undefined\n```\n### 作为对象的方法调用\n当函数作为一个对象里的方法被调用，`this`指向该对象\n```javascript\nvar obj = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\n\nobj.getName();              // cosyer\n```\n如果把对象的方法赋值给一个变量，再调用这个变量：\n```javascript\nvar obj = {\n    fun1 : function(){\n        console.log(this);\n    }\n}\nvar fun2 = obj.fun1;\nfun2();                     // window\n```\n此时调用 fun2 方法 输出了 window 对象，说明此时`this`指向了全局对象。给 fun2 赋值，其实是相当于：\n```javascript\nvar fun2 = function(){\n    console.log(this);\n}\n```\n可以看出，此时的`this`已经跟 obj 没有任何关系了。这时 fun2 是作为普通函数调用。\n\n### 作为构造函数调用\njs中没有类，但是可以从构造器中创建对象，并提供了`new`运算符来进行调用该构造器。构造器的外表跟普通函数一样，大部分的函数都可以当做构造器使用。当构造函数被调用时，`this`指向了该构造函数实例化出来的对象。\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n}\nvar obj = new Person();\nconsole.log(obj.name);      // cosyer\n```\n如果构造函数显式的返回一个对象，那么`this`则会指向该对象。\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n    return {\n        name : 'chenyu'\n    }\n}\nvar obj = new Person();\nconsole.log(obj.name);      // chenyu\n```\n如果该函数不用`new`调用，当作普通函数执行，那么`this`依然指向全局对象。\n\n### call() 或 apply() 调用 Function.prototype.bind()将当前函数绑定到指定对象绑定返回新函数之后再进行调用\n通过调用函数的 call() 或 apply() 方法可动态的改变`this`的指向。\n```javascript\nvar obj1 = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\nvar obj2 = {\n    name : 'chenyu'\n}\n\nobj1.getName();             // cosyer\nobj1.getName.call(obj2);    // chenyu\nobj1.getName.apply(obj2);   // chenyu\n```\n**简单的实现bind方法**\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 自定义的函数，模拟 bind() 对 this 的影响\nfunction myBind(func, target) {\n    return function() {\n        return func.apply(target, arguments); // 第一个参数为函数运行的this指向\n    };\n}\n\nconst testObj = myBind(test, obj);\ntest();     // false\ntestObj();  // true\n```\n从上面的示例可以看到，首先，通过闭包，保持了 target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this。\n\n不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 绑定到一个新对象，而不是 obj\nconst testObj = test.bind({});\ntest.apply(obj);    // true\n\n// 期望 this 是 obj，即输出 true\n// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\ntestObj.apply(obj); // false\n```\n\n## 箭头函数 \n{% note info %}\n箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对`this`的词法解析。\n在箭头函数出现之前，每个新定义的函数都有其自己的`this`值（例如，构造函数的`this`指向了一个新的对象；严格模式下的函数的`this`值为 undefined；如果函数是作为对象的方法被调用的，则其`this`指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。\n{% endnote %}\n\n### ES6 的箭头函数 ()=>，指向与一般function定义的函数不同，比较容易绕晕，箭头函数`this`的定义：箭头函数中的`this`是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的`this`，它的`this`是派生而来的。箭头函数会捕获其所在上下文的`this`值，作为自己的`this`值，即指向所在上下文的执行环境(直接外层函数)。\n\n### 基础语法\n```javascript\n// 等价于: => { return expression; } \n(param1, param2, …, paramN) => { statements }\n(param1, param2, …, paramN) => expression\n\n// 如果只有一个参数，圆括号是可选的:\n(singleParam) => { statements }\nsingleParam => { statements }\n\n// 无参数或者多参数的箭头函数需要使用圆括号或者下划线:\n() => { statements } _ => { statements }\n```\n### 高级语法\n```javascript\n// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:\nparams => ({foo: bar})\n\n// 支持 Rest parameters 和 default parameters:\n(param1, param2, ...rest) => { statements }\n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }\n\n// 支持参数列表中的解构赋值\nvar f = ([a, b] = [1, 2], c=3 ) => a + b + c;\nf(); // 6\n```\n\n### 箭头函数不可以使用arguments对象，\narguments对象在函数体内不存在，如果要用的话，可以用rest参数代替\n\n### 箭头函数没有原型\n```javascript\nvar Foo = () => {};\n\nconsole.log(Foo.prototype); // undefined\n```\n### 箭头函数无法构造函数\n```javascript\nvar Foo = () => {};\n\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n### 箭头函数无法使用yield\nyield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。\n\n### 箭头函数或者组件上绑定事件的时候this.xxx.bind(this)，这样会生成新函数，推荐constructor里bind() garbage collection(垃圾回收机制)，除非使用purecomponent只进行浅比较。\n","tags":["this指向"],"categories":["JS"]},{"title":"react面试题记录","url":"%2FreactInterview.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/reactInterview.jpeg , reactInterview, React%}\n---\n<!-- more -->\n\n## React面试问题\n下面是一个常用的关于 React 的面试问题列表：\n\n#### React 的工作原理\nReact 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diff\" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用`diff`的结果来更新真实DOM。虚拟DOM作为一种缓存机制优化了UI渲染减少昂贵的DOM变化的数量。\n\n#### 使用 React 有何优点\n* 只需查看 `render` 函数就会很容易知道一个组件是如何被渲染的\n* JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的\n* 支持服务端渲染，这可以改进 SEO 和性能\n* 易于测试\n* React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用\n\n#### 展示组件(Presentational component)和容器组件(Container component)之间有何不同\n展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\n\n容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 `Flux actions`，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。\n\n#### 类组件(Class component)和函数式组件(Functional component)之间有何不同\n* 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 `store` 并维持状态\n* 当组件仅是接收 `props`，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n\n#### (组件的)状态(state)和属性(props)之间有何不同\n`State` 是一种数据结构，用于组件挂载时所需数据的默认值。`State` 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\n\n`Props`(properties 的简写)则是组件的配置。`props` 由父组件传递给子组件，并且就子组件而言，`props` 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\n\n#### 指出(组件)生命周期方法的不同\n* `componentWillMount` -- 多用于根组件中的应用程序配置\n* `componentDidMount` -- 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成\n* `componentWillReceiveProps` -- 这个周期函数作用于特定的 prop 改变导致的 state 转换\n* `shouldComponentUpdate` -- 如果你担心组件过度渲染，`shouldComponentUpdate` 是一个改善性能的地方，因为如果组件接收了新的 `prop`， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染\n* `componentWillUpdate` -- 很少使用。它可以用于代替组件的 `componentWillReceiveProps` 和 `shouldComponentUpdate`(但不能访问之前的 props)\n* `componentDidUpdate` -- 常用于更新 DOM，响应 prop 或 state 的改变\n* `componentWillUnmount` -- 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器\n\n#### 应该在 React 组件的何处发起 Ajax 请求\n在 React 组件中，应该在 `componentDidMount` 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 `componentDidMount` 中发起网络请求将保证这有一个组件可以更新了。\n\n#### 何为受控组件(controlled component)\n在 HTML 中，类似 `<input>`, `<textarea>` 和 `<select>` 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 `onChange` 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。\n\n#### 在 React 中，refs 的作用是什么\nRefs 可以用于获取一个 DOM 节点或者 React 组件(组件实例)的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。\n\n#### 何为高阶组件(higher order component)\n高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 `connect` 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\n装饰器@decoration\n练习\n\n<hr />\n\n* 写一个反转其输入的 HOC\n* 写一个从 API 提供数据给传入的组件的 HOC\n* 写一个实现 shouldComponentUpdate 来避免 reconciliation 的 HOC\n* 写一个通过 `React.Children.toArray` 对传入组件的子组件进行排序的 HOC\n\n#### 使用箭头函数(arrow functions)的优点是什么\n* 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 `this` 值(在构造函数中是新对象；在严格模式下，函数调用中的 `this` 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 `this` 值。\n* 简单：箭头函数易于阅读和书写\n* 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 `this` 的值\n\n#### 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象\n因为 `this.props` 和 `this.state` 的更新可能是异步的，不能依赖它们的值去计算下一个 state。setState在生命周期里是异步的，第二个参数是组件重新渲染完成后的回调。\n\n#### 除了在构造函数中绑定 `this`，还有其它方式吗\n你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\n\n#### 怎么阻止组件的渲染\n在组件的 `render` 方法中返回 `null` 并不会影响触发组件的生命周期方法\n\n#### 当渲染一个列表时，何为 key？设置 key 的目的是什么\nKeys 会有助于 React 识别哪些 `items` 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 `items` 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 `items` 可以重新排序，就会导致 `re-render` 变慢。在map遍历是能唯一地标识元素item，时的处理列表更加高效。\n\n#### (在构造函数中)调用 super(props) 的目的是什么\n在 `super()` 被调用之前，子类是不能使用 `this` 的，在 ES2015 中，子类必须在 `constructor` 中调用 `super()`。传递 `props` 给 `super()` 的原因则是便于(在子类中)能在 `constructor` 访问 `this.props`。\n\n#### 何为 JSX\nJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就编程了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。\n\n#### 怎么用 React.createElement 重写下面的代码\n\nQuestion：\n\n```js\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n\nAnswer：\n\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n#### 何为 `Children`\n在JSX表达式中，一个开始标签(比如`<a>`)和一个关闭标签(比如`</a>`)之间的内容会作为一个特殊的属性`props.children`被自动传递给包含着它的组件。\n\n这个属性有许多可用的方法，包括 `React.Children.map`，`React.Children.forEach`， `React.Children.count`， `React.Children.only`，`React.Children.toArray`。\n\n#### 在 React 中，何为 state\nState 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。\n\n#### 你为何排斥 create-react-app\n在你排斥之前，你并不能去配置 webpack 或 babel presets。\n\n#### 何为 redux\nRedux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。\n\n#### 在 Redux 中，何为 store\nStore 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：\n\n* 允许通过 `getState()` 访问 state\n* 运行通过 `dispatch(action)` 改变 state\n* 通过 `subscribe(listener)` 注册 listeners\n* 通过 `subscribe(listener)` 返回的函数处理 listeners 的注销\n\n#### 何为 action\nActions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。\n\n#### 何为 reducer\n一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。\n\n#### Redux Thunk 的作用是什么\nRedux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。\n\n#### 何为纯函数(pure function)\n一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。\n\n#### redux有哪些中间件，作用？\n中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。\n\nredux-logger：提供日志输出\n\nredux-thunk：处理异步操作\n\nredux-promise：处理异步操作，actionCreator的返回值是promise\n\n#### 示例项目\n* [React Spotify](https://github.com/Pau1fitz/react-spotify)\n* [React Soundcloud](https://github.com/andrewngu/sound-redux)\n\n#### 虚拟dom 普通的js对象\n虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。具体实现步骤如下：用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。插入新组件有了key可以帮助react找到映射。\n\n#### 事件委托\n每个setState重新渲染整个子树标记为dirty。 如果要压缩性能，请尽可能调用 setState，并使用shouldComponentUpdate 来防止重新渲染大型子树。把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的key属性，方便比较。pureComponent(浅比较)+immutable 替换成preact\n\n#### diff算法 \n把树形结构按照层级分解，只比较同级元素。\n\n给列表结构的每个单元添加唯一的key属性，方便比较。\n\nReact 只会匹配相同 class 的 component（这里面的class指的是组件的名字）\n\n合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\n\n选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。\n\ndiff的只是html tag，并没有diff数据。\n\n#### setState的理解\n- setState 只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。\n- setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。\n- setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。\n\n#### 替换的属性\n\n- class/className for/htmlFor\n\n#### 插入html文本\n```javascript\ndangerouslySetInnerHTML={{__html: content}}\n```","tags":["面试"],"categories":["JS"]},{"title":"搭建VPS科学上网","url":"%2FscienceInternet.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/shadowsocks.jpg, Shadowsocks, Shadowsocks %}\n---\n<!-- more -->\n\n{% note info %}\n\n快速搭建Shadowsocks\n\n{% endnote %}\n\n## [购买Vultr服务器](https://www.vultr.com/)\n\n### Vultr服务器价格\n\nVultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题。\n\n最低价格的服务器是512M的内存，每个月500G的流量，只能说99%的情况下完全够用了！\n\n![introduce](http://p33v4b0bc.bkt.clouddn.com/vultr.png)\n\n## 买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令\n\n```javascript\n\nwget --no-check-certificate -O shadowsocks.sh\nhttps://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n \nchmod +x shadowsocks.sh\n \n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n\n```\n\n接着按照提示输入密码，端口和加密方式，如下图：\n\n![ss1](http://p33v4b0bc.bkt.clouddn.com/ss1.png)\n\n![ss2](http://p33v4b0bc.bkt.clouddn.com/ss1.png)\n\n然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息。\n\n## 安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。\n\nWindows客户端(代理端口默认1080)\nhttps://github.com/shadowsocks/shadowsocks-windows/releases\n\nUbuntu \nsudo add-apt-repository ppa:hzwhuang/ss-qt5 \nsudo apt-get update \nsudo apt-get install shadowsocks-qt5\n\nMac客户端(代理端口默认1086)\n\nhttps://github.com/shadowsocks/ShadowsocksX-NG/releases\n\nAndroid客户端\n\nhttps://github.com/shadowsocks/shadowsocks-android/releases","tags":["vultr"],"categories":["工具"]},{"title":"Promise诞生记","url":"%2FcreatePromise.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/promise.png, Promise, Promise %}\n\n前端近年的兴起，有大部分是因为 `NodeJS` 的诞生，而 `NodeJS` 是个适用于 **异步IO** 密集型的语言，一些基于 `NodeJS` 的框架，比如 *KOA2、Adonis* 就有大量的 `async` 和 `await` 语法，`async`的函数的返回值就是 `Promise` 对象，我们可以用 `async` 和 `await` 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。\n\n## Promise 概念\n`Promise`是一种对异步操作的封装，主流的规范是Promise/A+。\n`Promise`可以使得异步代码层次清晰，便于理解，且更加容易维护。\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n生成实例时回执信作为参数的函数；<Br/> \n`resolve`函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n`reject`函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n---\n<!-- more -->\n\n```javascript\n// 执行顺序\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise'); // 新建后立即执行\n  resolve();\n  console.log(111)\n  return 0\n});\npromise.then(function() {\n  console.log('resolved.'); // 同步任务执行完成后才会执行\n});\nconsole.log('Hi!');\n// Promise\n// 111\n// Hi!\n// resolved\n```\n接下来我们就用`Promise`结合ajax来使用\n```\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send(params);\n  });\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n这里我们会渐进式的来创建一个 `Promise` 的实现，如果，你还不了解 `Promise` ，赶快移步 [Promise](http://es6.ruanyifeng.com/#docs/promise) 了解学习，当然这个实现会符合 [Promise/A+](https://promisesaplus.com) 规范，`JavaScript` 中有很多第三方的 `Promise` 库，[bluebird](http://bluebirdjs.com/docs/getting-started.html) 就是一个第三方 `Promise` 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。\n\n---\n\n废话不多说，直接开干。。。 😠\n\n## 定义 Promise 类型\n\n一个简单 `Promise` 语法，如下\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... doSomething\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure 第二个函数可选\n});\n```\n\n### 实现 resolve 和 then\n\n首先我们以上 👆 的语法，自己定义一个 `Promise` 实例\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    callback(value);\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n一个简单的实例写好了，然后，来用一下，看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n\n```\n{% note info %}\n\n执行结果是：`callback is not a function`\n\n{% endnote %}\n\n### 改进1：延时resolve，修改 callback 为异步\n\n**这里就遇到一个问题： **  \n\n** 目前的Promise有一个bug，假如fn中所包含的是同步代码，则resolve会立即执行，`callback` 还是 `null` ，我们的代码是同步的，而不是异步的。</br> 如是，想办法解决掉这个问题，就是利用 `setTimeout` , 把 `callback` 加入异步队列** \n\n代码如下 👇\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    // 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法\n    setTimeout(function(){\n      callback(value);\n    },0)\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n\n### 改进2：注册多个回调函数，并实现then的链式调用\n\n```javascript\nfunction Promise(fn) {\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    callbackList.push(cb);\n    // 实现链式调用\n    return this\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       // 遍历callbackList数组依次执行\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n### 改进3：引入状态\n\n```javascript\nfunction Promise(fn) {\n  let state='pending'\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    if(state=='pending'){\n      // pending加入队列\n      callbackList.push(cb);\n      return this\n    }\n    if(state=='fulfilled'){\n      // fulfilled立即执行\n      cb(value)\n      return this\n    }\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n\n**手动实现一个Promise：**\n```javascript\nclass Promise(){\n  construtor(fn){\n       // 执行队列\n       this._wathcList=[]\n       // 成功\n       this._success_res=null\n       // 失败\n       this._error_res=null\n       this._status=\"success\"\n       fn((...args))=>{\n          // 保存成功数据\n          this._success_res=args\n          this._status='success'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn1(...args);\n          });\n       },(...args)=>{\n          // 保存失败数据\n          this._error_res=args\n          this._status='error'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn2(...args);\n          });\n       }\n  }\n  // then 函数\n  then(fn1, fn2) {\n      if (this._status === \"success\") {\n          fn1(...this._success_res);\n      } else if (this._status === \"error\") {\n          fn2(...this._error_res);\n      } else {\n          this._watchList.push({\n              fn1,\n              fn2\n          })\n      }\n  }\n}\n```\n**实现Promise.all**\n```javascript\nPromise1.all = function(arr) {\n    // 存放结果集\n    let result = [];\n    return Promise1(function(resolve, reject) {\n        let i = 0;\n        // 进行迭代执行\n        function next() {\n            arr[i].then(function(res) {\n                // 存放每个方法的返回值\n                result.push(res);\n                i++;\n                // 若全部执行完\n                if (i === result.length) {\n                    // 执行then回调\n                    resolve(result);\n                } else {\n                    // 继续迭代\n                    next();\n                }\n            }, reject)\n        }\n    })\n}\n```\n### 嵌套使用\nPromise可以嵌套使用，这样可以是多个任务有条不紊地进行，假设p1是一个Promise对象而p2、p3都是能够产生Promise对象的方法(如果直接new那么Promise将会被直接执行)，那么你可以这样写，使得他们按照顺序执行，并且可以一次性处理他们产生的错误。\n\n```javascript\nlet p1 = new Promise((resolve, reject) => {\n    console.log('p1');\n    setTimeout(() => {\n        resolve('p2');\n    }, 1000)\n});\n\nlet p2 = (result) => new Promise((resolve, reject) => {\n    console.log(result);\n    setTimeout(() => {\n        resolve('p3');\n    }, 2000);\n});\n\nlet p3 = (result) => new Promise((resolve, reject) => {\n    console.log(result);\n    setTimeout(() => {\n        resolve('over');\n    }, 3000);\n});\n\np1\n    .then(p2)\n    .then(p3)\n    .then((result) => {\n        console.log(result);\n    })\n    .catch((error) => {\n        console.log(error);\n    });\n```\n\n## Promise使用注意点\n1. 一般来说，调用`resolve`或`reject`以后，`Promise`的使命就完成了，后继操作应该放到`then`方法里面，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。\n\n2. `Promise`实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为`Promise`实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即then方法后面再调用另一个`then`方法。\n\n3. `Promise.prototype.catch`方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。`getJSON`方法返回一个`Promise`对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n4. 一般来说，不要在then方法里面定义`reject`状态的回调函数（即then的第二个参数），总是使用`catch`方法。\n\n5. 跟传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应，`Promise`会吃掉错误。\n","tags":["Promise"],"categories":["JS"]},{"title":"如何使用 markdown 语法写博客","url":"%2FmarkdownGrammar.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/markdown.png, Markdown, Markdown %}\n\n# 标题1\n## 标题2\n*斜体*\n**粗体**\n***粗斜体***<br/>\n~~删除线~~\n<u>下划线文本</u>\n\n1. I\n2. Love \n3. You\n\n- 点\n\n+ Foo\n+ Bar\n---\n<!-- more -->\n\n分隔线\n***\n--- \n___\n\n* * *\n>一级引用\n>>二级引用\n\n`#include<iostream>`\n```\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n```\n~~~\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n~~~\n|标题|标题|标题|\n|:---|:---:|---:|\n|居左测试文本|居中测试文本|居右测试文本|\n|居左测试文本1|居中测试文本2|居右测试文本3|\n|居左测试文本11|居中测试文本22|居右测试文本33|\n|居左测试文本111|居中测试文本222|居右测试文本333|\n\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n### 反斜杠\n\n`Markdown` 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n```\n\\*literal asterisks\\*\n```\n效果如下：\n\n\\*literal asterisks\\*\n\n`Markdown` 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```\n  \\   反斜线\n  `   反引号\n  *   星号\n  _   底线\n  {}  花括号\n  []  方括号\n  ()  括弧\n  #   井字号\n  +   加号\n  -   减号\n  .   英文句点\n  !   惊叹号\n```\n登录[百度](http://www.baidu.com)\n![Teddy Bear](http://img2.everychina.com/img/d7/f7/1b580dfa9315111397ef93fd24ea-250x250c1-77f7/love_valentine_plush_teddy_bear.jpg)\n","tags":["markdown"],"categories":["工具"]},{"title":"Hello World - 热爱编程的普通人，顺便以此为生。","url":"%2Fhello-world.html","content":"\n之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n---\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["吐槽"],"categories":["杂谈"]}]