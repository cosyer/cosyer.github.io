<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>cosyer&#39;s Blog</title>
    <link>http://mydearest.cn/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>陈宇的博客</description>
    <pubDate>Tue, 12 Jun 2018 13:43:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JavaScript深入之作用域</title>
      <link>http://mydearest.cn/scope.html</link>
      <guid>http://mydearest.cn/scope.html</guid>
      <pubDate>Tue, 12 Jun 2018 13:43:41 GMT</pubDate>
      <description>
      
      </description>
      
      <comments>http://mydearest.cn/scope.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript深入之从原型到原型链</title>
      <link>http://mydearest.cn/prototype.html</link>
      <guid>http://mydearest.cn/prototype.html</guid>
      <pubDate>Tue, 12 Jun 2018 11:47:24 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;构造函数创建对象&quot;&gt;&lt;a href=&quot;#构造函数创建对象&quot; class=&quot;headerlink&quot; title=&quot;构造函数创建对象&quot;&gt;&lt;/a&gt;构造函数创建对象&lt;/h2&gt;&lt;p&gt;我们先使用构造函数创建一个对象：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&quot;cosyer&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person.name); &lt;span class=&quot;comment&quot;&gt;// cosyer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><p>我们先使用构造函数创建一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">person.name = <span class="string">"cosyer"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure><p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p><hr><a id="more"></a><p>很简单吧，接下来进入正题：</p><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// prototype是函数才会有的属性</span></span><br><span class="line">Person.prototype.name = <span class="string">"cosyer"</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// cosyer</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure><p>那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？</p><p>其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。</p><p>那什么是原型呢？你可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p><p>让我们用一张图表示构造函数和实例原型之间的关系：<img src="http://p33v4b0bc.bkt.clouddn.com/prototype1.png" alt="prototype"></p><p>在这张图中我们用 Object.prototype 表示实例原型。</p><p>那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：</p><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>为了证明这一点,我们可以在火狐或者谷歌中输入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>于是我们更新下关系图：<img src="http://p33v4b0bc.bkt.clouddn.com/prototype2.png" alt="prototype"></p><p>既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p><p>为了验证这一点，我们可以尝试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以再更新下关系图：<img src="http://p33v4b0bc.bkt.clouddn.com/prototype3.png" alt="prototype">综上我们可以得出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ == Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == Person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 顺便学习一个ES5的方法,可以获得对象的原型 实例原型的constructor指向构造函数,构造函数的prototype指向实例原型,实例对象的__proto__指向实例原型,实例原型也是对象,它也有原型 最后的一个环节是null。访问实例对象的constructor时,也能从实例原型上去找,从而指向到构造函数。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"cosyer"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"Daisy"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Daisy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。</p><p>但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 cosyer。</p><p>但是万一还没有找到呢？原型的原型又是什么呢？</p><h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">"cosyer"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure><p>其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 <strong>proto</strong> 指向构造函数的 prototype ，所以我们再更新下关系图：<img src="http://p33v4b0bc.bkt.clouddn.com/prototype4.png" alt="prototype"></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>那 Object.prototype 的原型呢？</p><p>null，我们可以打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>然而 null 究竟代表了什么呢？</p><p>引用阮一峰老师的 《undefined 与 null 的区别》 就是：</p><p>null 表示“没有对象”，即该处不应该有值。</p><p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p><p>所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p><p>最后一张关系图也可以更新为：<img src="http://p33v4b0bc.bkt.clouddn.com/prototype5.png" alt="prototype"></p><p>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="constructor"><a href="#constructor" class="headerlink" title="constructor"></a>constructor</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.constructor === Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.constructor === Person.prototype.constructor;</span><br></pre></td></tr></table></figure><h3 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>其次是 <strong>proto</strong> ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p><ul><li>class 的引入只是语法糖本身还是基于原型的</li><li>几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line"><span class="comment">// p是一个继承自 o 的对象</span></span><br><span class="line">对象的原型链</span><br><span class="line">o===&gt;<span class="built_in">Object</span>.prototype===&gt;<span class="literal">null</span></span><br><span class="line">数组的原型链</span><br><span class="line">a===&gt;<span class="built_in">Array</span>.prototype===&gt;<span class="built_in">Object</span>.prototype===&gt;<span class="literal">null</span></span><br><span class="line">函数的原型链</span><br><span class="line">f===&gt;<span class="built_in">Function</span>.prototype===&gt;<span class="built_in">Object</span>.prototype===&gt;<span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="new-操作符具体干了什么"><a href="#new-操作符具体干了什么" class="headerlink" title="new 操作符具体干了什么"></a>new 操作符具体干了什么</h3><p>1.创建空对象，并且this变量引用该对象同时继承该函数的原型2.属性和方法加入到this引用的对象中3.新创建的对象用this引用，并且隐式地返回this</p><ul><li>es5使用Object.create()来创建对象 new {}使用Object.create()是将对象继承到<strong>proto</strong>属性上，Object.create(null)没有继承任何原型方法，也就是说它的原型链没有上一层。</li><li><p>es6使用class关键字</p></li><li><p>构造器就是普通的函数,new来作用称为构造方法(构造函数)</p></li><li><p>访问原型链会损耗性能,不存在的属性会遍历原型链直到最后一层</p></li><li><p>hasOwnProperty 是 JavaScript 中唯一处理属性并且不会遍历原型链的方法。</p></li></ul>]]></content:encoded>
      
      <comments>http://mydearest.cn/prototype.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>你所不知道的前端冷门小知识(长期更新)</title>
      <link>http://mydearest.cn/smallknowledge.html</link>
      <guid>http://mydearest.cn/smallknowledge.html</guid>
      <pubDate>Mon, 11 Jun 2018 13:55:52 GMT</pubDate>
      <description>
      
        &lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<hr><a id="more"></a><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>void其实是javascript中的一个函数，接受一个参数，返回值永远是undefined<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">0</span>  </span><br><span class="line"><span class="keyword">void</span> (<span class="number">0</span>)  </span><br><span class="line"><span class="keyword">void</span> <span class="string">"hello"</span>  </span><br><span class="line"><span class="keyword">void</span> (<span class="keyword">new</span> <span class="built_in">Date</span>())  </span><br><span class="line"><span class="comment">// all will return undefined  </span></span><br><span class="line">context == <span class="keyword">void</span> <span class="number">666</span></span><br></pre></td></tr></table></figure></p><h2 id="Element-scrollIntoViewIfNeeded"><a href="#Element-scrollIntoViewIfNeeded" class="headerlink" title="Element.scrollIntoViewIfNeeded"></a>Element.scrollIntoViewIfNeeded</h2><p> Element.scrollIntoViewIfNeeded（）方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.scrollIntoViewIfNeeded(); <span class="comment">// 等同于element.scrollIntoViewIfNeeded(true) </span></span><br><span class="line">element.scrollIntoViewIfNeeded(<span class="literal">true</span>); </span><br><span class="line">element.scrollIntoViewIfNeeded(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><ul><li>当元素已经在可视区域时，调用 Element.scrollIntoView()，无论设置什么参数，均发生滚动。</li><li>当元素已经在可视区域时，调用 Element.scrollIntoViewIfNeeded()，无论设置什么参数，均不发生滚动。</li></ul><h2 id="JS取整"><a href="#JS取整" class="headerlink" title="JS取整"></a>JS取整</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="number">2.5</span> <span class="comment">// 2 按位取反 -2^31~2^31-1 -2147483648~2147483647</span></span><br><span class="line"><span class="number">0</span>|<span class="number">3.123</span>;<span class="comment">// 3 或运算</span></span><br><span class="line"><span class="number">4.3</span>|<span class="number">0</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="number">4.3</span>&lt;&lt;<span class="number">0</span>; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>与Math.floor()的对比</p><table><thead><tr><th style="text-align:left">区别</th><th style="text-align:center">Math.floor</th><th style="text-align:right">~~</th></tr></thead><tbody><tr><td style="text-align:left">NaN</td><td style="text-align:center">NaN</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">+0</td><td style="text-align:center">+0</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">-0</td><td style="text-align:center">-0</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">+Infinity</td><td style="text-align:center">+Infinity</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">-Infinity</td><td style="text-align:center">-Infinity</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">1.2</td><td style="text-align:center">1.2</td><td style="text-align:right">1.2</td></tr><tr><td style="text-align:left">-1.2</td><td style="text-align:center">-1</td><td style="text-align:right">-1</td></tr></tbody></table><ol><li><p>位运算：~ 的结果是 int32 的有符号整数，所以肯定不可能是 NaN 和无穷，因此 1、4、5 两者不同。x|0  x&lt;&lt;0</p></li><li><p>Math.floor 向 +∞ 取整。</p></li><li><p>parseInt(string, radix);</p></li></ol><p>parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</p><p>parseInt 解析字符串 ‘-0’ 会得到 -0。如果参数是数字 -0，会得到 0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000000003</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'2017-07-04'</span>) <span class="comment">// 2017</span></span><br></pre></td></tr></table></figure><h2 id="全等判断"><a href="#全等判断" class="headerlink" title="全等判断"></a>全等判断</h2><p>javascript 中 +0 完全等于 -0，那么怎么分区两者呢？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">0</span> === <span class="number">1</span>/<span class="number">-0</span> <span class="comment">// false </span></span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>,<span class="number">-0</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>区分NaN<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> !== <span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false </span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h2 id="try-catch跳出forEach循环"><a href="#try-catch跳出forEach循环" class="headerlink" title="try-catch跳出forEach循环"></a>try-catch跳出forEach循环</h2><p>forEach遍历不能保证遍历的顺序，以及不能break;一般for循环的性能是forEach的20倍<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (v === <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'my err'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.message === <span class="string">'my err'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'breaked'</span>) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用some也可以做到[1,2,3].some((item)=&gt;{  return item === 2 // 如果item等于2就跳出循环})</p><h2 id="fetch模拟post进行api测试"><a href="#fetch模拟post进行api测试" class="headerlink" title="fetch模拟post进行api测试"></a>fetch模拟post进行api测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(apiUrl, &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">q</span>: <span class="number">1</span>&#125;)</span><br><span class="line">&#125;).then(<span class="keyword">async</span> res =&gt; <span class="built_in">console</span>.log(<span class="keyword">await</span> res.json()))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://mydearest.cn/smallknowledge.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>快速了解React 16新特性</title>
      <link>http://mydearest.cn/react16.html</link>
      <guid>http://mydearest.cn/react16.html</guid>
      <pubDate>Mon, 11 Jun 2018 12:09:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Error-Boundary&quot;&gt;&lt;a href=&quot;#Error-Boundary&quot; class=&quot;headerlink&quot; title=&quot;Error Boundary&quot;&gt;&lt;/a&gt;Error Boundary&lt;/h2&gt;&lt;p&gt;Error Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Error-Boundary"><a href="#Error-Boundary" class="headerlink" title="Error Boundary"></a>Error Boundary</h2><p>Error Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）</p><hr><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最佳实践：将ErrorBoundary抽象为一个公用的组件类</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidCatch(err, info) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">//sendErrorReport(err,info)</span></span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state.hasError)&#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;div&gt;Something went wrong!&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方式 包裹容易出错的组件</span></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ErrorBoundary&gt;</span><br><span class="line">        &lt;Profile user=&#123;<span class="keyword">this</span>.state.user&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;this.onClick&#125;&gt;Update&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="render方法新增返回类型"><a href="#render方法新增返回类型" class="headerlink" title="render方法新增返回类型"></a>render方法新增返回类型</h2><p>在React 16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string</span></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello,world'</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//number</span></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">12345</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//boolean</span></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> isTrue?<span class="literal">true</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//null</span></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//fragments，未加key标识符，控制台会出现warning</span></span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &lt;div&gt;hello&lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;world&lt;/</span>span&gt;,</span><br><span class="line">    &lt;p&gt;oh&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  ]</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>以上各种类型现在均可以直接在render中返回，不需要再在外层包裹一层容器元素，不过在返回的数组类型中，需要在每个元素上加一个唯一且不变的key值，否则控制台会报一个warning。</p><h2 id="使用createPortal将组件渲染到当前组件树之外"><a href="#使用createPortal将组件渲染到当前组件树之外" class="headerlink" title="使用createPortal将组件渲染到当前组件树之外"></a>使用createPortal将组件渲染到当前组件树之外</h2><h2 id="支持自定义DOM属性"><a href="#支持自定义DOM属性" class="headerlink" title="支持自定义DOM属性"></a>支持自定义DOM属性</h2><p>在之前的版本中，React会忽略无法识别的HTML和SVG属性，自定义属性只能通过data-*形式添加，现在它会把这些属性直接传递给DOM（这个改动让React可以去掉属性白名单，从而减少了文件大小）。</p><h2 id="setState传入null时不会再触发更新"><a href="#setState传入null时不会再触发更新" class="headerlink" title="setState传入null时不会再触发更新"></a>setState传入null时不会再触发更新</h2><h2 id="更好的服务器端渲染"><a href="#更好的服务器端渲染" class="headerlink" title="更好的服务器端渲染"></a>更好的服务器端渲染</h2><p>React 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。</p><h2 id="新的打包策略"><a href="#新的打包策略" class="headerlink" title="新的打包策略"></a>新的打包策略</h2><p>新的打包策略中去掉了process.env检查。React 16的体积比上个版本减小了32%（30% post-gzip），文件尺寸的减小一部分要归功于打包方法的改变。</p><h2 id="React-16采用了新的核心架构React-Fiber。官方解释是“React-Fiber是对核心算法的一次重新实现”"><a href="#React-16采用了新的核心架构React-Fiber。官方解释是“React-Fiber是对核心算法的一次重新实现”" class="headerlink" title="React 16采用了新的核心架构React Fiber。官方解释是“React Fiber是对核心算法的一次重新实现”"></a>React 16采用了新的核心架构React Fiber。官方解释是“React Fiber是对核心算法的一次重新实现”</h2>]]></content:encoded>
      
      <comments>http://mydearest.cn/react16.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>React 16新特性context api</title>
      <link>http://mydearest.cn/contextapi.html</link>
      <guid>http://mydearest.cn/contextapi.html</guid>
      <pubDate>Mon, 11 Jun 2018 09:19:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;React 16.3带来了正式版的context API。让我们来看看有哪些改变，在那些地方可以取代redux吧！&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>React 16.3带来了正式版的context API。让我们来看看有哪些改变，在那些地方可以取代redux吧！</p><hr><a id="more"></a><p>我当前依赖的版本<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"react"</span>: <span class="string">"^16.4.0"</span>,</span><br><span class="line">    <span class="string">"react-dom"</span>: <span class="string">"^16.4.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="创建context实例"><a href="#创建context实例" class="headerlink" title="创建context实例"></a>创建context实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建context实例</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(&#123;</span><br><span class="line">  background: <span class="string">'red'</span>,</span><br><span class="line">  color: <span class="string">'white'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;Provider,Consumer&#125; = ThemeContext</span><br></pre></td></tr></table></figure><h2 id="Provider-组件"><a href="#Provider-组件" class="headerlink" title="Provider 组件"></a>Provider 组件</h2><p><strong>Provider组件用于将context数据传给该组件树下的所有组件 value属性是context的内容。</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;&#123; <span class="attr">text</span>: <span class="string">'hello react!'</span> &#125;&#125;&gt;</span><br><span class="line">        &lt;Comp1 /&gt;</span><br><span class="line">        &lt;Comp2 /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="Consumer-组件"><a href="#Consumer-组件" class="headerlink" title="Consumer 组件"></a>Consumer 组件</h2><p><strong>Consumer消费Provider传递的数据</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="keyword">const</span> Comp1 = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Consumer&gt;</span><br><span class="line">    &#123;context =&gt; &lt;p&gt;&#123;context.text&#125;&lt;/p&gt;&#125;</span><br><span class="line">  &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 类</span></span><br><span class="line"><span class="regexp">class Comp2 extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Consumer&gt;</span></span><br><span class="line"><span class="regexp">        &#123;context =&gt; &lt;p&gt;&#123;context.text&#125;&lt;/</span>p&gt;&#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>如果你没有将Consumer作为Provider的子组件，那么Consumer将使用创建context时的参数作为context。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/contextapi.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何理解JS闭包</title>
      <link>http://mydearest.cn/closure.html</link>
      <guid>http://mydearest.cn/closure.html</guid>
      <pubDate>Sun, 10 Jun 2018 18:24:51 GMT</pubDate>
      <description>
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。&lt;/p&gt;
&lt;/blockquote&gt; 
&lt;h2 id=&quot;在JS中函数作为普通对象进行传递&quot;&gt;&lt;a href=&quot;#在JS中函数作为普通对象进行传递&quot; class=&quot;headerlink&quot; title=&quot;在JS中函数作为普通对象进行传递&quot;&gt;&lt;/a&gt;在JS中函数作为普通对象进行传递&lt;/h2&gt;
      
      </description>
      
      <content:encoded><![CDATA[<blockquote class="blockquote-center"><p>JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。</p></blockquote> <h2 id="在JS中函数作为普通对象进行传递"><a href="#在JS中函数作为普通对象进行传递" class="headerlink" title="在JS中函数作为普通对象进行传递"></a>在JS中函数作为普通对象进行传递</h2><a id="more"></a><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包?"></a>什么是闭包?</h2><p>简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。(函数和声明该函数的词法环境的组合)</p><h2 id="为什么需要闭包？"><a href="#为什么需要闭包？" class="headerlink" title="为什么需要闭包？"></a>为什么需要闭包？</h2><p>使用闭包主要是为了设计私有的变量和方法。闭包的优点可以避免全局变量的污染，缺点是会常驻内存，增大内存的使用量，使用不当会造成内存泄漏。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>定义外层函数，封装被保护的局部变量。 </li><li>定义内层函数，执行对外部函数变量的操作。 </li><li>外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>函数嵌套函数，内存函数被返回。</li><li>函数内部可以引用外部的参数和变量。</li><li>参数和变量不会被垃圾回收机制回收。</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line">add();</span><br><span class="line"><span class="comment">// add()调用过后应当销毁其变量，但其内层函数被返回了，并且还保留着对变量的引用，所以没有销毁还保留在内存当中。</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印3次3 执行setTimeout时for循环已经结束此时的i的值为3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="comment">// 匿名闭包</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[index])</span><br><span class="line">&#125;,index*<span class="number">1000</span>)</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免使用过多的闭包，可以用let关键词，每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/closure.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 Async/Await 让你的代码更简洁</title>
      <link>http://mydearest.cn/es7async.html</link>
      <guid>http://mydearest.cn/es7async.html</guid>
      <pubDate>Sun, 10 Jun 2018 17:30:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;Async/Await是一种允许我们像构建没有回调函数的普通函数一样构建Promise的新语法。以往的异步方法无外乎回调函数和&lt;code&gt;Promise&lt;/code&gt;。但是Async/Await建立于&lt;a href=&quot;https://mydearest.cn/createPromise.html&quot;&gt;Promise&lt;/a&gt;之上。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Async/Await是一种允许我们像构建没有回调函数的普通函数一样构建Promise的新语法。以往的异步方法无外乎回调函数和<code>Promise</code>。但是Async/Await建立于<a href="https://mydearest.cn/createPromise.html">Promise</a>之上。</p><hr><a id="more"></a><h2 id="Async-Await语法"><a href="#Async-Await语法" class="headerlink" title="Async/Await语法"></a>Async/Await语法</h2><h3 id="async关键字-放置在一个函数前面-。"><a href="#async关键字-放置在一个函数前面-。" class="headerlink" title="async关键字(放置在一个函数前面)。"></a>async关键字(放置在一个函数前面)。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">// return Promise.resolve(1)</span></span><br><span class="line">&#125;</span><br><span class="line">f().then(value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>async修饰过的函数总是返回一个promise，如果代码中有return &lt;非promise&gt;语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。</p><h3 id="await关键字-只能在async函数内部使用"><a href="#await关键字-只能在async函数内部使用" class="headerlink" title="await关键字(只能在async函数内部使用)"></a>await关键字(只能在async函数内部使用)</h3><p>关键词await可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="错误处理-使用try-catch捕获"><a href="#错误处理-使用try-catch捕获" class="headerlink" title="错误处理(使用try-catch捕获)"></a>错误处理(使用try-catch捕获)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'http://no-such-url'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        alet(err) <span class="comment">// TypeError: failed to fetch 也能捕获多行语句 类似链式Promise最后的单个catch函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br></pre></td></tr></table></figure><p>如果我们不使用try-catch，然后async函数f()的调用产生的promise变成reject状态的话，我们可以添加.catch去处理它：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'http://no-such-url'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// f()变成了一个rejected的promise</span></span><br><span class="line">f().catch(alert) <span class="comment">// TypeError: failed to fetch</span></span><br></pre></td></tr></table></figure></p><h3 id="结合Promise-all"><a href="#结合Promise-all" class="headerlink" title="结合Promise.all"></a>结合Promise.all</h3><p>async/await能够与Promise.all友好的协作，当我们需要等待多个promise时，我们可以将他们包装在Promise.all中然后使用await：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 直到数组全部返回结果</span></span><br><span class="line"><span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">   fetch(url1),</span><br><span class="line">   fetch(url2),</span><br><span class="line">   ...</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>随着单页JavaScript web程序的兴起和对NodeJS的广泛采用，如何优雅的处理并发对于JavaScript开发人员来说比任何以往的时候都显得更为重要。Async/Await缓解了许多因为控制流问题而导致bug遍地的这个困扰着JavaScript代码库数十年的问题，并且几乎可以保证让任何异步代码块变的更精炼，更简单，更自信。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/es7async.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>从 for 循环入手优化性能</title>
      <link>http://mydearest.cn/forloop.html</link>
      <guid>http://mydearest.cn/forloop.html</guid>
      <pubDate>Fri, 08 Jun 2018 12:32:57 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？</p><hr><a id="more"></a><p>从最简单的遍历数组说起。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数组arr（假设是从后台返回的数据）</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    arr.push(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想从数组 arr 中取出数据，就必须要进行遍历，普遍的做法是：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但其实这样的写法遍历是最慢的，他要经过两次迭代，第一次是 i 的迭代，每次都要判断 i 是否小于 arr.length，第二次是 arr 的迭代，每次循环 arr 都会调用底层的迭代器，对长度进行计算，这样循环的效率非常低，时间空间复杂度为 O[n^2]。</p><p>下面进行优化，看看两者到底有什么区别：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>区别就是，整个循环当中，我们预存了 len 来保存数组的长度，这样不需要每次循环都调用底层迭代器，调用一次即可，这样的时间空间复杂度为 O[n+1]。</p><p>但是这并不是最完美的，因为会多了一次迭代操作，那么该如何进行优化呢？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, item; item = arr[i++];) &#123;</span><br><span class="line">    <span class="comment">// item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这次迭代的时间空间复杂度为 O[n] ，完美做到了每次一迭代没有通过长度进行判断，而是直接通过下标进行取值的方式映射到了循环体内部。</p><p>最后用5万条数据进行测试各种方式的循环时间：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个数组arr（假设是从后台返回的数据）</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">while</span> (index &lt; <span class="number">50000</span>) &#123;</span><br><span class="line">    arr.push(index);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'one'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'two'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'two'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'three'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, item; item = arr[i++];) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'three'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6的数组遍历</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'four'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'four'</span>);</span><br><span class="line"><span class="comment">// 会访问可枚举属性和原型的遍历，数组不推荐使用</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'five'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'five'</span>);</span><br><span class="line"><span class="comment">// one: 0.711ms</span></span><br><span class="line"><span class="comment">// two: 4.508ms</span></span><br><span class="line"><span class="comment">// three: 0.006ms</span></span><br><span class="line"><span class="comment">// four: 3.255ms</span></span><br><span class="line"><span class="comment">// five: 11.144ms</span></span><br></pre></td></tr></table></figure></p><p>在数据量大的情况下，第三种循环方式效果显而易见。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/forloop.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>es6函数新特性</title>
      <link>http://mydearest.cn/es6function.html</link>
      <guid>http://mydearest.cn/es6function.html</guid>
      <pubDate>Fri, 08 Jun 2018 11:35:58 GMT</pubDate>
      <description>
      
        &lt;ol&gt;
&lt;li&gt;设置函数默认值 &lt;/li&gt;
&lt;li&gt;结合解构赋值默认值使用&lt;/li&gt;
&lt;li&gt;利用rest(…变量名)传入任意参数&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<ol><li>设置函数默认值 </li><li>结合解构赋值默认值使用</li><li>利用rest(…变量名)传入任意参数</li></ol><hr><a id="more"></a><h2 id="…rest和扩展运算符"><a href="#…rest和扩展运算符" class="headerlink" title="…rest和扩展运算符"></a>…rest和扩展运算符</h2><p>rest参数（…变量名），用于获取函数的多余参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入其中。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(y)  <span class="comment">// [1,2,3,4]</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><h2 id="利用扩展运算符（…数组）替代数组的apply方法"><a href="#利用扩展运算符（…数组）替代数组的apply方法" class="headerlink" title="利用扩展运算符（…数组）替代数组的apply方法"></a>利用扩展运算符（…数组）替代数组的apply方法</h2><p>在es5中，需要用apply将数组转化为函数参数，在es6中就不需要这种方式了，可以使用…来代替<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + <span class="string">' '</span> + y + <span class="string">' '</span> + z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// f.apply(null, args)</span></span><br><span class="line">f(...args)</span><br></pre></td></tr></table></figure></p><p>数组push的例子：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.concat(arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">//[ 0, 1, 2, 3, 4, 5 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.push(arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">//[ 0, 1, 2, [ 3, 4, 5 ] ]</span></span><br></pre></td></tr></table></figure></p><p>如果想使用arr1.push方法的话，就需要用apply传arr2了<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = <span class="built_in">Array</span>.prototype.push.apply(arr1, arr2) <span class="comment">//[ 0, 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure></p><p>如果使用扩展运算符的话，就简单一些了<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = arr1.push(...arr2)</span><br></pre></td></tr></table></figure></p><h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>函数的name属性可以返回函数名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function abc()&#123;</span><br><span class="line">    console.log(abc.name)</span><br><span class="line">&#125;</span><br><span class="line">abc() // &apos;abc&apos;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/es6function.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JavaScript 中 this 的详解</title>
      <link>http://mydearest.cn/jsthis.html</link>
      <guid>http://mydearest.cn/jsthis.html</guid>
      <pubDate>Fri, 08 Jun 2018 08:58:32 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;this-的指向&quot;&gt;&lt;a href=&quot;#this-的指向&quot; class=&quot;headerlink&quot; title=&quot;this 的指向&quot;&gt;&lt;/a&gt;this 的指向&lt;/h2&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 是 js 中定义的关键字， 它的指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。在实际应用中，&lt;code&gt;this&lt;/code&gt;的指向大致可以分为以下四种情况。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p><code>this</code> 是 js 中定义的关键字， 它的指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。在实际应用中，<code>this</code>的指向大致可以分为以下四种情况。</p><hr><a id="more"></a><h3 id="作为普通函数调用-直接调用-：函数名"><a href="#作为普通函数调用-直接调用-：函数名" class="headerlink" title="作为普通函数调用(直接调用)：函数名()"></a>作为普通函数调用(直接调用)：函数名()</h3><p>当函数作为一个普通函数被调用，<code>this</code>指向全局对象。在浏览器里，全局对象就是 window。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'cosyer'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">getName();                   <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure></p><p>可以看出，此时<code>this</code>指向了全局对象 window。(NodeJS的全部对象是global)在ECMAScript5的严格模式下，这种情况<code>this</code>已经被规定不会指向全局对象了，而是undefined。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">fun();                      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h3><p>当函数作为一个对象里的方法被调用，<code>this</code>指向该对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'cosyer'</span>,</span><br><span class="line">    getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getName();              <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure></p><p>如果把对象的方法赋值给一个变量，再调用这个变量：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fun1 : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun2 = obj.fun1;</span><br><span class="line">fun2();                     <span class="comment">// window</span></span><br></pre></td></tr></table></figure></p><p>此时调用 fun2 方法 输出了 window 对象，说明此时<code>this</code>指向了全局对象。给 fun2 赋值，其实是相当于：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，此时的<code>this</code>已经跟 obj 没有任何关系了。这时 fun2 是作为普通函数调用。</p><h3 id="作为构造函数调用"><a href="#作为构造函数调用" class="headerlink" title="作为构造函数调用"></a>作为构造函数调用</h3><p>js中没有类，但是可以从构造器中创建对象，并提供了<code>new</code>运算符来进行调用该构造器。构造器的外表跟普通函数一样，大部分的函数都可以当做构造器使用。当构造函数被调用时，<code>this</code>指向了该构造函数实例化出来的对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cosyer'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);      <span class="comment">// cosyer</span></span><br></pre></td></tr></table></figure></p><p>如果构造函数显式的返回一个对象，那么<code>this</code>则会指向该对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cosyer'</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name : <span class="string">'chenyu'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);      <span class="comment">// chenyu</span></span><br></pre></td></tr></table></figure></p><p>如果该函数不用<code>new</code>调用，当作普通函数执行，那么<code>this</code>依然指向全局对象。</p><h3 id="call-或-apply-调用-Function-prototype-bind-将当前函数绑定到指定对象绑定返回新函数之后再进行调用"><a href="#call-或-apply-调用-Function-prototype-bind-将当前函数绑定到指定对象绑定返回新函数之后再进行调用" class="headerlink" title="call() 或 apply() 调用 Function.prototype.bind()将当前函数绑定到指定对象绑定返回新函数之后再进行调用"></a>call() 或 apply() 调用 Function.prototype.bind()将当前函数绑定到指定对象绑定返回新函数之后再进行调用</h3><p>通过调用函数的 call() 或 apply() 方法可动态的改变<code>this</code>的指向。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">'cosyer'</span>,</span><br><span class="line">    getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name : <span class="string">'chenyu'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.getName();             <span class="comment">// cosyer</span></span><br><span class="line">obj1.getName.call(obj2);    <span class="comment">// chenyu</span></span><br><span class="line">obj1.getName.apply(obj2);   <span class="comment">// chenyu</span></span><br></pre></td></tr></table></figure></p><p><strong>简单的实现bind方法</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的函数，模拟 bind() 对 this 的影响</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBind</span>(<span class="params">func, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func.apply(target, <span class="built_in">arguments</span>); <span class="comment">// 第一个参数为函数运行的this指向</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testObj = myBind(test, obj);</span><br><span class="line">test();     <span class="comment">// false</span></span><br><span class="line">testObj();  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>从上面的示例可以看到，首先，通过闭包，保持了 target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this。</p><p>不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定到一个新对象，而不是 obj</span></span><br><span class="line"><span class="keyword">const</span> testObj = test.bind(&#123;&#125;);</span><br><span class="line">test.apply(obj);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望 this 是 obj，即输出 true</span></span><br><span class="line"><span class="comment">// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false</span></span><br><span class="line">testObj.apply(obj); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><div class="note info"><p>箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对<code>this</code>的词法解析。在箭头函数出现之前，每个新定义的函数都有其自己的<code>this</code>值（例如，构造函数的<code>this</code>指向了一个新的对象；严格模式下的函数的<code>this</code>值为 undefined；如果函数是作为对象的方法被调用的，则其<code>this</code>指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。</p></div><h3 id="ES6-的箭头函数-gt-，指向与一般function定义的函数不同，比较容易绕晕，箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的this，它的this是派生而来的。箭头函数会捕获其所在上下文的this值，作为自己的this值，即指向所在上下文的执行环境-直接外层函数-。"><a href="#ES6-的箭头函数-gt-，指向与一般function定义的函数不同，比较容易绕晕，箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的this，它的this是派生而来的。箭头函数会捕获其所在上下文的this值，作为自己的this值，即指向所在上下文的执行环境-直接外层函数-。" class="headerlink" title="ES6 的箭头函数 ()=&gt;，指向与一般function定义的函数不同，比较容易绕晕，箭头函数this的定义：箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的this，它的this是派生而来的。箭头函数会捕获其所在上下文的this值，作为自己的this值，即指向所在上下文的执行环境(直接外层函数)。"></a>ES6 的箭头函数 ()=&gt;，指向与一般function定义的函数不同，比较容易绕晕，箭头函数<code>this</code>的定义：箭头函数中的<code>this</code>是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的<code>this</code>，它的<code>this</code>是派生而来的。箭头函数会捕获其所在上下文的<code>this</code>值，作为自己的<code>this</code>值，即指向所在上下文的执行环境(直接外层函数)。</h3><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价于: =&gt; &#123; return expression; &#125; </span></span><br><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, …, paramN) =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个参数，圆括号是可选的:</span></span><br><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参数或者多参数的箭头函数需要使用圆括号或者下划线:</span></span><br><span class="line">() =&gt; &#123; statements &#125; _ =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持 Rest parameters 和 default parameters:</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持参数列表中的解构赋值</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], = </span>) =&gt;</span> a + b + c;</span><br><span class="line">f(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数不可以使用arguments对象，"><a href="#箭头函数不可以使用arguments对象，" class="headerlink" title="箭头函数不可以使用arguments对象，"></a>箭头函数不可以使用arguments对象，</h3><p>arguments对象在函数体内不存在，如果要用的话，可以用rest参数代替</p><h3 id="箭头函数没有原型"><a href="#箭头函数没有原型" class="headerlink" title="箭头函数没有原型"></a>箭头函数没有原型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数无法构造函数"><a href="#箭头函数无法构造函数" class="headerlink" title="箭头函数无法构造函数"></a>箭头函数无法构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="箭头函数无法使用yield"><a href="#箭头函数无法使用yield" class="headerlink" title="箭头函数无法使用yield"></a>箭头函数无法使用yield</h3><p>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。</p><h3 id="箭头函数或者组件上绑定事件的时候this-xxx-bind-this-，这样会生成新函数，推荐constructor里bind-garbage-collection-垃圾回收机制"><a href="#箭头函数或者组件上绑定事件的时候this-xxx-bind-this-，这样会生成新函数，推荐constructor里bind-garbage-collection-垃圾回收机制" class="headerlink" title="箭头函数或者组件上绑定事件的时候this.xxx.bind(this)，这样会生成新函数，推荐constructor里bind() garbage collection(垃圾回收机制)"></a>箭头函数或者组件上绑定事件的时候this.xxx.bind(this)，这样会生成新函数，推荐constructor里bind() garbage collection(垃圾回收机制)</h3>]]></content:encoded>
      
      <comments>http://mydearest.cn/jsthis.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>react面试题记录</title>
      <link>http://mydearest.cn/reactInterview.html</link>
      <guid>http://mydearest.cn/reactInterview.html</guid>
      <pubDate>Thu, 07 Jun 2018 06:47:09 GMT</pubDate>
      <description>
      
        &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://p33v4b0bc.bkt.clouddn.com/reactInterview.jpeg &quot; class=&quot;full-image&quot; alt=&quot;reactInterview&quot; title=&quot;React&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://p33v4b0bc.bkt.clouddn.com/reactInterview.jpeg " class="full-image" alt="reactInterview" title="React"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><hr><a id="more"></a><h2 id="React面试问题"><a href="#React面试问题" class="headerlink" title="React面试问题"></a>React面试问题</h2><p>下面是一个常用的关于 React 的面试问题列表：</p><ul><li><a href="#react-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">React 的工作原理</a>?</li><li><a href="#%E4%BD%BF%E7%94%A8-react-%E6%9C%89%E4%BD%95%E4%BC%98%E7%82%B9">使用 React 有何优点</a>？</li><li><a href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6presentational-component%E5%92%8C%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6container-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">展示组件(Presentational component)和容器组件(Container component)之间有何不同</a>？</li><li><a href="#%E7%B1%BB%E7%BB%84%E4%BB%B6class-component%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6functional-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">类组件(Class component)和函数式组件(Functional component)之间有何不同</a>？</li><li><a href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81state%E5%92%8C%E5%B1%9E%E6%80%A7props%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C">(组件的)状态(state)和属性(props)之间有何不同</a>？</li><li><a href="#%E6%8C%87%E5%87%BA%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C">指出(组件)生命周期方法的不同</a>？</li><li><a href="#%E5%BA%94%E8%AF%A5%E5%9C%A8-react-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%95%E5%A4%84%E5%8F%91%E8%B5%B7-ajax-%E8%AF%B7%E6%B1%82">应该在 React 组件的何处发起 Ajax 请求</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6controlled-component">何为受控组件(controlled component)</a>？</li><li><a href="#%E5%9C%A8-react-%E4%B8%ADrefs-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">在 React 中，refs 的作用是什么</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6higher-order-component">何为高阶组件(higher order component)</a>？</li><li><a href="#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0arrow-functions%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88">使用箭头函数(arrow functions)的优点是什么</a>？</li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BC%A0%E9%80%92%E7%BB%99-setstate-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA-callback-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</a>？</li><li><a href="#%E9%99%A4%E4%BA%86%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%91%E5%AE%9A-this%E8%BF%98%E6%9C%89%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E5%90%97">除了在构造函数中绑定 <code>this</code>，还有其它方式吗</a>？</li><li><a href="#%E6%80%8E%E4%B9%88%E9%98%BB%E6%AD%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93">怎么阻止组件的渲染</a>？</li><li><a href="#%E5%BD%93%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E6%97%B6%E4%BD%95%E4%B8%BA-key%E8%AE%BE%E7%BD%AE-key-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88">当渲染一个列表时，何为 key？设置 key 的目的是什么</a>？</li><li><a href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-superprops-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88">(在构造函数中)调用 super(props) 的目的是什么</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-jsx">何为 JSX</a>？</li><li><a href="#%E6%80%8E%E4%B9%88%E7%94%A8%20React.createElement%20%E9%87%8D%E5%86%99%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81">怎么用 React.createElement 重写下面的代码</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-children">何为 <code>Children</code></a>？</li><li><a href="#%E5%9C%A8-react-%E4%B8%AD%E4%BD%95%E4%B8%BA-state">在 React 中，何为 state</a>？</li><li><a href="#%E4%BD%A0%E4%B8%BA%E4%BD%95%E6%8E%92%E6%96%A5-create-react-app">你为何排斥 create-react-app</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-redux">何为 redux</a>？</li><li><a href="#%E5%9C%A8-redux-%E4%B8%AD%E4%BD%95%E4%B8%BA-store">在 Redux 中，何为 store</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-action">何为 action</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA-reducer">何为 reducer</a>？</li><li><a href="#redux-thunk-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">Redux Thunk 的作用是什么</a>？</li><li><a href="#%E4%BD%95%E4%B8%BA%E7%BA%AF%E5%87%BD%E6%95%B0pure-function">何为纯函数(pure function)</a>？</li><li><a href="#%E4%BD%A0%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2">你喜欢 React 的哪些方面</a>？</li><li><a href="#%E4%BD%A0%E4%B8%8D%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2">你不喜欢 React 的哪些方面</a>？</li><li><a href="#%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE">示例项目</a></li></ul><h4 id="React-的工作原理"><a href="#React-的工作原理" class="headerlink" title="React 的工作原理"></a>React 的工作原理</h4><p>React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diff” 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。</p><h4 id="使用-React-有何优点"><a href="#使用-React-有何优点" class="headerlink" title="使用 React 有何优点"></a>使用 React 有何优点</h4><ul><li>只需查看 <code>render</code> 函数就会很容易知道一个组件是如何被渲染的</li><li>JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的</li><li>支持服务端渲染，这可以改进 SEO 和性能</li><li>易于测试</li><li>React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用</li></ul><h4 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何不同"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同</h4><p>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</p><p>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 <code>Flux actions</code>，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</p><h4 id="类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><a href="#类组件-Class-component-和函数式组件-Functional-component-之间有何不同" class="headerlink" title="类组件(Class component)和函数式组件(Functional component)之间有何不同"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同</h4><ul><li>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 <code>store</code> 并维持状态</li><li>当组件仅是接收 <code>props</code>，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</li></ul><h4 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同"></a>(组件的)状态(state)和属性(props)之间有何不同</h4><p><code>State</code> 是一种数据结构，用于组件挂载时所需数据的默认值。<code>State</code> 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</p><p><code>Props</code>(properties 的简写)则是组件的配置。<code>props</code> 由父组件传递给子组件，并且就子组件而言，<code>props</code> 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p><h4 id="指出-组件-生命周期方法的不同"><a href="#指出-组件-生命周期方法的不同" class="headerlink" title="指出(组件)生命周期方法的不同"></a>指出(组件)生命周期方法的不同</h4><ul><li><code>componentWillMount</code> – 多用于根组件中的应用程序配置</li><li><code>componentDidMount</code> – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成</li><li><code>componentWillReceiveProps</code> – 这个周期函数作用于特定的 prop 改变导致的 state 转换</li><li><code>shouldComponentUpdate</code> – 如果你担心组件过度渲染，<code>shouldComponentUpdate</code> 是一个改善性能的地方，因为如果组件接收了新的 <code>prop</code>， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染</li><li><code>componentWillUpdate</code> – 很少使用。它可以用于代替组件的 <code>componentWillReceiveProps</code> 和 <code>shouldComponentUpdate</code>(但不能访问之前的 props)</li><li><code>componentDidUpdate</code> – 常用于更新 DOM，响应 prop 或 state 的改变</li><li><code>componentWillUnmount</code> – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</li></ul><h4 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 Ajax 请求"></a>应该在 React 组件的何处发起 Ajax 请求</h4><p>在 React 组件中，应该在 <code>componentDidMount</code> 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 <code>componentDidMount</code> 中发起网络请求将保证这有一个组件可以更新了。</p><h4 id="何为受控组件-controlled-component"><a href="#何为受控组件-controlled-component" class="headerlink" title="何为受控组件(controlled component)"></a>何为受控组件(controlled component)</h4><p>在 HTML 中，类似 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 <code>onChange</code> 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p><h4 id="在-React-中，refs-的作用是什么"><a href="#在-React-中，refs-的作用是什么" class="headerlink" title="在 React 中，refs 的作用是什么"></a>在 React 中，refs 的作用是什么</h4><p>Refs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。</p><h4 id="何为高阶组件-higher-order-component"><a href="#何为高阶组件-higher-order-component" class="headerlink" title="何为高阶组件(higher order component)"></a>何为高阶组件(higher order component)</h4><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 <code>connect</code> 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。装饰器@decoration练习</p><hr><ul><li>写一个反转其输入的 HOC</li><li>写一个从 API 提供数据给传入的组件的 HOC</li><li>写一个实现 shouldComponentUpdate 来避免 reconciliation 的 HOC</li><li>写一个通过 <code>React.Children.toArray</code> 对传入组件的子组件进行排序的 HOC</li></ul><h4 id="使用箭头函数-arrow-functions-的优点是什么"><a href="#使用箭头函数-arrow-functions-的优点是什么" class="headerlink" title="使用箭头函数(arrow functions)的优点是什么"></a>使用箭头函数(arrow functions)的优点是什么</h4><ul><li>作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 <code>this</code> 值(在构造函数中是新对象；在严格模式下，函数调用中的 <code>this</code> 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 <code>this</code> 值。</li><li>简单：箭头函数易于阅读和书写</li><li>清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 <code>this</code> 的值</li></ul><h4 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h4><p>因为 <code>this.props</code> 和 <code>this.state</code> 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p><h4 id="除了在构造函数中绑定-this，还有其它方式吗"><a href="#除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="除了在构造函数中绑定 this，还有其它方式吗"></a>除了在构造函数中绑定 <code>this</code>，还有其它方式吗</h4><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p><h4 id="怎么阻止组件的渲染"><a href="#怎么阻止组件的渲染" class="headerlink" title="怎么阻止组件的渲染"></a>怎么阻止组件的渲染</h4><p>在组件的 <code>render</code> 方法中返回 <code>null</code> 并不会影响触发组件的生命周期方法</p><h4 id="当渲染一个列表时，何为-key？设置-key-的目的是什么"><a href="#当渲染一个列表时，何为-key？设置-key-的目的是什么" class="headerlink" title="当渲染一个列表时，何为 key？设置 key 的目的是什么"></a>当渲染一个列表时，何为 key？设置 key 的目的是什么</h4><p>Keys 会有助于 React 识别哪些 <code>items</code> 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 <code>items</code> 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 <code>items</code> 可以重新排序，就会导致 <code>re-render</code> 变慢。</p><h4 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么"></a>(在构造函数中)调用 super(props) 的目的是什么</h4><p>在 <code>super()</code> 被调用之前，子类是不能使用 <code>this</code> 的，在 ES2015 中，子类必须在 <code>constructor</code> 中调用 <code>super()</code>。传递 <code>props</code> 给 <code>super()</code> 的原因则是便于(在子类中)能在 <code>constructor</code> 访问 <code>this.props</code>。</p><h4 id="何为-JSX"><a href="#何为-JSX" class="headerlink" title="何为 JSX"></a>何为 JSX</h4><p>JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React “元素”，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就编程了常规的 JavaScript 对象，这意味着你可以在 <code>if</code> 语句和 <code>for</code> 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。</p><h4 id="怎么用-React-createElement-重写下面的代码"><a href="#怎么用-React-createElement-重写下面的代码" class="headerlink" title="怎么用 React.createElement 重写下面的代码"></a>怎么用 React.createElement 重写下面的代码</h4><p>Question：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>Answer：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="何为-Children"><a href="#何为-Children" class="headerlink" title="何为 Children"></a>何为 <code>Children</code></h4><p>在JSX表达式中，一个开始标签(比如<code>&lt;a&gt;</code>)和一个关闭标签(比如<code>&lt;/a&gt;</code>)之间的内容会作为一个特殊的属性<code>props.children</code>被自动传递给包含着它的组件。</p><p>这个属性有许多可用的方法，包括 <code>React.Children.map</code>，<code>React.Children.forEach</code>， <code>React.Children.count</code>， <code>React.Children.only</code>，<code>React.Children.toArray</code>。</p><h4 id="在-React-中，何为-state"><a href="#在-React-中，何为-state" class="headerlink" title="在 React 中，何为 state"></a>在 React 中，何为 state</h4><p>State 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。</p><h4 id="你为何排斥-create-react-app"><a href="#你为何排斥-create-react-app" class="headerlink" title="你为何排斥 create-react-app"></a>你为何排斥 create-react-app</h4><p>在你排斥之前，你并不能去配置 webpack 或 babel presets。</p><h4 id="何为-redux"><a href="#何为-redux" class="headerlink" title="何为 redux"></a>何为 redux</h4><p>Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。</p><h4 id="在-Redux-中，何为-store"><a href="#在-Redux-中，何为-store" class="headerlink" title="在 Redux 中，何为 store"></a>在 Redux 中，何为 store</h4><p>Store 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：</p><ul><li>允许通过 <code>getState()</code> 访问 state</li><li>运行通过 <code>dispatch(action)</code> 改变 state</li><li>通过 <code>subscribe(listener)</code> 注册 listeners</li><li>通过 <code>subscribe(listener)</code> 返回的函数处理 listeners 的注销</li></ul><h4 id="何为-action"><a href="#何为-action" class="headerlink" title="何为 action"></a>何为 action</h4><p>Actions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。</p><h4 id="何为-reducer"><a href="#何为-reducer" class="headerlink" title="何为 reducer"></a>何为 reducer</h4><p>一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。</p><h4 id="Redux-Thunk-的作用是什么"><a href="#Redux-Thunk-的作用是什么" class="headerlink" title="Redux Thunk 的作用是什么"></a>Redux Thunk 的作用是什么</h4><p>Redux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。</p><h4 id="何为纯函数-pure-function"><a href="#何为纯函数-pure-function" class="headerlink" title="何为纯函数(pure function)"></a>何为纯函数(pure function)</h4><p>一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。</p><h4 id="你喜欢-React-的哪些方面"><a href="#你喜欢-React-的哪些方面" class="headerlink" title="你喜欢 React 的哪些方面"></a>你喜欢 React 的哪些方面</h4><p>…</p><h4 id="你不喜欢-React-的哪些方面"><a href="#你不喜欢-React-的哪些方面" class="headerlink" title="你不喜欢 React 的哪些方面"></a>你不喜欢 React 的哪些方面</h4><p>…</p><h4 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h4><ul><li><a href="https://github.com/Pau1fitz/react-spotify" target="_blank" rel="noopener">React Spotify</a></li><li><a href="https://github.com/andrewngu/sound-redux" target="_blank" rel="noopener">React Soundcloud</a></li></ul><h4 id="虚拟dom-普通的js对象"><a href="#虚拟dom-普通的js对象" class="headerlink" title="虚拟dom 普通的js对象"></a>虚拟dom 普通的js对象</h4><p>插入新组件有了key可以帮助react找到映射</p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>每个setState重新渲染整个子树。 如果要压缩性能，请尽可能调用 setState，并使用shouldComponentUpdate 来防止重新渲染大型子树。</p>]]></content:encoded>
      
      <comments>http://mydearest.cn/reactInterview.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>搭建VPS科学上网</title>
      <link>http://mydearest.cn/scienceInternet.html</link>
      <guid>http://mydearest.cn/scienceInternet.html</guid>
      <pubDate>Thu, 07 Jun 2018 02:21:24 GMT</pubDate>
      <description>
      
        &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://p33v4b0bc.bkt.clouddn.com/shadowsocks.jpg&quot; class=&quot;full-image&quot; alt=&quot;Shadowsocks&quot; title=&quot;Shadowsocks&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://p33v4b0bc.bkt.clouddn.com/shadowsocks.jpg" class="full-image" alt="Shadowsocks" title="Shadowsocks"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><hr><a id="more"></a><div class="note info"><p>快速搭建Shadowsocks</p></div><h2 id="购买Vultr服务器"><a href="#购买Vultr服务器" class="headerlink" title="购买Vultr服务器"></a><a href="https://www.vultr.com/" target="_blank" rel="noopener">购买Vultr服务器</a></h2><h3 id="Vultr服务器价格"><a href="#Vultr服务器价格" class="headerlink" title="Vultr服务器价格"></a>Vultr服务器价格</h3><p>Vultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题。</p><p>最低价格的服务器是512M的内存，每个月500G的流量，只能说99%的情况下完全够用了！</p><p><img src="http://p33v4b0bc.bkt.clouddn.com/vultr.png" alt="introduce"></p><h2 id="买好中意的地区节点服务器之后，windows系统可以用Xshell-ssh连接到服务器，并执行以下搭建ss脚本命令"><a href="#买好中意的地区节点服务器之后，windows系统可以用Xshell-ssh连接到服务器，并执行以下搭建ss脚本命令" class="headerlink" title="买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令"></a>买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">wget --no-check-certificate -O shadowsocks.sh</span><br><span class="line">https:<span class="comment">//raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span></span><br><span class="line"> </span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"> </span><br><span class="line">./shadowsocks.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>接着按照提示输入密码，端口和加密方式，如下图：</p><p><img src="http://p33v4b0bc.bkt.clouddn.com/ss1.png" alt="ss1"></p><p><img src="http://p33v4b0bc.bkt.clouddn.com/ss1.png" alt="ss2"></p><p>然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息。</p><h2 id="安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy-SwitchySharp来管理和切换代理配置非常好用。"><a href="#安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy-SwitchySharp来管理和切换代理配置非常好用。" class="headerlink" title="安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。"></a>安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。</h2><p>Windows客户端(代理端口默认1080)<a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>Ubuntu sudo add-apt-repository ppa:hzwhuang/ss-qt5 sudo apt-get update sudo apt-get install shadowsocks-qt5</p><p>Mac客户端(代理端口默认1086)</p><p><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a></p><p>Android客户端</p><p><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-android/releases</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/scienceInternet.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Promise诞生记</title>
      <link>http://mydearest.cn/createPromise.html</link>
      <guid>http://mydearest.cn/createPromise.html</guid>
      <pubDate>Mon, 04 Jun 2018 17:34:09 GMT</pubDate>
      <description>
      
        &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://p33v4b0bc.bkt.clouddn.com/promise.png&quot; class=&quot;full-image&quot; alt=&quot;Promise&quot; title=&quot;Promise&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;p&gt;前端近年的兴起，有大部分是因为 &lt;code&gt;NodeJS&lt;/code&gt; 的诞生，而 &lt;code&gt;NodeJS&lt;/code&gt; 是个适用于 &lt;strong&gt;异步IO&lt;/strong&gt; 密集型的语言，一些基于 &lt;code&gt;NodeJS&lt;/code&gt; 的框架，比喻 &lt;em&gt;KOA2、Adonis&lt;/em&gt; 就有大量的 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 语法，&lt;code&gt;async&lt;/code&gt;的函数的返回值就是 &lt;code&gt;Promise&lt;/code&gt; 对象，我们可以用 &lt;code&gt;async&lt;/code&gt; 和 &lt;code&gt;await&lt;/code&gt; 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。&lt;/p&gt;
&lt;h2 id=&quot;Promise-概念&quot;&gt;&lt;a href=&quot;#Promise-概念&quot; class=&quot;headerlink&quot; title=&quot;Promise 概念&quot;&gt;&lt;/a&gt;Promise 概念&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是一种对异步操作的封装，主流的规范是Promise/A+。
&lt;code&gt;Promise&lt;/code&gt;可以使得异步代码层次清晰，便于理解，且更加容易维护。
&lt;code&gt;Promise&lt;/code&gt;构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
生成实例时回执信作为参数的函数；&lt;br&gt; 
&lt;code&gt;resolve&lt;/code&gt;函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
&lt;code&gt;reject&lt;/code&gt;函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://p33v4b0bc.bkt.clouddn.com/promise.png" class="full-image" alt="Promise" title="Promise"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><p>前端近年的兴起，有大部分是因为 <code>NodeJS</code> 的诞生，而 <code>NodeJS</code> 是个适用于 <strong>异步IO</strong> 密集型的语言，一些基于 <code>NodeJS</code> 的框架，比喻 <em>KOA2、Adonis</em> 就有大量的 <code>async</code> 和 <code>await</code> 语法，<code>async</code>的函数的返回值就是 <code>Promise</code> 对象，我们可以用 <code>async</code> 和 <code>await</code> 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。</p><h2 id="Promise-概念"><a href="#Promise-概念" class="headerlink" title="Promise 概念"></a>Promise 概念</h2><p><code>Promise</code>是一种对异步操作的封装，主流的规范是Promise/A+。<code>Promise</code>可以使得异步代码层次清晰，便于理解，且更加容易维护。<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。生成实例时回执信作为参数的函数；<br> <code>resolve</code>函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><hr><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行顺序</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>); <span class="comment">// 新建后立即执行</span></span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>); <span class="comment">// 同步任务执行完成后才会执行</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>接下来我们就用<code>Promise</code>结合ajax来使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const getJSON = function(url) &#123;</span><br><span class="line">  const promise = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    const handler = function() &#123;</span><br><span class="line">      if (this.readyState !== 4) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.status === 200) &#123;</span><br><span class="line">        resolve(this.response);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        reject(new Error(this.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    const client = new XMLHttpRequest();</span><br><span class="line">    client.open(&quot;GET&quot;, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = &quot;json&quot;;</span><br><span class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</span><br><span class="line">    client.send(params);</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</span><br><span class="line">  console.log(&apos;Contents: &apos; + json);</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  console.error(&apos;出错了&apos;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我们会渐进式的来创建一个 <code>Promise</code> 的实现，如果，你还不了解 <code>Promise</code> ，赶快移步 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">Promise</a> 了解学习，当然这个实现会符合 <a href="https://promisesaplus.com" target="_blank" rel="noopener">Promise/A+</a> 规范，<code>JavaScript</code> 中有很多第三方的 <code>Promise</code> 库，<a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="noopener">bluebird</a> 就是一个第三方 <code>Promise</code> 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。</p><hr><p>废话不多说，直接开干。。。 😠</p><h2 id="定义-Promise-类型"><a href="#定义-Promise-类型" class="headerlink" title="定义 Promise 类型"></a>定义 Promise 类型</h2><p>一个简单 <code>Promise</code> 语法，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... doSomething</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure 第二个函数可选</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现-resolve-和-then"><a href="#实现-resolve-和-then" class="headerlink" title="实现 resolve 和 then"></a>实现 resolve 和 then</h3><p>首先我们以上 👆 的语法，自己定义一个 <code>Promise</code> 实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve</span></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callback = cb;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现 resolve , value:异步操作的最终值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    callback(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//执行 function 参数</span></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的实例写好了，然后，来用一下，看看 👀 结果如何</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">66</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><div class="note info"><p>执行结果是：<code>callback is not a function</code></p></div><h3 id="改进1：延时resolve，修改-callback-为异步"><a href="#改进1：延时resolve，修改-callback-为异步" class="headerlink" title="改进1：延时resolve，修改 callback 为异步"></a>改进1：延时resolve，修改 callback 为异步</h3><p><strong>这里就遇到一个问题： </strong>  </p><p><strong> 目前的Promise有一个bug，假如fn中所包含的是同步代码，则resolve会立即执行，<code>callback</code> 还是 <code>null</code> ，我们的代码是同步的，而不是异步的。<br> 如是，想办法解决掉这个问题，就是利用 <code>setTimeout</code> , 把 <code>callback</code> 加入异步队列</strong> </p><p>代码如下 👇</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> callback = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve</span></span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callback = cb;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实现 resolve , value:异步操作的最终值</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      callback(value);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//执行 function 参数</span></span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进2：注册多个回调函数，并实现then的链式调用"><a href="#改进2：注册多个回调函数，并实现then的链式调用" class="headerlink" title="改进2：注册多个回调函数，并实现then的链式调用"></a>改进2：注册多个回调函数，并实现then的链式调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> callbackList = [];</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callbackList.push(cb);</span><br><span class="line">    <span class="comment">// 实现链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">// 遍历callbackList数组依次执行</span></span><br><span class="line">       callbackList.forEach(<span class="function">(<span class="params">callback</span>)=&gt;</span>&#123;</span><br><span class="line">         callback(value)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进3：引入状态"><a href="#改进3：引入状态" class="headerlink" title="改进3：引入状态"></a>改进3：引入状态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state=<span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> callbackList = [];</span><br><span class="line">  <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state==<span class="string">'pending'</span>)&#123;</span><br><span class="line">      <span class="comment">// pending加入队列</span></span><br><span class="line">      callbackList.push(cb);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(state==<span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">      <span class="comment">// fulfilled立即执行</span></span><br><span class="line">      cb(value)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    value = newValue</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       callbackList.forEach(<span class="function">(<span class="params">callback</span>)=&gt;</span>&#123;</span><br><span class="line">         callback(value)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  fn(resolve);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动实现一个Promise：</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span>()</span>&#123;</span><br><span class="line">  construtor(fn)&#123;</span><br><span class="line">       <span class="comment">// 执行队列</span></span><br><span class="line">       <span class="keyword">this</span>._wathcList=[]</span><br><span class="line">       <span class="comment">// 成功</span></span><br><span class="line">       <span class="keyword">this</span>._success_res=<span class="literal">null</span></span><br><span class="line">       <span class="comment">// 失败</span></span><br><span class="line">       <span class="keyword">this</span>._error_res=<span class="literal">null</span></span><br><span class="line">       <span class="keyword">this</span>._status=<span class="string">"success"</span></span><br><span class="line">       fn(<span class="function">(<span class="params">...args</span>))=&gt;</span>&#123;</span><br><span class="line">          <span class="comment">// 保存成功数据</span></span><br><span class="line">          <span class="keyword">this</span>._success_res=args</span><br><span class="line">          <span class="keyword">this</span>._status=<span class="string">'success'</span></span><br><span class="line">          <span class="comment">// 若为异步则回头执行then成功方法</span></span><br><span class="line">          <span class="keyword">this</span>._watchList.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">              element.fn1(...args);</span><br><span class="line">          &#125;);</span><br><span class="line">       &#125;,(...args)=&gt;&#123;</span><br><span class="line">          <span class="comment">// 保存失败数据</span></span><br><span class="line">          <span class="keyword">this</span>._error_res=args</span><br><span class="line">          <span class="keyword">this</span>._status=<span class="string">'error'</span></span><br><span class="line">          <span class="comment">// 若为异步则回头执行then成功方法</span></span><br><span class="line">          <span class="keyword">this</span>._watchList.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">              element.fn2(...args);</span><br><span class="line">          &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then 函数</span></span><br><span class="line">  then(fn1, fn2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._status === <span class="string">"success"</span>) &#123;</span><br><span class="line">          fn1(...this._success_res);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._status === <span class="string">"error"</span>) &#123;</span><br><span class="line">          fn2(...this._error_res);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>._watchList.push(&#123;</span><br><span class="line">              fn1,</span><br><span class="line">              fn2</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>实现Promise.all</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Promise1.all = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 存放结果集</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">return</span> Promise1(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 进行迭代执行</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            arr[i].then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 存放每个方法的返回值</span></span><br><span class="line">                result.push(res);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 若全部执行完</span></span><br><span class="line">                <span class="keyword">if</span> (i === result.length) &#123;</span><br><span class="line">                    <span class="comment">// 执行then回调</span></span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 继续迭代</span></span><br><span class="line">                    next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, reject)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Promise使用注意点"><a href="#Promise使用注意点" class="headerlink" title="Promise使用注意点"></a>Promise使用注意点</h2><ol><li><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，<code>Promise</code>的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p></li><li><p><code>Promise</code>实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为<code>Promise</code>实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。<code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即then方法后面再调用另一个<code>then</code>方法。</p></li><li><p><code>Promise.prototype.catch</code>方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。<code>getJSON</code>方法返回一个<code>Promise</code>对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p></li><li><p>一般来说，不要在then方法里面定义<code>reject</code>状态的回调函数（即then的第二个参数），总是使用<code>catch</code>方法。</p></li><li><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，<code>Promise</code>对象抛出的错误不会传递到外层代码，即不会有任何反应，<code>Promise</code>会吃掉错误。</p></li></ol>]]></content:encoded>
      
      <comments>http://mydearest.cn/createPromise.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何使用 markdown 语法写博客</title>
      <link>http://mydearest.cn/markdownGrammar.html</link>
      <guid>http://mydearest.cn/markdownGrammar.html</guid>
      <pubDate>Fri, 06 Apr 2018 23:25:19 GMT</pubDate>
      <description>
      
        &lt;span itemprop=&quot;image&quot; itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;http://p33v4b0bc.bkt.clouddn.com/markdown.png&quot; class=&quot;full-image&quot; alt=&quot;Markdown&quot; title=&quot;Markdown&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
&lt;h1 id=&quot;标题1&quot;&gt;&lt;a href=&quot;#标题1&quot; class=&quot;headerlink&quot; title=&quot;标题1&quot;&gt;&lt;/a&gt;标题1&lt;/h1&gt;&lt;h2 id=&quot;标题2&quot;&gt;&lt;a href=&quot;#标题2&quot; class=&quot;headerlink&quot; title=&quot;标题2&quot;&gt;&lt;/a&gt;标题2&lt;/h2&gt;&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;
&lt;strong&gt;粗体&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;粗斜体&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
&lt;del&gt;删除线&lt;/del&gt;
&lt;u&gt;下划线文本&lt;/u&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I&lt;/li&gt;
&lt;li&gt;Love &lt;/li&gt;
&lt;li&gt;You&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;点&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Foo&lt;/li&gt;
&lt;li&gt;Bar&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="http://p33v4b0bc.bkt.clouddn.com/markdown.png" class="full-image" alt="Markdown" title="Markdown"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><p><em>斜体</em><strong>粗体</strong><strong><em>粗斜体</em></strong><br><del>删除线</del><u>下划线文本</u></p><ol><li>I</li><li>Love </li><li>You</li></ol><ul><li>点</li></ul><ul><li>Foo</li><li>Bar</li></ul><hr><a id="more"></a><p>分隔线</p><hr><hr><hr><hr><blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote></blockquote><p><code>#include&lt;iostream&gt;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">标题</th><th style="text-align:center">标题</th><th style="text-align:right">标题</th></tr></thead><tbody><tr><td style="text-align:left">居左测试文本</td><td style="text-align:center">居中测试文本</td><td style="text-align:right">居右测试文本</td></tr><tr><td style="text-align:left">居左测试文本1</td><td style="text-align:center">居中测试文本2</td><td style="text-align:right">居右测试文本3</td></tr><tr><td style="text-align:left">居左测试文本11</td><td style="text-align:center">居中测试文本22</td><td style="text-align:right">居右测试文本33</td></tr><tr><td style="text-align:left">居左测试文本111</td><td style="text-align:center">居中测试文本222</td><td style="text-align:right">居右测试文本333</td></tr></tbody></table><ul><li style="list-style: none"><input type="checkbox" checked> 已完成事项</li><li style="list-style: none"><input type="checkbox"> 待办事项1</li><li style="list-style: none"><input type="checkbox"> 待办事项2</li></ul><h3 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h3><p><code>Markdown</code> 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*literal asterisks\*</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><p>*literal asterisks*</p><p><code>Markdown</code> 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><p>登录<a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a><img src="http://img2.everychina.com/img/d7/f7/1b580dfa9315111397ef93fd24ea-250x250c1-77f7/love_valentine_plush_teddy_bear.jpg" alt="Teddy Bear"></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/markdownGrammar.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World - 热爱编程的普通人，顺便以此为生。</title>
      <link>http://mydearest.cn/hello-world.html</link>
      <guid>http://mydearest.cn/hello-world.html</guid>
      <pubDate>Sat, 31 Mar 2018 17:34:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。&lt;/p&gt;
&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。</p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><hr><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content:encoded>
      
      <comments>http://mydearest.cn/hello-world.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
