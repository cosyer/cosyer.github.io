[{"title":"事件机制","url":"%2F2019%2F%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.html","content":"\n事件机制的核心就是发布-订阅模式。维护一个对象，对象的 key 存的是事件 type，对应的 value 为触发相应 type 的回调函数，即 listeners，然后 trigger 时遍历通知，即 forEach 进行回调执行。\n\n```js\nclass EventTarget {\n    constructor() {\n        this.listener = [];\n    }\n\n    // 监听事件\n    on(type, callback) {\n        // 如果是第一次监听该事件，则初始化数组\n        if (!this.listeners[type]) this.listeners[type] = [];\n        this.listeners[type].push(callback);\n    }\n\n    // 只监听一次\n    once(type, callback) {\n        if (!this.listeners[type]) this.listeners[type] = [];\n        // once 只触发一次，触发后 off 即可 回调函数加上标识\n        callback._once = true;\n        this.listeners[type].push(callback); \n    }\n\n    // 取消监听\n    off(type, callback) {\n        const listeners = this.listeners[type];\n        if (Array.isArray(listeners)) {\n            // filter 返回新的数组，会每次对 this.listeners[type] 分配新的空间\n            // this.listeners[type] = listeners.filter(l => l !== callback);\n            // 根据 type 取消对应的回调\n            const index = listeners.indexOf(callback);\n            // 用 splice 要好些，直接操作原数组\n            this.listeners[type].splice(index, 1);\n            // 如果回调为空，删除对该事件的监听\n            if (this.listeners[type].length === 0) delete this.listeners[type];\n        }\n    }\n\n    // 执行 扳机社\n    trigger(event) {\n        // type 为必传属性\n        const { type } = event;\n        if (!type) throw new Error('没有要触发的事件！');\n        // 判断是否之前对该事件进行监听了\n        const listeners = this.listeners[type];\n        if (!listeners) throw new Error(`没有对象监听 ${type} 事件！`);\n        if (!event.target) event.target = this;\n        listeners.forEach(l => {\n            l(event);\n            // 如果通过 once 监听，执行一次后取消\n            if (l._once) this.off(type, l);\n        });\n    }\n}\n```\n","tags":["深入理解"],"categories":["JS"]},{"title":"关于requestAnimationFrame","url":"%2F2019%2F%E5%85%B3%E4%BA%8ErequestAnimationFrame.html","content":"\n在JS中，我们可以使用 `setTimeout` 和 `setIntarval` 实现动画，但是 H5 的出现，让我们又多了两种实现动画的方式，分别是 CSS 动画（`transition`、`animation`）和 H5的`canvas` 实现。除此以外，H5还提供了一个专门用于请求动画的API，让 DOM 动画、canvas动画、svg动画、webGL动画等有一个专门的刷新机制。\n\n### 1. 定义\n`requestAnimationFrame` 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。\n\n```js\nwindow.requestAnimationFrame(callback)\n```\n\n* callback：下一次重绘之前更新动画帧所调用的函数，**callback仅有一个参数，为DOMHighResTimeStamp参数，表示requestAnimationFrame()开始执行回调函数的时刻。**\n* 返回值：一个 long 类型整数，唯一标志元组在列表中的位置，你可以传这个值给`cancelAnimationFrame()` 以取消动画。\n\n在使用和实现上， `requestAnimationFrame` 与 `setTimeout` 类似。举个例子：\n\n```js\nlet count = 0;\nlet rafId = null;\n/**\n * 回调函数\n * @param time requestAnimationFrame 调用该函数时，自动传入的一个时间\n */\nfunction requestAnimation(time) {\n  console.log(time); // 打印执行requestAnimation函数的时刻\n  // 动画没有执行完，则递归渲染\n  if (count < 5) {\n    count++;\n    // 渲染下一帧\n    rafId = window.requestAnimationFrame(requestAnimation);\n  }\n}\n// 渲染第一帧\nwindow.requestAnimationFrame(requestAnimation);\n```\n\n### 2.怎样执行\n* 首先判断 `document.hidden` 属性是否可见（true），可见状态下才能继续执行以下步骤\n* 浏览器清空上一轮的动画函数\n* `requestAnimationFrame` 将回调函数追加到动画帧请求回调函数列表的末尾\n  **注意：当执行 requestAnimationFrame(callback)的时候，不会立即调用 callback 回调函数，只是将其放入回调函数队列而已，同时注意，每个 callback回调函数都有一个 cancelled 标志符，初始值为 false，并对外不可见。**\n* 当页面可见并且动画帧请求callback**回调函数列表**不为空时，浏览器会**定期**将这些回调函数加入到浏览器 UI 线程的队列中（**由系统来决定回调函数的执行时机**）。当浏览器执行这些 callback 回调函数的时候，会判断每个元组的 callback 的cancelled标志符，只有 **cancelled 为 false** 时，才执行callback回调函数。\n\n### 3. 优点\n1. `requestAnimationFrame` 自带**函数节流**功能，采用**系统时间间隔**，保持最佳绘制效率，不会因为间隔时间的过短，造成过度绘制，增加页面开销，也不会因为间隔时间过长，造成动画卡顿，不流程，影响页面美观。\n   浏览器的重绘频率一般会和显示器的刷新率保持同步。大多数采用 W3C规范，浏览器的渲染页面的标准频率也为 60 FPS（frames/per second）即每秒重绘60次，**requestAnimationFrame的基本思想是 让页面重绘的频率和刷新频率保持同步**，即每 1000ms / 60 = **16.7ms**执行一次。\n   通过 `requestAnimationFrame` 调用回调函数引起的页面重绘或回流的时间间隔和显示器的刷新时间间隔相同。所以  `requestAnimationFrame`  不需要像 `setTimeout` 那样传递时间间隔，而是浏览器通过系统获取并使用显示器刷新频率。例如在某些高频事件（resize，scroll 等）中，使用 `requestAnimationFrame` 可以防止在一个刷新间隔内发生多次函数执行，这样保证了流程度，也节省了开销\n2. 另外，该函数的**延时效果是精确的**，没有`setTimeout`或`setInterval`不准的情况（JS是单线程的，`setTimeout` 任务被放进异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列的任务是否需要开始执行，造成时间延时）。\n   `setTimeout`**的执行只是在内存中对图像属性进行改变，这个改变必须要等到下次浏览器重绘时才会被更新到屏幕上**。如果和屏幕刷新步调不一致，就可能导致中间某些帧的操作被跨越过去，直接更新下下一帧的图像。即 **掉帧**\n   使用  `requestAnimationFrame` 执行动画，最大优势是**能保证回调函数在屏幕每一次刷新间隔中只被执行一次**，这样就不会引起丢帧，动画也就不会卡顿\n3. 节省资源，节省开销\n   在之前介绍`requestAnimationFrame`执行过程，我们知道只有当页面激活的状态下，页面刷新任务才会开始，才执行 `requestAnimationFrame`，当页面隐藏或最小化时，会被暂停，页面显示，会继续执行。**节省了 CPU 开销**。\n   **注意：当页面被隐藏或最小化时，定时器`setTimeout`仍在后台执行动画任务，此时刷新动画是完全没有意义的（实际上 FireFox/Chrome 浏览器对定时器做了优化：页面闲置时，如果时间间隔小于 1000ms，则停止定时器，与`requestAnimationFrame`行为类似。如果时间间隔>=1000ms，定时器依然在后台执行）**\n   ```js\n   // 在浏览器开发者工具的Console页执行下面代码。\n   // 当开始输出count后，切换浏览器tab页，再切换回来，可以发现打印的值从离开前的值继续输出\n   let count = 0;\n       function requestAnimation() {\n           if (count < 100) {\n               count++;\n               console.log(count);\n               requestAnimationFrame(requestAnimation);\n           }\n       }\n   requestAnimationFrame(requestAnimation);\n   ```\n4. 能够在动画流刷新之后执行，即**上一个动画流会完整执行**\n\n### 4. 实现\n我们可以使用 `requestAnimationFrame` 实现`setInterval`及 `setTimeout`\n\n```js\n// setInterval实现\nfunction setInterval(callback, interval) {\n    let timer\n    const now = Date.now\n    let startTime = now()\n    let endTime = startTime\n    const loop = () ={\n        timer = window.requestAnimationFrame(loop)\n        endTime = now()\n        if (endTime - startTime >= interval) {\n            startTime = endTime = now()\n            callback(timer)\n        }\n    }\n    timer = window.requestAnimationFrame(loop)\n    return timer\n}\n\nlet a = 0\nsetInterval(timer ={\n    console.log(a)\n    a++\n    if (a === 3) window.cancelAnimationFrame(timer)\n}, 1000)\n// 0\n// 1\n// 2\n```\n\n```js\n// setTimeout 实现\nfunction setTimeout(callback, interval) {\n    let timer\n    const now = Date.now\n    let startTime = now()\n    let endTime = startTime\n    const loop = () ={\n        timer = window.requestAnimationFrame(loop)\n        endTime = now()\n        if (endTime - startTime >= interval) {\n            callback(timer)\n            window.cancelAnimationFrame(timer)\n        }\n    }\n    timer = window.requestAnimationFrame(loop)\n    return timer\n}\n\nlet a = 0\nsetTimeout(timer ={\n    console.log(a)\n    a++\n}, 1000)\n// 0\n```\n\n### 5. 参考\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)\n","tags":["深入理解"],"categories":["JS"]},{"title":"git相关问题场景和命令","url":"%2F2019%2Fgit%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%E5%92%8C%E5%91%BD%E4%BB%A4.html","content":"\n### 一、必备知识点\n![git](http://cdn.mydearest.cn/blog/images/git.png)\n\n---\n<!--more-->\n\n#### 仓库\n1. **Remote:** 远程主仓库；\n2. **Repository：** 本地仓库；\n3. **Index：** Git追踪树,暂存区；\n4. **workspace：** 本地工作区（即你编辑器的代码）\n\n### 二、git add 提交到暂存区，出错怎么办\n一般代码提交流程为：**工作区** -`git status` 查看状态 -`git add .` 将所有修改加入**暂存区**-`git commit -m \"提交描述\"` 将代码提交到 **本地仓库** -`git push` 将本地仓库代码更新到 **远程仓库**\n\n#### 场景1：工作区\n当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令` git checkout -- file`。\n\n```js\n// 丢弃工作区的修改\ngit checkout -- <文件名>\n```\n\n#### 场景2：暂存区\n当你不但改乱了工作区某个文件的内容，还 `git add` 添加到了暂存区时，想丢弃修改，分两步，第一步用命令 `git reset HEAD file`，就回到了场景1，第二步按场景1操作。\n\n```js\ngit reset HEAD <文件名// 把暂存区的修改撤销掉（unstage），重新放回工作区。\n```\n\n### 三、git commit 提交到本地仓库，出错怎么办？\n#### 1. 提交信息出错\n更改 commit 信息\n\n```js\ngit commit --amend -m“新提交消息”\n```\n\n#### 2. 漏提交\ncommit 时，遗漏提交部分更新，有两种解决方案：\n\n* 方案一：再次 commit\n  ```js\n  git commit -m“提交消息”\n  ```\n  \n  \n  此时，git 上会出现两次 commit\n* 方案二：遗漏文件提交到之前 commit 上\n  ```js\n  git add missed-file // missed-file 为遗漏提交文件\n  git commit --amend --no-edit\n  ```\n  \n  \n  `--no-edit` 表示提交消息不会更改，在 git 上仅为一次提交\n\n#### 3. 提交错误文件，回退到上一个 commit 版本，再 commit\n##### git reset\n删除指定的 commit\n\n```js\n// 修改版本库，保留暂存区，保留工作区\n// 将版本库软回退1个版本，软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。\ngit reset --soft HEAD~1\n\n// 修改版本库，修改暂存区，修改工作区\n// 将版本库回退1个版本，不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本\ngit reset --hard HEAD~1\n// git版本回退，回退到特定的commit_id版本，可以通过git log查看提交历史，以便确定要回退到哪个版本(commit 之后的即为ID);\ngit reset --hard commit_id \n```\n\n##### git revert\n撤销 某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销\n\n作为一次最新的提交\n\n```js\n// 撤销前一次 commit\ngit revert HEAD\n// 撤销前前一次 commit\ngit revert HEAD^\n// (比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。\ngit revert commit\n```\n\n`git revert`是提交一个新的版本，将需要`revert`的版本的内容再反向修改回去，\n版本会递增，不影响之前提交的内容\n\n##### `git revert` 和 `git reset` 的区别\n* `git revert`是用一次新的commit来回滚之前的commit，`git reset`是直接删除指定的commit。\n* 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为`git revert`是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是`git reset`是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。\n* `git reset` 是把HEAD向后移动了一下，而`git revert`是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。\n\n### 四、常用命令\n#### 1. 初始开发 git 操作流程\n* 克隆最新主分支项目代码 `git clone 地址`\n* 创建本地分支 `git branch 分支名`\n* 查看本地分支 `git branch`\n* 查看远程分支 `git branch -a`\n* 切换分支  `git checkout 分支名 ` (一般修改未提交则无法切换，大小写问题经常会有，可强制切换  `git checkout 分支名 -f`  非必须慎用)\n* 将本地分支推送到远程分支 `git push <远程仓库<本地分支>:<远程分支>`\n\n#### 2. git fetch\n将某个远程主机的更新，全部/分支 取回本地（此时之更新了Repository）它取回的代码对你本地的开发代码没有影响，如需彻底更新需合并或使用`git pull`\n\n#### 3. git pull\n拉取远程主机某分支的更新，再与本地的指定分支合并（相当与fetch加上了合并分支功能的操作）\n\n#### 4. git push\n将本地分支的更新，推送到远程主机，其命令格式与`git pull`相似\n\n#### 5. 分支操作\n* 使用 Git 下载指定分支命令为：`git clone -b 分支名仓库地址`\n* 拉取远程新分支 `git checkout -b serverfix origin/serverfix`\n* 合并本地分支 `git merge hotfix`：(将 hotfix 分支合并到当前分支)\n* 合并远程分支 `git merge origin/serverfix`\n* 删除本地分支 `git branch -d hotfix`：(删除本地 hotfix 分支)\n* 删除远程分支 `git push origin --delete serverfix`\n* 上传新命名的本地分支：`git push origin newName`;\n* 创建新分支：`git branch branchName`：(创建名为 branchName 的本地分支)\n* 切换到新分支：`git checkout branchName`：(切换到 branchName 分支)\n* 创建并切换分支：`git checkout -b branchName`：(相当于以上两条命令的合并)\n* 查看本地分支：`git branch`\n* 查看远程仓库所有分支：`git branch -a`\n* 本地分支重命名： `git branch -m oldName newName`\n* 重命名远程分支对应的本地分支：`git branch -m oldName newName`\n* 把修改后的本地分支与远程分支关联：`git branch --set-upstream-to origin/newName`\n\n### 五、优化操作\n#### 1. 拉取代码 pull --rebase\n在团队协作过程中，假设你和你的同伴在本地中分别有各自的新提交，而你的同伴先于你 `push` 了代码到远程分支上，所以你必须先执行 `git pull` 来获取同伴的提交，然后才能` push` 自己的提交到远程分支。\n\n而按照 Git 的默认策略，如果远程分支和本地分支之间的提交线图有分叉的话（即不是 fast-forwarded），Git 会执行一次 `merge` 操作，因此产生一次没意义的提交记录，从而造成了像上图那样的混乱。\n\n其实在 pull 操作的时候，，使用 `git pull --rebase `选项即可很好地解决上述问题。 加上 `--rebase` 参数的作用是，提交线图有分叉的话，Git 会 rebase 策略来代替默认的 merge 策略。\n\n假设提交线图在执行 pull 前是这样的：\n\n```\n                 A---B---C  remotes/origin/master\n                /\n           D---E---F---G  master\n```\n\n如果是执行 `git pull` 后，提交线图会变成这样：\n\n```\n                 A---B---C remotes/origin/master\n                /         \\\n           D---E---F---G---H master\n```\n\n结果多出了 `H` 这个没必要的提交记录。如果是执行 `git pull --rebase` 的话，提交线图就会变成这样：\n\n```\n                       remotes/origin/master\n                           |\n           D---E---A---B---C---F'---G'  master\n```\n\n`F` `G` 两个提交通过 `rebase` 方式重新拼接在 `C` 之后，多余的分叉去掉了，目的达到。\n\n##### 小结\n大多数时候，使用 `git pull --rebase `是为了使提交线图更好看，从而方便 code review。\n\n不过，如果你对使用 git 还不是十分熟练的话，我的建议是 `git pull --rebase `多练习几次之后再使用，因为 **rebase 在 git 中，算得上是『危险行为』**。\n\n另外，还需注意的是，使用 `git pull --rebase `比直接 pull 容易导致冲突的产生，如果预期冲突比较多的话，建议还是直接 pull。\n\n注意：\ngit pull = git fetch + git merge\ngit pull --rebase = git fetch + git rebase\n\n#### 2. 合代码 merge --no-ff\n上述的 `git pull --rebase` 策略目的是修整提交线图，使其形成一条直线，而即将要用到的 `git merge --no-ff <branch-name>` 策略偏偏是反行其道，刻意地弄出提交线图分叉出来。\n\n假设你在本地准备合并两个分支，而刚好这两个分支是 fast-forwarded 的，那么直接合并后你得到一个直线的提交线图，当然这样没什么坏处，但如果你想更清晰地告诉你同伴：**这一系列的提交都是为了实现同一个目的**，那么你可以刻意地将这次提交内容弄成一次提交线图分叉。\n\n执行 `git merge --no-ff <branch-name>` 的结果大概会是这样的：\n\n![git merge --no-ff](http://cdn.mydearest.cn/blog/images/git-chain1.png)\n\n中间的分叉线路图很清晰的显示这些提交都是为了实现 **complete adjusting user domains and tags**\n\n##### 更进一步\n往往我的习惯是，在合并分支之前（假设要在本地将 feature 分支合并到 dev 分支），会先检查 feature 分支是否『部分落后』于**远程 dev 分支**：\n\n```\ngit checkout dev\ngit pull # 更新 dev 分支\ngit log feature..dev\n```\n\n如果没有输出任何提交信息的话，即表示 feature 对于 dev 分支是 up-to-date 的。如果有输出的话而马上执行了 `git merge --no-ff` 的话，提交线图会变成这样：\n\n![git-merge](http://cdn.mydearest.cn/blog/images/git-chain2.png)\n\n所以这时在合并前，通常我会先执行：\n\n```\ngit checkout feature\ngit rebase dev\n```\n\n这样就可以将 feature 重新拼接到更新了的 dev 之后，然后就可以合并了，最终得到一个干净舒服的提交线图。\n\n**再次提醒：像之前提到的，rebase 是『危险行为』，建议你足够熟悉 git 时才这么做，否则的话是得不偿失啊。**\n\n##### 总结\n使用 `git pull --rebase` 和 `git merge --no-ff` 其实和直接使用 `git pull` `git merge` 得到的代码应该是一样。\n\n使用 `git pull --rebase` 主要是为是将提交约线图平坦化，而 `git merge --no-ff` 则是刻意制造分叉。\n\n### 六、SSH\n#### 1. 查看是否生成了 SSH 公钥\n```\n$ cd ~/.ssh\n$ ls\nid_rsa      id_rsa.pub      known_hosts\n```\n\n其中 id_rsa 是私钥，id_rsa.pub 是公钥。\n\n#### 2. 如果没有那就开始生成，设置全局的user.name与user.email\n```js\ngit config --list // 查看是否设置了user.name与user.email，没有的话，去设置\n// 设置全局的user.name与user.email\ngit config --global user.name \"XX\"\ngit config --global user.email \"XX\"\n```\n\n#### 3. 输入 ssh-keygen 即可（或`ssh-keygen -t rsa -C \"email\"`）\n```\n$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Users/schacon/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /Users/schacon/.ssh/id_rsa.\nYour public key has been saved in /Users/schacon/.ssh/id_rsa.pub.\nThe key fingerprint is:\n```\n\n#### 4. 生成之后获取公钥内容，输入 cat ~/.ssh/id_rsa.pub 即可， 复制 ssh-rsa 一直到 .local这一整段内容\n```\n$ cat ~/.ssh/id_rsa.pub\nssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU\nGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3\nPbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA\nt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En\nmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx\nNrRFi9wrf+M7Q== schacon@agadorlaptop.local\n```\n\n#### 5. 打开 GitLab 或者 GitHub，点击头像，找到设置页\n#### 6. 左侧找到 SSH keys 按钮并点击，输入刚刚复制的公钥即可\n### 七、暂存\n`git stash` 可用来暂存当前正在进行的工作，比如想 pull 最新代码又不想 commit ， 或者另为了修改一个紧急的 bug ，先 stash，使返回到自己上一个 commit,，改完 bug 之后再 stash pop , 继续原来的工作；\n\n* 添加缓存栈： `git stash` ;\n* 查看缓存栈： `git stash list` ;\n* 推出缓存栈： `git stash pop` ;\n* 取出特定缓存内容： `git stash apply stash@{1}` ;\n\n### 八、文件名过长错误\nFilename too long warning: Clone succeeded, but checkout failed.\n\n```\ngit config --system core.longpaths true\n```\n\n### 九、邮箱和用户名\n#### 查看\n```\ngit config user.name\n\ngit config user.email\n```\n\n#### 修改\n```\ngit config --global user.name \"username\"\n\ngit config --global user.email \"email\"\n```\n\n### 十、.gitignore 更新后生效：\n```\ngit rm -r --cached .\ngit add .\ngit commit -m \".gitignore is now working”\n```\n\n### 十一、同步Github fork 出来的分支\n1、配置remote，指向原始仓库\n\n```\ngit remote add upstream https://github.com/cosyer/jelly.git\n```\n\n2、上游仓库获取到分支，及相关的提交信息，它们将被保存在本地的 upstream/master 分支\n\n```\ngit fetch upstream\n# remote: Counting objects: 75, done.\n# remote: Compressing objects: 100% (53/53), done.\n# remote: Total 62 (delta 27), reused 44 (delta 9)\n# Unpacking objects: 100% (62/62), done.\n# From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY\n# * [new branch] master -upstream/master\n```\n\n3、切换到本地的 master 分支\n\n```\ngit checkout master\n# Switched to branch 'master'\n```\n\n4、把 upstream/master 分支合并到本地的 master 分支，本地的 master 分支便跟上游仓库保持同步了，并且没有丢失本地的修改。\n\n```\ngit merge upstream/master\n# Updating a422352..5fdff0f\n# Fast-forward\n# README | 9 -------\n# README.md | 7 ++++++\n# 2 files changed, 7 insertions(+), 9 deletions(-)\n# delete mode 100644 README\n# create mode 100644 README.md\n```\n\n5、上传到自己的远程仓库中\n\n```\ngit push \n```\n\n### 参考\n本文参考了 [洁癖者用 Git：pull --rebase 和 merge --no-ff](http://hungyuhei.github.io/2012/08/07/better-git-commit-graph-using-pull---rebase-and-merge---no-ff.html)\n\n","tags":["git"],"categories":["工具"]},{"title":"npm总结","url":"%2F2019%2Fnpm%E6%80%BB%E7%BB%93.html","content":"\n### 一. package.json 解读\n```js\n{\n\t\"name\": \"hello world\", // 项目名称\n\t\"version\": \"0.0.1\", // 版本号：大版本.次要版本.小版本\n\t\"author\": \"张三\",\n\t\"description\": \"第一个node.js程序\",\n\t\"keywords\":[\"node.js\",\"javascript\"], // 关键词，有助于 npm search 发现\n\t\"repository\": { // 存储库，指定代码所在位置（如果git repo在GitHub上，那么该npm docs 命令将能够找到文件位置。）\n\t\t\"type\": \"git\",\n\t\t\"url\": \"https://path/to/url\"\n\t},\n\t\"license\":\"MIT\", // 指定包许可证，详细可见[SPDX许可证ID的完整列表](https://spdx.org/licenses/)\n\t\"engines\": {\"node\": \"0.10.x\"}, // 指定该模块运行的平台，可以指定 node 版本、npm 版本等\n\t\"bugs\":{\"url\":\"http://path/to/bug\",\"email\":\"bug@example.com\"}, // 项目问题跟踪器的URL和应报告问题的电子邮件地址。\n\t\"contributors\":[{\"name\":\"李四\",\"email\":\"lisi@example.com\"}],\n    \"bin\": { // 指定内部命令对应的可执行文件的位置，在 scripts 中就可以简写\n    \t\"webpack\": \"./bin/webpack.js\"\n  \t},\n    \"main\": \"lib/webpack.js\", // 指定加载的模块入口文件，require('moduleName')就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。\n    \"config\" : { \"port\" : \"8080\" }, // 用于添加命令行的环境变量（用户在运行 scripts 命令时，就默认在脚本文件中添加 process.env.npm_package_config_port，用户可以通过 npm config set foo:port 80 命令更改这个值）\n\t\"scripts\": { // 指定运行脚本的 npm 命令行缩写\n\t\t\"start\": \"node index.js\"\n\t},\n    \"peerDependencies\": { // 指定项目安装必须一起安装的模块及其版本号，（注意：从 npm 3.0 开始，peerDependencies不会再默认安装）\n    \t\"chai\": \"1.x\"\n  \t},\n\t\"dependencies\": { // 指定项目运行所依赖的模块\n\t\t\"express\": \"latest\",\n\t\t\"mongoose\": \"~3.8.3\",\n\t\t\"handlebars-runtime\": \"~1.0.12\",\n\t\t\"express3-handlebars\": \"~0.5.0\",\n\t\t\"MD5\": \"~1.2.0\"\n\t},\n\t\"devDependencies\": { // 指定项目开发所需要的模块\n\t\t\"bower\": \"~1.2.8\",\n\t\t\"grunt\": \"~0.4.1\",\n\t\t\"grunt-contrib-concat\": \"~0.3.0\",\n\t\t\"grunt-contrib-jshint\": \"~0.7.2\",\n\t\t\"grunt-contrib-uglify\": \"~0.2.7\",\n\t\t\"grunt-contrib-clean\": \"~0.5.0\",\n\t\t\"browserify\": \"2.36.1\",\n\t\t\"grunt-browserify\": \"~1.3.0\",\n\t},\n    \"browser\": { // 指定该模板供浏览器使用的版本\n  \t\t\"tipso\": \"./node_modules/tipso/src/tipso.js\"\n\t},\n    \"preferGlobal\": true, // 表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。\n}\n```\n\n`package.json` 在 node 和 npm 环节都要使用，node 在调用 `require` 的时候去查找模块，会按照一个次序去查找，`package.json` 会是查找中的一个环节。npm 用的就比较多，其中的 `dependencies` 字段就是本模块的依赖的模块清单。每次`npm update`的时候，npm会自动的把依赖到的模块也下载下来。当`npm install` 本模块的时候，会把这里提到的模块都一起下载下来。通过package.json,就可以管理好模块的依赖关系。\n\n关于更多规范，请看官方[npm-package.json](https://docs.npmjs.com/files/package.json.html)\n\n---\n<!--more-->\n\n### 二. 版本号规范\n* **指定版本**：比如`1.2.2`，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n* **波浪号（tilde）+指定版本**：比如`~1.2.2`，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。\n* **插入号（caret）+指定版本**：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。**需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。**\n* **latest**：安装最新版本。\n\n### 三. npm install 与 **npm update**\n* 如果本地 `node_modules` 已安装，再次执行 `install` 不会更新包版本, 执行 `update` 才会更新; 而如果本地 `node_modules` 为空时，执行 `install/update` 都会直接安装更新包;\n* `npm update` 总是会把包更新到符合 `package.json` 中指定的 semver(语义化版本) 的**最新**版本号——本例中符合 `^1.8.0` 的最新版本为 `1.15.0`\n* 一旦给定 `package.json`, 无论后面执行 `npm install` 还是 `update`, `package.json` 中的 webpack 版本一直顽固地保持 一开始的 `^1.8.0` 岿然不动\n\n### 四. npm i 与 **npm install**\n实际使用的区别点主要如下：\n\n* 用`npm i`安装的模块无法用`npm uninstall`删除，用`npm un`才卸载掉\n* `npm i`会帮助检测与当前 node 版本最匹配的 npm 包版本号，并匹配出来相互依赖的 npm 包应该提升的版本号\n* 部分 npm 包在当前 node 版本下无法使用，必须使用建议版本\n* 安装报错时 install 肯定会出现 `npm-debug.log`  文件，`npm i`不一定\n\n### 五. npm devDependencies 与 dependencies\n`--save-dev`\n\n或\n\n`—save`\n\n首先需要说明的是 Dependencies一词的中文意思是依赖和附属的意思，而dev则是 develop（开发）的简写。\n\n所以它们的区别在 package.json 文件里面体现出来的就是，使用 `--save-dev` 安装的 插件，被写入到 devDependencies 域里面去，而使用 `—save` 安装的插件，则是被写入到 dependencies 区块里面去。\n\n那 package.json 文件里面的 devDependencies  和 dependencies 对象有什么**区别**呢？\n\n**devDependencies  里面的插件只用于开发环境，不用于生产环境，而 dependencies  是需要发布到生产环境的**。\n\n比如我们写一个项目要依赖于jQuery，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies\n\n### 六. 全局安装与本地安装\n通过 `-g` 来安装的包，将包安装成全局可用的可执行命令。\n\n#### 1. 全局安装， 将包安装成全局可用的可执行命令\n```js\n// 全局安装 babel-cli\nbabel app.js\n```\n\n#### 2. 本地安装\n```js\n// 本地安装 babel-cli\nnode_modules/.bin/babel app.js\n```\n\n#### 3. 修改全局安装默认路径\n* 设置自定义的全局安装路径\n  ```js\n  npm config set prefix \"/usr/local/npm\" // 自定义的全局安装路径\n  npm config set cache \"/usr/local/npm\" // 自定义的全局安装路径\n  ```\n* 设置环境变量\n  切到  ~/.bash_profile 文件中配置路径：\n  ```js\n  GNPM_PATH=/usr/local/npm\n  export GNPM_PATH\n  export PATH=$PATH:$GNPM_PATH/bin  // 将 /usr/local/npm/bin 追加到 PATH 变量中\n  export NODE_PATH=$PATH:$GNPM_PATH/lib/node_modules // 指定 NODE_PATH 变量\n  ```\n  \n  \n  操作系统中都会有一个`PATH`环境变量，想必大家都知道，当系统调用一个命令的时候，就会在PATH变量中注册的路径中寻找，如果注册的路径中有就调用，否则就提示命令没找到。\n  而 `NODE_PATH` 就是`NODE`中用来 **寻找模块所提供的路径注册环境变量** 。我们可以使用上面的方法指定`NODE_PATH` 环境变量。\n  使用 `npm config list` 查看配置\n\n### 七. npm 包命令\n```js\nnpm list -g --depth 0 // 查看全局安装过的包 -g:全局的安装包 list：已安装的node包 –depth 0：深度0\nnpm view <packageName// 查看npm服务器中包版本号 \nnpm info <packageName// npm服务器更多信息，更多版本号\nnpm ls <packageName// 本地包\nnpm ls <packageName-g // 全局安装包\nnpm docs // 打开包git目录\n\n// 注意：npm build 与 npm start 是项目中常用的命令，注意它们有什么不同\nnpm start [--<args>] // 在 package.json 文件中定义的 \"scripts\" 对象中查找 \"start\" 属性，执行该属性定义的命令，如果没有定义，默认执行 node server.js 命令\nnpm build [<package-folder>] // 其中，<package-folder为其根目录中包含一个 package.json 文件的文件夹，这是由 npm link 命令和 npm install 命令组成的管道命令，通常在安装过程中被调用。如果想要直接运行它，则运行 npm run build\n```\n\n还有其他的 钩子命令，具体项目中我还没用到，你可以自行了解。\n\npackage.json 中 scripts 常用命令：\n\n```js\n// 删除目录\n\"clean\": \"rimraf dist/*\",\n\n// 本地搭建一个 HTTP 服务\n\"serve\": \"http-server -p 9090 dist/\",\n\n// 打开浏览器\n\"open:dev\": \"opener http://localhost:9090\",\n\n// 实时刷新\n \"livereload\": \"live-reload --port 9091 dist/\",\n\n// 构建 HTML 文件\n\"build:html\": \"jade index.jade dist/index.html\",\n\n// 只要 CSS 文件有变动，就重新执行构建\n\"watch:css\": \"watch 'npm run build:css' assets/styles/\",\n\n// 只要 HTML 文件有变动，就重新执行构建\n\"watch:html\": \"watch 'npm run build:html' assets/html\",\n\n// 部署到 Amazon S3\n\"deploy:prod\": \"s3-cli sync ./dist/ s3://example-com/prod-site/\",\n\n// 构建 favicon\n\"build:favicon\": \"node scripts/favicon.js\",\n```\n\n### 八. 简写形式\n```js\nnpm start   // 是 npm run start 的简写\nnpm stop    // 是 npm run stop 的简写\nnpm test    // 是 npm run test 的简写\nnpm restart // 是 npm run stop && npm run restart && npm run start 的简写\n```\n\n### 九. process\n我们可以通过环境变量`process.env`对象，拿到 npm 所有的配置变量。其中 npm 脚本可以通过`npm_config_`前缀，拿到 npm 的配置变量。通过`npm_package_`前缀，拿到`package.json`里面的字段。\n\n```js\nconsole.log(process.env.npm_package_name); // chejianer\nconsole.log(process.env.npm_package_version); // 1.0.0\nconsole.log(process.env); // ... \n```\n\n对于 **全局模式安装的包（通过 -g 来安装的包，将包安装成全局可用的可执行命令，并不意味着任何地方都可以通过 require() 来引用它）**：它会通过 bin 字段配置，将实际脚本链接到 Node 可执行目录下，例如\n\n```js\n\"bin\": {\n  \"webpack\": \"./bin/webpack.js\"\n},\n```\n\n通过全局安装的包都安装到一个统一的目录下，可以通过以下方式获得:\n\n```js\npath.resolve(process.execPath, \"..\", \"..\", \"lib\", \"node_modules\") \n// 例如：/usr/local/lib/node_modules\n```\n\n### 一零. npm 发布包\n* **创建一个空文件**：\n\n```js\n// lib/index.js\nexports.sayHello = function () {\n    return \"Hello An!\";\n};\n```\n\n* **运行：`npm init`**\n\n```js\npackage name: (module) hello-an\nversion: (1.0.0) 0.1.0\ndescription: a hello-an package\nentry point: (hello.js) \ntest command: \ngit repository: \nkeywords: hello an\nauthor: sisterAn\nlicense: (ISC) MIT\nAbout to write to /Users/lianran777/Study/node/chejianer_node/module/package.json:\n\n{\n  \"name\": \"hello-an\",\n  \"version\": \"1.0.0\",\n  \"description\": \"a hello-an package\",\n  \"main\": \"hello.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [\n    \"hello\",\n    \"an\"\n  ],\n  \"author\": \"sisterAn\",\n  \"license\": \"MIT\"\n}\n\n\nIs this OK? (yes) \n```\n\n* **注册 npm 包仓库账号**\n\n```js\nnpm adduser\n```\n\n* **上传包**\n\n```js\nnpm publish . // package.json 所在目录\n```\n\n在这个过程中，npm 会将目录打包成一个存档文件，然后上传到官方源仓库中\n\n* **管理包权限**\n\n```js\nnpm owner add <user[<@scope>/]<pkg>\nnpm owner rm <user[<@scope>/]<pkg>\nnpm owner ls [<@scope>/]<pkg>\n```\n\n在自己的项目中安装包 `npm install`，通过 `npm ls` 分析模块路径找到的所有包，并生成依赖树。\n","tags":["工具"],"categories":["知识"]},{"title":"浏览器兼容问题总结","url":"%2F2019%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html","content":"\n1. png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.\n\n2. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一\n\n3. IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。\n\n浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 10px;}\n\n这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 _display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)\n\n```css\n.bb{\n    background-color:red;/*所有识别*/\n    background-color:#00deff\\9; /*IE6、7、8识别*/\n    +background-color:#a200ff;/*IE6、7识别*/\n    _background-color:#1e0bd1;/*IE6识别*/\n}\n```\n---\n<!--more-->\n\n4. IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;Firefox下,只能使用getAttribute()\n获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。\n\n5. IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。\n\n6. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; \n\n7. 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:\n\nL-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}\n\n8. 样式初始化\n- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。\n\n- 初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。\n\n最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议）\n```css\nbody, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }\nbody, button, input, select, textarea { font:12px/1.5tahoma, arial, \\5b8b\\4f53; }\nh1, h2, h3, h4, h5, h6{ font-size:100%; }\naddress, cite, dfn, em, var { font-style:normal; }\ncode, kbd, pre, samp { font-family:couriernew, courier, monospace; }\nsmall{ font-size:12px; }\nul, ol { list-style:none; }\na { text-decoration:none; }\na:hover { text-decoration:underline; }\nsup { vertical-align:text-top; }\nsub{ vertical-align:text-bottom; }\nlegend { color:#000; }\nfieldset, img { border:0; }\nbutton, input, select, textarea { font-size:100%; }\ntable { border-collapse:collapse; border-spacing:0; }\n```\n\n9. CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？\n\n对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.\n如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.\n仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.\n\n10. 让页面里的字体变清晰，变细用CSS怎么做？\n-webkit-font-smoothing: antialiased;\n\n11. display:inline-block 什么时候会显示间隙？\n移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing\n","tags":["兼容性"],"categories":["知识"]},{"title":"租房须知","url":"%2F2019%2F%E7%A7%9F%E6%88%BF%E9%A1%BB%E7%9F%A5.html","content":"## 文档目的\n\n希望这篇文档能够帮助到北上广深杭等租房漂泊的同学在找房的时候规避一些明显的问题。\n\n这里枚举了一些常见问题，适当参考文档作出一个判断，或许可以减少租客和房东都不开心的情况的出现，并节约时间。\n\n作为租客，即使在预算并不充裕，或者稍低于目标区域平均价格的时候，也可以找到靠谱的房子，只要策略得当。\n\n希望看过文档的同学可以少遇到居住不舒服的房子，至少，不要遇到居住那么不舒服的房子 :D\n\n---\n<!--more-->\n\n## 租房要点\n\n**一般原则：**\n\n* 尽量提前进行房源的寻找，不要等到房子到期、或者旺季（财年结束跳槽季、毕业季、实习季）的时候进行。\n* 尽量寻找直租房屋，不推荐经过“转交”的房源，除非你对转手房源的人信得过。\n* 寻找房源前，请确定清楚预算和期望居住的区域，提高找房效率，避免无意义时间浪费。\n\n**特殊情况下的一般推荐策略：** \n\n### 如果租房者时间紧迫\n\n- 不太介意暂时没有独立的空间，请优先在公司群、公司或高校BBS、同学群中进行询问，看看是否有人愿意同你分享房子或者信息，相对知根知底的同事、同学比陌生人靠谱的概率大的多。\n- 请在本地寻找当地相对最大最正规的中介连锁。\n- 如果行李不多，部分青旅可以扛几天。（12年有同事这么经历过）\n\n### 如果一定要和中介打交道\n\n如果有可能，尽可能不要租中介的房子，尤其是市场占有率低的小中介，可能发生以下问题：\n\n1. 代理人中途跑路或以各种各样的方式进行诈骗。\n2. 合约到期后，以各种手段侵占押金。\n3. 屋内财务不翼而飞。\n\n**黑名单：**\n\n开来营，活跃于回龙观，霍营，龙泽地区，从2011年开始行骗至今，据不完全统计已有数百人上当受骗，其本人依靠骗来的钱财，购置了一处房产，买了一辆50多w的豪车，雇佣了保镖以及打手数人。被骗人员多次报警，起诉，均无果，任由开来营继续逍遥法外。\n\n### 有幸遇到房东直租\n\n“好”房东很重要，如果感觉气场不和，请不要将就，对双方都不好。\n\n- 因为供暖排水门锁证件等偶发的琐事产生沟通的时候，房东与你于之前的租客进行对比“之前租客都没问题”，请小心，推荐和爽快的人沟通，可以避免下面的许多问题（房子质量好同样可以大概率避免问题）。\n- **不要急于交定金/押金，多数是套路**（房源确实抢手的时期，房东靠谱，交全款也没事）\n- 去现场看房子的时候，如果房子很破，屋内东西乱丢，99%是二房东或者刚买来专门用来出租的屋子，请多留意屋子中的排水和保暖问题。\n- 靠谱房东，在你看房子的时候，多数会主动跟你沟通和妥协：“这个灯不好，我下午给你换了”对比“这个将就一下也能用”好坏立辨，但也请判别是否是专业中介，只说不做的那种...\n\n### 期望合租的房客\n\n不论是为了节约租房成本，控制房租在个人经济支出比重，还是考虑有个互相照应、结识新朋友，来到大城市的前期，合租是个不错的选择。\n\n- 你单枪匹马，屋子已经有其他房客入住\n\t- 尽可能了解到对方是从事什么职业，以及是否为常住人员。避免和经常流动的人员同住，发生潜在的安全隐患以及财物损失。\n\t- 尽可能了解房屋基础安全设施是否到位\n\t\t- 是否存在老化的煤气管道、开关，房东是否愿意修理或者更换，或者允许租客修理替换。\n\t\t- 是否存在随处可见的烟头。\n\t\t- 是否存在同住房客随意带陌生人留宿的现象\n- 你和小伙伴组队租房\n\t- 大家觉得都OK最重要\n\t- 其他参考上面的事项\n\n### 相对靠谱的房子来源\n\n任何一个平台、渠道信息量大之后，难免出现“有效信息质量下降”，诸如赶某网、5某网、搜某网、豆某小组等网站，上面的中介&伪装成中介的骗子居多，如使用该渠道，请仔细辨别：\n\n- 请优先使用校园论坛、朋友介绍、公司BBS、熟人IM社群等信息，但是同样需要仔细辨别信息真实程度。\n- 除了主动或者被动（被相关信息网站标记）显示是中介的，包含以下信息大概率为二房东：\n\t- 对标题做过特别优化等内容、发布内容格式特别“规范化”，例如：五道口地铁附近三室一厅朝南房主直急租月付季付当面可谈（巴不得内容全部在标题中体现）。\n\t- 房子照片可以在其他非租房信息发布的地方被搜到，多数为效果图、设计图等。推荐使用搜索引擎以图搜图来判别。\n\t\t- 同一手机号码发布多条不在同一地点的房源，基本是骗子类型的中介。\n\t\t- 张贴满大街的广告并非一般房东所为，一般为二房东或者小中介。\n\t- 黑中介的特点无非是：\n\t\t- **广泛投放性价比高出市场对信息**：在各种分类信息网站或者论坛投放大量描述红红绿绿、价格远低于市场价、描述看起来很好、效果图惊艳的房子。\n\t\t- **避免直接与客户进行沟通露馅**：打电话联系他们，会被对方草草挂掉，然后短信回复你，告知你一个公司的所在地，让你来公司办理入住业务。\n\t\t- **在看房之前急于促成租房合同**：去公司之后，一个劲保证你想要住的地方绝对有房子，先签合同会有专人带你看房。交完佣金之后，可能会给你一套破烂到不行的房子。\n\t\t- **电话里沟通过的房子在带看的时候进行更换**：电话里沟通好的房子，见面后告知刚被出租出去，恰好有另外一个惊喜的房子在等待你；在你不满意时，就带你去一个别的小区（不是你原计划居住的小区），带你去的小区往往是居住条件不好，房子多没人住的小区。同时，房东会因为找中介给佣金而提高房价。\n\t\t- 这样你用高价住了破房子还甩给了黑中介一笔佣金。\n\n### 可能被夸大描述的信息\n\n在签合同入住之前，请客观对房子进行评价，对房屋信息做到眼见为实，而不是轻信描述信息。\n\n- 大\n- 安静\n- 朝向南\n- 有某设施\n- 低时间成本\n- 超高的性价比\n\n展开描述一下：\n\n- 房子的平米数据很漂亮，但是有的二房东可以把一个70平米的房子拆成4个25平米的房子租出去。\n- 建议在房子内多待一阵，计划长租可以白天晚上都去房子里看看，街道、邻居是否过分喧哗。\n- 朝向这个是玄学、西南向的房子不太好住。\n- 带阳台、带窗户。注意，“带”和“带有用的”是两回事。\n- 离地铁 5～10 分钟，可能需要特别的大长腿，或者步幅特别快。\n\n总之，基本上除了地方可以勉强信一下，其他信息在眼见为实之前基本不要轻信。\n\n- 如果是中介，不要相信不要中介费，羊毛出在羊身上。\n- 如果找中介，请找靠谱中介。所谓靠谱，就是必须至少十几家以上连锁，店面名字你听说过。不然貌似省下来的中介费，最终很有可能会从诸如说你破坏东西扣除或者赖着不给你的押金、签合同时突然增加的卫生费（丫才不给你打扫）等等方式找回来。为了省心，请选靠谱中介。\n- 如果不确定中介是否靠谱，可以搜中介名称+骗子，然后自行鉴定。\n- 提前至少两周开始找房子，多打电话，中介一律屏蔽（不然烦死你）。多看房，找到房东之后看房本。合同一定要签，不要犯傻。\n- 如果和中介签合同，尤其不是靠谱中介，合同的每一个字都要看，不要相信他所说的话，合同他都有不承认的时候。\n- 永远不要信，我是房东，我出差在外面，请转账给我老婆。\n- **签合同的小技巧**合同中约定（例如必需水电的故障需要3日内修好，或者说好给你个衣柜之类）的内容房东有时会拒绝执行，在签署合同的时候，首先一切以合同为准，其次在约定中补充*如果不能满足允许房客随时退房，押金不得以任何理由扣留，已经交的租金按日计算返还*，一般会比较有效。\n\n### 签订合同前建议获取的信息\n\n- 先了解和你沟通的出租人**是否有权利出租该房屋**。\n\t- 必须验明房东产权证，验看出租人的身份证是否与产权证一致。\n\t- 代替家人（公公／婆婆／表亲）进行房屋出租的“房东”，是否为戏精租客扮演的二房东，如果是真的亲戚代理房东进行出租，如果出了问题，她能代理和解决么。\n\t- 尽量不要和房东朋友（基友／闺蜜）代理房东出租房屋产生合作，减少不必要麻烦。\n- 租客是否有权再次出租、转租房屋，如果是房东一般不允许出租，转租也是比较抵触的。\n- 房东是否能提供或者办理《房屋租赁许可证》，一般建议到当地街道派出所进行办理，对房东也是一种保护，不过这个会牵扯到一些额外的费用，许多房东会回避掉。\n\t- 该许可证也可能会因为特殊原因没有，如回迁房。\n- 查看房屋的实际使用条件与状况\n\t- 房子的实际使用面积是否能够接受\n\t- 房子的隔音效果是否能接受（邻居、街道）\n\t- 房子的家具是否有严重的气味（装修、家具、环境等因素）\n\t- 窗户是否严密，开关是否正常（漏风）\n\t- 如果阳台没有包裹，建议不要租，会有蚊虫、灰尘，以及保暖隐患。\n\t- 如果周围有工地和马路，不要租，会很喧哗，特殊情况，会喧哗到很晚。\n\t- 如果是老房子，房屋下水（洗手池/马桶/地漏）有问题，不要租，轻则影响自己，重则淹了楼下。\n\t- 如果是老房子，门锁有问题，房东含糊换锁或者不可以换锁的话，不要租。\n\t- 附加：电梯的使用（搬家/购置东西）\n\t- 如果缺少的东西，房东是否能补齐\n\t- 有条件的话，最好可以试住一到两天。检查的时候看不出问题，住进去潜在问题就会出来。\n- 简单了解治安状况\n\t- 小区、单元是否有门禁系统、或者物业保安值守。\n\t- 一般距离地铁越近的小区，流动性越大，距离地铁有十几分钟的走路时间的小区可能是不错的选择（共享单车、顺风车）。\n- 房子周围设施是否相对方便\n\t- 交通措施是否过度单一或者匮乏\n\t- 是否有社区医疗应急（附近有大医院可忽略）\n\t- 附近吃喝的地方多吗（依赖外卖、自己做饭可忽略）\n\t- 便利店、超市、购物中心是否存在，如果购置东西并非全部依赖在线，需要考虑线下购物的便利性。\n\t- 如果只是为了距离上班地点近，可以舍弃一些或者全部\n- **针对在上海的同学们：** 需要提前和与你签协议的人沟通，是否能办理居住证，办理居住证对于希望常驻上海的同学来说很重要，因为有些东西（买车买房小孩上学之类）是要看居住证的年限的。建议将*必须要办理居住证，否则随时可退房*作为补充条款写入。\n- **针对有小孩的同学们** 提前和房东沟通可否办理租住手续（官方），现在租住同权，如果租住的是学区房小孩可以在该学区上学，但是有的时候一些自己有小孩的房东可能会拒绝。\n- 明确公用的基础设施的使用和维修：对于群租的同学来说，**卫生间（热水器，洗衣机），厨房（煤气灶、冰箱、微波炉）**很可能是公用的，当公用的设施损坏以后，维修的责任需要在合同中厘清，并且规定维修时间，以防止房东或者二房东推脱责任，或者拖延不予维修。\n\n### 明确费用\n\n明确以下费用由谁承担，可以注明数字时间的费用建议进行备注说明。\n\n- 水费\n\t- 是否分冷水/热水/清洁用水，如果区分单独确定费用。\n\t- 比如北京热水涨价汹涌，问清楚价格，和充值方式（特别远的话，使用的话，多充值一点）。\n\t- 热水可能以非常长的时间为缴纳周期，入住时，确保热水费用之前房东和中介是正常缴纳的。（遇到过几年没缴纳过热水费的自如房子）\n- 电费\n\t- 缴费方式，自己交电卡，有无电卡，还是代缴，价格。\n\t- 是否为商用电（部分住宅是商用电）\n- 煤气费\n\t- 酒店公寓可能没有煤气，不存在煤气费一说。\n\t- 如果依赖此项目，优先查看。\n\t- 煤气费可能以非常长的时间为缴纳周期，入住时，确保煤气费用之前房东和中介是正常缴纳的。（遇到过几年没缴纳过煤气费的自如房子）\n- 电话费\n\t- 有的房子不存在此项，但是有的房子会是和房东手机绑定一起的。\n\t- 如果是合租的人绑定手机，那么要查看单子缴费是月度/季度/年度。\n-  电视费用\n\t- 即使你不使用这个设备，这个费用也要询问的，以免账单突然多出一年费用。\n- 卫生费\n- 物业费\n- 网费\n- 供暖费\n\t- 仅限北方，明确暖气费谁来承担，到了冬天才发现合同上未见说明。租金是承担了暖气费的标准的价格，但是却要自己交。以及暖气片存在位置会不会和合租人员产生缴费分歧。\n- 维修费和附带影响\n\t- 房东仓促做防水，防水坏掉了，楼下水漫金山，要维修，你可能要一半个月不能用卫生间。\n\t- 年代久远的空调因漏气/坏件，还要租客你承担费用的情况，另外如果是发生在南方冬天...\n\t- 灯泡这类易耗品最好也问下，一年不到，不知道是质量问题还是电压，换了4/5个，直到换了LED灯\n- 损坏赔偿\n\t- 如果存在某些情况，这个时候赔偿是补新，还是几倍价格，还是如何，确认清楚\n- 另外需要查看是否有欠费\n\t- 曾经遇到欠费600多的煤气费的业主出国，居委会三天两头上门找\n- 租赁期间对房屋修缮\n\t- 房屋以及附属设备出现问题或者故障，由谁维护，费用由谁承担\n\n### 租金支付\n\n- 租金由出租人收取，是承租人使用房屋的对价;\n- 物业管理费则由物业管理公司收取，是物业公司以自己的经营活动为所有业主、租户提供服务所收取的费用，二者不是一个法律关系，不能混为一谈。\n- 但如双方在合同中对于此项无具体约定，则出租人无权要求承租人支付物业管理费。\n- 签订租赁合同时要仔细阅读合同条款，对于模糊内容要详加询问，并落实于字面。\n\t- 在双方签订《房屋租赁合同》时最好将屋内所有物品详列一份清单，作为其合同附件收好。\n\t- 如果可能多复印一份，我和舍友租房子，结果都找不到合同了。\n\t- 合同明确租期内，房东是否可以涨价\n\t- 合同明确押金以及押金退换方式（**这里是深水区**）\n\t- 留意退房时卫生的字眼，比如“退房时房屋没有打扫干净，要扣200押金”。退房时的卫生要做到什么程度，要和房东提前明确，最好留录音和租房前的房屋照片。避免退房时被恶心房东刁难。\n- 如果万一不可避免地与奇葩房东发生冲突，可以参考以下维权案例\n\t- [DIY 打官司](https://g.leaskh.com/2014/11/13/DIY-打官司-目录/)\n\n### 退房退租\n\n- 不管出于什么原因，请尽早至少半个月，推荐一个月，和房东说明，以免耽误房东再次转租，影响自己的押金和人品。\n- 在退房前，如果钥匙丢失，不能如数退还给房东。建议尽可能配一把钥匙。以免房东以影响安全的名义要你换锁。其实就是变相要扣押金，不要给他开口的机会。\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"webpack","url":"%2F2019%2Fwebpack.html","content":"\n## 谈谈你对webpack的看法\nwebpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。\n\n## webpack的基本功能和工作原理？\n- 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等\n- 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等\n- 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载\n- 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件\n- 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器\n- 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过\n- 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。\n\n## webpack构建过程\n- 从entry里配置的module开始递归解析entry依赖的所有module\n- 每找到一个module，就会根据配置的loader去找对应的转换规则\n- 对module进行转换后，再解析出当前module依赖的module\n- 这些模块会以entry为单位分组，一个entry和其所有依赖的module被分到一个组Chunk\n- 最后webpack会把所有Chunk转换成文件输出\n- 在整个流程中webpack会在恰当的时机执行plugin里定义的逻辑\n\n## webpack打包原理\n将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载\n---\n<!--more-->\n\n## 什么是webpack，与gulp,grunt有什么区别\n- webpack是一个模块打包工具，可以递归地打包项目中的所有模块，最终生成几个打包后的文件。\n- 区别：webpack支持代码分割，模块化（AMD,CommonJ,ES2015），全局分析\n\n## 什么是entry,output?\n- entry 入口，告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/index.js\n- output 出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist\n\n## 什么是loader，plugins?\n- loader是用来告诉webpack如何转换某一类型的文件，并且引入到打包出的文件中。\n- plugins(插件)作用更大，可以打包优化，资源管理和注入环境变量\n\n## 什么是bundle,chunk,module?\nbundle是webpack打包出来的文件，chunk是webpack在进行模块的依赖分析的时候，代码分割出来的代码块。module是开发中的单个模块\n\n## 如何自动生成webpack配置？\n可以用一些官方脚手架\n\n- webpack-cli\n- vue-cli\n\n```js\n// 首先安装\nnpm install -g @vue/cli\n// 新建项目hello\nvue create hello\n```\n\nnuxt-cli\n```js\n// 确保安装了npx,npx在npm5.2.0默认安装了\n// 新建项目hello\nnpx create-nuxt-app hello\n```\n\n## webpack如何配置单页面和多页面的应用程序？\n```js\n// 单个页面\nmodule.exports = {\n    entry: './path/to/my/entry/file.js'\n}\n\n// 多页面应用程序\nmodule.entrys = {\n    entry: {\n        pageOne: './src/pageOne/index.js',\n        pageTwo: './src/pageTwo/index.js'\n    }\n}\n```\n\n## 几个常见的loader\n- file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件\n- url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去\n- source-map-loader：加载额外的 Source Map 文件，以方便断点调试\n- image-loader：加载并且压缩图片文件\n- babel-loader：把 ES6 转换成 ES5\n- css-loader：加载 CSS，支持模块化、压缩、文件导入等特性\n- style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。\n- eslint-loader：通过 ESLint 检查 JavaScript 代码\n\n## 几个常见的plugin\n- define-plugin：定义环境变量\n- terser-webpack-plugin：通过TerserPlugin压缩ES6代码\n- html-webpack-plugin 为html文件中引入的外部资源，可以生成创建html入口文件\n- mini-css-extract-plugin：分离css文件\n- clean-webpack-plugin：删除打包文件\n- happypack：实现多线程加速编译\n\n```js\nvar UglifyJSPlugin = require('uglifyjs-webpack-plugin');\nvar webpack = require('webpack');\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\nvar providePlugin = new webpack.ProvidePlugin({$: 'jquery', jQuery: 'jquery', 'window.jQuery': 'jquery'});\nmodule.exports = {\n    entry: {\n        index: './src/js/index.js',\n        goodsInfo: './src/js/goodsInfo.js'\n    },\n    output: {\n        filename: '[name].js',\n        path: __dirname + '/out',\n        publicPath: 'http://localhost:8080/out'\n    },\n    module: {\n        rules: [\n            {test: /.js$/, use: ['babel-loader']},\n            // // {test: /.css$/, use: ['style-loader','css-loader']},\n            // {\n            //     test: /.css$/,\n            //     use: ExtractTextPlugin.extract({\n            //       fallback: \"style-loader\",\n            //       use: \"css-loader\"\n            //     })\n            // },\n            {test: /.jpg|png|gif|svg$/, use: ['url-loader?limit=8192&name=./[name].[ext]']}, \n            {test: /.less$/, use: ['style-loader', 'css-loader', 'less-loader']}\n        ]\n    },\n    plugins: [\n        new UglifyJSPlugin(),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: \"commons\",\n            filename: \"commons.js\",\n            minChunks:2}),  \n        new ExtractTextPlugin(\"[name].css\"), \n        providePlugin     \n    ]\n}\n```\n","tags":["打包"],"categories":["工具"]},{"title":"成为优秀程序员的建议","url":"%2F2019%2F%E6%88%90%E4%B8%BA%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BB%BA%E8%AE%AE.html","content":"\n### 1. 善用google⭐   \n作为一名程序员，你要知道如何搜索问题的答案。学会有效的使用google，你将节省大量开发时间。  \n\n### 2. 谨慎承诺超额交付⭐\n让你的团队知道一项任务需要三周的时间，并在两周内完成，这比让他们知道相反的情况要好。通过谨慎承诺和超额交付，你会建立信任。\n   \n### 3. 善待产品设计人员，他们是你的朋友   \n产品设计人员为用户的痛点提供解决方案。向他们学习，团结一致地构建有效的产品。\n\n### 4. 找到一名导师  \n找到一个可以学习和借鉴的人。如果你需要技术指导，[Coding Coach](https://codingcoach.io/)会是一个不错的地方。\n\n### 5. 成为一名导师   \n做一个别人可以学习和借鉴的人。你可以尝试在[Coding Coach](https://codingcoach.io/)成为别人的导师。\n\n### 6. 写些有用的评论\n写下有用的回答而不是问为什么，mark和灌水也没什么意思。\n\n---\n<!--more-->\n\n### 7. 合理的命名变量和函数名  \n函数和变量应该准确地表示它们的用途，因此myCoolFunction不是一个好名字。\n\n### 8. 给自己放个假   \n我们都需要时间来缓解压力。去一个你一直想去的地方放个假。你的大脑和同事都会感谢你的。\n\n### 9. 删除无用代码⭐   \n没有理由积累更多技术债务。\n\n### 10. 学会阅读代码⭐ \n阅读代码是一项非常宝贵的被低估的技能。\n\n### 11. 找到健康工作和生活平衡点   \n结束一周的工作之后，周末放松一下。关闭工作通知，删除手机上的应用程序。\n\n### 12. 只安排必要的会议 \n能用邮件解决的就没必要开会，如果非要开，也应该让会议简短高效。\n\n### 13. 结对编程   \n结对编程可以让你同时扮演老师和学生的角色。\n\n### 14. 写好邮件\n邮件的内容应该简洁而清晰，抓住重点。没人会想看你的四页邮件，兄弟。\n\n### 15. 加入社区⭐\n和志同道合的人在一起会激励你走出低谷。\n\n### 16. 清理你的分支⭐\n清理你的版本控制分支，就像在你的岳父母来访之前清理你的房子一样。如果你不再需要，请删掉它，不删留着过年啊。\n\n### 17. 接纳萌新\n包容点，不要告诉别人不够好，不能进入这个行业，每个人都是有价值。\n\n### 18. 活到老学到老   \n你选择了一个需要不断学习的职业，学会爱上它。\n\n### 19. 永不言弃   \n这并不容易，但是我们都是从同一个地方开始，你也能做到。  \n\n### 20. 敢于接受有挑战性的任务⭐ \n如果任务没有挑战，它就不会帮助你成长。\n\n### 21. 项目开始前明确需求⭐\n在开撸之前，你应该了解验收标准，这将为你节省时间和痛苦。\n\n### 22. 工欲善其事，必先利其器⭐   \n拥有一套你熟悉的工具，了解哪些工具服务于哪些目的，以及项目何时可以从使用这些工具中获益。\n\n### 23. 我们需要建设性的批评   \n向信任的同事和朋友寻求建设性的批评，它将帮助你更优秀。 \n\n### 24. 保持开放思维⭐\n技术在变化，而且变化得很快。不要反对新技术，学习它，然后形成自己的观点。 \n\n### 25. 保持在技术前沿，不要掉队⭐\n通过关注出版物，博客，播客和科技新闻，及时了解最新的科技新闻。\n\n### 26. 专注于解决问题⭐ \n锻炼自己解决问题的能力，强大的解决问题的能力能够帮助你应付一切，专注于解决问题的方法。\n\n### 27. 保持谦虚⭐\n三人行必有我师，无论你什么头衔，什么公司，都要保持谦逊。\n\n### 28. 不光要代码写的好，PPT也要讲得好  \n学习如何吸引你的听众，并给出有效的演示。\n\n### 29.  选型如买菜，也要货比三家⭐     \n给自己更多选择，在开展工作前，调研尽可能多的解决方案。\n\n### 30. 找到自己的定位⭐   \n科技产业也有很多分类，找到你最感兴趣的领域，并成为一名专家。\n\n### 31. 养成好习惯⭐   \n试着建立一致的、健康的习惯，比如保持专注，合理安排时间，出席会议，从最重要的任务开始。这可能需要一些时间来适应，但从长远来看是值得的。\n\n### 32. 学会debug⭐ \n探索浏览器调试器工具。学习使用IDE调试的细节。通过学习最有效的调试问题和跟踪错误的方法，再困难的bug也能搞定。\n\n### 33. 锻炼你现有的技能⭐     \n并不是说你已经掌握了一项技能就不需要再锻炼它。业精于勤荒于嬉，除非有意识地提高技能，否则技能会随着时间的推移而消失。而这个行业又发展得如此之快，坚持练习是很重要的。从“我一直都是这样做的”的心态中走出来，进入“有没有更好的方法来做这件事”的心态。  \n\n仅仅是因为你现在拥有六块腹肌，不意味着你就可以每天吃一个🍩。\n\n### 34. 了解原因⭐   \n有时你必须表达自己的意见，因此了解其背后的原因非常重要。为什么解决方案A比解决方案B更好？提供有效的论据，你的意见将更加可靠。\n\n### 35. 了解自己的价值   \n技术也是商品，应该得到适当的报酬。了解你所在地区的行业平均水平。如果你赚的钱少了，是时候和你的老板谈谈，追求你应得的。\n\n### 36. 不要害怕寻求帮助⭐   \n如果你被困在一个问题上，花了太多时间寻找解决方案，是时候寻求帮助了。我们都是人，我们都需要帮助，寻求同事的援助并不可耻。\n\n### 37. 学会学习⭐ \n人们学习的方式不同，有些人通过视频教程学得最好，有些人通过阅读书籍学得最好。弄清楚你的学习风格，然后努力实践。\n\n### 38. 与人为善   \n有时你会被要求向同事提供反馈，友善一点，你可以对某位同事不够积极表达看法，而不是出言不逊。\n\n### 39. 休息一下 \n连续敲8个小时代码几乎是不可能，你很快就会筋疲力尽，犯很多错误。所以设个闹钟来提醒自己停下来休息一下。去散散步，和同事一起喝杯咖啡，远离屏幕会对你的工作效率和质量产生积极的影响。\n\n### 40. 跟踪你的学习进度\n学习编程需要时间，当你看不到进展时，你会感到非常沮丧。所以跟踪你的成就和实现目标的进展非常重要。在你的电脑旁边放一个小清单，每次你完成一件事，把它写下来，不管它有多小，最终将会从量变到质变。\n\n### 41. 不要依赖库和框架⭐\n掌握一个框架和库不如深入学习这门语言，没有必要一个接一个的学习这些库和框架，但是理解框架和库如何实现可以帮助你写出更简洁强壮的代码。\n\n### 42. 学会爱上代码审查\n让别人阅读和分析你的代码可能会让你不安，但是可以提供宝贵的反馈，这会让你成为一个更好的程序员。而且你也应该提高进行良好代码评审的能力。\n\n### 43. 多方位全面学习\n学习其他领域的基础知识, 如设计、营销、前端开发或后端开发。它将帮助你成为一个更全面的程序员。\n\n### 44. 不要选择熟悉的技术，而应该是正确的⭐   \n每个项目都有不同的需求，因此我们必须为这项工作选择合适的工具。尽管选择以前使用过的技术很方便，但是如果它们不适合项目的需要，应该探索其他替代方案。\n\n### 45. 勇于承担责任⭐   \n所有人都会犯错，在你的职业生涯中，你会犯很多很多的错误。因此，当你犯了错误时，站出来承担责任是很重要的，它将与你的团队成员和管理层建立信任。\n\n### 46. 检查自己的代码⭐   \n在发起PR请求之前，检查自己的代码，如果这是同事的工作，你会发表什么评论？在请求代码审查之前首先尝试自己诊断问题或错误非常重要，就像考试交卷前应该自己检查一遍。\n\n### 47. 从失败中吸取教训⭐   \n失败只是没有达到预期的结果，并不一定是件坏事。在我们的职业生涯中，我们会面临很多失败，从失败中学习下次你能做些什么。   \n\n### 48. 正视自己的缺点   \n了解你自己，你的缺点是什么?也许你总是在推送之前忘记更新测试，或者你真的不擅长回复电子邮件。了解你的弱点，这样你就能积极地改善它们。\n\n### 49. 保持好奇心⭐   \n这个行业在不断发展，所以好奇心很重要。如果你不明白什么，不管是项目需求还是一行代码，大声说出来。没有人会因为你要求说明而批评你，你会因此创造出更好的代码。   \n\n### 50. 不要试图学习一切⭐\n世界上有无穷无尽的知识宝库，你不可能征服它。选择几个要掌握的主题，其余的就不要管了。你可以获得其他领域的相关知识，但你不可能掌握所有内容。\n\n### 51.  该舍弃就舍弃\n仅仅因为你写了一些代码并不意味着你需要对它产生感情。没有人喜欢他们所做的工作被丢弃，但是代码有一个生命周期，所以没有必要一直保留着它。\n\n### 52.  团队支持\n优秀的团队相互支持，这为尝试新事物创造了一个安全的空间，而不用担心受到惩罚。\n\n### 53. 在社区中寻找鼓舞\n在行业里找几个你钦佩的人。它会激励你继续你的项目或尝试新事物\n\n### 54. 重视并且珍惜你的工作\n不管你有多少经验或者你的职位是什么，你的工作都是有价值的，给予它应有的价值。\n\n### 55. 排除干扰\n关掉闲置的通知、短信、电子邮件和社交媒体会帮助你集中精力，最大化你的工作日。晚30分钟回复你朋友的信息，他死不了，真有事就打电话了。\n\n### 56. 乐于助人\n试着支持你的团队成员，无论是参加一个重要的演讲，还是在他们遇到困难时帮助他们。\n\n### 57. 不要吝啬你的赞美⭐\n如果有人做得很好，告诉他们。正面反馈是与团队成员建立信任和帮助他们事业发展的好方法。他们也更有可能帮助你\n\n### 58. 测试你的代码⭐\n测试是很重要的。单元测试、回归测试、集成测试、端到端测试。测试你的代码，你的产品将会更加稳定。\n\n### 59. 制定应对计划\n当你收到一个新功能需求或bug修改时，先制定应对计划，你需要什么来解决这个问题或开发这个特性？花几分钟来做这件事，也许后面可以为你节省数小时的沮丧。\n\n### 60. 掌握伪代码\n伪代码是一项很好的技能，因为它允许你在不浪费时间编写代码的情况下考虑复杂的问题。将一种方法写在纸上，运行不同的测试用例，看看缺陷在哪里。\n\n### 61. 记录你的成就\n如果你在工作中获得了嘉奖，把它写下来。如果你开发了一个重要的功能，把它写下来。你会拥有一些积累、沉淀，它将有助于你职业晋升亦或在某一艰难的日子鼓舞你的士气。\n\n### 62. 学习编程基础⭐ \n学习一些基本的排序和搜索算法以及数据结构。它们与语言无关，可以帮助你跨语言解决问题。\n\n### 63. 选择长期维护的技术\n尽管测试最新的技术很有趣，但是选择那些在企业应用程序中易于维护的技术。你们的团队将在未来的岁月里感谢你们。\n\n### 64. 学习设计模式⭐\n设计模式是构建代码的有效工具。你可能不是每个项目都需要它们，但是对它们有一个基本的了解将有助于构建更大的应用程序。\n\n### 65. 化繁为简⭐\n不要编写复杂的代码来展示你高超的编程技能，而要着眼于可读性和简单性。这将使你的团队成员更容易做出贡献。\n\n### 66. 还清技术债务\n技术债务可能会对性能产生巨大影响，所以如果能够重构，就应该重构。（这个建议绝对是好的，但是现实中要面临诸多问题）\n\n### 67. 优先小版本迭代\n与其每个月发布一次大规模的升级，不如更频繁地发布较小的变更。这样你不太可能会引入bug和破坏更改。\n\n### 68. 尽早并经常提交⭐\n尽早提交和经常提交是确保你的工作保持干净的最好方法，并且还可以减少意外地恢复重要更改的压力。\n\n### 69. 了解何时寻求帮助\n你不仅不应该害怕寻求帮助，而且你应该学会什么时候寻求帮助。在寻求帮助之前，你应该试着解决问题，并记录下你尝试的事情。但是当你被一个简单的问题难住一个多小时的时候，代价大于收益，你应该向同事求助。\n\n### 70. 问一些有效的问题⭐\n当你问问题的时候，要尽可能的具体，（可以参考github提issue的要求）。\n\n### 71. 工作中及时寻求反馈\n你的工作不需要完成就能得到反馈。如果你不确定方向，请一位值得信赖的同事来检查你的解决方案的有效性。\n\n### 72. 阅读文档⭐\n文档是关于技术的最纯粹的事实来源，因此学习阅读文档可以快速帮助你成为专家。\n\n###　73. 尽可能做出各种尝试⭐\n没有什么能阻止你尝试解决问题的方法，你有什么损失呢？\n\n### 74. 在会议上积极发言\n你的想法和意见是有价值的，所以参加会议将有助于你与你的团队和管理层建立融洽的关系。\n\n### 75. 跨团队协作\n如果你有机会和公司里的其他团队一起工作，那就去争取吧。\n\n### 76. 保持项目热情\n当你每周工作40个小时时，花时间做你感兴趣的项目是很重要的（72小时的话更要如此）。它们可以帮助你重新找回对编程的热爱，并尝试你在工作中可能无法接触到的新技术。\n\n### 77. 确定你的职业目标⭐\n对你的职业生涯有一个理想的轨迹是很重要的。如果你不这样做，你就是在没有目标的情况下射箭。\n\n### 78. 加入到讨论中来⭐\n在博客上发表评论，参与Twitter主题，参与社区活动，做一个积极的旁观者会比单纯的旁观学到更多东西。\n\n### 79. 确定任务优先级\n学会确定任务的优先顺序将有助于提高您的工作效率，建立一个日常任务和长期任务待办事项列表，并按最重要的顺序排序。\n\n### 80. 不要忽略细节\n细节可以在项目中产生很大的影响。\n\n### 81. 信任你的同事\n你的同事因为他们的技能而被雇佣，交给他们工作，并相信他们能完成。\n\n### 82. 学会委托\n如果你处于领导地位，学习如何有效地委派任务。它会节省你的时间，你不能做所有的事。\n\n### 83. 不要拿自己和别人比较\n你唯一应该比较的是昨天的自己。\n\n### 84. 找到你的盟友\n学习编程将是一个漫长而不怎么容易的过程，和那些帮助你成长并鼓励你坚持下去的人在一起。\n\n### 85. 不要想一步登天⭐\n一开始考虑太多做一个大而全的项目会让你不堪重负。构建时要考虑可伸缩性，但在需要时才开始扩展。这样你就不会用不必要的膨胀来压倒你的团队，而是保持了成长的能力。\n\n### 86. 衡量性能影响⭐\n如果你想使用一种很酷的新技术，你应该权衡这样做的性能影响。你能在不影响性能的情况下实现类似的功能吗？如果可以，你可能需要重新考虑你的方法了。\n\n### 87. 技术歧视不可取⭐\n不要歧视新技术或新想法，对学习新技能的可能性保持开放的心态，也不要歧视他人，我们都值得尊重。（也不要歧视旧技术，即使现在前端框架盛行，但你也不能说Jquery就没有任何可取之处。）\n\n### 88. 申请你不能胜任的工作\n你永远不可能满足工作的所有要求，所以抓住机会申请吧，你有什么损失呢？\n\n### 89. 模块化你的代码\n你可以在一个长文件中编写所有代码，但这是不可维护的。通过模块化，我们确保代码易于理解和测试。\n\n### 90. 不要只是做代码的搬运工⭐\n如果你要复制并粘贴[Stack Overflow](https://stackoverflow.com/)中的解决方案，你应该确切地理解它的作用，有意识地选择要引入的代码。\n\n### 91. 创造一个舒适的工作环境⭐\n如果你喜欢你的工作环境和技术设置，你会更有动力去工作，所以还在等什么？\n\n### 92. 记住你来自哪里\n我们都是从同一个地方开始的，随着你的技能和职位的发展，不要忘记你来自哪里，不要膨胀。\n\n### 93. 试着保持乐观\n如果出了什么问题，试着乐观一点。明天是新的一天。乐观会帮助你的团队充满活力和精神健康。\n\n### 94. 不断重新评估你的工作流程⭐\n仅仅因为某样东西现在有效，并不意味着它永远有效。重新评估你的工作流程，并在必要时做出调整。\n\n### 95. 学会在家办公\n如果你有能力在家工作，那就学会有效地在家工作。找一个独立的办公空间，远离干扰。[Boneskull](https://dev.to/boneskull/pro-tips-for-devs-working-at-home-3b63)写了一篇很棒的关于在家工作的文章，你应该看看。\n\n### 96. 无障碍代码\n无障碍不是事后才想到的，也不一定很难，每个人都应该能够使用你的产品。\n\n### 97. 遵守你的承诺⭐\n如果你告诉别人你会在某一天完成某件事，要信守承诺。如果你不能在截止日期前完成任务，那就早点说出来。\n\n### 98. 积极主动\n如果你有额外的精力，找一个任务来帮助你的团队，他们会很感激你是主动的。\n\n### 99. 创建一个令人惊叹的作品集\n一个优秀的作品集让你与众不同，使用它作为展示你的编程和设计技巧的机会！\n\n### 100. 记住你喜欢编程的原因⭐\n你进入这个行业是因为它激发了你的兴趣，如果你感到沮丧和怨恨，休息一下，给自己空间重新点燃你对编程的激情。\n\n### 101. 分享你的知识⭐\n如果你学到了一些很酷的东西，不要吝惜分享它，参加当地的技术交流会，在午餐时间教你的同事或学员，分享你的知识可以让更多人受益同时自己也能巩固提高。\n\n完结撒花 🎉🎉🎉\n\n这就是我关于成为一个优秀程序员的全部建议，希望你们喜欢。\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"Commit Message规范","url":"%2F2019%2FCommit%20Message%E8%A7%84%E8%8C%83.html","content":"\n在团队开发中，commit message（提交说明）就如同代码注释一样重要。良好的commit message能让团队中的其他成员对你的每次提交的目的、\n\n涉及的代码范围及作用一目了然，方便日常的查询和帮助其他成员更好的帮你Code Review，必要时还能方便的生成Change log。\n\n---\n<!--more-->\n\n## Commit message格式\n\n```js\n// 格式：<type>(<scope>): <subject>\n```\n\n1. type：\n`必填` 用于说明commit的类型。总共7个标识：\n\n- feat： 新增feature\n- fix: 修复bug\n- docs: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等\n- style: 仅仅修改了空格、格式缩进、变量名等等，不改变代码逻辑\n- refactor: 代码重构，没有加新功能或者修复bug\n- perf: 优化相关，比如提升性能、体验\n- test: 测试用例，包括单元测试、集成测试等\n- chore: 改变构建流程、或者增加依赖库、工具等\n- revert: 回滚到上一个版本\n\n2. scope：\n`可选` scope用于说明 commit 影响的范围，比如数据层、控制层、视图层或者目录甚至文件等等，视项目不同而不同。\n\n3. subject：\n`必填` subject是 commit 目的的简短描述，不超过50个字符。\n\n- 约定好commit message的语言，对我们来说最好使用中文\n- 最好以动词开头（如使用英文请使用第一人称现在时，并且第一个字母小写）\n- `<scope>`之后的冒号后面留一个英文输入法的空格\n- 结尾不加句号或其他标点符号\n- 若此次commit是解决某个issue应该在行末尾注明并加链接，如：...(#101)\n\n## Commit message检查工具\n\n1. [commitizen](https://github.com/commitizen/cz-cli): 一个撰写合格 Commit message 的工具；\n\n2. [validate-commit-msg](https://github.com/kentcdodds/validate-commit-msg): 用于检查 Node 项目的 Commit \n\nmessage 是否符合格式。\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"提问的智慧","url":"%2F2019%2F%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7.html","content":"\n## 提问之前\n\n在向别人提出一个技术问题之前，请尝试从以下几个途径去寻找答案：\n\n1. Google\n\n2. Stackoverflow\n\n3. 相应的社区\n\n4. 官方文档\n\n5. 项目的Issue\n\n6. 项目源码（看个人能力）\n\n## 提问之时\n\n以上尝试无果的情况下向别人提出问题时：\n\n1. 认真做足相关功课，并整理好提问思路\n\n2. 礼多人不怪，一定要谦虚礼貌\n\n3. 清楚描述使用的环境、需求及问题的症状，语言要精简\n\n4. 能够提供一些问题的必要的截图、例子或者错误信息\n\n## 提问结束\n\n1. 一定要表示感谢，不管问题有没有得到解决\n\n2. 如果问题解决，在论坛或者社区一定要 留下你的解决方案并加以必要的说明，方便后人(我深受其害)；哪怕是问的身边的人，有价值的问题也要在博客上做记录\n\n3. 如果以上方法都尝试了还是解决不了那就先放一放，说不定过两天就有思路了\n\n4. 再不行，那就换个思路或者方案来解决你的需求吧\n\n参考资料：\n\nhttps://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md\n","tags":["杂谈"],"categories":["杂谈"]},{"title":"效率工作","url":"%2F2019%2F%E6%95%88%E7%8E%87%E5%B7%A5%E4%BD%9C.html","content":"\n1. 时间常有，时间在于优先。\n\n2. 时间总会有的：每天只计划 4～5 小时真正的工作。\n\n3. 当你在状态时，就多干点；不然就好好休息：有时候会连着几天不是工作状态，有时在工作状态时却又能天天忙活 12 小时，这都很正常的。\n\n4. 重视你的时间，并使其值得重视：你的时间值 1000 美元/小时，你得动起来。\n\n5. 不要多任务，这只会消耗注意力；保持专注，一心一用。\n\n6. 养成工作习惯，并持之以恒，你的身体会适应的。\n\n7. 在有限的时间内，我们总是非常专注并且有效率。\n\n8. 进入工作状态的最佳方式就是工作，从小任务开始做起，让工作运转起来。\n\n9. 迭代工作，期待完美收工会令人窒息：“做完事情，要胜于完美收工” 。动手做，胜过任何完美的想象。\n\n10. 工作时间越长，并不等于效率越高。\n\n11. 按重要性工作，提高效率。\n\n12. 有会议就尽早安排，用于准备会议的时间往往都浪费掉了。\n\n13. 把会议和沟通 (邮件或电话) 结合，创造不间断工作时间：一个小会，也会毁了一个下午，因为它会把下午撕成两个较小的时间段，以至于啥也干不成。PS：当看到一个程序员冥思苦想时，不要过去打扰，甚至一句问候都是多余的。\n\n14. 一整天保持相同的工作环境。在项目/客户之间切换，会效率低。\n\n15. 工作—放松—工作=高效(番茄工作法)。\n\n> 番茄工作法是弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n\n16. 把不切实际的任务分割成合理的小任务，只要每天都完成小任务，你就会越来越接近那个大目标了。\n\n17. 从来没有两个任务会有相同的优先级，总会有个更重要，仔细考虑待办事情列表。\n\n18. 必须清楚白天必须完成的那件事，是什么。 只去做那件有着最大影响的事情。\n\n19. 把任务按时间分段，就能感觉它快被搞定了。\n\n20. 授权并擅用他人的力量。—君子善假于物(人)也，如果某件事其他人也可以做到八成，那就给他做！\n\n21. 把昨天翻过去，只考虑今天和明天。昨天的全垒打赢不了今天的比赛。—好汉不提当年勇。\n\n22. 给所有事情都设定一个期限。不要让工作无期限地进行下去。\n\n23. 针对时间紧或有压力的任务，设置结束时间，万事皆可终结。\n\n24. 多记，多做笔记。\n\n25. 进入高效状态后，记下任何分散你注意力的东西比如Google搜索词、灵光乍现的想法、新点子等等。如果你把它们记下来，它就不会再蹦来蹦去了。\n\n26. 休息，休息一下～。","tags":["杂谈"],"categories":["杂谈"]},{"title":"ES6Proxy","url":"%2F2019%2FES6Proxy.html","content":"\nProxy，代理，是ES6新增的功能，可以理解为代理器（即由它代理某些操作）。\n\nProxy 对象用于定义或修改某些操作的自定义行为，可以在外界对目标对象进行访问前，对外界的访问进行改写。\n\n---\n<!--more-->\n\n### 1. Proxy 定义\n```js\nvar proxy = new Proxy(target, handler)\n```\n\n`new Proxy()`表示生成一个 Proxy 实例\n\n* target：目标对象\n* handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。\n\n**注意：要实现拦截操作，必须是对 Proxy 实例进行操作，而不是针对目标对象 target 进行操作。**\n\n首先，看个例子：\n\n```js\nlet handler = {\n    get: function(target, key, receiver) {\n        console.log(`getter ${key}!`)\n        return Reflect.get(target, key, receiver)\n    },\n    set: function(target, key, value, receiver) {\n    \tconsole.log(`setter ${key}=${value}`)\n\t\treturn Reflect.set(target, key, value, receiver)\n\t}\n}\nvar obj = new Proxy({}, handler)\nobj.a = 1 // setter a=1\nobj.b = undefined // setter b=undefined\n\nconsole.log(obj.a, obj.b) \n// getter a!\n// getter b!\n// 1 undefined\n\nconsole.log('c' in obj, obj.c)\t\n// getter c!\n// false undefined\n```\n\n在这个例子中，proxy 拦截了get和set操作。\n\n再看一个例子：\n\n```js\nlet handler = {\n    get: function(target, key, receiver) {\n        return 1\n    },\n  \tset: function (target, key, value, receiver) {\n    \tconsole.log(`setting ${key}!`);\n    \treturn Reflect.set(target, key, value, receiver);\n  \t}\n}\nvar obj = new Proxy({}, handler)\nobj.a = 5 // setting a!\nconsole.log(obj.a) // 1\n```\n\n则由上面代码看出：**Proxy 不仅是拦截了行为，更是用自己定义的行为覆盖了组件的原始行为**。\n\n**若`handler = {}`，则代表 Proxy 没有做任何拦截，访问 Proxy 实例就相当于访问 target 目标对象。**这里不再演示，有兴趣的可以自己举例尝试。\n\n### 2. Proxy handler方法（拦截方法）\n* `get(target, key, receiver)`：拦截 target 属性的读取\n* `set(target, key, value, receiver)`：拦截 target 属性的设置\n* `has(target, key)`：拦截 `key in proxy` 的操作，并返回是否存在（boolean值）\n* `deleteProperty(target, key)`：拦截 `delete proxy[key]`的操作，并返回结果（boolean值）\n* `ownKeys(target)`：拦截`Object.getOwnPropertyName(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for ... in`循环。并返回目标对象所有自身属性的属性名数组。注意：**`Object.keys()`的返回结果数组中只包含目标对象自身的可遍历属性**\n* `getOwnPropertyDescriptor(target, key)`：拦截 `Object.getOwnPropertyDescriptor(proxy, key)`，返回属性的描述对象\n* `defineProperty(target, key, desc)`：拦截`Object.defineProperty(proxy, key, desc)`、`Object.defineProperties(proxy, descs)`，返回一个 boolean 值\n* `preventExtensions(target)`：拦截`Object.preventExtensions(proxy)`，返回一个 boolean 值\n* `getPrototypeOf(target)`：拦截`Object.getPrototypeOf(proxy)`，返回一个对象\n* `isExtensible(target)`：拦截`Object.isExtensible(proxy)`，返回一个 boolean 值\n* `setPrototypeOf(target, key)`：拦截`Object.setPrototypeOf(proxy, key)`，返回一个 boolean 值。如果目标对象是函数，则还有两种额外操作可以被拦截\n* `apply(target, object, args)`：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`\n* `construct(target, args)`：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`\n\n总共 13 个拦截方法，下面进行简要举例说明，更多可见阮一峰老师的 [《ECMAScript 6 入门》](https://link.juejin.im/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fproxy)\n\n#### 1. get，set\n`get`方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n\n`set`拦截 target 属性的设置，可以接受四个参数，依次为目标对象、属性名、value和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。\n\n```js\nlet target = {foo: 1}\nlet proxy = new Proxy(target, {\n    get(target, key, receiver) {\n        console.log(`getter ${key}!`)\n        return target[key]\n    },\n    set: function(target, key, value, receiver) {\n        console.log(`setter ${key}!`)\n        target[key] = value;\n    }\n})\n\nlet obj = Object.create(proxy)\nconsole.log(obj.foo) \n// getter foo!\n// 1\n```\n\n#### 2. has\n拦截 propKey in proxy 的操作，返回一个布尔值。\n\n```js\n// 使用 has 方法隐藏某些属性，不被 in 运算符发现\nvar handler = {\n    has (target, key) {\n        if (key.startsWith('_')) {\n            return false;\n        }\n        return key in target;\n    }\n};\nvar foo = { _name: 'foo', name: 'foo' };\nvar proxy = new Proxy(foo, handler);\nconsole.log('_name' in proxy); // false\nconsole.log('name' in proxy); // true\n```\n\n#### 3. ownKeys\n拦截自身属性的读取操作。并返回目标对象所有自身属性的属性名数组。具体返回结果可结合 MDN [属性的可枚举性和所有权](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)\n\n* `Object.getOwnPropertyName(proxy)`\n* `Object.getOwnPropertySymbols(proxy)`\n* `Object.keys(proxy)`\n* `for ... in`循环\n\n```js\nlet target = {\n  _foo: 'foo',\n  _bar: 'bar',\n  name: 'An'\n};\n\nlet handler = {\n  ownKeys (target) {\n    return Reflect.ownKeys(target).filter(key =key.startsWith('_'));\n  }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n  console.log(target[key]);\n}\n// \"An\"\n```\n\n#### 4. apply\napply 拦截 Proxy 实例作为函数调用的操作，比如函数的调用（`proxy(...args)`）、call（`proxy.call(object, ...args)`）、apply（`proxy.apply(...)`）等。\n\n```js\nvar target = function () { return 'I am the target'; };\nvar handler = {\n  apply: function () {\n    return 'I am the proxy';\n  }\n};\n\nvar proxy = new Proxy(target, handler);\n\nproxy();\n// \"I am the proxy\"\n```\n\nProxy 方法太多，这里只是将常用的简要介绍，更多请看阮一峰老师的 [《ECMAScript 6 入门》](https://link.juejin.im/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fproxy)\n\n","tags":["深入理解"],"categories":["JS"]},{"title":"linux安装mongodb及常见命令","url":"%2F2019%2Flinux%E5%AE%89%E8%A3%85mongodb%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/mongodb.jpg, MongoDB, MongoDB %}\n\nMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。\n---\n<!--more-->\n\n## 安装、配置\n```shell\n## 下载\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.6.5.tgz\n\n## 解压\ntar -zxvf mongodb-linux-x86_64-3.6.5.tgz \n\n## 移动到指定目录\nmv  mongodb-linux-x86_64-3.6.5/ /usr/local/mongodb\n\n## MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：当前终端有效(可跳过)\nexport PATH=/usr/local/mongodb/bin:$PATH\n\n## 到根目录创建文件夹 或者mongodb下\nmkdir data/db\nmkdir data/log\n\n## vim /etc/profile 添加到全局命令\nexport PATH=/usr/local/mongodb/bin:$PATH \n\n## 如果有多个\nexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:/usr/local/mongodb/bin:$PATH\n\n## 保存，退出，然后运行\nsource /etc/profile\n```\n\n```shell\n## mongodb.conf\ndbpath=/usr/local/mongodb/db\nlogpath=/usr/local/mongodb/log/mongodb.log\nbind_ip=0.0.0.0\nfork=true\n```\n\n```shell\n## 关闭\nps -ef|grep mongod\nkill -9\n\n## 后台启动 开启用户认证\nnohup mongod --auth -f /usr/local/mongodb/mongodb.conf > myLog.log 2>&1 &\n```\n\n## 常见命令\n\n### 设置用户和命令\n```shell\n## 创建管理员\nmongo\n\nuse admin\n\ndb.createUser(\n  {\n    user: \"testuser\",\n    pwd: \"testpassword\",\n    roles: [ { role: \"readWriteAnyDatabase\", db: \"admin\" } ]\n  }\n)\n\n## 认证登录\ndb.auth(\"admin\", \"password\")\n\n## 显示当前系统用户\ndb.system.users.find()\n\n## 删除用户(删除用户的时候需要切换到用户管理的数据库才可以删除)\ndb.dropUser(\"testuser\")\n\n## 修改密码\ndb.addUser('testUser','111')\n\ndb.changeUserPassword('tank2','test')\n```\n\n### mongoose账号密码连接\n```js\nmongoose.connect(\"mongodb://user:pwd@111.231.121.29/ticket\", {\n  authSource: \"admin\",\n  useMongoClient: true\n});\n```\n\n## 导入导出表字段\n```js\nmongoexport -d book -c books -o books.json --type json\n\nmongoimport -d book -c books --file /home/mongodump/articles.json --type json\n```\n\n## 备份恢复数据库\n```js\nmongodump -h 127.0.0.1 -d book -o D:\\iview-book-admin\\static\\js\n\nmongorestore -h dbhost -d book --dir D:\\iview-book-admin\\static\\js\\book\n```\n","tags":["数据库"],"categories":["工具"]},{"title":"blur事件与click事件冲突的解决办法","url":"%2F2019%2Fblur%E4%BA%8B%E4%BB%B6%E4%B8%8Eclick%E4%BA%8B%E4%BB%B6%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html","content":"\n在处理表单登录的过程中，遇到了一个问题，当我们在输入框输入内容输入框获取到焦点时，输入框后面会出现一个图标删除已输入的内容，因此删除图标会绑定一个click事件，但是当我们点击图标的时候，也触发了input的blur事件，blur事件会让input失去焦点时隐藏删除的图标，并且blur事件先于图标的click事件执行，因此这时候点击图标并不会删除输入框已输入的内容，而是图标消失了。还有弹窗输入框blur同时点击取消按钮关闭，也会出现需要点击2次的情况。\n\n<p align=\"center\"><img src=\"http://cdn.mydearest.cn/blog/images/blur.png\" alt=\"blur img\"></p>\n\n---\n<!--more-->\n\n- blur事件：当元素失去焦点时触发blur事件；blur 事件仅发生于表单元素上。在新浏览器中，该事件可用于任何元素，blur和focus事件不会冒泡，其他表单事件都可以。\n\n- click事件：当点击元素时触发click事件；所有元素都有此事件，会产生冒泡。\n\n### 原因分析\n> blur事件比click事件先触发，而javascript为单线程，同一时间只能执行处理一个事件，所以当blur执行时，导致其后续click事件并不会执行。\n\n### 方案一 加定时器延时触发blur事件\n\n缺点：设置多久的延时是一个难以两全的问题，时间太短不能保证click事件的100%触发，时间太长则会造成卡顿的感觉，影响用户体验。\n\n### 方案二 将click事件改为mousedown事件，mousedown事件是优先于blur事件执行\n\n缺点：鼠标按下便触发了事件，不收起、长按也会触发，可能造成用户体验不好。还需要判断是否是鼠标左键点击(event.button===0)。\n\n### 方案三 给click所在元素再添加一个mousedown事件，在其中执行event.preventDefault()阻止浏览器默认事件，这样点击按钮时输入框就不会失去焦点了\n\n缺点：如果是弹窗下次打开时，焦点仍然存在。\n\n### 方案四 动态绑定移除blur事件\n\n**推荐方案三和四**\n","tags":["解决方案"],"categories":["知识"]},{"title":"前端模块化发展扩展","url":"%2F2019%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95%E6%89%A9%E5%B1%95.html","content":"\nJavaScript 一开始并没有内建模块化支持，也几乎没有模块化这种概念。当时没那么大的需求，搞个模块化显得大材小用啊。随着互联网的发展，尤其是 2006 年 ajax 技术的出现和之后 Web 2.0 的兴起，越来越多的业务逻辑向前端转移，前端开发的复杂程度和代码量逐渐提升。这时，由于缺乏模块化概念，JavaScript 的一些问题便凸显出来：代码难以复用、容易出现全局变量污染和命名冲突、依赖管理难以维护等等。一开始，开发者们使用诸如暴露全局对象、自执行函数等方法来规避这些问题，但仍无法从根本上解决问题。\n\n<!-- more -->\n\n## CommonJS\n\n2009 年，基于将 JavaScript 应用于服务端的尝试，ServerJS 诞生了。之后 ServerJS 更名为 CommonJS，并逐步发展为一个完整的模块规范。简称 CMD(Common Module Definition)\n\n[CommonJS官网](http://www.commonjs.org/)\n[CommonJS阮一峰](http://javascript.ruanyifeng.com/nodejs/module.html)\n\nCommonJS 为模块的使用定义了一套 API。比如，它定义了全局函数 require，通过传入模块标识来引入其他模块，如果被引入的模块又依赖了其他模块，那么会依次加载这些模块；通过 module.exports 向外部暴露 API，以便其他的模块引入。\n\n由于 CommonJS 是使用`同步方式`加载模块的，即只有加载完成才能进行接下来的操作，因此当应用于浏览器端时会受到网速的限制。\n\nCommonJS对模块的定义主要分为模块引用、模块定义和模块标识3个部分。\n\n``` JS\nconst $ = require('jquery')\n\n// 定义私有方法\nfunction log (...arg) {\n  console.log(...arg)\n}\n// 定义公有方法\nfunction sayHello () {\n  const el = $('body')\n  log('zhouyu, hello', el)\n}\n// 暴露公有方法\nmodule.exports = {\n  sayHello\n}\n```\n\n## AMD\n\n之后，在 CommonJS 组织的讨论中，AMD(Asynchronous Module Definition)应运而生。和 CommonJS 不同的是，它使用`异步方式`加载模块，因此更适合被浏览器端采用。AMD 用全局函数 define 来定义模块，它需要三个参数：模块名称、模块的依赖数组、所有依赖都可用之后执行的回调函数(该函数按照依赖声明的顺序，接收依赖作为参数)。\n\n[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)\n[AMD中文](https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)\n\n``` JS\ndefine(['jquery'], function ($) {\n  // 定义私有方法\n  function log (...arg) {\n    console.log(...arg)\n  }\n  // 定义公有方法\n  function sayHello () {\n    const el = $('body')\n    log('zhouyu, hello', el)\n  }\n  // 暴露公有方法\n  return sayHello\n})\n```\n\n## UMD\n\n如果需要同时支持 CommonJS 和 AMD 两种格式，那么可以使用 UMD(Universal Module Definition)。事实上，UMD 通过一系列 if/else 判断来确定当前环境支持的模块体系，因此多数情况下 UMD 格式的模块会占用更大的体积。\n\n``` js\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery'], factory)\n  } else if (typeof exports === 'object') {\n    // Nodejs 或 CommonJS\n    module.exports = factory(require('jquery'))\n  } else {\n    // 浏览器全局变量(root 即 window)\n    root.returnExports = factory(root.jQuery)\n  }\n}(this, function ($) {\n  // 定义私有方法\n  function log (...arg) {\n    console.log(...arg)\n  }\n  // 定义公有方法\n  function sayHello () {\n    const el = $('body')\n    log('zhouyu, hello', el)\n  }\n  // 暴露公有方法\n  return sayHello\n}));\n```\n\n## ES6 Modules\n\n无论是 CommonJS，AMD 还是 UMD，它们都不是标准的 JavaScript 模块解决方案。换句话说，它们都没有被写进 ECMA 的规范中。直到 2015 年 6 月，TC39 委员会终于将 Modules 写进 ECMAScript 2015 中，标志着原生模块新时代的到来。至此，JavaScript 文件有了两种形式：脚本(自 JavaScript 诞生起我们就在使用的)和模块(即 ECMAScript 2015 Modules)。下面就让我们来一起探索 ECMAScript 2015 Modules(以下简称 ES6 Modules)\n\n[ES6 Modules](http://www.ecma-international.org/ecma-262/6.0/#sec-modules)\n[ES6阮一峰](http://es6.ruanyifeng.com/#docs/module)\n\n``` js\nimport $ from('jquery')\n\n// 定义私有方法\nfunction log (...arg) {\n  console.log(...arg)\n}\n// 定义公有方法\nfunction sayHello () {\n  const el = $('body')\n  log('zhouyu, hello', el)\n}\n\nexport default sayHello\n```\n\n## ES6 Modules 现状\n\n时至今日，几大主流浏览器都在积极推进支持原生 ES6 Modules 的工作，部分浏览器的技术预览版也已经初步完成了这一使命。可以通过 [caniuse](https://caniuse.com/#search=module) 查看目前浏览器的支持情况。\n\n## 使用 Babel 和 webpack\n\n由于绝大多数浏览器都不支持 ES6 Modules，所以目前如果想使用它的语法，需要借助 Babel 和 webpack，即通过 Babel 将代码编译为 ES5 的语法，然后使用 webpack 打包成目标格式。\n\n## 直接使用 ES6 Modules\n\n有些游览器已经支持 ES6 Modules，我们利用 `<script type=\"module\">`(默认是 defer)来使用。\n\n## 其他探索\n\n* 动态加载方案 `import()`\n\n``` js\nconst load = async (url) => {\n  const module = await import(url)\n  console.log(module, window[tempGlobal])\n}\n```\n\n``` js\nfunction load (url) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script')\n    const tempGlobal = '__tempModuleLoadingVariable' + Math.random().toString(32).substring(2)\n    script.type = 'module'\n    script.textContent = `import * as m from \"${url}\"; window.${tempGlobal} = m;`\n\n    script.onload = () => {\n      resolve(window[tempGlobal])\n      delete window[tempGlobal]\n      script.remove()\n    }\n\n    script.onerror = () => {\n      reject(new Error('Failed to load module script with URL ' + url))\n      delete window[tempGlobal]\n      script.remove()\n    }\n\n    document.documentElement.appendChild(script)\n  })\n}\n```\n\n* 基于 ES6 Modules 的 `module-pusher` 尝试\n","tags":["模块化"],"categories":["知识"]},{"title":"健康指标","url":"%2F2019%2F%E5%81%A5%E5%BA%B7%E6%8C%87%E6%A0%87.html","content":"\n接上次的[维生素](https://mydearest.cn/2019/%E7%BB%B4%E7%94%9F%E7%B4%A0.html)😊，罗列一些生活中需要知道健康指标。\n\n<!-- more -->\n\n# 血糖\n\n血中的葡萄糖称为血糖。\n\n血糖的来源包括：①食物消化、吸收；②肝内储存的糖原分解；③脂肪和蛋白质的转化。\n\n血糖的去路包括：①氧化转变为能量；②转化为糖原储存于肝脏、肾脏和肌肉中；③转变为脂肪和蛋白质等其他营养成分加以储存。\n\n胰岛是体内调节血糖的血糖浓度的主要器官，肝脏储存肝糖元。此外，血糖浓度还受神经、内分泌激素的调节。\n\n## 血糖值\n\n### 空腹血糖\n\n全血血糖(手指)。血浆血糖(静脉)。\n\n空腹血糖正常值，全血血糖：3.89～6.11 mmol/L，血浆血糖：3.90～6.90 mmol/L\n\n空腹全血血糖 ≥ 6.70 mmol/L，血浆血糖 ≥ 7.80 mmol/L，2 次重复测定可诊断为糖尿病。\n\n### 餐后血糖\n\n餐后 1 小时：血糖 6.7-9.4 mmol/L。最多也不超过 11.1 mmol/L。\n\n餐后 2 小时：血糖 ≤ 7.8 mmol/L。\n\n餐后 3 小时：第三小时后恢复正常，各次尿糖均为阴性。\n\n### 孕妇血糖\n\n空腹不超过 5.1 mmol/L。\n\n餐后 1 小时不得超过 10.0 mmol/L 才是血糖的正常水平。\n\n## 糖尿病\n\n糖尿病患者的空腹血糖参考值：\n\n轻度糖尿病：7.0~8.4 mmol/L，中度糖尿病：8.4~11.1 mmol/L，重度糖尿病：大于 11.1 mmol/L。\n\n## 药物\n\n二甲双胍。\n\n1. 二甲双胍片首选用单纯饮食控制及体育锻炼治疗无效的2型糖尿病，特别是肥胖的2型糖尿病。\n2. 本品与胰岛素合用，可减少胰岛素用量，防止低血糖发生。\n3. 可与磺酰脲类降血糖药合用，具协同作用。\n\n服用本品时应尽量避免饮酒。\n\n## 哪些食物降血糖\n\n1.饮食宜清淡，忌辛辣，低糖、低油、低盐，按时饮食\n\n2.可以吃：苦瓜、洋葱、山药、海带、魔芋多吃，冬瓜、芹菜、菠菜、藕等少吃\n\n3.可以吃：柚子、苹果、橘子、樱桃、草莓、梨、桃等升糖指数比较低，西瓜吃靠近瓜皮的，不吃瓜心\n\n4.不能吃：香蕉、山楂、柿子、枣子\n\n5.多喝凉白开，不要憋尿\n\n6.检测足部，保护足部\n\n7.多做足部运动，踮脚、脚趾抓地、泡完脚后用掌心搓脚心\n\n8.不含糖的甜味剂，比如木糖醇、三氯蔗糖、阿斯巴甜、甜菊糖苷这类甜味剂；如果含有这些的食品，可以少量食用。燕麦片\n\n多吃：冬瓜、苦瓜、洋葱、山药、海带、魔芋、芹菜、菠菜、木耳、藕\n\n### 燕麦片\n\n燕麦片是燕麦粒轧制而成，呈扁平状，直径约相当于黄豆粒，形状完整的一种食品。燕麦煮出来高度粘稠，其中 beta 葡聚糖健康成分所带来的，具有降血脂、降血糖、高饱腹的效果，长期食用具有减肥功效。此外，燕麦中含有丰富的维生素 B1、B2、E、叶酸等，可以改善血液循环、缓解生活工作带来的压力；含有的钙、磷、铁、锌、锰等矿物质也有预防骨质疏松、促进伤口愈合、防止贫血的功效。\n\n### 魔芋\n\n降血糖、降血脂、降血压、散毒、养颜、通脉、减肥、通便、开胃。\n\n生魔芋有毒，必须煎煮 3 小时以上才可食用。\n\n消化不良的人，每次食量不宜过多。\n\n有皮肤病的人少食。\n\n魔芋性寒，有伤寒感冒症状的应少食用。\n\n### 海带\n\n海带是一种营养价值很高的蔬菜，同时具有一定的药用价值。含有丰富的碘等矿物质元素。海带含热量低、蛋白质含量中等、矿物质丰富。研究发现，海带具有降血脂、降血糖、调节免疫、抗凝血、抗肿瘤、排铅解毒和抗氧化等多种生物功能。\n\n吃海带后不要马上喝茶(茶含鞣酸)，也不要立刻吃酸涩的水果(酸涩水果含植物酸)。\n\n吃多也不好，会得甲亢。\n\n### 山药\n\n具有滋养强壮，助消化，敛虚汗，止泻之功效，主治脾虚腹泻、肺虚咳嗽、糖尿病消渴、小便短频、遗精、妇女带下及消化不良的慢性肠炎。\n\n# 血压\n\n是指血液在血管内流动时作用于单位面积血管壁的侧压力，它是推动血液在血管内流动的动力。在不同血管内被分别称为动脉血压、毛细血管压和静脉血压，通常所说的血压是指体循环的动脉血压。\n\n影响动脉血压的因素主要有五个方面：①每搏输出量；②外周阻力；③心率；④主动脉和大动脉管壁的弹性；⑤循环血量与血管容量。\n\n## 血压值\n\n收缩压：高压。舒张压：低压。\n\n正常成人安静状态下的血压范围较稳定，正常范围收缩压 90～139 mmHg，舒张压 60～89 mmHg，脉压 30～40 mmHg。\n\n高血压：未使用抗高血压药的前提下，18 岁以上成人收缩压 ≥ 140 mmHg 和(或)舒张压 ≥ 90mmHg。\n\n低血压：未使用抗高血压药的前提下，18 岁以上成人收缩压 < 90 mmHg 和(或)舒张压 < 60mmHg。\n\n## 哪些食物降血压\n\n### 茄子\n\n降低胆固醇，降血脂、降血压，防治胃癌，治疗慢性胃炎、肾炎水肿，防治坏血病及促进伤口愈合，清热解毒。\n\n消化不良、容易腹泻、脾胃虚寒、便溏症状的人不宜多吃。\n\n秋后的茄子有一定的毒素，不要吃。\n\n### 白萝卜\n\n清肠排毒，促进消化，增强食欲，防癌抗癌，降血压\n\n### 芹菜\n\n降低胆固醇，降血压\n\n【芹菜+鸡肉】容易伤元气。\n\n【芹菜+兔肉】容易引起脱皮。\n\n# BMI 指数\n\n身体质量指数，简称体质指数，又称体重.\n\n体质指数(BMI)= 体重(kg)÷ 身高(m)^ 2\n\n成人的BMI数值：\n  - 过轻：低于 18.5\n  - 正常：18.5-23.9\n  - 过重：24-27\n  - 肥胖：28-32\n  - 非常肥胖：高于 32\n\n60 / (1.68 * 1.68) = 21.26\n\n65 / (1.68 * 1.68) = 23.04\n\n67 / (1.68 * 1.68) = 23.74\n\n60 / (1.70 * 1.70) = 20.77\n\n65 / (1.70 * 1.70) = 22.50\n\n69 / (1.70 * 1.70) = 23.88\n\n60 / (1.72 * 1.72) = 20.29\n\n65 / (1.72 * 1.72) = 21.98\n\n70 / (1.72 * 1.72) = 23.67\n\n# 其他\n\n## 韭菜\n\n补肾，健胃，提神，降低胆固醇。\n\n春食则香，夏食则臭。\n\n【韭菜+菠菜】同食会有滑肠作用，容易引起腹泻。\n\n【韭菜+牛肉】发 热动火，引起牙齿肿痛，口疮。\n\n【韭菜+白酒】引起胃炎，胃溃肠病复发。\n\n【韭菜+蜂蜜】同食容易引起腹泻。","tags":["杂谈"],"categories":["杂谈"]},{"title":"EventLoop","url":"%2F2019%2FEventLoop.html","content":"\n## 描述事件队列的过程？\n\n- js是单线程的，会出现阻塞问题，因此有了异步队列的出现\n- 主进程同步执行任务，异步操作将添加到异步队列中\n- 等候主进程执行完毕后再执行异步队列中的操作\n\n---\n<!--more-->\n\n## 什么是宏任务什么是微任务？\n\n- 异步队列中有宏任务微任务之分\n- 一次事件循环：先运行宏任务队列中的一个，然后运行微任务队列中的所有任务。接着开始下一次循环\n\n## 哪些是宏任务哪些是微任务？\n\n### 宏任务\n- setTimeout\n- setImmediate\n- setIntarval\n- requestAnimationFrame\n- I/O\n- UI rendering\n\n### 微任务\n- process.nextTick\n- Promise.then\n- Object.observe\n- MutationObserver\n\n### 练习题\n```js\nconsole.log(1)\nsetTimeout(()=>{\n    console.log(2)\n}, 0)\nvar promise = new Promise(function(resolve, reject) {\n    console.log(3)\n    resolve();\n})\npromise.then(function(){\n    console.log(4)\n})\nconsole.log(5)\n// 13542\n\nconsole.log(1)\nsetTimeout(()=>{\n    console.log(2)\n},0)\n\nvar intervalId = setInterval(function(){\n    console.log(3)\n}, 0)\nsetTimeout(function(){\n    console.log(10)\n    new Promise(function(resolve){\n        console.log(11)\n        resolve()\n    }).then(()=>{\n        console.log(12)\n    }).then(()=>{\n        console.log(13)\n        clearInterval(intervalId)\n    })\n}, 0)\nPromise.resolve().then(()=>{\n    console.log(7)\n}).then(()=>{\n    console.log(8)\n})\nconsole.log(9)\n// 1 9 7 8 2 3 10 11 12 13\n```","tags":["深入理解"],"categories":["JS"]},{"title":"前端模块化发展","url":"%2F2019%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8F%91%E5%B1%95.html","content":"\n# 一、前端模块化发展简介\n\n## 1.CommonJS\n\n2009年，美国程序员Ryan Dahl创造了[node.js](http://nodejs.org/)项目，将javascript语言用于服务器端编程。这标志\"Javascript模块化编程\"正式诞生。nodeJs中的模块，一律为[CommonJS](https://en.wikipedia.org/wiki/CommonJS) 格式。\n\n### 1.1 语法风格\n\n```javascript\n//Math.js\nmodule.exports = {\n\t'add': function(a, b) {\n\t\treturn a + b;\n\t}\n}\n```\n\n```javascript\n//main.js\nconst Math = require('./Math');\nconsole.log(Math.add(2, 3));\nconsole.log('done');\n```\n\n---\n<!--more-->\n\n### 1.2 同步加载\n\n### 1.3 动态加载\n\n```javascript\n//main.js\nconst Math = require('./Ma' + 'th');//动态拼接\nconsole.log(Math.add(2, 3));\nconsole.log('done');\n```\n\n### 1.4 浏览器不支持CommonJS规范。\n\n浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。\n\n- module\n- exports\n- require\n- global\n\n可以使用工具进行转换，例如：[Browserify](http://browserify.org/)\n\n------\n\n## 2.AMD\n\nCommonJS是主要为了JS在后端的表现制定的，他是不适合前端的。\n\n[AMD](http://github.com/amdjs/amdjs-api/wiki/AMD)是\"Asynchronous Module Definition\"的缩写，意思就是\"异步模块定义\"。\n\n**RequireJS**实现了AMD规范。下面以RequireJS为例，了解一下AMD规范。\n\n### 2.1 语法风格\n\n```javascript\n//Math.js\ndefine([], function(){\n    return {\n        'add': function(a, b) {\n\t\t\treturn a + b;\n\t\t}\n    }\n})\n```\n\n```javascript\n//main.js\nrequire.config({\n    paths : {\n        \"math\" : \"Math\"\n    }\n});\nrequire(['math'], function (math) {\n\tconsole.log(math.add(2, 3));\n});\nconsole.log('done');\n//done\n//5\n```\n\n### 2.2 异步加载\n\n### 2.3 动态加载\n\n### 2.4 依赖前置，提前执行\n\n------\n\n## 3.CMD\n\nCMD是SeaJS 在推广过程中对模块定义的规范化产出。\n\n### 3.1 语法风格\n\n```js\n// CMD\ndefine(function(require, exports, module) {\n    var a = require('./a');\n    a.doSomething();\n    //...\n    var b = require('./b');   // 依赖可以就近书写\n    b.doSomething();\n    // ... \n    require.async('./c',function(c){ //支持异步加载\n        c.doSomething();\n    });\n})\n\n// AMD 默认推荐的是\ndefine(['./a', './b'], function(a, b) { // 依赖必须一开始就写好\n    a.doSomething();\n    //...\n    b.doSomething();\n    //...\n}) \n```\n\n### 3.2 AMD和CMD的区别\n\n1) **对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。**不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible（尽可能的懒加载，也称为延迟加载，即在需要的时候才加载）。\n\n2) **CMD 推崇依赖就近，AMD 推崇依赖前置。**虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。\n\n### 3.3 推荐链接\n\n[与 RequireJS 的异同](<https://github.com/seajs/seajs/issues/277>)\n\n[SeaJS官方文档](https://seajs.github.io/seajs/docs/)\n\n# 二、Module\n\nES6中Module的特点\n\n- 浏览器，服务器通用\n- 静态加载\n\n## 1. 基本语法\n\n### 1.1 export\n\n一个模块就是一个独立的文件。`export`关键字用来输出该变量。可以输出变量，函数或类。\n\n```javascript\n// test.js\nexport var firstName = 'cheng';\nexport var lastName = 'zhang';\nexport var age = 18;\n```\n\n```javascript\n// test.js\nvar firstName = 'cheng';\nvar lastName = 'zhang';\nvar age = 18;\n\nexport { firstName, lastName, age };\n```\n\n可以使用`as`为输出变量重命名。\n\n```javascript\nvar firstName = 'cheng';\nvar lastName = 'zhang';\nvar age = 18;\n\nexport {\n\tfirstName as name, \n    lastName as lastname, \n    age\n};\n```\n\n需要特别注意的是，`export`**命令规定的是对外的接口**，必须与模块内部的变量建立一一对应关系。\n\n```javascript\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n```\n\n`export`语句输出的接口，与其对应的值是**动态绑定关系**，即通过该接口，可以取到模块内部实时的值。\n\n```javascript\nexport var foo = 'bar';\nsetTimeout(() => foo = 'baz', 1000);\n```\n\n`export`命令可以出现在模块的任何位置，只要处于**模块顶层**就可以。\n\n### 1.2 import\n\n其他 JS 文件通过`import`命令加载模块。大括号里面的变量名，必须与被导入模块（`test.js`）对外接口的名称相同。\n\n```javascript\n// main.js\nimport { firstName, lastName, age } from './test.js';\n\nfunction showName() {\n  console.log(firstName + ' ' + lastName);\n}\n//cheng zhang\n```\n\n`import`命令输入的变量都是**只读**的，因为它的本质是输入接口。\n\n```javascript\nimport {a} from './xxx.js'\n\na = {}; // Assignment to constant variable.\n```\n\n如果`a`是一个对象，改写`a`的属性是允许的。和const一样。\n\n```javascript\nimport {a} from './xxx.js'\n\na.foo = 'hello'; // 合法操作\n```\n\n可以用星号（`*`）指定一个对象，进行整体加载。\n\n```javascript\n// main.js\nimport * as test from './test.js';\n\nfunction showName() {\n  console.log(test.firstName + ' ' + test.lastName);\n}\n//cheng zhang\n\ntest.lastName = 'yun';\n//Cannot assign to read only property 'lastName' of object '[object Module]'\n//如果是对象，可以修改对象的属性。\n```\n\n`import`命令**具有提升效果**，会提升到整个模块的头部，首先执行。\n\n```javascript\nfoo();\n\nimport { foo } from 'my_module';\n```\n\n由于`import`是静态执行，所以**不能使用表达式和变量**。\n\n```javascript\n// 报错\nimport { 'f' + 'oo' } from 'my_module';\n```\n\n`import`语句**会执行所加载的模块**，因此可以有下面的写法。仅仅执行`lodash`模块，但是不输入任何值。\n\n```javascript\nimport 'lodash';\n```\n\n即使加载多次，也只会执行一次。也就是说，`import`语句是 **Singleton 模式**。\n\n### 1.3 单例模式解读\n\n```javascript\n//counter.js\nexport let counter = 1;\nexport function addCounter(){\n    counter++;\n}\naddCounter();\n```\n\n```javascript\n//main.js\nimport {counter, addCounter} from './counter';\nconsole.log('main:' + counter);\naddCounter();\nconsole.log('main:' + counter);\n\n//main:2\n//main:3\n```\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<title>module test</title>\n\t\t<script type=\"module\" src='main.js'></script>\n\t\t<script type=\"module\" src='main2.js'></script>\n\t</head>\n</html>\n```\n\n```javascript\n//main2.js\nimport {counter, addCounter} from './counter';\nconsole.log('main2:' + counter);\naddCounter();\nconsole.log('main2:' + counter);\n\n//main2:3\n//main2:4\n```\n\n### 1.4 export default\n\n使用`export default`可以不用关注输出模块中的变量名。\n\n```javascript\n// export-default.js\nexport default function () {\n  console.log('foo');\n}\n```\n\n```javascript\n// import-default.js\nimport customName from './export-default';\ncustomName(); // 'foo'\n```\n\n`import`命令可以为该匿名函数指定任意名字。`import`命令后面，不使用大括号。\n\n```javascript\n// export-default.js\nfunction foo() {\n  console.log('foo');\n}\n\nexport default foo;\n```\n\n`export default`的本质，就是输出一个叫做`default`的变量或方法。\n\n`imort something from ..`.的本质，就是`import {default as something} from ...`\n\n```javascript\n// 正确\nexport var a = 1;\n\n// 正确\nvar a = 1;\nexport default a;\n\n// 错误\nexport default var a = 1;\n```\n\n```javascript\n// 正确\nexport default 42;\n\n// 报错\nexport 42;\n```\n\n所以`export default`是比较常用的方法：\n\n```javascript\n// MyClass.js\nexport default class { ... }\n\n// main.js\nimport MyClass from 'MyClass';\nlet o = new MyClass();\n```\n\n### 1.5 import&export混合使用\n\n```javascript\nexport { foo, bar } from 'my_module';\n\n// 可以简单理解为\nimport { foo, bar } from 'my_module';\nexport { foo, bar };\n```\n\n上面代码中，`export`和`import`语句可以结合在一起，写成一行。但需要注意的是，写成一行以后，`foo`和`bar`**实际上并没有被导入当前模块**，只是相当于对外转发了这两个接口，导致**当前模块不能直接使用**`foo`和`bar`。\n\n```javascript\n// 接口改名\nexport { fooName as newName } from 'my_module';\n\n//具名接口改为默认接口\nexport { foo as default } from './someModule';\n\n//接口也可以改名为具名接口\nexport { default as es6 } from './someModule';\n```\n\n### 1.6 模块的继承\n\n```javascript\n//calculator.js\nexport function add(a, b) {\n  return a + b;\n}\n```\n\n```javascript\n//calculatorPlus.js\nexport * from './calculator.js';\nexport function multiply(a, b) {\n  return a * b;\n}\n```\n\n```javascript\n//main.js\nimport * as cal from './calculatorPlus.js';\n\ncal.add(2, 3);//5\ncal.multiply(2, 3);//6\n```\n\n### 1.7 import()\n\n`import()`提案是为了解决`import`**动态加载**，和**不能写在代码块中**的问题。\n\n```javascript\nimport(a + '.js')\n.then(...);\n      \nimport(f())\n.then(...);\n```\n\n```javascript\nif (condition) {\n  import('moduleA').then(...);\n} else {\n  import('moduleB').then(...);\n}\n```\n\n## 2. Module补充\n\n### 2.1 浏览器加载\n\nhtml中加载 ES6 模块，也使用`<script>`标签，但是要加入`type=\"module\"`属性。\n\n```html\n<script type=\"module\" src=\"./myModule.js\"></script>\n<!--等同于-->\n<script type=\"module\" src=\"./myModule.js\" defer></script>\n\n<script type=\"module\" src=\"./myModule.js\" async></script>\n```\n\n- `defer`:要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行。保证执行顺序。\n\n- `async`:一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。不能保证执行顺序。\n\n对于外部的模块脚本，要注意：\n\n- 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。\n- 模块脚本自动采用严格模式，不管有没有声明`use strict`。\n- 模块之中，可以使用`import`命令加载其他模块（`.js`后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用`export`命令输出对外接口。\n- **模块之中，顶层的`this`关键字返回`undefined`，而不是指向`window`。也就是说，在模块顶层使用`this`关键字，是无意义的**。\n- 同一个模块如果加载多次，将只执行一次。\n\n### 2.2 循环加载\n\n```javascript\n// a.js\nimport {bar} from './b';\nconsole.log('a.js');\nconsole.log(bar);\nexport let foo = 'foo';\n```\n\n```javascript\n// b.js\nimport {foo} from './a';\nconsole.log('b.js');\nconsole.log(foo);\nexport let bar = 'bar';\n```\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<title>module test</title>\n\t\t<script type=\"module\" src='a.js'></script>\n\t</head>\n</html>\n<!--Cannot access 'foo' before initialization-->\n```\n\n------\n\n```javascript\n// a.js\nimport {bar} from './b';\nconsole.log('a.js');\nconsole.log(bar());\nfunction foo() { return 'foo' }\nexport {foo};\n```\n\n```javascript\n// b.js\nimport {foo} from './a';\nconsole.log('b.js');\nconsole.log(foo());\nfunction bar() { return 'bar' }\nexport {bar};\n```\n\n```javascript\n//b.mjs\n//foo\n//a.mjs\n//bar\n```\n\n因为函数具有提升作用。\n\n### 2.3 ES6模块和CommonJS模块的差异\n\n1. `import`和`export`是关键字，`require`不是。\n\n2. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。(详情见上方【单例模式解读】)\n\n3. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n             因为 CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n          ```javascript\n          //counter.js\n          let counter = 2;\n          function addCounter(){\n              counter++;\n          }\n          addCounter();\n          module.exports = {\n              counter,\n              addCounter: addCunter\n          }\n          ```\n\n          ```javascript\n          //main.js\n          var counter = require('./addCounter.js');\n\n          console.log('main:' + counter.counter);//3\n          counter.addCounter();\n          console.log('main:' + counter.counter);//3\n          ```\n4. **`this`指向不同**。ES6 模块之中，顶层的`this`指向`undefined`；CommonJS 模块的顶层`this`指向当前模块，这是两者的一个重大差异。\n","tags":["模块化"],"categories":["知识"]},{"title":"PWA手记","url":"%2F2019%2FPWA%E6%89%8B%E8%AE%B0.html","content":"\nPWA作为2018最火热的技术概念之一，对提升Web应用的安全、性能和体验有着很大的意义，非常值得我们去了解与学习。\n\nPWA是Progressive Web App的英文缩写，也就是渐进式增强WEB应用。目的就是在移动端利用提供的标准化框架，在网页应用中实现和原生应用相近的用户体验。\n\n一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的\n\n安装和离线等功能。\n\n我们需要理解的是，PWA不是某一项技术，或者某一个新的产物；而是一系列Web技术与标准的集合与应用。通过应用这些新的技术与标准，可以从安\n\n全、性能和体验三个方面，优化我们的Web App。所以，其实PWA本质上依然是一个Web App。\n---\n<!--more-->\n\n## 核心技术\n\n- Service Worker （可以理解为服务工厂）\n\n- Manifest （应用清单）\n\n- Push Notification（推送通知）\n\n## service worker (web worker)\n- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n- 一旦被 install，就永远存在，除非被 uninstall\n- 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源）\n- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n- 不能直接操作DOM出于安全的考虑，必须在 HTTPS 环境下才能工作\n- 异步实现，内部大都是通过 Promise 实现\n\nweb worker\nweb worker  是运行在后台的JavaScript，独立于其他脚本，不会影响页面的性能。\n\n浏览器一般有三类 web Worker\n\n- Dedicated Worker ：专用的 worker，只能被创建它的 JS 访问，创建它的页面关闭，它的生命周期就结束了。\n\n- Shared  Worker ：共享的 worker，可以被同一域名下的 JS 访问，关联的页面都关闭时，它的生命周期就结束了。\n\n- Service Worker ：是事件驱动的 worker，生命周期与页面无关，关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动。SW 作用于浏览器与服务器之间，相当于一个代理服务器。\n\n### Service Worker生命周期 \n看成红绿灯\n红 下载和解析\n黄 正在执行 还没准备好\n绿 随时可使用\n且第一次加载页面 sw还没有激活 不会处理任何请求 只有安装和激活后才能使用。（刷新页面和跳转新页面才会生效）\n\n- 步骤\n1. 用户导航到url\n2. 注册sw 过程中浏览器下载解析执行sw\n3. 一旦执行激活安装时间\n4. 安装成功就可以控制客户端功能事件\n\n### 全局变量\n- self: 表示 Service Worker 作用域, 也是全局变量\nSW 的默认作用域为基于当前文件 URL 的 ./。意思就是如果你在//example.com/foo/bar.js里注册了一个 SW，那么它默认的作用域为 //example.com/foo/。\n\n通过查看navigator.serviceWorker.controller是否为 null 来查看一个client是否被 SW 控制。\n- caches: 表示缓存\n- skipWaiting: 表示强制当前处在 waiting 状态的脚本进入 activate 状态（为了在页面更新的过程当中，新的 SW 脚本能够立刻激活和生效。无需刷新或者跳转新页面。）\n- clients: 表示 Service Worker 接管的页面\n- clients.claim() 在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。\n\n### Service Worker 注册\n```js\n// 检查当前浏览器是否支持sw\nif ('serviceWorker' in navigator) {\n    // 如果支持开始注册sw\n    navigator.serviceWorker\n        .register('./service-worker.js')\n        .then(registration => { \n            console,log('注册成功', registration)\n            // 消息推送 获取授权\n            // Notification.requestPermission(function(result) {\n            //         console.log('result', result)\n            //         if (result === 'granted') {\n            //             registration.showNotification('Vibration Sample', {\n            //                 body: 'Buzz! Buzz!',\n            //                 icon: './img/mario.png',\n            //                 vibrate: [200, 100, 200, 100, 200, 100, 200],\n            //                 tag: 'vibration-sample'\n            //             });\n            //         } else {\n            //             alert(result);\n            //         }     \n            // });\n            // 手动更新\n            // registration.update();\n        })\n        .catch(err => console.log('注册失败',err));\n}\n// 查看是否注册成功可以在 PC 上chrome 浏览器, 输入 chrome://inspect/#service-workers\n```\n\n### Service Worker 安装（处理静态缓存）\n\n1. 这个状态发生在 Service Worker 注册之后，是 sw 触发的第一个事件并且只触发一次。表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存。修改你的 SW 后，浏览器会认为这是一个新的 SW，从而会再触发这个新 SW 的install事件。\n\n2. e.waitUntil() 传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。如果 Promise 被拒绝，则安装失败，SW会进入 Redundant（ 废弃 ）状态。确保 Service Worker 不会在 waitUntil() 里面的代码执行完毕之前安装完成。\n\n3. sw 在安装成功和激活之前不会触发任何的 fetch 或 push 等事件。\n\n4. 默认情况下，页面的请求（fetch）不会通过 SW，除非它本身是通过 SW 获取的，也就是说，在安装 SW 之后，需要刷新页面才能有效果。\n\n5. clients.claim()可以改变这种默认行为。\n\nlocalStorage 的用法和 Service Worker cache 的用法很相似，但是由于 localStorage 是同步的用法，所以不允许在 Service Worker 中使用。 IndexedDB 也可以在 Service Worker 内做数据存储。\n\n```js\n// 首先定义需要缓存的路径, 以及需要缓存的静态文件的列表。\nvar cacheName = 'minimal-pwa-1'\n\nvar cacheList = [\n  '/',\n  \"index.html\",\n  \"main.css\",\n  \"e.png\"\n]\nself.addEventListener('install', e => {\n    console.log(\"安装事件，注册后触发只触发一次\");\n    e.waitUntil(\n        // 使用指定的缓存名来打开缓存\n        caches.open(cacheName)\n            .then(cache => {\n                console.log(\"加入缓存\", cacheList);\n                return cache.addAll(cacheList);\n            })\n            // 可加\n            .then(() => {\n                console.log('跳过等待')\n                return self.skipWaiting()\n            })\n    );\n});\n// self.oninstall = e => {}\n```\n\n###  Service Worker 激活（更新缓存）\n\n在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装，并且清除了其他的 worker 以及关联缓存的旧缓存资源，等待新的 Service Worker 线程被激活。\n\n```js\n// 激活 缓存更新\nself.addEventListener('activate', e => {\n    console.log('[ServiceWorker] Activate');\n    e.waitUntil(\n        caches.keys()\n            .then(keyList => Promise.all(keyList.map(key => {\n                if (key !== cacheName) {\n                    console.log('移除旧缓存', key);\n                    return caches.delete(key);\n                }\n            })))\n            // 可加\n            .then(() => {\n            return self.clients.matchAll()\n                .then(clients => {\n                if (clients && clients.length) {\n                    clients.forEach((v,i) => {\n                        // 发送字符串'sw.update'\n                        v.postMessage('sw '+i+' update')\n                    })\n                }\n                })\n            })\n            // return self.clients.claim();\n    );\n    // return self.clients.claim();\n});\n```\n\n### 已激活 （activated）\n\n在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、 sync (后台同步)、 push (推送)。\n\n### 废弃 （redunant）\n\n这个状态表示一个 Service Worker 的生命周期结束。\n\n这里特别说明一下，进入废弃 (redundant) 状态的原因可能为这几种：\n\n- 安装 (installing) 失败\n\n- 激活 (activating) 失败\n\n- 新版本的 Service Worker 替换了它并成为激活状态\n\n### 处理动态缓存\n监听捕获 fetch 事件，在 caches 中去 match 事件的 request ，如果 response 不为空的话就返回 response ，最后返回 fetch 请求，在 fetch 事件中我们也可以手动生成 response 返回给页面。\n```js\n// 捕获请求\nself.addEventListener('fetch', e => {\n    console.log('fetch事件', e.request.url);\n    e.respondWith(\n        caches.match(e.request)\n            .then(response => response || fetch(e.request))\n    );\n    // e.respondWith(\n    //     caches.match(e.request)\n    //         .then(response => {\n    //             if(response) {\n    //                 return response; // || fetch(e.request)\n    //             }\n    //             // 新的内容添加到缓存中\n    //             // 复制请求 请求是一个流 只能使用一次\n    //             var requestToCache = e.request.clone();\n    //             return fetch(requestToCache).then(function(response){\n    //                 if(!response || response.status !==200) {\n    //                     // 错误信息立即返回\n    //                     return response;\n    //                 }\n    //                 var responseToCache = response.clone();\n    //                 // 将响应添加到缓存中\n    //                 caches.open(cacheName).then(function (cache){\n    //                     cache.put(requestToCache, responseToCache);\n    //                 })\n    //             })\n    //         }) \n    // );\n\n    // 自定义响应\n    // e.respondWith(new Response('<p>it is a response</p>', {\n    //     headers:{\n    //         'Content-Type': 'text/html'\n    //     }\n    // }))\n});\n```\n\n通过存放到 Cache Storage 中，我们下次访问的时候如果是弱网或者断网的情况下，就可以不走网络请求，而直接就能将本地缓存的内容展示给用户，优化用户的弱网及断网体验。\n\n两种方式的比较\n\n- on install 的优点是第二次访问即可离线，缺点是需要将需要缓存的 URL 在编译时插入到脚本中，增加代码量和降低可维护性；\n\n- on fetch 的优点是无需更改编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线可用。\n\n### Service Worker 调试\n\n- 借助 Chrome 浏览器 debug\n使用 Chrome 浏览器，可以通过进入控制台 Application -> Service Workers 面板查看和调试。\n\n- 查看缓存\nService Worker 使用 Cache API 缓存只读资源，可以在 Chrome DevTools 上查看缓存的资源列表。\n\nhttp缓存：由服务器告知资源何时缓存和何时过期。sw缓存是对http缓存的增强\n\n### Service Worker 网络跟踪\n经过 Service Worker 的 fetch 请求 Chrome 都会在 Chrome DevTools Network 标签页里标注出来，其中：\n\n- 来自 Service Worker 的内容会在 Size 字段中标注为 from ServiceWorker\n\n- Service Worker 发出的请求会在 Name 字段中添加 ‘齿轮’ 图标。\n\n### Service Worker 功能性事件\n\n- fetch (请求)：当浏览器在当前指定的 scope 下发起请求时，会触发 fetch 事件，并得到传有 response 参数的回调函数，回调中就可以做各种代理缓存的事情了。\n\n- push (推送)：push 事件是为推送准备的。不过首先需要了解一下 Notification API 和 PUSH API。通过 PUSH API，当订阅了推送服务后，可以使用推送方式唤醒 Service Worker 以响应来自系统消息传递服务的消息，即使用户已经关闭了页面。\n\n- sync (后台同步)：sync 事件由 background sync (后台同步)发出。background sync 配合 Service Worker 推出的 API，用于为 Service Worker 提供一个可以实现注册和监听同步处理的方法。但它还不在 W3C Web API 标准中。在 Chrome 中这也只是一个实验性功能，需要访问 chrome://flags/#enable-experimental-web-platform-features ，开启该功能，然后重启生效。\n\n## APP Manifest 与添加到主屏幕\n\n允许将站点添加至主屏幕，是 PWA 提供的一项重要功能\n\n1. 定义 manifest.json 配置添加到主屏幕功能\n\n2. 创建 manifest.json 文件，并将它放到你的站点目录中\n\n3. 在所有页面引入该文件\n\n4. 可以在 Service Worker 中监听 beforeinstallprompt 事件做一些应用内的行为处理\n\n```js\n{ \n    \"name\" : \"Minimal PWA\" , \n    \"short_name\" : \"PWA Demo\" , \n    \"display\" : \"standalone\" , \n    \"start_url\" : \"/\" , \n    \"theme_color\" : \"#313131\" , \n    \"background_color\" : \"#313131\" , \n    \"icons\" : [ \n        { \n        \"src\" : \"e.png\" , \n        \"sizes\" : \"256x256\" , \n        \"type\" : \"image/png\" \n        } \n    ] \n}\n```\n\n- name ：定义此PWA的名称。\n\n- icons ：定义一系列的图标以适应不同型号的设备。\n\n- theme_color ：主题颜色（影响手机状态栏颜色）。\n\n- background_color ：背景颜色。\n\n- start_url ：启动地址。由于PWA实际上是一个web页面，所以需要定义PWA 在启动时应该访问哪个地址。\n\n- display ：\"standalone\"表示其以类似原生APP的全屏方式启动。\n\n### IOS Safari 设置\n```js\n应用图标： \n<link rel=\"apple-touch-icon\" href=\"apple-touch-icon.png\" > \n启动画面： \n<link rel=\"apple-touch-startup-image\" href=\"launch.png\" > \n应用名称： \n<meta name=\"apple-mobile-web-app-title\" content=\"Todo-PWA\" > \n全屏效果： \n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" > \n设置状态栏颜色： \n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"#fff\" >\n```\n\n### window10 贴片图标\n```js\n<meta name=\"msapplication-TileImage\" content=\"images/logo/144x144.png\" > \n<meta name=\"msapplication-TileColor\" content=\"#2F3BA2\" >\n```\n\n### 在线生成 manifest.json 文件\n\n- https://app-manifest.firebaseapp.com/\n\n- https://tomitm.github.io/appmanifest/\n\n- https://brucelawson.github.io/manifest/\n\n### 参考资料\n\n1. [Web App Manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest)\n\n2. [manifest.json 简介](https://lavas.baidu.com/doc/engage-retain-users/add-to-home-screen/introduction)\n\n## App Shell\n\nApp Shell，顾名思义，就是`壳`的意思，也可以理解为`骨架屏`，说白了就是在内容尚未加载完全的时候，优先展示页面的结构、占位图、主题和背景颜色等，它们都是一些被强缓存的html，css和javascript。\n\n要用好App Shell，就必须保证这部分的资源被Service Worker缓存起来。我们在组织代码的时候，可以优先完成App Shell的部分，然后把这部分代码分别打包构建出来。\n\n### 优势\n\n- 始终快速的可靠性能\n\n- 如同本机一样的交互\n\n- 数据的经济使用\n\n### 参考资料\n\n1. [App Shell 模型](https://developers.google.cn/web/fundamentals/architecture/app-shell)\n\n## 使用Offine-Plugin把网站升级成 PWA\n\n### 参考资料\n\n1. [offline-plugin](https://github.com/NekR/offline-plugin)\n\n2. [offline-plugin DEMO](https://offline-plugin.now.sh)\n\n3. [使用offline-plugin搭配webpack轻松实现PWA](https://segmentfault.com/a/1190000010669126)\n\n## 与PWA相关的开源框架\n\n### Lavas\n\n基于 Vue 的 PWA 解决方案，帮助开发者快速搭建 PWA 应用，解决接入 PWA 的各种问题\n\n1. [Lavas 官 网](https://lavas.baidu.com/)\n\n2. [Lavas GitHub](https://github.com/lavas-project/lavas)\n\n### 加载库\nimportScripts() // sw里的全局函数\n```js\nimportScripts('workbox-sw.prod.v1.1.0.js');\n\nconst workboxSW = new self.WorkboxSW();\n\nworkbox.precaching([\n  // 注册成功后要立即缓存的资源列表\n]);\n\n// html的缓存策略\nworkbox.routing.registerRoute(\n  new RegExp(''.*\\.html'),\n  workbox.strategies.networkFirst()\n);\n\nworkbox.routing.registerRoute(\n  new RegExp('.*\\.(?:js|css)'),\n  workbox.strategies.cacheFirst()\n);\n\nworkbox.routing.registerRoute(\n  new RegExp('https://your\\.cdn\\.com/'),\n  workbox.strategies.staleWhileRevalidate()\n);\n\nworkbox.routing.registerRoute(\n  new RegExp('https://your\\.img\\.cdn\\.com/'),\n  workbox.strategies.cacheFirst({\n    cacheName: 'example:img'\n  })\n);\n```\n通过 workbox.precaching 中的是 install 以后要塞进 caches 中的内容，workbox.routing.registerRoute 中第一个参数是一个正则，匹配经过 fetch 事件的所有请求，如果匹配上了，就走相应的缓存策略。\n\n## 注意事项\n- 避免改变 SW 的 URL（对index.html做了缓存，这样永远拿不到新的sw）","tags":["深入理解"],"categories":["JS"]},{"title":"use strict","url":"%2F2019%2Fuse%20strict.html","content":"\n严格模式是ES5引入的，更好的将错误检测引入代码的方法。顾名思义，使得JS在更严格的条件下运行。\n\n```js\n变量必须先声明，再使用\nfunction test(){\n\"use strict\";\nfoo = 'bar'; // Error\n}\n\n不能对变量执行delete操作\nvar foo = \"test\";\nfunction test(){}\n\ndelete foo; // Error\ndelete test; // Error\n\nfunction test2(arg) {\ndelete arg; // Error\n}\n对象的属性名不能重复\n{ foo: true, foo: false } // Error\n\n禁用eval()\n\n函数的arguments参数\nsetTimeout(function later(){\n// do stuff...\nsetTimeout( later, 1000 );\n}, 1000 );\n\n禁用with(){}\n\n不能修改arguments\n不能在函数内定义arguments变量\n不能使用arugment.caller和argument.callee。因此如果你要引用匿名函数，需要对匿名函数命名。\n```\n\n`严格模式`的优点：\n\n1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;\n\n2. 消除代码运行的一些不安全之处，保证代码运行的安全；\n\n3. 提高编译器效率，增加运行速度；\n\n4. 为未来新版本的Javascript做好铺垫。\n\n- 注：经过测试 IE6,7,8,9 均不支持严格模式。\n\n缺点：\n\n现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。\n\n---\n<!--more-->\n\n## 详细说明\n1.使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。\n\n2.变量在赋值之前必须声明,防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。\n\n3.取消this值的强制转换。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。在严格模式下，引用 null或未定义的 this 值会抛出错误。严格模式下，this不会指向window \n\n4.不允许重复的属性名称或参数值。当检测到对象中重复命名的属性，例如：\n```js\nvar object = {foo: \"bar\", foo: \"baz\"};\n\n// 或检测到函数中重复命名的参数时,例如：\n\nfunction foo(val1, val2, val1){}）\n\n// 严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。\n```\n5.使 eval() 更安全。在严格模式和非严格模式下， eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。\n\neval()没有被移除，但它在严格模式下发生了一些变化。最大的改变是：在eval()语句中声明的变量以及函数不会在包含域中创建。例如：\n```js\n(function() {\n\neval(\"var x = 10;\");  \n \n// 非严格模式下，x为10  \n// 严格模式下，x没有声明，抛出一个错误  \nalert(x);  \n})(); \n任意由eval()创建的变量或函数仍呆在eval()里。然而，你可以通过从eval()中返回一个值的方式实现值的传递：\n\n(function() {\n\nvar result = eval(\"var x = 10, y = 20; x + y\");  \n \n// 严格模式与非严格模式下都能正常工作（得到30）  \nalert(result);  \n}()); \n```\n6.在 delete 使用无效时抛出错误。 delete 操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。\n\n7.严格模式去除了with语句\n\n8.不能修改arguments ，不能在函数内定义arguments变量  ，不能使用arugment.caller和argument.callee。因此如果你要引用匿名函数，需要对匿名函数命名。  \n\n## 简洁说明\n\n- 变量必须声明后再使用\n- 函数的参数不能有同名属性，否则报错\n- 不能使用with语句\n- 不能对只读属性赋值，否则报错\n- 不能使用前缀 0 表示八进制数，否则报错\n- 不能删除不可删除的属性，否则报错\n- eval不会在它的外层作用域引入变量\n- eval和arguments不能被重新赋值\n- arguments不会自动反映函数参数的变化\n- 不能使用arguments.callee\n- 不能使用arguments.caller\n- 禁止this指向全局对象\n- 不能使用fn.caller和fn.arguments获取函数调用的堆栈\n- 增加了保留字（比如protected、static和interface）\n","tags":["知识"],"categories":["JS"]},{"title":"ES6Reflect对象","url":"%2F2019%2FES6Reflect%E5%AF%B9%E8%B1%A1.html","content":"\n## 介绍\nReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与处理器对象的方法相同。Reflect不是一个函数对象，因此它是不可构造的。\n\nReflect这个对象在新版本的chrome是支持的， ff比较早就支持Proxy和Reflect了，要让node支持Reflect可以安装[harmony-reflect](https://github.com/tvcutsem/harmony-reflect/);\n\nReflect不是构造函数， 要使用的时候直接通过Reflect.method()调用， Reflect有的方法和Proxy差不多， 而且多数Reflect方法原生的Object已经重新实现了。\n\n与大多数全局对象不同，Reflect没有构造函数。你不能将其与一个new运算符一起使用，或者将Reflect对象作为一个函数来调用。Reflect的所有属性和方法都是静态的（就像Math对象）。\n\n---\n<!--more-->\n\n##  为什么使用\n\n- 更加有用的返回值\n\nReflect有一些方法和ES5中Object方法一样样的， 比如： Reflect.getOwnPropertyDescriptor和Reflect.defineProperty,  不过, Object.defineProperty(obj, name, desc)执行成功会返回obj， 以及其它原因导致的错误， Reflect.defineProperty只会返回false或者true来表示对象的属性是否设置上了，\n\n```js\ntry {\n  Object.defineProperty(obj, name, desc);\n  // property defined successfully\n} catch (e) {\n  // possible failure (and might accidentally catch the wrong exception)\n}\n```\n可以重构成\n```js\nif (Reflect.defineProperty(obj, name, desc)) {\n  // success\n} else {\n  // failure\n}\n```\n\n- 函数操作\n```js\nname in obj // Reflect.has(obj, name)\ndelete obj[name] // Reflect.deleteProperty(obj, name)\n```\n\n- 更加可靠的函数式执行方式： 在ES中， 要执行一个函数f，并给它传一组参数args， 还要绑定this的话， 要这么写：\n```js\nf.apply(obj, args) // apply有可能被篡改\nFunction.prototype.apply.call(f, obj, args) // Reflect.apply(f, obj, args)\n```\n\n- 可变参数形式的构造函数\n```js\nvar obj = new F(...args)\nvar obj = Reflect.construct(F, args)\n```\n\n- 控制访问器或者读取器的this\n```js\nobj.name\nobj['name']\nReflect.get(obj, name, wrapper)\nReflect.set(obj, name, value, wrapper)\n```\n\n访问器中不想使用自己的方法，而是想要重定向this到wrapper：\n```js\nvar  obj = {\n    set foo(value){\n        return this.bar();\n    }\n    bar(){\n        console.log(1)\n    }\n}\n\nvar wrapper = {\n    bar(){\n        console.log(2)\n    }\n}\nReflect.set(obj, \"foo\", \"value\", wrapper)\n```\n\n- 避免直接访问__proto__\n\n### Reflect.apply\nReflect.apply其实就是ES5中的 Function.prototype.apply() 替身， 执行Reflect.apply需要三个参数\n\n第一个参数为： 需要执行的函数；\n第二个参数为： 需要执行函数的上下文this；\n第三个参数为： 是一个数组或者伪数组， 会作为执行函数的参数；\n\n### Reflect.construct\nReflect.construct其实就是实例化构造函数，通过传参形式的实现， 执行的方式不同， 效果其实一样， construct的第一个参数为构造函数， 第二个参数由参数组成的数组或者伪数组， 第三个参数为一个超类， 新元素会继承这个超类；\n```js\nvar Fn = function(arg) {\n    this.args = [arg]\n};\nconsole.log( new Fn(1), Reflect.construct(Fn,[1]) ); // 输出是一样的\n\nvar d = Reflect.construct(Date, [2019, 5, 2]);\nd instanceof Date; // true\nd.getFullYear(); // 2019\n```\n\n### Reflect.defineProperty\nReflect.defineProperty返回的是一个布尔值， 通过直接赋值的方式把属性和属性值添加给对象返回的是一整个对象， 如果添加失败会抛错；\n```js\nvar obj = {};\nif( Reflect.defineProperty(obj, \"x\", {value : 7 }) ) {\n    console.log(\"added success\");\n}else{\n    console.log(\"添加失败\");\n};\n```\n\n### Reflect.deleteProperty\nReflect.deleteProperty和Reflect.defineProperty的使用方法差不多， Reflect.deleteProperty和 delete obj.xx的操作结果是一样， 区别是使用形式不同：一个是操作符，一个是函数调用；\n```js\nReflect.deleteProperty(Object.freeze({foo: 1}), \"foo\"); // false\ndelete Object.freeze({foo: 1}).foo; //输出：false；\n```\n\n### Reflect.get\n这个方法的有两个必须的参数： 第一个为obj目标对象， 第二个为属性名对象， 第三个是可选的，是作为读取器的上下文(this);\n```js\nvar obj = {};\nobj.foo = 1;\nconsole.log( obj.foo ); //输出：1;\nconsole.log( Reflect.get(obj, \"foo\") ) //输出：1;\n```\n\n### Reflect.getOwnPropertyDescritptor\n获取属性描述\n```js\nReflect.getOwnPropertyDescriptor({x: \"hello\"}, \"x\");\n//也可以这样获取：\nObject.getOwnPropertyDescriptor({x:\"1\"},\"x\");\n//这两个的区别是一个会包装对象， 一个不会：\nReflect.getOwnPropertyDescriptor(\"hello\",0); //抛出异常\nObject.getOwnPropertyDescriptor(\"hello\",0); //输出： {value: \"h\", writable: false, enumerable: true, configurable: false}\n```\n\n### Reflect.getPrototypeOf\n同Object.getPrototypeOf\n\n### Reflect.has\n同 in\n```js\nReflect.has({x:0}, \"x\") //输出： true；\n```\n\n### Reflect.isExtensible\n```js\n// 现在这个元素是可以扩展的；\nvar empty = {};\nReflect.isExtensible(empty); // === true\n\n// 使用preventExtensions方法， 让这个对象无法扩展新属性；\nReflect.preventExtensions(empty);\nReflect.isExtensible(empty); // === false\n\n// 这个对象无法扩展新属性， 可写的属性依然可以改动\nvar sealed = Object.seal({});\nReflect.isExtensible(sealed); // === false\n\n// 这个对象完全被冻结了\nvar frozen = Object.freeze({});\nReflect.isExtensible(frozen); // === false\n```\n\n### Reflect.ownKeys\n返回对象的keys\n```js\nconsole.log(Reflect.ownKeys({\"a\":0,\"b\":1,\"c\":2,\"d\":3})); //输出 ：[\"a\", \"b\", \"c\", \"d\"]\nconsole.log(Reflect.ownKeys([])); // [\"length\"]\n```\nreflect.ownKeys的排序是根据: 先显示数字， 数字根据大小排序，然后是 字符串根据插入的顺序排序， 最后是symbol类型的key也根据插入插入顺序排序;\n\n### Reflect.set\n```js\nvar obj = {};\nReflect.set(obj, \"prop\", \"value\"); // 输出：true\nconsole.log( obj.prop ); // 输出：\"value\"\n\nvar obj = {};\nReflect.set(obj); // 输出：true\n// 相当于 Reflect.set(obj, undefined, undefined);\n```\n\n### Reflect.setPrototypeOf\n修改对象的\\_\\_proto\\_\\_属性\n```js\nReflect.setPrototypeOf({}, Object.prototype); // 输出true\n\n// 给该对象数组[[Prototype]] 为null.\nReflect.setPrototypeOf({}, null); // true\n// 此时的obj.__proto__为undefine\n\n//把对象冻结以后重新设置[[prototype]]\nReflect.setPrototypeOf(Object.freeze({}), null); // false\n\n// 如果原型链循环依赖的话就会返回false.\nvar target = {};\nvar proto = Object.create(target);\nReflect.setPrototypeOf(target, proto); // false\n```","tags":["深入理解"],"categories":["JS"]},{"title":"深入了解HTTP","url":"%2F2019%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3HTTP.html","content":"\n## HTTP 特性\n- 基于TCP-IP协议 应用层协议 默认端口号80\n- 无连接无状态\n\n### 什么是无状态\n- 状态】的含义就是：客户端和服务器在某次会话中产生的数据\n- 那么对应的【无状态】就意味着：这些数据不会被保留\n- 通过增加cookie和session机制，现在的网络请求其实是有状态的\n- 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话\n\n## HTTP 报文    \n### 请求报文\nHTTP 协议是以 ASCII （a s ki）码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。\n\n- GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制\n- 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制\n- 参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里\n\n---\n<!--more-->\n\n### POST提交的方式\nHTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。\n\n但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 PHP、Python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。\n\n1. application/x-www-form-urlencoded\n这是最常见的 POST 数据提交方式。浏览器的原生 <form> 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。\n\n2. multipart/form-data\n使用表单上传文件时，必须让 <form> 表单的 enctype 等于 multipart/form-data。\n\n上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也只支持这两种方式（通过 <form> 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。\n\n随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 application/json，application/form-data，text/xml，乃至 application/x-protobuf 这种二进制格式，只要服务器可以根据 Content-Type 和 Content-Encoding 正确地解析出请求，都是没有问题的。\n\n### 响应报文\n- 状态行\n- 响应头(Response Header)\n- 响应正文\n\nGET 请求 304获取缓存\n第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。\n\n/*\n    *通过RandomSource.getRandomValues() 方法获取符合密码学要求的安全的随机值\n    */\nthis.getRandomNumbers = function (min, max) {\n    var minValue = min || '';\n    var maxValue = max || '';\n    var cryptoObj = window.crypto || window.msCrypto;\n    /*eslint-disable*/\n    var array = new Uint32Array(1);\n    /*eslint-enable*/\n    cryptoObj && cryptoObj.getRandomValues(array);\n    var result = 0;\n    if (minValue || maxValue) {\n        if (!maxValue) {\n            minValue = 0;\n            maxValue = min;\n        }\n        result = parseInt(minValue, 10) + (array[0] % (parseInt(maxValue, 10) - parseInt(minValue, 10)));\n    } else {\n        result = array[0];\n    }\n    return result;\n};\n\n### 持久连接\n\n在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际上它是被附加到 HTTP 1.0协议上，如果客户端浏览器支持 Keep-Alive ，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。\n\n在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 \"Connection: close\" 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了。\n\n- HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。\n\n- HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。\n\n### HTTP Pipelining（HTTP 管线化）\n默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3。\n\nHTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3\n\n### 会话跟踪\n1. 什么是会话？\n\n客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。\n\n2. 什么是会话跟踪？\n\n会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。\n\n3. 为什么需要会话跟踪？\n\n浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。\n\nCookie\n\nCookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,以便下次使用。\n\n客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。\n\nCookie 是可以被客户端禁用的。\n\nSession:\n\n每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。\n\n在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。\n\nSession 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。\n\n### 跨站攻击\n\n#### CSRF（Cross-site request forgery，跨站请求伪造）\n\n- 如何防范 CSRF 攻击？\n\n1. 关键操作只接受 POST 请求\n2. 验证码\n3. 检测referer\n4. token\n\n#### XSS（Cross Site Scripting，跨站脚本攻击）\n\nXSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。\n\nXSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。\n\n### http缓存\n- 强缓存（from cache）强制浏览器使用本地缓存\n    - cache-control\n    - Expires\n    - Pragma\n- 协商缓存（304还是要和服务器通信一次）\n    - last-modified\n    - Etag\n\n## HTTPS基本过程\nHTTPS即 HTTP over TLS，是一种在加密信道进行HTTP内容传输的协议\n\n> TLS 的早期版本叫做 SSL。SSL 的 1.0, 2.0, 3.0 版本均已经被废弃，出于安全问题考虑广大浏览器也不再对老旧的 SSL 版本进行支持了，因此这里我们就统一使用 TLS 名称了。","tags":["HTTP"],"categories":["知识"]},{"title":"维生素","url":"%2F2019%2F%E7%BB%B4%E7%94%9F%E7%B4%A0.html","content":"\n## 维生素分类\n\n### 维生素A\n\n> 长期用眼。\n\n维生素A缺乏，会带来眼睛干涩，夜间视力下降等问题。\n\n![维生素A](http://cdn.mydearest.cn/blog/images/VA.jpg)\n\n---\n<!--more-->\n\n### 维生素C\n\n> 果蔬没吃够的\n\n![维生素A](http://cdn.mydearest.cn/blog/images/VC.jpg)\n\n### 维生素D\n\n> 太阳晒的少，影响钙吸收\n\n### 维生素B\n\nB类的维生素有很多种。\n\n#### 硫胺素(维生素B1)\n\n运动越多，消耗能量（主要是碳水化合物）越多，硫胺素需要也越多。随着进食量增加，硫胺素摄入可能也会增加，**所以一般不必额外补充。**\n\n#### 核黄素（维生素B2）\n\n核黄素跟蛋白质、脂肪、碳水化合物的能量产生都有关系。我国目前是成年男性1.4毫克/天，女性1.2毫克/天。运动人群，增加到推荐量的1-2倍足矣。食物补充的话，平时可以多吃肉、蛋和奶制品。花椰菜、芦笋、菠菜这类绿色蔬菜核黄素含量也比较高。**这些东西吃的少的话，可以考虑补充剂。**\n\n#### 烟酸（维生素B3）\n\n烟酸跟蛋白质、碳水化合物、脂肪的能量产生都有关。含烟酸比较丰富的食物有肉类、谷类、豆类食物。因为色氨酸在体内能转化成烟酸，动物蛋白摄入比较多的人，**烟酸一般都不会缺乏**。所以，常吃较多肉的人，即便是运动人群，也基本不用额外补充烟酸。\n\n#### 维生素B6\n\n这种维生素主要跟糖原和蛋白质代谢有关。体内储存的糖原想变成葡萄糖，氨基酸想转换利用，都需要维生素B6，所以这东西跟运动关系密切。\n\n维生素B6跟别的B族维生素不一样，这玩意有毒性。但一般都要达到药物剂量才会中毒。比如治疗经期按综合症、哮喘有时会用到B6。维生素B6的最高耐受上限是100毫克/天。低于这个剂量一般没有太大问题。\n\n比较安全的补充方式还是食物，肉、蔬菜、坚果、香蕉、全谷物食品里含B6都很丰富。比如100克鸡胸肉里就有大约0.6毫克维生素B6。所以，这些东西吃的比较多的话，一般不用吃补充剂额外补充。\n\n#### 橙子、橘子、柚子、青柠、西柚、柠檬、芦柑的关系。\n\n橙子是橘子和柚子杂交来的，橘子和橙子杂交成了芦柑，柚子和橙子又杂交成了青柠，橙子和青柠杂交了柠檬，橙子和柚子杂交成了西柚。","tags":["杂谈"],"categories":["杂谈"]},{"title":"vuex学习笔记","url":"%2F2019%2Fvuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","content":"\n## vuex\n数据驱动模板（管理共享状态）\n核心store仓库（响应式的状态存储）\n提交mutation才能修改内部状态 记录每次改变保存状态快照\n\n```js\nconst store = new Vuex.Store({\n    state:{\n        count:0\n    },\n    mutations: {\n        increase(state){\n            state.count++;\n        }\n    },\n    // 开启严格模式\n    strict: process.env.NODE_ENV !== 'production'\n    // 在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。\n})\n\nstore.commit('increase');\nstore.state.count;\n```\n\n不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。\n\n---\n<!--more-->\n\n### state（单一状态树）\n\n用一个对象包含所有的应用层级状态\n\n- 从store实例中读取状态\n```js\n// 计算属性\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n- 从根组件注入实例\n```js\nconst app = new Vue({\n  el: '#app',\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n// 读取\nthis.$store.state.count\n```\n\n- 多个属性使用mapState()辅助函数\n```js\ncomputed: mapState({\n    count: state => state.count,\n    name: state=> state.name\n})\n// 如果属性与state子节点名称相同 传入字符串数组\n// 映射 this.count 为 store.state.count\nmapState(['count'])\n```\n\n### getter对state数据的派生操作（共享数据的共享函数）\n```js\nconst store = new Vuex.Store({\n    state:{\n        todos: [\n            { id: 1, text: '...', done: true },\n            { id: 2, text: '...', done: false }\n        ]\n    },\n    getters: {\n        doneTodos: state => {\n            return state.todos.filter(todo => todo.done)\n        }\n        // 接收getter参数\n        doneTodosCount: (state, getters) => {\n            return getters.doneTodos.length\n        }\n        // 方法\n        getTodoById: (state) => (id) => {\n            return state.todos.find(todo => todo.id === id)\n        }\n    }\n})\n// 访问\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n```\n- mapGetters()辅助函数\n```js\ncomputed: {\n    // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n        'doneTodosCount',\n        'anotherGetter',\n        // ...\n    ])\n}\nmapGetters({\n    // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n    doneCount: 'doneTodosCount'\n})\n```\n\n### mutation\n提交mutation\n```js\nstore.commit(\"increase\")\n// 传参\nstore.commit('increase', 10)\n// 最好还是规范传payload对象\nstore.commit('increase', {\n    amount:10\n})\n// 对象风格提交\nstore.commit({\n  type: 'increase',\n  amount: 10\n})\n```\n1.最好提前在你的 store 中初始化好所有所需属性。\n\n2.当需要在对象上添加新属性时，你应该\n\n•使用 Vue.set(obj, 'newProp', 123), 或者\n\n•以新对象替换老对象。\n```js\nstate.obj = { ...state.obj, newProp: 123 }\n```\n\n- 常量替代事件类型\n```js\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n```js\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n\n**mutation必须是同步函数**\n一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n\n#### 组件中提交mutation\n1. \n```js\nthis.$store.commit('xxx')\n```\n\n2. mapMutations 辅助函数\n```js\nmethods: {\n    ...mapMutations([\n      'increase', // 将 `this.increase()` 映射为 `this.$store.commit('increase')`\n\n      // `mapMutations` 也支持载荷：\n      'increaseBy' // 将 `this.increaseBy(amount)` 映射为 `this.$store.commit('increaseBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increase' // 将 `this.add()` 映射为 `this.$store.commit('increase')`\n    })\n}\n```\n\n### action\n```js\nstore.commit('increment')\n// 任何由 \"increment\" 导致的状态变更都应该在此刻完成。\n```\n\nAction 类似于 mutation，不同在于：\n•Action 提交的是 mutation，而不是直接变更状态。\n•Action 可以包含任意异步操作。\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increase (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increase (context) {\n      context.commit('increase')\n    },\n    increaseOr({commit}) {\n      commit('increase')\n    },\n    increaseAsync ({ commit }) {\n        // 支持异步操作\n        setTimeout(() => {\n        commit('increment')\n        }, 1000)\n    }\n  }\n})\n```\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。\n\n- 触发action\n```js\nstore.dispatch('increase')\n```\n- 支持同样的载荷方式和对象方式分发\n```js\n// 以载荷形式分发\nstore.dispatch('increaseAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'increaseAsync',\n  amount: 10\n})\n```\n\n```js\n// 购物车操作实例\nactions: {\n  checkout ({ commit, state }, products) {\n    // 把当前购物车的物品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发出结账请求，然后乐观地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接受一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () => commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n```\n\n#### 组件中分发action\n在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increase', // 将 `this.increase()` 映射为 `this.$store.dispatch('increase')`\n\n      // `mapActions` 也支持载荷：\n      'increaseBy' // 将 `this.increaseBy(amount)` 映射为 `this.$store.dispatch('increaseBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increase' // 将 `this.add()` 映射为 `this.$store.dispatch('increase')`\n    })\n  }\n}\n```\n\n#### action组合嵌套\nstore.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise\n```js\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  },\n   actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n\n采用async await\n\n```js\n// getData() 和 getOtherData() 返回的是 Promise\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n\n### module切分模块\n```js\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n- 模块内部的action\n```js\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  },\n   getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n- 命名空间\n```js\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n\n- 在带命名空间的模块内访问全局内容（Global Assets）\n```js\nmodules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n- 在带命名空间的模块注册全局 action\n若需要在带命名空间的模块注册全局 action，可添加 root: true，并将这个 action 的定义放在函数 handler 中。\n```js\n{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch('someAction')\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> 'someAction'\n        }\n      }\n    }\n  }\n}\n```\n\n- 带命名空间的绑定函数\n```js\ncomputed: {\n  ...mapState({\n    a: state => state.some.nested.module.a,\n    b: state => state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    'some/nested/module/foo', // -> this['some/nested/module/foo']()\n    'some/nested/module/bar' // -> this['some/nested/module/bar']()\n  ])\n}\n```\n\n简化\n```js\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n\n也可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数\n```js\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }\n}\n```\n\n## 定义插件\n```js\nconst myPlugin = store => {\n    // 传入store初始化时调用\n    store.subscribe((mutation, state)=>{\n        // 每次mutation之后调用\n        // mutation 的格式为 {type, payload}\n    })\n}\n```\n\n## 表单处理\n因为提交mutation才能修改状态，所以v-model不适合绑定vuex里的state，不符合vuex的思想。\n```html\n<input v-model=\"obj.message\">\n```\n假设这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。\n\n1. 不采用v-model\n所以需要input绑定value，然后调用input或者change提交mutation修改状态\n```html\n<input :value=\"message\" @input=\"updateMessage\">\n```\n```js\ncomputed: {\n    ...mapState({\n        message: state => state.obj.message\n    })\n},\nmethod: {\n    updateMessage(e){\n        this.$store.commit(\"updateMessage\", e.target.value)\n    }\n}\n```\n\n2. 采用v-model\n```js\n// ...\ncomputed: {\n  message: {\n    get () {\n      return this.$store.state.obj.message\n    },\n    set (value) {\n      this.$store.commit('updateMessage', value)\n    }\n  }\n}\n```","tags":["vue"],"categories":["知识"]},{"title":"macvscode更新失败：Permissiondenied解决办法","url":"%2F2019%2Fmacvscode%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%EF%BC%9APermissiondenied%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html","content":"\n## 场景 -- mac vscode不能安装更新\n> Could not create temporary directory: Permission denied\n\n## 原因分析\nmac下`/Users/username/Library/Caches/`用户文件不一样，root和username\n\n导致\n\n> drwxr-xr-x   6 username  staff   204B Jan 17 20:33 com.microsoft.VSCode\n> drwxr--r--   2 root    staff    68B Dec 17 13:51 com.microsoft.VSCode.ShipIt\n\n## 解决方案\n```\n// 1. 关闭vscode\n\n// 2. 这一步是需要输入密码的\nsudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/ \n\n// 3. 这一步是不需要输入密码的, 如果不进行第一步，第二步会报错\nsudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/*\n\n// 4. 更新xattr\nxattr -dr com.apple.quarantine /Applications/Visual\\ Studio\\ Code.app\n```\n\n## 重新安装更新 完成😁","tags":["安装"],"categories":["工具"]},{"title":"borderRadius百分比50和100究竟有什么区别","url":"%2F2019%2FborderRadius%E7%99%BE%E5%88%86%E6%AF%9450%E5%92%8C100%E7%A9%B6%E7%AB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html","content":"\n\nborder-radius的值是百分比的话，就相当于盒子的宽度和高度的百分比。我们知道在一个正方形内做一个面积最大的圆形，这个圆的半径就为正方形边长的一半。所\n\n以border-radius为50%时，则会形成圆。那么可能有人就会问，border-radius为100%时，对应圆的半径长度不就是正方形的宽高么，这种情况下，为什么还是会\n\n形成一个和值为50%一样的圆形呢？\n\n---\n<!--more-->\n\n　　其实这是W3C对于[重合曲线](https://www.w3.org/TR/css-backgrounds-3/#corner-overlap)有这样的规范：如果两个相邻角的半径和超过了对应的\n\n盒子的边的长度，那么浏览器要重新计算保证它们不会重合。下面我们假定一个宽\n\n高为100px的正方形A。此时设置border-top-left-radius=100%；则正方形A会变成一个半径为100px的四分之一圆弧。 \n\n![radius1](http://cdn.mydearest.cn/blog/images/radius1.png)\n\n　　然后我们再给border-top-right-radius=100%。此时相邻的角的半径已经超过了对应的盒子的边的长度。浏览器需要重新计算。重新计算的规则是同时缩放两\n\n个圆角的半径知道他们刚好符合这个方形。\n\n\n　　建议使用border-radius = 50% 来避免浏览器不必要的计算。值得注意的是在涉及到与圆角相关动画的情况下，值为50%和100%，在动画效果上会有不同。\n\n## 示例代码\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>动画效果差异</title>\n</head>\n<style>\ndiv{\n  width: 100px;\n  height: 100px;\n  margin-bottom: 10px;\n  \n  transition: border-radius 3s;\n\n}\n.half{\n  border-radius: 50%;\n  background: #000;\n}\n.full{\n  border-radius: 100%;\n  background: #f00;\n}\n\n.box1:hover div{\n  border-radius: 0;\n}\n.wrap{\n  width:100px;\n  height: 250px;\n  border: 1px solid red;\n  cursor: pointer;\n}\n\n.box2 .half{\n    border-radius: 0;\n    background: #000;\n}\n\n.box2 .full{\n    border-radius: 0;\n    background: #f00;\n}\n.box2:hover .half{\n  border-radius: 50%;\n}\n.box2:hover .full{\n  border-radius:100%\n}\n</style>\n<body>\n  <div class='wrap box1'>\n    <div class=\"half\"></div>\n    <div class=\"full\"></div>\n  </div>\n  \n  <div class='wrap box2'>\n    <div class=\"half\"></div>\n    <div class=\"full\"></div>\n  </div>\n  <p>将鼠标移到红框内</p>\n</body>\n</html>\n```","tags":["知识"],"categories":["CSS"]},{"title":"JS函数基础","url":"%2F2019%2FJS%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80.html","content":"\n## 函数的定义\n函数其实就是一个封装一段代码段的**对象**，那函数名其实仅是用来引用函数对象的一个普通变量\n\n写代码的时候我们避免不了要重复用一些代码，一直重复写很耗时，而且不美观也不利于维护，因此函数的出现就是来让代码重用，便于维护。\n\n一段代码，可能被反复使用，可以定义为函数，然后调用函数来使用这段代码。\n\n在JavaScript中函数就是对象。函数不同于其他对象的决定性特点是，函数存在一个被称为[[Call]]的内部属性。内部属性无法通过代码访问而是\n\n定义了代码执行时的行为。ECMAScript为JavaScript的对象定义了多种内部属性，这些内部属性都用双重中括号来标注。\n\n[[Call]]属性是函数独有的，表明该对象可以被执行。由于仅函数拥有该属性，ECMAScript定义了typeof操作符对任何具有[[Call]]属性的对\n\n象返回 `[object Function]`\n\n---\n<!--more-->\n\n## 函数的创建\n**function 声明**\n\n```js\nfunction 函数名(参数列表) {\n  函数体;\n  return 返回值;\n}\n```\n\n**直接量声明**\n\n```js\nvar 函数名 = function(参数列表) {\n  函数体;\n  return 返回值;\n};\n```\n\n**用 new 创建**\n\n因为 Function 是内置类型，本身有一个 Function 的构造函数，是内置类型，所以是可以 `new` 的\n\n```js\nvar 函数名 = new Function(\"参数名1\",\"参数名2\",...,\"函数体; return 返回值\")\n```\n\n这里注意，参数和函数体都要用引号引起来，但是一般函数的创建都不会这样创建，以前面的两种为主，那其实前面两种的创建是存在一定的差别的，下面会提到\n\n## 函数的参数\n函数执行时必须的数据变量，它分为显示参数(Parameters)与隐式参数(Arguments)\n\n### 显示参数\n```js\nfunction fun(name, id) {\n  //函数体\n}\n```\n\n这种直接传进来的 name 和 id 就是显示参数，也就是你能看到的。其实函数传递的参数就相当于在函数体内又声明了一个局部变量\n\n```js\nvar i = 10;\nfunction fun(i) {\n  i++;\n  console.log(i);\n}\nfun(i);\n```\n\n上面的代码，就相当于下面的代码\n\n```js\nvar i = 10;\nfunction fun() {\n  var i = 10; //这个值就是传进来的参数的值\n  i++;\n  console.log(i);\n}\nfun(i); //在此处传入i\n```\n\n### 隐式参数\n每个 JavaScript 函数内部都有一个对象 `arguments` 对象,其实是一个类数组的对象,它会自动接受所有传入函数的参数值。\n\n```js\nfunction func(          ) {\n  //arguments[          ]\n}\n```\n\n值得一说的是,`arguments` 有下标有长度，可以通过下标来获得传入的参数，比如 `arguments[0]` 就是第一个参数, `length` 就可以遍历这个类数组对象，但是，毕竟它不是数组，所以不能进行一些数组特有的操作，比如 `sort`\n\n### 函数重载\n强类型语言对重载的定义：函数名相同，参数不同，或者是参数类型不同都可以叫做函数的重载。\n\n但在js中因为 arguments 的存在，JavaScript的函数根本就不存在所谓的签名，所以重载在JavaScript中实际是不存在的。\n```js\n// 模拟函数重载\nfunction abc(){\n    if (arguments.length ===1){\n        //A\n    }\n    if(arguments.length ===2){\n        //B\n    }\n}\n\nabc(11);\nabc(11,22);\n```\n\n## 声明提前\n在开始执行程序前,js 引擎会首先查找 `var` 声明的变量和 `function` 声明的函数，将其提前到当前作用域的顶部集中创建，而将赋值操作保留在原地,这里特别说一下,未用 `var` 声明的变量不会声明提前.\n\n```js\nconsole.log(a); //a is not defined\na = 10;\n```\n\n```js\nconsole.log(a); //undefined\nvar a = 10;\nconsole.log(a); //10\n```\n\n但是在它下面声明并赋值变量 `a`,因为声明提前,其实代码会变成下面这个样子\n\n```js\nvar a;\nconsole.log(a);\na = 10;\nconsole.log(a);\n```\n\n这样看，一切都变得很合理。。\n\n函数也是一样\n\n```js\nfunction fun() {\n  console.log(1);\n}\nfun(); //2\nfunction fun() {\n  console.log(2);\n}\nfun(); //2\n```\n\n控制台会输出两个 2,因为 function 声明的函数也会声明提前,代码其实是下面这个样子\n\n```js\nfunction fun() {\n  console.log(1);\n}\nfunction fun() {\n  console.log(2);\n}\nfun(); //2\nfun(); //2\n```\n\n第二次声明因为方法名字一样，后者覆盖了前者，所以再调用的时候就会调用最后这个\n\n但是声明提前会增加程序解读的难度，因此我们在写程序时，尽量避免声明提前所带来的危害\n\n### 声明提前的解决方法\n那我们既然知道会有声明提前这种操作，就在变量和函数的声明时都放在当前作用域的顶部。\n\n在 ES6 中 可以用 let 代替 var,不过要求在当前作用域中 let 变量之前不允许出现声明的变量\n\n也可以用直接量声明变量的方法\n\n```js\nvar fun = function() {\n  console.log(1);\n};\nfun(); //1\nvar fun = function() {\n  console.log(2);\n};\nfun(); //2\n```\n\n这种当然也会声明提前，那我们看一下声明提前后的代码\n\n```js\nvar fun;\nvar fun;\nfun = function() {\n  console.log(1);\n};\nfun(); //1\nfun = function() {\n  console.log(2);\n};\nfun(); //2\n```\n\n声明提前但是赋值还是留在原地，所以虽然有声明提前，但是并不会改变我们原本想要的结果。也就解决了声明提前带来的危害。\n\n## 匿名函数\n函数创建时没有指定函数名\n\n匿名函数使用后自动释放,会节约内存,它会划分临时作用域，避免全局变量污染全局。\n\n### 用处\n**callback**\n\n将一个函数作为参数传入另一个函数内，被其它函数调用\n\n举个栗子🌰\n\n```js\narr.sort(function(a, b) {\n  return a - b;\n});\n```\n\n```js\nstr.replace(/reg/g, function(kw,$1,$2,...){return 替换值})\n```\n\n#### 自调\n定义函数后自己调用自己，调用结束后，立刻释放，不占内存\n\n举个例子🌰\n\n```js\n(function(参数列表) {\n  函数体;\n  return 返回值;\n})(参数值列表);\n```\n\n会定义一个临时的作用域，减少使用全局变量，避免全局污染。\n\n## 重载\n相同函数名，不同参数列表的多个函数。在调用时，根据传入参数的不同，自动选择匹配的函数执行。\n\n这样可以减少 api 的数量，减轻调用者的负担。\n\n听起来很诱人，但是 js 语法不支持重载，原因是 js 不允许多个同名函数同时存在，后声明的函数会覆盖前面声明的。(哇。js 不支持你在这里说什么，神经病啊).\n\n既然说重载，那肯定是可以通过某些方法实现的。这个方法就是利用 `arguments`\n\n```js\nfunction test() {\n  if (arguments.length == 0) {\n    //不传值的操作\n  } else if (arguments.length == 1) {\n    //传一个值进行的操作\n  } else {\n    //....等等\n  }\n}\n```\n\n其实也不是真正意义上的重载，因为并没有创建同名的多个函数，但是实现的效果是和重载差不多的。\n","tags":["深入理解"],"categories":["JS"]},{"title":"NodeJSHttp加载静态资源","url":"%2F2019%2FNodeJSHttp%E5%8A%A0%E8%BD%BD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90.html","content":"\n问题场景：浏览器向后台发送请求后，后台返回一个html界面。但是在浏览器中没有加载js、css等静态资源，查找原因后发现是Content-Type的原因。浏览器不知道css、js等文件的文件格式，无法成功加载静态文件。所以，需要设置正确的文件格式。\n\n---\n<!--more-->\n\n## 搭建简单的本地服务\n```js\nvar http = require('http');//引入http模块\n\n//开启服务，监听8888端口\n//端口号最好为6000以上\nvar server = http.createServer(function(req,res){\n    /*\n        req用来接受客户端数据\n        res用来向客户端发送服务器数据\n    */\n\n    console.log('有客户端连接');//创建连接成功显示在后台\n\n    //一参是http请求状态，200连接成功\n    //连接成功后向客户端写入头信息\n    res.writeHeader(200,{\n        'content-type' : 'text/html;charset=\"utf-8\"'\n    });\n\n    res.write('这是正文部分');//显示给客户端\n    res.end();\n\n}).listen(8888);\n\nconsole.log('服务器开启成功');\n```\n\n## 访问本地站点\n```js\nvar http = require('http');\nvar fs = require('fs');//引入文件读取模块\n\nvar documentRoot = 'E:/PhpProject/html5/websocket/www';\n//需要访问的文件的存放目录\n\nvar server= http.createServer(function(req,res){\n\n    var url = req.url; \n    //客户端输入的url，例如如果输入localhost:8888/index.html\n    //那么这里的url == /index.html \n\n    var file = documentRoot + url;\n    console.log(url);\n    //E:/PhpProject/html5/websocket/www/index.html \n\n\n    fs.readFile( file , function(err,data){\n    /*\n        一参为文件路径\n        二参为回调函数\n            回调函数的一参为读取错误返回的信息，返回空就没有错误\n            二参为读取成功返回的文本内容\n    */\n        if(err){\n            res.writeHeader(404,{\n                'content-type' : 'text/html;charset=\"utf-8\"'\n            });\n            res.write('<h1>404错误</h1><p>你要找的页面不存在</p>');\n            res.end();\n        }else{\n            res.writeHeader(200,{\n                'content-type' : 'text/html;charset=\"utf-8\"'\n            });\n            res.write(data);//将index.html显示在客户端\n            res.end();\n\n        }\n\n    });\n\n\n\n}).listen(8888);\n\nconsole.log('服务器开启成功');\n```\n\n## 无法加载静态文件\n\n### 解决方案一\n- 手动设置Content-Type\n```js\nvar http = require('http');\nvar fs = require('fs');//引入文件读取模块\n\nvar documentRoot = './dist';\n//需要访问的文件的存放目录\n\nhttp.createServer(function(req,res){\n\n    var url = req.url; \n    //客户端输入的url，例如如果输入localhost:8888/index.html\n    //那么这里的url == /index.html \n\n    var file = documentRoot + url;\n    console.log(file);\n\n    fs.readFile(file , function(err,data){\n    /*\n        一参为文件路径\n        二参为回调函数\n            回调函数的一参为读取错误返回的信息，返回空就没有错误\n            二参为读取成功返回的文本内容\n    */\n        if(err){\n            res.writeHeader(404,{\n                'content-type' : 'text/html;charset=\"utf-8\"'\n            });\n            res.write('<h1>404错误</h1><p>你要找的页面不存在</p>');\n            res.end();\n        }else{\n            var type = file.substr(file.lastIndexOf(\".\")+1,file.length)\n            res.writeHeader(200,{'Content-type':\"text/\"+type+';charset=\"utf-8\"'});\t//在这里设置文件类型，告诉浏览器解析方式\n            // 根据后缀名判断文件类型不太准确 可以使用mime模块 mime.getType(filePath)\n            res.write(data);//将index.html显示在客户端\n            res.end();\n        }\n    });\n}).listen(8888);\n\nconsole.log('服务器开启成功');\n\n\n// // 手动设置content-type\n// http.createServer(function(req,res){\n// \tvar path = req.url;\t\n// \tconsole.log(\"path: \"+path)\n// \tif(path == \"/\"){\n// \t\tpath = \"/index.html\";\n// \t}\n// \tsendFile(res,path);\n// }).listen(8888)\n\n// function sendFile(res,path){\n//   var path = process.cwd()+'/dist'+path;\n// \tfs.readFile(path,function(err,stdout,stderr){\n// \t\tif(!err){\n// \t\t\tvar data = stdout;\n// \t\t\tvar type = path.substr(path.lastIndexOf(\".\")+1,path.length)\n// \t\t\tres.writeHead(200,{'Content-type':\"text/\"+type+';charset=\"utf-8\"'});\t//在这里设置文件类型，告诉浏览器解析方式\n// \t\t\tres.write(data);\n// \t\t}\n// \t\tres.end();\n//   })\n// }\n```\n\n### 解决方案二\n\n- 使用mime模块，npm install mime.\n- mime.getType(filePath)","tags":["NodeJS"],"categories":["Node"]},{"title":"switch的块级作用域","url":"%2F2019%2Fswitch%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F.html","content":"\nES6 或 TS 引入了块级作用域,通过let和const、class等可以定义块级作用域里的变量，块级作用域内的变量不存在变量提升，且存在暂时性死区。常见的if语句，for循环的循环体内都可以定义块级变量。那么switch语句中的块级作用域是什么呢？ 先给出结论：\n\n`switch语句中的块级作用域，在整个switch语句中，而不是对于每一个case生成一个独立的块级作用域。`\n\n---\n<!--more-->\n\n举个栗子🌰\n```javascript\nlet number = 1;\nswitch(number){\n  case 1:\n    let name = 'cosyer';\n  default:\n    console.log(name)\n}\n// cosyer\n```\n\n```javascript\nlet number = 1;\nswitch(number){\n  case 1:\n    let name = 'cosyer';\n    break;\n  case 2:\n    let name = 'yu';\n    break;\n  default:\n   console.log(name);\n}\n// Uncaught SyntaxError: Identifier 'name' has already been declared\n```\n\n## 可能存在的问题\n```javascript\nlet number = 1;\nswitch(number){\n    case 1 : name = 'cosyer'; break;\n}\n// name虽然没有声明，但是给name赋值相当于给全局的window对象复制，也就是window.name = 'cosyer'。\n```\n\n```javascript\nlet number = 2;\nswitch(number){\n  case 1:\n    let name = 'cosyer';\n    break;\n  case 2:\n    name = 'yu';\n    break;\n}\n// Uncaught ReferenceError: name is not defined\n```\n\n这里虽然case里面定义的块级虽然不会存在变量提升，但是会存在暂时性死区,也就是说如果let name = 'cosyer' 没有执行，也就是name定义的过程没有执行，那么name在整个块级作用域内都是不可用的，都是undefined。\n\n所以尽量不要在case里定义块级变量。","tags":["深入理解"],"categories":["JS"]},{"title":"深入理解instanceof","url":"%2F2019%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3instanceof.html","content":"\n在JS中，大家通常用`typeof`来判断基本类型，`instanceof`来判断引用类型。\n\n## typeof\n> typeof一般只能返回如下几个结果：number,boolean,string,function,object,undefined字符串\n\n> 对于Array,null等特殊对象使用typeof一律返回object，而函数返回function这正是typeof的局限性。\n\n> 在判断除Object类型的对象(基本类型)时比较方便。\n\n\n## instanceof\n> object instanceof constructor\n\n> instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。\n\n> 换种说法就是左侧的对象是否是右侧对象的实例。\n\n## 相关练习\n```javascript\n'123' instanceof String // true\nlet str = new String('123')\nstr instanceof String // true\n```\n\n---\n<!--more-->\n\n```javascript\n// 都是Object的实例 true\nconsole.log({} instanceof Object)\nconsole.log([] instanceof Array)\nconsole.log([] instanceof Object)\nconsole.log(function() {} instanceof Function)\nconsole.log(function() {} instanceof Object)\n```\n\n```javascript\nfunction Foo(){} \nfunction BFoo(){} \nFoo.prototype = new BFoo();\nlet foo = new Foo();\nconsole.log(foo instanceof Foo); // true\nconsole.log(foo instanceof BFoo); // true  \n```\n\n```javascript\nconsole.log(String instanceof String); // flase\nconsole.log(String instanceof Object);\nconsole.log(String instanceof Function);\nconsole.log(Object instanceof Object); \nconsole.log(Function instanceof Function); \nconsole.log(Function instanceof Object);\n\nfunction Foo(){} \nfunction BFoo(){} \nFoo.prototype = new BFoo();\nconsole.log(Foo instanceof Function);\nconsole.log(Foo instanceof Foo);\n```\n\n## instanceof实现\n```javascript\nfunction instance_of(L, R) {//L 表示左边的object，R 表示右边的constructor\n const R_P = R.prototype;// 取 R 的显式原型\n L = L.__proto__;// 取 L 的隐式原型,并且可能会顺着原型链重新赋值\n while (true) { \n   if (L === null) \n     return false; \n   if (R_P === L)// 这里重点：严格比较 true \n     return true; \n   L = L.__proto__; \n } \n}\n```\n\n## 重点解析\n![原型链](https://user-images.githubusercontent.com/25027560/37870377-2bc8211a-3007-11e8-92a0-04fa96aabf13.png)\n\n- \\_\\_proto\\_\\_ 属性，指向了创建该对象的构造函数的原型\n\n- 所有JS对象都有 \\_\\_proto\\_\\_ 属性，除了Object.prototype.\\_\\_proto\\_\\_ === null\n\n- 注意Object(),它是由function生成的，所以它的__proto__属性指向了function的构造器Function的原型Function.prototype\n\n- 注意构造器Function,它是唯一一个prototype和__proto__指向相同的对象\n\n- 一般来说，我们日常自行创建的构造器Foo的__proto__属性指向function的构造器Function的原型Function.prototype，但是构造器的原型对象Foo.prototype的__proto__属性是直接指向Object.prototype对象的","tags":["深入理解"],"categories":["JS"]},{"title":"深入理解JS的继承","url":"%2F2019%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E7%9A%84%E7%BB%A7%E6%89%BF.html","content":"\n{% fi https://user-images.githubusercontent.com/25027560/38763933-ac0fdb2a-3fd8-11e8-8510-5e8a2444f49a.png, Summary, Summary %}\n\n---\n<!--more-->\n\n## 总览\n![c5925056-aa27-4b97-9f5d-2ec786ea5125](https://user-images.githubusercontent.com/25027560/38763933-ac0fdb2a-3fd8-11e8-8510-5e8a2444f49a.png)\n\n## 一、借助构造函数\n```js\nfunction Parent1() {\n  this.name = 'parent1'\n}\nfunction Child1() {\n  // 将父类的执行上下文指向子类，父类执行时的实例属性都会指向子类\n  Parent1.call(this);// apply\n  this.type = 'child1'\n}\n```\n\n#### 缺点\n子类没有继承父类的原型方法\n只继承了父类构造函数中的属性和方法\n\n```js\nParent1.prototype.method = (arg) =console.log(arg);\nconsole.log(new Child1().method); // undefined\n```\n\n## 二、借助原型链\n```js\nfunction Parent2() {\n  this.name = 'parent2';\n  this.arr = [1, 2, 3];\n  this.method = (arg) =console.log(arg)\n}\nfunction Child2() {\n  this.type = 'child2'\n}\nChild2.prototype = new Parent2();\n```\n\n原型图如下\n![f9311957-d401-4bc0-961b-65f3f49d65ea](https://user-images.githubusercontent.com/25027560/38763935-b449916e-3fd8-11e8-8b76-e12f58c20d27.png)\n\n#### 缺点\n引用类型的属性被所有实例共享，实例之间会互相影响\n\n```js\nlet c21 = new Child2();\nlet c22 = new Child2();\n\nc21.arr.push(4);\nconsole.log(c21.arr, c22.arr);\n// 注意，下面是直接给实例添加method属性\n// 只是修改了method指针，没有修改原型链上的method方法\n// 只有修改引用对象才是真正的修改\nc21.method = 'c21';\nconsole.log(Parent2);\nconsole.log(c21, c22);\n```\n\n![c79f3ffe-030d-4753-9f32-361a2dffb9d2](https://user-images.githubusercontent.com/25027560/38763937-bad54c58-3fd8-11e8-9248-1f6b2954daf9.png)\n\n## 三、组合（构造+原型链）\n```js\nfunction Parent3() {\n  this.name = 'parent3';\n  this.arr = [1, 2, 3]\n}\nfunction Child3() {\n  Parent3.call(this);\n  this.type = 'child3'\n}\nChild3.prototype = new Parent3();\n```\n\n#### 优点\n每个实例不会再互相影响\n\n#### 缺点\n实例化时，父类被构造了两次，这没有必要\ncall一次，new一次\n\n## 四、组合优化一\n```js\nfunction Parent4() {\n  this.name = 'parent4';\n  this.arr = [1, 2, 3]\n}\nfunction Child4() {\n  Parent4.call(this);\n  this.type = 'child4'\n}\nChild4.prototype = Parent4.prototype;\n```\n\n![3dcc9c3e-5e1d-45bc-bcb5-72aaea635cc2](https://user-images.githubusercontent.com/25027560/38763939-c318a5fe-3fd8-11e8-9581-9e04e57976a4.png)\n\n#### 缺点\n无法判断实例的构造函数是父类还是子类\n\n```js\nlet c41 = new Child4();\nlet c42 = new Child4();\nconsole.log(c41 instanceof Child4, c41 instanceof Parent4);\n// true true\n```\n\n但其实，构造函数就是父类本身\n\n```js\nconsole.log(c41.constructor); // Parent4\n```\n\n很难得才通过`Parent4.call(this)`改变了构造函数的指向，现在又改回去了？天……不想看下去了行不行，兄dei，坚持一会就是胜利，别打瞌睡\n\n`Child4.prototype = Parent4.prototype`只是把`Child4`的`prototype`属性指针指向了`Parent4.prototype`这个引用对象而已，实际上`Parent4.prototype.constructor = Parent4`\n![af779508-30f5-43ea-8af8-ff25a308ccf9](https://user-images.githubusercontent.com/25027560/38763942-cdc97b40-3fd8-11e8-8f45-c7bdb95f8f5f.png)\n\n## 五、组合优化二\n```js\nfunction Parent5() {\n  this.name = 'parent5';\n  this.arr = [1, 2, 3]\n}\nfunction Child5() {\n  Parent5.call(this);\n  this.type = 'child5'\n}\n// 组成原型链\nChild5.prototype = Object.create(Parent5.prototype);\n```\n\n但是，这时候，实例对象的`constructor`依然是`Parent5`\n\n![f611911f-9fc1-4ff8-8da6-eb7874eeb335](https://user-images.githubusercontent.com/25027560/38763943-d3d9703a-3fd8-11e8-92d4-d161a335c80c.png)\n\n所以需要重新指定实例对象的构造器\n\n```js\nChild5.prototype.constructor = Child5;\n```\n\n```js\nlet c51 = new Child5();\nlet c52 = new Parent5();\nconsole.log(c51 instanceof Child5, c51 instanceof Parent5);\nconsole.log(c52 instanceof Child5, c52 instanceof Parent5);\nconsole.log(c51.constructor, c52.constructor);\n// true true\n// false true\n// Child5 Parent5\n```\n\n## 相关链接\n[js创建对象实现继承](https://mydearest.cn/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF.html)","tags":["深入理解"],"categories":["JS"]},{"title":"深入理解JS的类型、值和类型转换","url":"%2F2019%2FECMAScript%202016%E3%80%812017%E3%80%812018%20%E6%96%B0%E7%89%B9%E6%80%A7%20.html","content":"\n![image](https://user-images.githubusercontent.com/25027560/38468332-c0336d1c-3b76-11e8-93b5-94f73acab1c6.png)\n\n---\n<!--more-->\n\n## 一、ECMAScript 2016\n### 1、Array.prototype.includes\n[Array.prototype.includes() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)\n\n```js\nconst arr = [1, 2, 3, NaN];\n\nif (arr.indexOf(3) >= 0) {\n  console.log(true)\n}\n// true\n\nif (arr.includes(3)) {\n  console.log(true)\n}\n// true\n\narr.indexOf(NaN)\n// -1  无法识别NaN\narr.includes(NaN);\n// true   可以识别NaN\n```\n\n### 2、指数（幂）运算符 **\n```js\nMath.pow(2, 3)\n// 8\n\n2 ** 3\n// 8\n```\n\n## 二、ECMAScript 2017\n### 1、Object.values()\n[Object.values() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values)\n\n```js\nconst obj = { foo: \"bar\", baz: 42 };\nconsole.log(Object.values(obj)); // ['bar', 42]\n```\n\n### 2、Object.entries()\n[Object.entries() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n\n```js\nconst obj = { foo: 'bar', baz: 42 };\nconsole.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n```\n\n### 3、字符串填充 String padding\n[String.prototype.padStart() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart)\n[String.prototype.padEnd() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd)\n\n```js\n'abc'.padStart(10);         // \"       abc\"\n'abc'.padStart(10, \"foo\");  // \"foofoofabc\"\n'abc'.padStart(6,\"123465\"); // \"123abc\"\n'abc'.padStart(8, \"0\");     // \"00000abc\"\n'abc'.padStart(1);          // \"abc\"\n\n'abc'.padEnd(10);          // \"abc       \"\n'abc'.padEnd(10, \"foo\");   // \"abcfoofoof\"\n'abc'.padEnd(6, \"123456\"); // \"abc123\"\n'abc'.padEnd(1);           // \"abc\"\n```\n\n注意，Emojis和双字节字符会占据两位\n\n```js\n'heart'.padStart(10, \"❤️\"); // '❤️❤️❤heart'\n```\n\n### 4、Object.getOwnPropertyDescriptors\n[Object.getOwnPropertyDescriptor() - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)\n\n```js\nObject.getOwnPropertyDescriptor(obj, prop)\n```\n\n`Object.getOwnPropertyDescriptor() `方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n\n### 5、函数参数结尾逗号\n```js\nfunction fn(a, b,) {}\n// 注意，参数b后面多了个逗号，不会报语法错误\n```\n\n### 6、Async/Await\n[async function - JavaScript | MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function)\n\n## 三、ECMAScript 2018\n### 1、共享内存与原子操作\n\n即使有event loop的”伪多线程“和Service Worker的强力增援，但依然掩盖不了JS是单线程的事实。\n\n共享内存与原子操作，给JS带来了多线程的功能，允许开发人员自行管理内存来开发高性能高并发的程序。\n\n直到目前为止，我们只能通过`postMessage`在JS主线程和web worker之间通信，传输数据。\n\n### 2、非转义序列的模板字符串\n[非转义序列的模板字符串 | esnext | es6 es7 es2017 es2018 es2019](http://esnext.justjavac.com/proposal/template-literal-revision.html)\n\n### 3、对象展开运算符\n```js\nlet { firstName, age, ...rest } = {\n  firstName: 'a',\n  age: 18,\n  a: 1,\n  b: 2\n};\n\nfirstName; // 'a',\nage; // 18\nrest;\n// 重点看这里 { a: 1, b: 2 }\n```\n\n### 4、Promise.prototype.finally()\n\n### 5、异步迭代器\n提供了`for-await-of`，异步迭代，等待每个promise被resolve再执行下一个\n\n```js\nconst promises = [\n  new Promise(resolve =resolve(1)),\n  new Promise(resolve =resolve(2)),\n  new Promise(resolve =resolve(3))\n];\n```\n\n```js\n// old\nasync function test1() {\n  for (const obj of promises) {\n    console.log(obj);\n  }\n}\ntest1(); // \n// Promise {<resolved>: 1}\n// Promise {<resolved>: 2}\n// Promise {<resolved>: 3}\n```\n\n```js\n// new\nasync function test2() {\n  for await (const obj of promises) {\n    console.log(obj);\n  }\n}\ntest2();\n// 1, 2, 3\n```\n\n### 6、正则表达式相关\n\n* `dotAll` 模式，使 . 可以匹配任意字符\n* 命名捕获组，可以理解为增加一个引用\n\n```js\nconst regex = /(\\d{4})-(\\d{2})-(\\d{2})/;\nconst matchers = regex.exec('2015-01-02');\nmatchers[0];    // 2015-01-02\nmatchers[1];    // 2015\nmatchers[2];    // 01\nmatchers[3];    // 02\n```\n\n* 反向断言 Lookbehind Assertions\n* Unicode转义 Unicode Property Escapes","tags":["深入理解"],"categories":["JS"]},{"title":"深入理解JS的类型、值和类型转换","url":"%2F2019%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%81%E5%80%BC%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html","content":"\n## 一、七种内置类型和常见引用类型\n![精简](https://user-images.githubusercontent.com/25027560/37508449-123fc606-292e-11e8-9cf8-9667338b9ac4.png)\n\n![复杂](https://user-images.githubusercontent.com/25027560/37508456-1c2c0648-292e-11e8-94d7-541f20942869.png)\n\n---\n<!--more-->\n \n## 二、特殊的`null`\n用`typeof`来检查上述七种类型时，返回的是对应的类型字符串值\n \n```js\ntypeof null === 'ogject' // true\n```\n \n`null`是唯一一个用`typeof`检测会返回`object`的**基本类型值**（注意‘基本’两字）\n \n不同的对象在底层都表示为二进制\n在JavaScript中二进制前三位为0的话都会被判断为object类型\nnull的二进制表示全是0，自然前三位也是0\n所以 typeof null === “object”\n \n## 三、引用类型的子类型：typeof [引用类型] === what ?\n上面的图中虽然列出了七种引用类型，但是\n`typeof ‘引用类型’ === ‘object’ `一定成立吗？\n \n不，还有一种情况：`typeof ‘某些引用类型’ === ‘function’`\n\n```js\ntypeof Function; // 'function'\ntypeof new Function(); // 'function'\ntypeof function() {}; // 'function'\n\ntypeof Array; // 'function'\ntypeof Array(); // 'object'\ntypeof new Array(); // 'object'\ntypeof []; // 'object'\n\ntypeof Boolean; // \"function\"\ntypeof Boolean(); // \"boolean\"\ntypeof new Boolean(); // \"object\"\n\ntypeof Math; // 'object'\ntypeof Math(); // Math is not a function\ntypeof new Math(); // Math is not a constructor\n```\n\n### 1、引用类型中的函数\n先看前三句，原来typeof除了能判断`基本类型`和`object`之外，还能判断`function`类型，函数也属于对象\n\n### 2、引用类型的子类型\n拿`Array`举例子\n\n```js\ntypeof Array; // 'function'\ntypeof Array(); // 'object'\ntypeof new Array(); // 'object'\ntypeof []; // 'object'\n```\n\n`Array`是个构造函数，所以直接打印出function\n但构造出来的`Array()`却又是另一回事了，构造出来的结果是个数组，自然属于引用类型，所以也就打印出了`‘object’`\n\n构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的\n\n### 3、引用类型中的基本包装类型\n```js\ntypeof Boolean; // \"function\"\ntypeof Boolean(); // \"boolean\"\ntypeof new Boolean(); // \"object\"\n```\n\n`Boolean`是个构造函数，第一句没问题\n`Boolean()`直接执行，得出了布尔值，所以得到了`‘boolean’`\n\n而new出来的是个Boolean对象，具体来说就是：`通过构造函数创建出来的是封装了基本类型值的封装对象`\n\n这里用`String`来举个例子吧，看到了吗，一个封装对象\n![封装对象](https://user-images.githubusercontent.com/25027560/37508489-350e6e80-292e-11e8-81f2-3124d28d219e.png)\n\n但是，不推荐使用这种封装对象，举个例子\n\n```js\nvar a = new Boolean(false);\nif (!a) {\n  console.log('Oops'); // false\n}\n```\n\na是个对象，对象永远是真。\n\n### 4、Math到底是什么？\nMath和Global（浏览器中替代为window）都是内置的对象，并不是引用类型的一种\n\n```js\ntypeof Math; // 'object'\ntypeof Math(); // Math is not a function\ntypeof new Math(); // Math is not a constructor\n```\n\n既不是函数，也不是构造器。\n\n## 四、typeof的安全防范机制\n首先，我们需要知道`underfined`和`undeclared`的区别\n未定义与未声明\n\n但是，对于typeof来说，这两者都一样，返回的都是underfined\n\n```js\nvar a;\ntypeof a; // 'underfined'\ntypeof b; // 'underfined'\n```\n\n很明显，我们知道b就是undeclared（未声明的），但在typeof看来都是一样\n\n这个特性，可以拿来做些什么呢？\n\n举个简单的例子，在程序中使用全局变量 DEBUG 作为“调试模式”的开关。在输出调试信 息到控制台之前，我们会检查 DEBUG 变量是否已被声明。顶层的全局变量声明 var DEBUG = true 只在 debug.js 文件中才有，而该文件只在开发和测试时才被加载到浏览器，在生产环 境中不予加载。\n\n问题是如何在程序中检查全局变量 DEBUG 才不会出现 ReferenceError 错误。这时 typeof 的 安全防范机制就成了我们的好帮手:\n\n```js\n// 这样会抛出错误\nif (DEBUG) {\n  console.log('Debugging is starting');\n}\n// 这样是安全的\nif (typeof DEBUG !== 'undefined') {\n  console.log('Debugging is starting');\n}\n```\n\n这不仅对用户定义的变量(比如 DEBUG)有用，对内建的 API 也有帮助:\n\n```js\nif (typeof atob === \"undefined\") {\n         atob = function() { /*..*/ };\n}\n```\n\n## 五、值\n这一part引用自[一、内存空间详解 · Sample GitBook](https://yangbo5207.github.io/wutongluo/ji-chu-jin-jie-xi-lie/yi-3001-nei-cun-kong-jian-xiang-jie.html)\n\nJS的执行上下文生成之后，会创建一个叫做变量对象的特殊对象，JS的基础类型都保存在变量对象中\n\n严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。\n\n但引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。\n\n在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。\n\n这里的引用，我们可以理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。\n\n![3719a7f3-3915-4719-93d8-7629fa5b47bb](https://user-images.githubusercontent.com/25027560/37508497-409cd7fa-292e-11e8-8bc4-a62effd0f3c8.png)\n\n\n而为什么基础数据类型存在栈中，而引用数据类型存在堆中呢?\n\n- 堆比栈大，栈比堆速度快。\n- 基础数据类型比较稳定，而且相对来说占用的内存小。\n- 引用数据类型大小是动态的，而且是无限的。\n- 堆内存是无序存储，可以根据引用直接获取。\n\n## 六、强制类型转换\n《you don’t know JS》中 第一部分第4章\n\n类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时(runtime)。\n\n然而在 JavaScript 中通常将它们统称为强制类型转换，我个人则倾向于用“隐式强制类型转换”(implicit coercion)和“显式强制类型转换”(explicit coercion)来区分。\n\n### 1、抽象值操作\n介绍显式和隐式强制类型转换之前，我们需要先掌握字符串、数字和布尔值之间类型转换的基本规则\n\n1️⃣**ToString**\ntoString() 可以被显式调用，或者在需要字符串化时自动调用\n\nnull 转换为 \"null\"，undefined 转换为 \"undefined\"，true 转换为 \"true\"。\n数字的字符串化则遵循通用规则\n极小和极大的 数字使用指数形式:\n\n```js\n// 1.07 连续乘以七个 1000\nvar a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;\n// 七个1000一共21位数字 \na.toString(); // \"1.07e21\"\n```\n\n数组的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用 \",\" 连接起 来\n\n```js\nvar a = [1,2,3];\n a.toString(); // \"1,2,3\"\n```\n\n2️⃣ **ToNumber**\n其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。\n处理失败 时返回 NaN(处理数字常量失败时会产生语法错误)\n\n3️⃣ **ToBoolean**\n先看什么是假值\n\n```\n• undefined\n• null\n• false\n• +0、-0 和 NaN\n• \"\"\n```\n假值的布尔强制类型转换结果为 false。\n从逻辑上说，假值列表以外的都应该是真值(truth)\n\n```js\nvar a = new Boolean(false);\nvar b = new Number(0);\nvar c = new String('');\n\nvar d1 = Boolean( a && b && c );\nvar d2 = a && b && c;\n```\n\n![63754230-e3da-4363-a04d-cccca7030a15](https://user-images.githubusercontent.com/25027560/37508500-49f02fd2-292e-11e8-929b-168ea4309baf.png)\n\n如果假值对象并非封装了假值的对象，那它究竟是什么?\n值得注意的是，虽然 JavaScript 代码中会出现假值对象，但它实际上并不属于 JavaScript 语言的范畴。\n浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来(exotic) 值，这些就是“假值对象”。\n假值对象看起来和普通对象并无二致(都有属性，等等)，但将它们强制类型转换为布尔 值时结果为 false。\n\n**真值就是假值列表之外的值**\n\n```js\nvar a = 'false';\nvar b = '0';\nvar c = \"''\";\nvar d1 = Boolean(a && b && c);\nvar d2 = a && b && c\n```\n\n![985c49a4-061f-42fe-978c-83f7724d8867](https://user-images.githubusercontent.com/25027560/37508506-4e686bd8-292e-11e8-881b-81d56ac71281.png)\n\n\n```js\nvar a = \"0\";\nvar b = [];\nvar c = {};\nvar d = \"\";\nvar e = 0;\nvar f = null;\nvar g;\nBoolean( a ); // true  特别注意这个，字符串0和空字符串不一样\nBoolean( b ); // true\nBoolean( c ); // true\nBoolean( d ); // false  和第一个比，空字符串是false\nBoolean( e ); // false\nBoolean( f ); // false\nBoolean( g ); // false\n```\n\n### 2、显式类型转换\n\n```js\n// 字符串转换\nvar a = 42;\nvar b = String(a);\n// 数字转换\nvar c = '3.14';\nvar d = Number(c);\n// 布尔值转换\nvar e = [];\nvar f = Boolean(e)\n```\n\n### 3、隐式强制类型转换\n1️⃣字符串和数字之间的隐式转换\n\n```js\nvar a = '42';\nvar b = '0';\nvar c = 42;\nvar d = 0;\na + b; // \"420\" 这个地方，注意一下\nc + d; // 42\n```\n\n```js\nconsole.log([] + {}); // [object object]\nconsole.log({} + []); // ?这会是多少呢？\n```\n\n《you don’t know JS 》中5.1.3章节是这样说的\n\n还有一个坑常被提到(涉及强制类型转换，参见第 4 章)\n[] + {}; // \"[object Object]\"\n{} + []; // 0\n表面上看 + 运算符根据第一个操作数([] 或 {})的不同会产生不同的结果，实则不然。 第一行代码中，{} 出现在 + 运算符表达式中，因此它被当作一个值(空对象)来处理。第\n4 章讲过 [] 会被强制类型转换为 \"\"，而 {} 会被强制类型转换为 \"[object Object]\"。\n但在第二行代码中，{} 被当作一个独立的空代码块(不执行任何操作)。代码块结尾不需 要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换(参见第 4 章) 为 0。\n\n但目前的chrome浏览器控制台是这样的\n![034d7fa4-b144-4028-a346-0a52a3ab7faa](https://user-images.githubusercontent.com/25027560/37508514-5698c8fc-292e-11e8-9220-52136c53d5c4.png)\n\n\n{} 其实应该当成一个代码块，而不是一个 Object，当你在console.log使用的时候，{} 被当成了一个 Object\n![8c597cc9-d2e2-4a51-ad8c-dd1a25ac27db](https://user-images.githubusercontent.com/25027560/37509112-ef5b653e-2930-11e8-8456-824fd66271da.png)\n\n2️⃣ 隐式强制类型转换为布尔值\n下面的情况会发生 布尔值隐式强制类型转换。\n\n* (1)if (..)语句中的条件判断表达式。\n* (2)for ( .. ; .. ; .. )语句中的条件判断表达式(第二个)。\n* (3) while (..) 和 do..while(..) 循环中的条件判断表达式。\n* (4)? :中的条件判断表达式。\n* (5) 逻辑运算符 ||(逻辑或)和 &&(逻辑与)左边的操作数(作为条件判断表达式)。\n\n3️⃣ || 与 &&\n就一句话，理解了就万岁，称之为“操作数选择器”\n\n```js\na || b;\n// 大致相当于(roughly equivalent to): a ? a : b;\na && b;\n// 大致相当于(roughly equivalent to): a ? b : a;\n```\n\n### 4、== 与 ===\n- 常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”\n- 正确的解释是:“== 允许在相等比较中进行强制类型转换，而 === 不允许。","tags":["深入理解"],"categories":["JS"]},{"title":"React Refs揭密","url":"%2FReact%20Refs%E5%92%8CDOM%E6%8F%AD%E5%AF%86.html","content":"\n## 什么是Ref\nReact的官方介绍是这样的：\n\nIn the typical React dataflow, props are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.\n\n其中提到了这几个概念：\n\n在典型的React数据流理念中，父组件跟子组件的交互都是通过传递属性(properties)实现的。如果父组件需要修改子组件，只需要将新的属性传递给子组件，由子组件来实现具体的绘制逻辑。\n \n在特殊的情况下，如果你需要命令式(imperatively)的修改子组件，React也提供了应急的处理办法--Ref。\n\nRef 既支持修改DOM元素，也支持修改自定义的组件。\n\n---\n<!-- more -->\n\n## 什么是声明式编程(Declarative Programming)\n值得一提的是当中声明式编程(Declarative Programming)和命令式编程(Imperative Programming)的区别。声明式编程的特点是只描述要实现的结果，而不关心如何一步一步实现的，而命令式编程则相反，必须每个步骤都写清楚。我们可以根据语义直观的理解代码的功能是：针对数组的每一个元素，将它的值打印出来。不必关心实现其的细节。而命令式编程必须将每行代码读懂，然后再整合起来理解总体实现的功能。\n\nReact有2个基石设计理念：一个是声明式编程，一个是函数式编程。函数式编程以后有机会再展开讲。声明式编程的特点体现在2方面：\n\n组件定义的时候，所有的实现逻辑都封装在组件的内部，通过state管理，对外只暴露属性。\n\n组件使用的时候，组件调用者通过传入不同属性的值来达到展现不同内容的效果。一切效果都是事先定义好的，至于效果是怎么实现的，组件调用者不需要关心。\n\n因此，在使用React的时候，一般很少需要用到Ref。那么，Ref的使用场景又是什么？\n\n## Ref使用场景\nReact官方文档是这么说的：\n\nThere are a few good use cases for refs: Managing focus, text selection, or media playback.Triggering imperative animations.Integrating with third-party DOM libraries. Avoid using refs for anything that can be done declaratively.\n\n简单理解就是，控制一些DOM原生的效果，如输入框的聚焦效果和选中效果等；触发一些命令式的动画；集成第三方的DOM库。最后还补了一句：如果要实现的功能可以通过声明式的方式实现，就不要借助Ref。\n\n通常我们会利用 render 方法得到一个 App 组件的实例，然后就可以对它做一些操作。但在组件内，JSX 是不会返回一个组件的实例的，它只是一个ReactElement，只是告诉你，React被挂载的组件应该什么样：\n\n```js\nconst myApp = <App />\n```\n\nrefs就是由此而生，它是React组件中非常特殊的props， 可以附加到任何一个组件上，从字面意思上看，refs即reference，组件被调用时会创建一个该组件的实例，而refd就会指向这个实例。\n\n## Ref用法\n如果作用在原生的DOM元素上，通过Ref获取的是DOM元素，可以直接操作DOM的API：\n\n```js\nclass CustomTextInput extends React.Component {  \n    constructor(props) {    \n        super(props);        \n         this.focusTextInput = this.focusTextInput.bind(this);  \n    } \n    focusTextInput() {    \n        if(this.myTextInput !== null) {         \n             this.textInput.current.focus();    \n        }  \n    }  \n    render() {    \n         return (      \n             <div>        \n                 <input type=\"text\" ref={(ref) => this.myTextInput = ref} />        \n                 <input type=\"button\" value=\"Focus the text input\" onClick={this.focusTextInput}/>      \n             </div>    \n \n         );  \n     } \n }\n ```\n \n 如果作用在自定义组件，Ref获取的是组件的实例，可以直接操作组件内的任意方法：\n \n ```js\n class AutoFocusTextInput extends React.Component {  \n    constructor(props) {    \n        super(props);    \n         this.textInput = React.createRef();  \n    }  \n    componentDidMount() {    \n        this.textInput.current.focusTextInput();  \n    }  \n    render() {    \n        return (      \n            <CustomTextInput ref={this.textInput} />    \n        );  \n    } \n}\n```\n \n## Ref总结\n为了防止内存泄漏，当卸载一个组件时，组件里所有的refs就会变成null。\n\n值得注意的是，`findDOMNode` 和 `refs` 都无法用于无状态组件中。因为，无状态组件挂载时只是方法调用，并没有创建实例。\n\n对于 React 组件来讲，refs 会指向一个组件类实例，所以可以调用该类定义的任何方法。如果需要访问该组件的真实 DOM ，可以用 ReactDOM 。 findDOMNode来找到 DOM 节点，但并不推荐这样做，因为这大部分情况下都打破了封装性，而且通常都能用更清晰的方法在React中构建代码。","tags":["React"],"categories":["JS"]},{"title":"flutter入门","url":"%2Fflutter%E5%85%A5%E9%97%A8.html","content":"\n## 什么是flutter\n> Flutter is Google’s mobile UI framework for crafting high-quality \n> native interfaces on iOS and Android in record time. Flutter works \n> with existing code, is used by developers and organizations around \n> the world,and is free and open source.\n\n## 环境安装\n\n### 下载SDK\nhttps://flutter.io/docs/development/tools/sdk/archive?tab=macos#macos\n或者\ngit clone -b beta https://github.com/flutter/flutter.git\n\n### 镜像\n添加环境变量 .bash_profile\n```bash\nexport ANDROID_HOME=~/Library/Android/sdk\nexport PATH=${PATH}:${ANDROID_HOME}/tools\nexport PATH=${PATH}:${ANDROID_HOME}/platform-tools\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\nexport PATH=/Users/chenyu/treasure/flutter/flutter/bin:$PATH\n```\n\n### 运行`flutter doctor`查看是否需要安装其它依赖项来完成安装：\n\n该命令检查您的环境并在终端窗口中显示报告。Dart SDK已经在捆绑在Flutter里了，没有必要单独安装Dart。 仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务（以粗体显示）\n\n## 创建项目\n1. 在AndroidStudio安装Dart插件。启动studio，搜索flutter，自动安装Dart插件，完成后重启studio。 \n\n2. Android Studio - File - New -New Flutter Project\n\n### 文件入口\n项目路径下的lib文件夹下的main.dart文件\n\n```java\nimport 'package:flutter/material.dart'; //导包\nvoid main() => runApp(new MyApp());\nclass MyApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return new MaterialAp\n}\n```","tags":["flutter"],"categories":["JS"]},{"title":"如何用js实现JSON.parse()","url":"%2F%E5%A6%82%E4%BD%95%E7%94%A8js%E5%AE%9E%E7%8E%B0JSON.parse().html","content":"\n## eval\n```javascript\nvar json = '{\"a\":\"1\", \"b\":2}';\nvar obj = eval(\"(\" + json + \")\");  // obj 就是 json 反序列化之后得到的对象\n```\n> 为什么要加括号呢？\n因为js中{}通常是表示一个语句块，eval只会计算语句块内的值进行返回。加上括号就变成一个整体的表达式。\n\n```javascript\nconsole.log( eval('{}') );      // undefind\nconsole.log( eval('({})') );    // Object {}\n```\n\n> eval作用域问题\n```javascript\nvar s = 1;\nfunction a() {\n    eval('var s=2');\n    console.log(s);\n}\na();                // 2\nconsole.log(s);     // 1\n```\n在局部环境使用eval便会创建局部变量。可以显示指定eval调用者来改变上下文环境。\n\n```javascript\nvar s = 'global';\nfunction a() {\n    eval('var s = \"local\"');\n    console.log(s);                 // local\n    console.log(eval('s'));         // local\n    console.log(window.eval('s'));  // global\n}\n```\n\n### 对参数json进行校验防止xss漏洞\n```javascript\nvar rx_one = /^[\\],:{}\\s]*$/;\nvar rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n\nif (\n    rx_one.test(\n        json\n            .replace(rx_two, \"@\")\n            .replace(rx_three, \"]\")\n            .replace(rx_four, \"\")\n    )\n) {\n    var obj = eval(\"(\" +json + \")\");\n}\n```\n\n## 递归手动扫描每个字符\n\n## new Function 函数声明的传参形式\n```javascript\nvar add = new Function('a, b', 'return a+b;');\nconsole.log( add(2, 3) );    // 5\n```\n\n```javascript\nvar jsonStr = '{ \"age\": 20, \"name\": \"jack\" }',\n    json = (new Function('return ' + jsonStr))();\n```\n\n## 插入script\n> 模拟jsonP的方式拼接字符串然后以callBack的方式返回。","tags":["JSON"],"categories":["JS"]},{"title":"Sass、Less和Stylus区别","url":"%2Fsass%E3%80%81less%E5%92%8Cstylus%E5%8C%BA%E5%88%AB.html","content":"\n在前端界，有三大 CSS 预处理器，分别是 SASS(SCSS), Less, Stylus。\n本文便总结下 Sass、Less CSS、Stylus这三个预处理器的区别和各自的基本语法。\n\n> 我永远喜欢Stylus :>\n\n## 什么是CSS预处理器\n\nCSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让CSS 更见简洁，适应性更强，代码更直观等诸多好处。\n\n## 基本语法比较\n\n### Sass和Less\n首先 Sass 和 Less 都使用的是标准的 CSS 语法，因此如果可以很方便的将已有的 CSS 代码转为预处理器代码，默认 Sass 使用 .scss 扩展名，而 Less 使用 .Less 扩展名。\n```css\n/* style.scss or style.Less */\nh1 {\n  color: #0982C1;\n}\n```\n另一种也是最早的 Sass 语法格式，被称为缩进格式 (Indented Sass) 通常简称 \"Sass\"，是一种简化格式。它使用 “缩进” 代替 “花括号” 表示属性属于某个选择器，用 “换行” 代替 “分号” 分隔属性，很多人认为这样做比 SCSS 更容易阅读，书写也更快速。缩进格式也可以使用 Sass 的全部功能，只是与 SCSS 相比个别地方采取了不同的表达方式。\n```css\n/* style.Sass */\nh1\n  color: #0982c1\n```\n\n而 Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名。可以随意地书写。\n```css\n/* style.styl */\nh1 {\n  color: #0982C1;\n}\n/* 省略花括号 */\nh1\n  color: #0982C1;\n/* 省略花括号和分号 */\nh1\n  color #0982C1\n```\n\n---\n<!--more-->\n\n### 变量声明\n1. Sass\n> Sass变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。\n2. Less\n>  Less变量都是用@开头的。\n3. Stylus\n>  Stylus对变量是没有任何约束，可以是以$开头，或者任何的字符，而且与变量之间可以用冒号，空格隔开。\n\n### 嵌套\n```css\nsection {\n  margin: 10px;\n  nav {\n    height: 25px;\n    a {\n      color: #0982C1;\n      &:hover {\n        text-decoration: underline;\n      }\n    }\n  }\n} \n/* 使用“&”符号来引用父选择器。 */\n```\n\n### 运算符\n```css\nbody {\n  margin: (14px/2);\n  top: 50px + 100px;\n  right: 80 * 10%;\n}\n```\n\n### 颜色函数\n- Sass\n```css\nlighten($color, 10%); /* 返回的颜色在$color基础上变亮10% */\ndarken($color, 10%);  /* 返回的颜色在$color基础上变暗10% */\nsaturate($color, 10%);   /* 返回的颜色在$color基础上饱和度增加10% */\ndesaturate($color, 10%); /* 返回的颜色在$color基础上饱和度减少10% */\ngrayscale($color);  /* 返回$color的灰度色*/\ncomplement($color); /* returns complement color of $color */\ninvert($color);     /* 返回$color的反相色 */\nmix($color1, $color2, 50%); /* mix $color1 with $color2 with a weight of 50% */ \n```\n\n- Less\n```css\nlighten(@color, 10%); /* 返回的颜色在@color基础上变亮10% */\ndarken(@color, 10%);  /* 返回的颜色在@color基础上变暗10%*/\nsaturate(@color, 10%);   /* 返回的颜色在@color基础上饱和度增加10% */\ndesaturate(@color, 10%); /* 返回的颜色在@color基础上饱和度降低10%*/\nspin(@color, 10);  /* 返回的颜色在@color基础上色调增加10 */\nspin(@color, -10); /* 返回的颜色在@color基础上色调减少10 */\nmix(@color1, @color2); /* 返回的颜色是@color1和@color2两者的混合色 */  \n```\n\n- Stylus\n```css\nlighten(color, 10%); /* 返回的颜色在'color'基础上变亮10% */\ndarken(color, 10%);  /* 返回的颜色在'color'基础上变暗10% */\nsaturate(color, 10%);   /* 返回的颜色在'color'基础上饱和度增加10% */\ndesaturate(color, 10%); /* 返回的颜色在'color'基础上饱和度降低10% */  \n```\n\n### css预处理器处理属性前缀\n```css\n @mixin border-radius($values) {\n  -webkit-border-radius: $values;\n     -moz-border-radius: $values;\n          border-radius: $values;\n}\ndiv {\n  @include border-radius(10px);\n} \n```\n\n### 导入 (Import)\n很多 CSS 开发者对导入的做法都不太感冒，因为它需要多次的 HTTP 请求。但是在 CSS 预处理器中的导入操作则不同，它只是在语义上包含了不同的文件，但最终结果是一个单一的 CSS 文件，如果你是通过 @ import “file.css”; 导入 CSS 文件，那效果跟普通的 CSS 导入一样。\n```css\n/* file.{type} */\nbody {\n  background: #EEE;\n}\n```\n\n```css\n@import \"reset.css\";\n@import \"file.{type}\";\np {\n  background: #0982C1;\n} \n```\n\n- 转译出的css\n```css\n@import \"reset.css\";\nbody {\n  background: #EEE;\n}\np {\n  background: #0982C1;\n}  \n```\n\n### 混合（Mixins）\nMixins是预处器中的函数。当某段CSS样式经常要用到多个元素中，这样就需要重复的写多次。Mixins是一个公认的选择器，还可以在Mixins中定义变量或者是默认参数。\n- Sass @mixin声明 @include调用\n```css\n@mixin error($borderWidth: 2px) {\n  border: $borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  @include error(); //这里调用默认 border: 2px solid #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  @include error(5px); //这里调用 border:5px solid #F00;\n}\n```\n\n- Less\n```css\n.error(@borderWidth: 2px) {\n  border: @borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  .error(); //这里调用默认 border: 2px solid #F00;\n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  .error(5px); //这里调用 border:5px solid #F00;\n}\n```\n\n- Stylus 像函数一样\n```css\nerror(borderWidth= 2px) {\n  border: borderWidth solid #F00;\n  color: #F00;\n}\n.generic-error {\n  padding: 20px;\n  margin: 4px;\n  error(); \n}\n.login-error {\n  left: 12px;\n  position: absolute;\n  top: 20px;\n  error(5px); \n}\n```\n\n- example Sass3d文本\n```css\n@mixin text3d($color) {\n  color: $color;\n  text-shadow: 1px 1px 0px darken($color, 5%),\n               2px 2px 0px darken($color, 10%),\n               3px 3px 0px darken($color, 15%),\n               4px 4px 0px darken($color, 20%),\n               4px 4px 2px #000;\n}\n\nh1 {\n  font-size: 32pt;\n  @include text3d(#0982c1);\n}\n```\n\n### 继承（Inheritance）\n在多个元素应用相同的样式时，我们在CSS通常都是这样写：\n```css\np,\nul,\nol {\n  /* 样式写在这 */\n} \n```\n\n- Sass和Stylus @extend\n```css\n.block {\n  margin: 10px 5px;\n  padding: 2px;\n}\np {\n  @extend .block; /* 继承.block所有样式 */\n  border: 1px solid #EEE;\n}\n```\n\n- Less\nLESS支持的继承和Sass与Stylus不一样,他不是在选择器上继承，而是将Mixins中的样式嵌套到每个选择器里面。这种方法的缺点就是在每个选择器中会有重复的样式产生。\n```css\n .block {\n  margin: 10px 5px;\n  padding: 2px;\n}\np {\n  .block; /* 继承 '.block'中的样式 */\n  border: 1px solid #EEE;\n}\n```\n\n### if语句\n- Sass\n```css\n.mixin (@color) when (lightness(@color) > 30%) {\n    background-color: black;\n}\n.mixin (@color) when (lightness(@color) =<; 30%) {\n    background-color: white;\n}\n```\n\n- Less\n```css\n@if lightness($color) > 30% {\n    background-color: black;\n}\n\n@else {\n    background-color: white;\n}\n```\n\n- Stylus\n```css\nif lightness(color) > 30%\n    background-color black\nelse\n    background-color white\n```\n### loop\n- Sass\n```css\n@for $i from 1px to 3px {\n    .border-#{i} {\n        border: $i solid blue;\n    }\n}\n```\n\n- Less\n```css\n.loop(@counter) when (@counter > 0){\n    .loop((@counter - 1));\n\n    .border-@{counter} {\n        border: 1px * @counter solid blue;\n    }\n}\n```\n\n- Stylus\n```css\nfor num in (1..3)\n    .border-{num}\n        border 1px * num solid blue\n```\n\n### 作用域\n- Sass\nSass中不存在什么全局变量.\n```css\n$color: black;\n.scoped {\n  $bg: blue;\n  $color: white;\n  color: $color; /*白色*/\n  background-color:$bg;\n}\n.unscoped {\n  color:$color;/*白色*/\n}\t\n```\n\n- Less\nLESS中的作用域和其他程序语言中的作用域非常的相同，他首先会查找局部定义的变量，如果没有找到，会像冒泡一样，一级一级往下查找，直到根为止。\n```css\n@color: black;\n.scoped {\n  @bg: blue;\n  @color: white;\n  color: @color; /*白色*/\n  background-color:@bg;\n}\n.unscoped {\n  color:@color; /*黑色*/\n}\n```\n\n- Stylus\nStylus虽然起步比较晚，但其作用域的特性和LESS一样，可以支持全局变量和局变量。会向上冒泡查找，直到根为止。\n\n## 总结\nLess 从语言特性的设计到功能的健壮程度和另外两者相比都有一些缺陷，但用 Less 可以满足大多数场景的需求。\n但相比另外两者，基于 Less 开发类库会复杂得多，实现的代码会比较脏，能实现的功能也会受到 DSL 的制约。\n比 Stylus 语义更清晰、比 Sass 更接近 CSS 语法，使得刚刚转用 CSS 预编译的开发者能够更平滑地进行切换。\nSass 在三者之中历史最久，也吸收了其他两者的一些优点。\n从功能上来说 Sass 大而全，语义明晰但是代码很容易显得累赘。\n主项目基于 Ruby 可能也是一部分人不选择它的理由（Less 开始也是基于 Ruby 开发，后来逐渐转到 Less.js 项目中）。\nSass 有一个「事实标准」库——Compass，于是对于很多开发者而言省去了选择类库的烦恼，对于提升开发效率也有不小的帮助。\nStylus 的语法非常灵活，很多语义都是根据上下文隐含的。\n基于 Stylus 可以写出非常简洁的代码，但对使用团队的开发素养要求也更高，更需要有良好的开发规范或约定。\n总的来说，三种预处理器百分之七八十的功能是类似的。Less 适合帮助团队更快地上手预处理代码的开发，而 Sass 和 Stylus 的差异更在于口味。","tags":["Stylus"],"categories":["CSS"]},{"title":"angular7详解","url":"%2Fangular7%E8%AF%A6%E8%A7%A3.html","content":"\n## 开始准备\n1. 安装nodejs\n```\nnpm -v\n```\n\n2. 安装@angular/cli\n```\nnpm i -g @angular/cli\n```\n\n3. CLI命令建立项目\n```\nng new ng7demo\n```\n选择是否加入路由模块以及哪种css预处理器\n\n> 可ctrl+c取消自动安装node_modules，手动进入项目npm install\n> node-sass安装不上可切换淘宝镜像库或者用cnpm安装\n1. npm config set registry https://registry.npm.taobao.org \n   npm install\n\nor \n\n2. npm install -g cnpm \n   cnpm install \n\n4. 启动项目\n```javascript\nng serve --open // 自动打开浏览器 http://localhost:4200/\n```\n---\n<!--more-->\n\n## 语法\n### 生成组件\n```\n// 标签app-article 如果不想要或者自定义前缀可在angular.json里修改prefix属性\nng g c article\n// 可添加目录\nng g s ./serveices/eventBus\n// \n```\n### 组件引用\n```\n// 标签方式引用\n<app-article></app-article>\n// 属性方式引用\n<div app-article></div>\n// 类方式引用\n<div class=\"app-article\"></div>\n```\n\n```\n// @Component装饰器标识这是一个组件\n@Component({\n  //selector: 'app-article',\n  //selector: '[app-article]', //属性方式\n    selector: '.app-article',//类方式\n  templateUrl: './article.component.html',\n  styleUrls: ['./article.component.css']\n})\n```\n\n### 插值表达式\n将业务逻辑中的数据通过插值表达式显示在模板文件，即html页面上，或者将html页面上的事件传输到业务逻辑。\n\n```\n<p>标题是{{title}}</p>\n```\n### 属性绑定\n```\n<img [src]=\"imgSrc\" />\n<input value=\"value\"\n```\n\n### 插值运算 加减乘除/字符串拼接/三元/方法调用\n```\n{{5+3}},{{5-3}},{{5*3}},{{5/3}},{{ \"a\" + \"b\"}},{{true?1:0}}\n```\n### 事件绑定\n```\n<button (click)=\"showModal('click')\"><button>\n// 传递事件参数\n<input type=\"text\" (keyup) = \"updateContent($event)\"/>\n// 双向绑定 视图和数据，只要一方发生变化，另一方跟着变化。\n// 不需要在代码中手动更新视图，简化开发，增加代码内聚性，代码可读性更强。\n<input type=\"text\" [(ngModel)]=\"title\"/>\n// 为了ngModel能够解析需要引入import {FormsModule} from \"@angular/forms\";\n```\n\n### 模板指令\n#### 判断指令\n```\n<img *ngIf=\"imgShow;else #p1\"/>\n<p #p1></p>\n```\n#### 样式指令\n```\n<p [ngClass]=\"{bg:true}\">这段内容应用的是类样式。</p>\n<p [ngStyle]=\"{backgroundColor:pink}\">本段内容样式是内联样式。</p>\n```\n#### 循环指令\n```\n<ul>\n    <li *ngFor=\"let race of raceList; let i = index\">\n    {{ race.name }}-{{ i + 1 }}\n    </li>\n</ul>\n```\n\n### 管道符\n```\n{{currentTime | date: \"yyyy-MM-dd HH:mm:ss\" }}\n```\n### 父子组件通信\n```\n// 输入\n<child title=\"我的子组件\"></child>\n@Input\npublic title:string =\"\"\n// 输出\n<child title=\"我的子组件\" #child (follow)=\"getFollow($event)\"></child>\n@Output()\npublic follow = new EventEmitter();\nthis.follow.emit(\"子组件传来的数据\");\n```\n### localsStorage\n\n### 服务总线\n1. 注册服务\n```\nng g s ./services/eventBus\nimport { Injectable } from \"@angular/core\";\nimport { Observable, Subject } from \"rxjs\";\n// 服务总线 组件间分享数据\n@Injectable({\n  providedIn: \"root\"\n})\nexport class EventBusService {\n  public eventBus: Subject<string> = new Subject();\n  constructor() {}\n}\n```\n\n2. 组件内发射数据\n```javascript\nthis.eventBusService.eventBus.next(\"child组件发送的数据\");\n```\n\n3. 组件接收数据\n```javascript\nthis.eventBusService.eventBus.subscribe(arg => {\n    console.log(`接收到事件${arg}`);\n});\n```\n\n### 标签变量引用\n```\n<child title=\"我的子组件\" #child (follow)=\"getFollow($event)\"></child>\n<button (click)=\"child.sayHello()\">子组件说话</button>\n```\n\n### 组件注册\n```\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n// import部分是模块以及装饰器的引入。\n// declarations部分是声明模块的内部成员。\n// imports部分是导入其它模块。\n// providers指定应用程序根级别需要使用的service。\n// bootstrap是app启动的根组件。\n// export控制将那些内部成员暴露给外部使用。\n```\n\n### 路由导航\n```\nimport { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { ChildComponent } from \"./child/child.component\";\nimport { BrotherComponent } from \"./brother/brother.component\";\n\nconst routes: Routes = [{\n  path: '',\n  component: ChildComponent\n},\n{\n  path: 'brother',\n  component: BrotherComponent\n}];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n``` \n\n```\n<!--RouterOutlet 相当于一个占位符,在Angular中根据路由状态动态插入视图。-->\n<a [routerLink]=\"['/']\">child</a><br/>\n<a [routerLink]=\"['/brother']\">brother</a>\n<router-outlet></router-outlet>\n```\n### http服务\n```\n// app.module.ts\nimport { HttpModule } from '@angular/http';\nimport { HttpClientModule } from '@angular/common/http';\n// services\nimport { Headers } from '@angular/http';\nimport { HttpClient, HttpResponse } from '@angular/common/http';\n\nthis.httpClient.request(UserService.METHOD_POST, url, options).subscribe((data)=>{});\n``` \n\n## ng7的新特性\n```\n// angular.json\n\"budgets\": [\n    {\n        \"type\": \"initial\",\n        \"maximumWarning\": \"2mb\",\n        \"maximumError\": \"5mb\"\n    }\n]\n// 这个配置适用于打包文件限制 ng build --prod \n// 打包生成生产环境时如果包大于2MB,那么CLI工具会提示waning,如果大于5MB,中断打包。\n```\n\n## npm i 和 npm install的小区别\n1、用npm i 安装的模块无法用npm uninstall卸载，需要用npm uninstall i命令\n\n2、npm i 会帮助检测与当前node版本最匹配的npm包 版本号，并匹配出来相互依赖的npm包应该提升的版本号\n\n3、部分npm包在当前node版本下无法使用，必须使用建议版本\n\n4、安装报错时intall肯定会出现npm-debug.log 文件，npm i不一定","tags":["angular"],"categories":["JS"]},{"title":"大漠穷秋angular7讲座","url":"%2F%E5%A4%A7%E6%BC%A0%E7%A9%B7%E7%A7%8Bangular7%E8%AE%B2%E5%BA%A7.html","content":"h5 132合法标签\n大而全的angular\nemmm一上午要讲基础--还都是基本例子基本都见过\n\n### 编译器\n集成开发环境@angular/cli\n### 模板引擎\n\n## 组件库\n- datagrid\n- tree z-tree\n- datepicker\n- formvalid\nng2-admin \n比较接地气\n- JHipster\n- nicefish\n\n- 生成组件\n> ng g c User\n\n```javascript\nnpm install -g @angular/cli\n```\n--- \n<!--more-->\n\n我的看法(好用程度)\nstylus>less>sass\n\n* 人类的本质就是复读机\n* 学习本就是一个不断抄袭、模仿、联系、创新的过程。\n* 就这么个意思还是学习了语法绑定，自己说服自己。会语法基本就能做东西，深入才是重点。\n大佬自己都说angular慢0.0，基本都会涵盖demo的内容实现业务开发。\n\n##  第一天感受\n大佬上午讲了js的发展历史，下午讲了ng的基础语法、环境搭建等特性。比较基础的demo示例，比较低端，以前就做过。有点小失望。\n\n优化记录\n1. index.js 2.4M\n2. 七牛云的图片域名被回收了\n\n## qs.stringify和JSON.stringify\n```javascript\nvar a = {name:'hehe',age:10};\n qs.stringify(a)\n// 'name=hehe&age=10'\nJSON.stringify(a)\n// '{\"name\":\"hehe\",\"age\":10}'\n```\nwp php建站 主题模板 响应式插件 资讯门户站\n加载慢，angular这种大而全的框架很不错，但是我永远喜欢react.jpg😁","tags":["讲座"],"categories":["JS"]},{"title":"css高度坍塌和判断横竖屏","url":"%2Fcss%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C%E5%92%8C%E5%88%A4%E6%96%AD%E6%A8%AA%E7%AB%96%E5%B1%8F.html","content":"\n{% centerquote %} \n 1.01^365=37.8\n{% endcenterquote %}\n\n两个盒子，一个下边距20px，一个上边距50px，最后为两个盒子之间的距离为多少 50px\n解决:根据W3C的标准，在页面中元素都一个隐含的属性叫做Block FormattingContext\n简称BFC，该属性可以设置打开或者关闭，默认是关闭的。\n\n---\n<!--more-->\n### css高度坍塌\n\nBFC——块级格式化上下文\n\n- 触发条件\n  - float不为none\n  - overflow不为visible\n  - display为table-cell，table-caption，inline-block\n  - position为absolute，fixed\n  - fieldset元素\n- 功能\n  - 自我独立，内部元素不会影响外部元素\n  - 会包含浮动元素\n  - 同一个BFC的margin重叠\n\n#### 当开启元素的BFC以后，元素将会具有如下的特性：\n1. 父元素的垂直外边距不会和子元素重叠\n2. 开启BFC的元素不会被浮动元素所覆盖\n3. 开启BFC的元素可以包含浮动的子元素\n\n#### 如何开启元素的BFC\n1. 设置元素浮动(不推荐)\n- 使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题\n2. 设置元素绝对定位(不推荐)\n3. 设置元素为inline-block(不推荐)\n- 可以解决问题，但是会导致宽度丢失，不推荐使用这种方式\n4. 将元素的overflow设置为一个非visible的值（aotu hidden）\n推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。\noverflow: hidden;\n\n但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。\n在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做hasLayout，该属性的作用和BFC类似，所在IE6浏览器可以通过开hasLayout来解决该问题开启方式很多，我们直接使用一种副作用最小的：直接将元素的zoom设置为1即可。\n\n> zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍\n> zoom:1表示不放大元素，但是通过该样式可以开启hasLayout\n> zoom这个样式，只在IE中支持，其他浏览器都不支持。\n\n### 设备旋转监听\n- 事件\n```javascript\n// Listen for orientation changes\nwindow.addEventListener(\"orientationchange\", function() {\n    // Announce the new orientation number\n    alert(window.orientation);\n\n}, false);\n```\n\n- 媒体查询\n```html\n<!-- link元素中的CSS媒体查询 -->\n<link rel=\"stylesheet\" media=\"(max-width: 800px)\" href=\"example.css\" />\n```\n\n```css\n/* 样式表中的CSS媒体查询 */\n@media all and (orientation: portrait) {\n  body div {background: red;} \n\n}\n@media (min-width: 700px) and (orientation: landscape) { \n  body div {background: blue; } \n}\n```\n\n- resize方法\n可以用resize事件来判断。用innerWidth ， innerHeight，可以检索得到屏幕大小。依据宽和高的大小比较判断，宽小于高为竖屏，宽大与高就是横屏。\n```javascript\n(function(){\n    var updateOrientation = function(){\n        var orientation = (window.innerWidth > window.innerHeight) ? 'landscape' : 'portrait';\n    };\n\n    var init = function(){\n\n        updateOrientation();\n        \n        //监听resize事件\n        window.addEventListener('resize',updateOrientation,false);\n    };\n\n    window.addEventListener('DOMContentLoaded',init,false);\n})();\n```","tags":["布局"],"categories":["知识"]},{"title":"使用命令行激活windows10专业版","url":"%2F%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BF%80%E6%B4%BBwindows10%E4%B8%93%E4%B8%9A%E7%89%88.html","content":"\n以管理员的身份运行cmd\n\n1. 先卸载密钥\n```bash\nslmgr.vbs /upk\n```\n- 此时弹出窗口显未“已成功卸载了产品密钥”。\n\n2. 安装密钥\n```bash\nslmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX\n```\n- 弹出窗口提示：“成功的安装了产品密钥”。\n\n3. 设置计算机名\n```bash\nslmgr /skms cosyer的个人电脑\n```\n- 弹出窗口提示：“密钥管理服务计算机名成功的设置为cosyer的个人电脑”。\n\n---\n<!-- more -->\n\n4. 激活密钥\n```bash\nslmgr /ato\n```\n- 此时将弹出窗口提示：“成功的激活了产品”。\n\n如果第4步未能成功地激活，则重复执行第3步、第4步，且将第3步的语句修改为以下几个之一，需要一个一个进行尝试。\n\n```bash\n“slmgr /skms 110.noip.me”\n“slmgr /skms kms.lotro.cc”\n“slmgr /skms mhd.kmdns.net”\n“slmgr /skms xykz.f3322.org”\n“slmgr /skms 106.186.25.239”\n“slmgr /skms 3rss.vicp.net:20439”\n“slmgr /skms 45.78.3.223”\n“slmgr /skms kms.chinancce.com”\n“slmgr /skms kms.didichuxing.com”\n“slmgr /skms skms.ddns.net”\n“slmgr /skms franklv.ddns.net”\n“slmgr /skms 192.168.2.8”\n```","tags":["windows10激活"],"categories":["知识"]},{"title":"chrome插件扩展程序开发指南","url":"%2Fchrome%E6%8F%92%E4%BB%B6%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.html","content":"\n### 什么是chrome extensions\nChrome Extensions，中文名叫 “Chrome浏览器扩展程序”。引用官方文档的描述，翻译一下就是 “可以修改和增强浏览器功能的 H5 小程序”。\n它的入口在浏览器窗口的右上角，地址栏的最右边\n\n---\n<!-- more -->\n\n### 入门\n#### manifest.json\nmanifest.json 是整个插件扩展程序中最重要的一个描述文件，这个 json 格式的文件包含了你整个扩展程序的一些重要描述，比如 “扩展程序名称”、“扩展程序图标”、“权限申请” 等。\n\n```json\n{\n  // Required\n  \"manifest_version\": 2, // manifest 版本号，这里都写 2 就好了，从 Google Chrome 18 开始，就开始升级到 2 版本了\n  \"name\": \"My Extension\",\n  \"version\": \"1.0.0\", // 扩展程序版本，这个是自定义的，建议参考 semver 规范(http://semver.org/)\n\n  // Recommended\n  \"default_locale\": \"zh\", // 默认语言，具体可以看 i18n 文档(https://developer.chrome.com/extensions/i18n)\n  \"description\": \"A plain text description\", // 项目描述\n  \"icons\": { // icon，不同的位置支持不同大小的 icon，具体看文档(https://developer.chrome.com/extensions/manifest/icons)\n    \"128\": \"icons/icon_128.png\",\n    \"48\": \"icons/icon_48.png\",\n    \"16\": \"icons/icon_16.png\"\n  },\n\n  // Pick one (or none)\n  \"browser_action\": { // 多数都是使用这个，插件扩展程序针对的是浏览器行为（图标是在地址栏外面）\n    \"default_icon\": \"icons/24.png\", // 最佳大小为19*19，地址栏上的插件扩展程序的 icon（一般作为主入口）\n    \"default_popup\": \"popup.html\", // 点击插件扩展程序 icon 后弹出来的窗口的主页面 html\n    \"default_title\": \"extentsions demo\" // 当鼠标放到扩展程序图标上时显示的文字\n  },\n  \"page_action\": { // 插件扩展程序针对的是页面行为（图标是在地址栏里面的）\n    ...\n  },\n\n  // Optional\n  \"author\": ...,\n  \"automation\": ...,\n  \"background\": {\n    // Recommended\n    \"persistent\": false\n  },\n  \"background\": {\n    \"scripts\": [\"eventPage.js\"],\n    \"persistent\": false\n  },\n  \"chrome_settings_overrides\": {...},\n  \"chrome_ui_overrides\": {\n    \"bookmarks_ui\": {\n      \"remove_bookmark_shortcut\": true,\n      \"remove_button\": true\n    }\n  },\n  \"chrome_url_overrides\": {...},\n  \"commands\": {...},\n  \"content_capabilities\": ...,\n  \"content_scripts\": [{...}],\n  \"content_security_policy\": \"policyString\",\n  \"converted_from_user_script\": ...,\n  \"current_locale\": ...,\n  \"declarative_net_request\": ...,\n  \"devtools_page\": \"devtools.html\",\n  \"event_rules\": [{...}],\n  \"externally_connectable\": {\n    \"matches\": [\"*://*.example.com/*\"]\n  },\n  \"file_browser_handlers\": [...],\n  \"file_system_provider_capabilities\": {\n    \"configurable\": true,\n    \"multiple_mounts\": true,\n    \"source\": \"network\"\n  },\n  \"homepage_url\": \"http://path/to/homepage\",\n  \"import\": [{\"id\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"}],\n  \"incognito\": \"spanning, split, or not_allowed\",\n  \"input_components\": ...,\n  \"key\": \"publicKey\",\n  \"minimum_chrome_version\": \"versionString\",\n  \"nacl_modules\": [...],\n  \"oauth2\": ...,\n  \"offline_enabled\": true,\n  \"omnibox\": {\n    \"keyword\": \"aString\"\n  },\n  \"optional_permissions\": [\"tabs\"],\n  \"options_page\": \"options.html\",\n  \"options_ui\": {\n    \"chrome_style\": true,\n    \"page\": \"options.html\"\n  },\n  \"permissions\": [\"tabs\"],\n  \"platforms\": ...,\n  \"plugins\": [...],\n  \"requirements\": {...},\n  \"sandbox\": [...],\n  \"short_name\": \"Short Name\",\n  \"signature\": ...,\n  \"spellcheck\": ...,\n  \"storage\": {\n    \"managed_schema\": \"schema.json\"\n  },\n  \"system_indicator\": ...,\n  \"tts_engine\": {...},\n  \"update_url\": \"http://path/to/updateInfo.xml\",\n  \"version_name\": \"aString\",\n  \"web_accessible_resources\": [...]\n}\n```\n\n#### 学做一个demo\n1. manifestjson(该文本文件需要用UTF8字符集保存)\n```json\n{\n  \"name\": \"第一个Chrome插件\",\n  \"manifest_version\": 2,\n  \"version\": \"1.0\",\n  \"description\": \"我的第一个Chrome插件，还不错吧\",\n  \"browser_action\": {\n    \"default_icon\": \"1.png\"\n  },\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://www.baidu.com/\"],\n      \"js\": [\"test.js\"]\n    }\n  ]\n}\n```\n\n2. test.js\n```javascript\nalert(\"Hello World\");\ndocument.body.style.backgroundColor=\"gray\";\n```\ncontent_scripts是运行在打开页面的脚本，可以拿到整个页面的DOM对象，所以可以利用该脚本对页面进行操作。\n\n3. 添加图片1.png\n\n4. 打开chrome，打开菜单，找到扩展程序选项更多工具>扩展程序路径下。点击加载已解压的扩展程序，添加文件夹就OK啦！\n\n\n### 常用api \n- bookmarks: 书签管理接口，可以对浏览器的书签进行增删改查等管理\n- tabs: 标签管理接口，可以对浏览器的标签进行增删改查等管理\n- contextMenus: 右键菜单管理\n- cookies: 浏览器 cookie 的管理\n- notifications: 消息通知\n- desktopCapture: 可针对 “窗口” 或者 ”标签“ 的截图接口\n- i18n: 国际化（多语言支持）\n\n### 程序发布和分享\n打包扩展程序，第一次打包只需要设置根目录，打包完成后会生成.crx和.pem密钥文件(版本的迭代需要此文件，否则则会生成新的程序文件)，将.crx文件发给其他人拖入扩展程序页面即可安装。\n\n### 发布到chrome商店\n当一切准备就绪，就可以准备发布上线了，Chrome 有个官方的插件扩展程序市场，还自带了发布和更新等一体化管理的流程，非常方便。\n传送门：[Chrome商店dashboard](https://chrome.google.com/webstore/developer/dashboard)\n\n注意，上传的是 zip 而不是生成的 crx 文件，具体参考：[https://developer.chrome.com/webstore/publish](https://developer.chrome.com/webstore/publish)\n\n### 常见问题\n1. 引入外部 js 时报 Refused to load the script 的问题\n```javascript\n<script src=\"https://code.jquery.com/jquery-3.2.1.min.js\"></script>\n```\n解决方案：修改 content_security_policy，把对应的域名加上去即可，比如以上的问题可以解决：\n\n```json\n{\n    \"content_security_policy\": \"https://code.jquery.com\"\n}\n```\n> 以上表示允许 https://code.jquery.com 域名下的外部 js 的引入。\n2. Chrome 插件扩展程序是开源的方式安装的，可以去安装目录通过扩展程序 ID 来找到源码。\n正常情况下，Chrome 插件扩展程序的默认安装目录如下：\n\n- Windows XP：C:\\Documents and Settings\\用户名\\Local Settings\\Application Data\\Google\\Chrome\\User Data\\Default\\Extensions\n- Windows7：C:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions\n- Mac：~/Library/Application Support/Google/Chrome/Default/Extensions\n- Ubuntu：~/.config/google-chrome/Default/Extensions\n如果在这些不同操作系统中的默认安装位置没找到插件，那么还有一种方法可以查询到。\n\n地址栏访问 chrome:version\n找到 “个人资料路径”，该路径下的 extensions 文件夹就是 Chrome 插件扩展程序的安装路径了\n安装路径下的插件扩展程序，是以 ID 为目录区分的\n地址栏访问 chrome://extensions/，可以查看每个插件扩展程序的 ID\n\n### 高级教程-chrome插件合集\n[项目地址](https://github.com/cosyer/chrome-extensions)\n\n### 参考资料\n[官方文档](https://developer.chrome.com/extensions/overview)","tags":["整理"],"categories":["知识"]},{"title":"helloPHP","url":"%2FhelloPHP.html","content":"\n1年以前我就浅学过PHP，用`thinkPHP`框架开发起来确实比较轻松快捷流水化。最近闲来无事，再次回顾学习下这个世界上最好的语言。\n\n## 简介\nPHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。\n\n## 语法\nPHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。\n\nPHP 脚本可以放在文档中的任何位置。\n\nPHP 脚本以 <?php 开始，以 ?> 结束。很多语言的语法都相类似。\n\n```php\n<!DOCTYPE html> \n<html> \n<body> \n<?php \necho \"Hello World!\";\n// 单行注释\n/*\n多行注释\n*/\n?> \n</body> \n</html>\n```\n\n---\n<!-- more -->\n\n### 变量\n- 变量以 $ 符号开始，后面跟着变量的名称\n\n- 变量名必须以字母或者下划线字符开始\n\n- 变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）\n\n- 变量名不能包含空格\n\n- 变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\n> 同js一样PHP也是弱类型脚本语言不需要声明变量的数据类型\n\n### 作用域\n1. local 局部\n2. global 全局\n3. static 静态\n4. parameter 参数\n\n```php\n<?php \n$x=5; // 全局变量 \n$z=5;\nfunction myTest() \n{ \n    $y=10; // 局部变量 \n    global $x,$z; // 函数内部访问全局变量需要加global关键字\n    $z=$x+$z;\n    // 一样的效果$GLOBALS['z']=$GLOBALS['x']+$GLOBALS['z'];\n}  \n\nmyTest(); \necho \"<p>测试函数外变量:<p>\"; \necho \"变量 x 为: $x\"; \necho \"<br>\"; \necho \"变量 y 为: $y\"; \necho $z; // 10\n?>\n```\n\n当一个函数完成时，它的所有变量通常都会被删除。所以当需要时可以声明静态变量\n\n```php\n<?php\nfunction myTest($y)\n{\n    static $x=0;\n    echo $x,$y; // 参数变量\n    $x++;\n}\n \nmyTest(1);\nmyTest(2);\nmyTest(3);\n?>\n```\n\n### 输出echo和print\necho 和 print 区别:\n- echo - 可以输出一个或多个字符串\n- print - 只允许输出一个字符串，返回值总为 1\n> echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。\n\n### 语句加分号\n\n### 数据类型\n1. String（字符串）\n\n```php\n<?php \n$txt1=\"Hello\"; \n$txt2=\"World\"; \necho $txt1 . \" \" . $txt2;  // \"Hello world\"\necho strlen(\"Hello World!\"); // 返回长度\necho strpos(\"Hello World!\",\"World\"); // 返回索引和js indexOf很像\n?>\n```\n\n2. Integer（整型）\n3. Float（浮点型）\n4. Boolean（布尔型）\n5. Array（数组）\n```php\n<?php\n$cars=array(\"Volvo\",\"BMW\",\"Toyota\");\necho count($cars);\n?>\n// 数组遍历\n<?php\n$cars=array(\"Volvo\",\"BMW\",\"Toyota\");\n$arrlength=count($cars);\n \nfor($x=0;$x<$arrlength;$x++)\n{\n    echo $cars[$x];\n    echo \"<br>\";\n}\n?>\n// 关联数组 object？\n<?php\n$age=array(\"Peter\"=>\"35\",\"Ben\"=>\"37\",\"Joe\"=>\"43\");\necho \"Peter is \" . $age['Peter'] . \" years old.\";\n?>\n// 遍历关联数组\n<?php\n$age=array(\"Peter\"=>\"35\",\"Ben\"=>\"37\",\"Joe\"=>\"43\");\n \nforeach($age as $x=>$x_value)\n{\n    echo \"Key=\" . $x . \", Value=\" . $x_value;\n    echo \"<br>\";\n}\n?>\n```\n数组排序函数\n- sort() - 对数组进行升序排列\n- rsort() - 对数组进行降序排列\n- asort() - 根据关联数组的值，对数组进行升序排列\n- ksort() - 根据关联数组的键，对数组进行升序排列\n- arsort() - 根据关联数组的值，对数组进行降序排列\n- krsort() - 根据关联数组的键，对数组进行降序排列\n\n6. Object（对象）\n使用class关键字声明类对象。类是可以包含属性和方法的结构。\n\n```php\n<?php\nclass Car\n{\n  var $color;\n  function __construct($color=\"green\") {\n    $this->color = $color;\n  }\n  function what_color() {\n    return $this->color;\n  }\n}\n?>\n```\n\n7. NULL（空值）\n> PHP var_dump() 函数返回变量的数据类型和值：\n### 常量的声明\ndefine()函数 \n> define(\"slogan\", \"hello\");\n该函数有三个参数:\n- name：必选参数，常量名称，即标志符。\n- value：必选参数，常量的值。\n- case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。\n\n### if...elseif....else 语句\n```php\n<?php\n$t=date(\"H\");\nif ($t<\"10\")\n{\n    echo \"Have a good morning!\";\n}\nelseif ($t<\"20\")\n{\n    echo \"Have a good day!\";\n}\nelse\n{\n    echo \"Have a good night!\";\n}\n?>\n```\n\n### 超级全局变量\n- $GLOBALS(超级全局变量组)\n- $_SERVER(包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组)\n- $_REQUEST(用于收集HTML表单提交的数据)\n- $_POST(用于收集HTML表单提交的数据,method设置为post)\n- $_GET(用于收集HTML表单提交的数据,method设置为get,也可以收集URL中发送的数据)\n- $_FILES\n- $_ENV\n- $_COOKIE\n- $_SESSION\n\n```php\n<?php\n$x=array(\"one\",\"two\",\"three\");\nforeach ($x as $value)\n{\n    echo $value . \"<br>\";\n}\n?>\n```\n\n### 魔术常量(预定义常量)\n- __LINE__(当前行号)\n- __FILE__(文件的完整路径和文件名)\n- __DIR__(文件所在目录)\n- __FUNCTION__(函数内部返回函数名)\n- __CLASS__(类内部返回类名)\n- __TRAIT__(Trait 名包括其被声明的作用区域)\n从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。\n其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。\n\n```php\n<?php\nclass Base {\n    public function sayHello() {\n        echo 'Hello ';\n    }\n}\n \ntrait SayWorld {\n    public function sayHello() {\n        parent::sayHello();\n        echo 'World!';\n    }\n}\n \nclass MyHelloWorld extends Base {\n    use SayWorld;\n}\n \n$o = new MyHelloWorld();\n$o->sayHello(); // Hello World\n?>\n```\n\n- __METHOD__(返回方法定义时的名称)\n- __NAMESPACE__(当前的命名空间名称)\n1. 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。\n2. 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。\n\n### php获取下拉菜单的数据\n```php\n<?php\n$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';\nif($q) {\n        if($q =='BAIDU') {\n                echo '百度<br>http://www.baidu.com';\n        } else if($q =='GOOGLE') {\n                echo 'Google 搜索<br>http://www.google.com';\n        } else if($q =='TAOBAO') {\n                echo '淘宝<br>http://www.taobao.com';\n        }\n} else {\n?>\n<form action=\"\" method=\"get\"> \n    <select name=\"q\">\n    <option value=\"\">选择一个站点:</option>\n    <option value=\"BAIDU\">Runoob</option>\n    <option value=\"GOOGLE\">Google</option>\n    <option value=\"TAOBAO\">Taobao</option>\n    </select>\n    <input type=\"submit\" value=\"提交\">\n    </form>\n<?php\n}\n?>\n```\n\n### 获取当前时间\n```php\n<?php\n//设置默认当前时区\ndate_default_timezone_set('PRC');\necho date('Y-m-d H:i:s',time());\n?>\n```\n\n### 文件引入\n> include 和 require 的区别\n- require 一般放在 PHP 文件的最前面，程序在执行前就会先导入要引用的文件；\n- include 一般放在程序的流程控制中，当程序执行时碰到才会引用，简化程序的执行流程。\n- require 引入的文件有错误时，执行会中断，并返回一个致命错误；\n- include 引入的文件有错误时，会继续执行，并返回一个警告。\n\n### 打开文件\n```php\n$file = fopen(\"test.txt\",\"r\");\n\n// 读取文件每一行，直到文件结尾\nwhile(!feof($file))\n{\n    echo fgets($file). \"<br>\";\n    //  逐个字符echo fgetc($file);\n}\n\nfclose($file);\n```\n\n### 文件上传\n```html\n<form action=\"upload_file.php\" method=\"post\" enctype=\"multipart/form-data\">\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n```\n\n```php\n<?php\nheader(\"Content-Type: text/html;charset=utf-8\");\n// 允许上传的图片后缀\n$allowedExts = array(\"gif\", \"jpeg\", \"jpg\", \"png\", \"PNG\");\n$temp = explode(\".\", $_FILES[\"file\"][\"name\"]);\necho $_FILES[\"file\"][\"size\"];\n$extension = end($temp);     // 获取文件后缀名\nif ((($_FILES[\"file\"][\"type\"] == \"image/gif\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/jpeg\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/jpg\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/pjpeg\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/x-png\")\n|| ($_FILES[\"file\"][\"type\"] == \"image/png\"))\n&& ($_FILES[\"file\"][\"size\"] < 204800)   // 小于 200 kb\n&& in_array($extension, $allowedExts))\n{\n    if ($_FILES[\"file\"][\"error\"] > 0)\n    {\n        echo \"错误：: \" . $_FILES[\"file\"][\"error\"] . \"<br>\";\n    }\n    else\n    {\n        echo \"上传文件名: \" . $_FILES[\"file\"][\"name\"] . \"<br>\";\n        echo \"文件类型: \" . $_FILES[\"file\"][\"type\"] . \"<br>\";\n        echo \"文件大小: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" kB<br>\";\n        echo \"文件临时存储的位置: \" . $_FILES[\"file\"][\"tmp_name\"] . \"<br>\";\n        \n        // 判断当期目录下的 upload 目录是否存在该文件\n        // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777\n        if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"]))\n        {\n            echo $_FILES[\"file\"][\"name\"] . \" 文件已经存在。 \";\n        }\n        else\n        {\n            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下\n            move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]);\n            echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"];\n        }\n    }\n}\nelse\n{\n    echo \"非法的文件格式\";\n}\n?>\n```\n\n### 设置cookie(必须写在html之前)\n```php\nsetcookie(\"user\", \"cosyer\", time()+3600); // 1小时后过期\necho $_COOKIE[\"user\"]; // (isset($_COOKIE[\"user\"])判断是否设置了cookie\n// 删除setcookie(\"user\", \"\", time()-3600);设置成过去的时点\n```\n\n### 存储session\n```php\nsession_start();\n// 存储 session 数据\n$_SESSION['views']=1;\n// 释放 session 数据\n// unset($_SESSION['views']);\n// 清空所有数据\n// session_destroy();\n```\n\n### php发送email\n```php\n<?php\nif (isset($_REQUEST['email'])) { // 如果接收到邮箱参数则发送邮件\n    // 发送邮件\n    $email = $_REQUEST['email'] ;\n    $subject = $_REQUEST['subject'] ;\n    $message = $_REQUEST['message'] ;\n    mail(\"someone@example.com\", $subject,\n    $message, \"From:\" . $email);\n    echo \"邮件发送成功\";\n} else { // 如果没有邮箱参数则显示表单\n    echo \"<form method='post' action='mailform.php'>\n    Email: <input name='email' type='text'><br>\n    Subject: <input name='subject' type='text'><br>\n    Message:<br>\n    <textarea name='message' rows='15' cols='40'>\n    </textarea><br>\n    <input type='submit'>\n    </form>\";\n}\n?>\n```\n\n### 错误处理\n> die(\"文件不存在\");\n### 异常处理 同 try catch new Exception()","tags":["PHP"],"categories":["PHP"]},{"title":"webapck4零配置了解一下","url":"%2Fwebpack4%E9%9B%B6%E9%85%8D%E7%BD%AE%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B.html","content":"\nwebpack4 最主要的卖点便是零配置，要想成为一位webpack配置工程师怎么能不开始了解呢？话不多说，让我们开始体验 webpack 4 的一些特性。\n\n### entry 和 output\n1. 创建空目录，初始化配置\n```bash\nmkdir webpack4-quickstart\ncd  webpack4-quickstart\nnpm init -xyz\n```\n\n2. 安装相关依赖\n```bash\nnpm i webpack --save-dev\nnpm i webpack-cli --save-dev\n```\n\n- webpack： 即 webpack 核心库。它提供了很多 API, 通过 Node.js 脚本中 require('webpack') 的方式来使用 webpack。\n- webpack-cli：是 webpack 的命令行工具。webpack 4 之前命令行工具是集成在 webpack 包中的，4.0 开始 webpack 包本身不再集成 cli。\n\n3. package.json添加构建命令\n```javascript\n\"scripts\":{\n    \"build\":\"webpack\"\n}\n```\n---\n<!-- more -->\n\n- 如果直接开始运行`npm run build`会因为缺少指定的默认目录的文件导致抛出错误\n- 添加入口文件 \n```javascript\n// ./src/index.js\nconsole.log(\"hello world\")\n```\n- 再执行`npm run build`，则默认生成了'./dist/main.js'文件\n\n### development和production模式\n在webpack 4 以前，拥有2份配置文件是webpack项目常见的情况，一个常规的项目配置可能是这样的：\n\n> 一份开发环境的配置，用来配置 dev server 和其他的一些东西\n> 一份生产环境的配置，配置一些 UglifyJSPlugin、sourcemaps 等等\n但是在webpack 4中，我们可以通过设置命令行参数production和development来区分环境：\n\n```json\n\"scripts\": {\n  \"dev\": \"webpack --mode development\",\n  \"build\": \"webpack --mode production\"\n}\n```\n\n分别执行`npm run dev`和`npm run build`会发现第二种执行的代码被压缩了。\n\n> Development mode 则是在速度上进行了优化，只不过不会提供压缩功能。\n> Production mode 可以实现各种优化，包括 代码压缩、tree-shaking...\n\n### 脚本中覆盖默认的入口和出口\n```json\n\"scripts\": {\n  \"dev\": \"webpack --mode development ./entry/index.js --output ./output/main.js\",\n  \"build\": \"webpack --mode production ./entry/index.js --output ./output/main.js\"\n}\n```\n\n### babel插件配置es6->es5\n\n1. 插件依赖\n> babel-core\n> babel-loader\n> babel-preset-env 编译 ES6 -> ES5 \n```javascript\nnpm i babel-core babel-loader babel-preset-env --save-dev\n```\n\n2. 通过`./babelrc`来配置相关插件\n```json\n{\n    \"presets\":[\n        \"env\"\n    ]\n}\n```\n\n3. 2种方式来配置`babel-loader`\n> webpack.config.js配置\n```javascript\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \"babel-loader\"\n        }\n      }\n    ]\n  }\n};\n```\n> 脚本命令配置 --module-bind\n```json\n\"scripts\": {\n    \"dev\": \"webpack --mode development --module-bind js=babel-loader\",\n    \"build\": \"webpack --mode production --module-bind js=babel-loader\"\n  }\n```\n\n这里只是简单的介绍，想要详细的了解webpack4的新特性请访问[github地址](https://github.com/cosyer/webpack4)。","tags":["整理"],"categories":["知识"]},{"title":"实现前端路由","url":"%2F%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1.html","content":"\n现代的前端框架react/vue/angular都有路由router的概念，通过手写实现可以帮助我们更好地了解它的工作原理。\n\n### 实现路由的2种方式\n1. hash模式\n2. history模式\n\n### 缺点\nhash: 地址栏会多出一个#号，对url造成影响，在某些场景下如微信支付有坑。\nhistory: 兼容性差，直接访问汇报400，需要服务器做处理。\n\n### 基本原理\nhash基于hashchange，而history则基于pushState和popState\n\n### hash模式\n```javascript\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n  <style>\n    body {\n      margin: 0;\n      padding: 0;\n    }\n\n    #login, #index {\n      width: 100%;\n      height: 100%;\n      display: none;\n    }\n\n    #login {\n      background: #f5f5f5;\n      display: block;\n    }\n\n    #index {\n      background: #aaddff;\n    }\n  </style>\n</head>\n<body>\n\n<!--登录页-->\n<div id=\"login\" class=\"component\">\n  <input type=\"button\" onclick=\"hashPush('index?id=1')\" value=\"登陆\">\n</div>\n\n<!--首页-->\n<div id=\"index\" class=\"component\">\n  <input type=\"button\" onclick=\"hashPush('login?key=2',{data:'params data'})\" value=\"退出登陆\">\n</div>\n\n</body>\n<script>\n  // 全局变量\n  var params = {}\n\n  // 页面跳转\n  function hashPush(url, param) {\n    location.hash = \"#\" + url\n\n    // 解析url\n    let questionIndex = url.indexOf(\"?\")\n    let path = url\n    if (questionIndex >= 0) {\n      path = url.substr(0, questionIndex)\n    }\n\n    if (param) {\n      params[path] = param\n    }\n  }\n\n  // 监听hash的变动\n  window.addEventListener('hashchange', function (e) {\n    let url = location.hash.slice(1) || \"index\"\n    // 解析url\n    let questionIndex = url.indexOf(\"?\")\n    let path, query\n    if (questionIndex >= 0) {\n      path = url.substr(0, questionIndex)\n      let queryString = url.substr(questionIndex + 1)\n      let queryArray = queryString.split(\"&\")\n      let queryObject = {}\n      queryArray.map(str => {\n        let equalIndex = str.indexOf(\"=\")\n        if (equalIndex > 0) {\n          let key = str.substr(0, equalIndex)\n          let value = str.substr(equalIndex + 1)\n          queryObject[key] = value\n        }\n      })\n      query = queryObject\n    } else {\n      path = url\n      query = {}\n    }\n\n    console.log('接收到url传递的参数', query)\n    console.log('直接用params传递的参数', params[path])\n    setVisible(path)\n  })\n\n  // 显示跟路由地址对应的内容，隐藏其他内容\n  function setVisible(url) {\n    let components = Array.from(document.body.querySelectorAll(\".component\"))\n    components.map(item => {\n      if (item.id === url) {\n        // console.log('显示',item.id)\n        item.style.display = 'block'\n      } else {\n        // console.log('隐藏',item.id)\n        item.style.display = 'none'\n      }\n\n    })\n  }\n</script>\n</html>\n```\n\n### history模式(需要服务器环境)\n```javascript\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Document</title>\n  <style>\n    body {\n      margin: 0;\n      padding: 0;\n    }\n\n    #login, #index {\n      width: 100%;\n      height: 100%;\n      display: none;\n    }\n\n    #login {\n      background: #f5f5f5;\n      display: block;\n    }\n\n    #index {\n      background: #aaddff;\n    }\n  </style>\n</head>\n<body>\n\n<!--登录页-->\n<div id=\"login\" class=\"component\">\n  <input type=\"button\" onclick=\"historyPush('index')\" value=\"登陆\">\n</div>\n\n<!--首页-->\n<div id=\"index\" class=\"component\">\n  <input type=\"button\" onclick=\"historyPush('login',{data:'params data'})\" value=\"退出登陆\">\n</div>\n\n</body>\n<script>\n  // 全局变量\n  var params = {}\n\n  // 页面跳转\n  function historyPush(url, param) {\n    history.pushState(param, '我是页面标题', url)\n    if (param) {\n      params[url] = param\n    }\n  }\n\n  // 监听前进后退\n  window.addEventListener('popstate', function (e) {\n    // e.state 就是pushState 的时候，传的第一个参数\n    let url = state.target.location.pathName\n    console.log('接收到传递的参数', e.state)\n    console.log('直接用params传递的参数', params[path])\n    setVisible(path)\n  })\n\n  // 显示跟路由地址对应的内容，隐藏其他内容\n  function setVisible(url) {\n    let components = Array.from(document.body.querySelectorAll(\".component\"))\n    components.map(item => {\n      if (item.id === url) {\n        // console.log('显示',item.id)\n        item.style.display = 'block'\n      } else {\n        // console.log('隐藏',item.id)\n        item.style.display = 'none'\n      }\n\n    })\n  }\n</script>\n</html>\n```","tags":["整理"],"categories":["知识"]},{"title":"js函数柯里化","url":"%2Fjs%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96.html","content":"\n### 函数柯里化定义\n\n函数柯里化（function currying）又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数后，\n\n该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包里被保存起来。待到函数真正需要求值的时候，之前传入的参数都会被一次性用于求值。\n\n把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。\n\n顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。\n\n```javascript\nfunction add(x,y){\n    return x + y;\n}\n// 函数只传入一个参数的时候实现加法\nfunction curry(x){\n    return function(y){\n        return x + y;\n    }\n}\nvar add2 = curry(1);\nadd2(1) // 2 即curry(1)(1)\n```\n\n--- \n<!-- more -->\n\n### 函数柯里化实践\n\n```javascript\n// 通过以上简单介绍我们大概了解了，函数柯里化基本是在做这么一件事情：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。用公式表示就是我们要做的事情其实是\n\nfn(a,b,c,d)=>fn(a)(b)(c)(d)；\n\nfn(a,b,c,d)=>fn(a，b)(c)(d)；\n\nfn(a,b,c,d)=>fn(a)(b，c，d)；\n\n......\n\n// 再或者这样：\n\nfn(a,b,c,d)=>fn(a)(b)(c)(d)()；\n\nfn(a,b,c,d)=>fn(a)；fn(b)；fn(c)；fn(d)；fn()；\n```\n\n> 通用的函数柯里化版本\n\n```javascript\n// 这里需要传入长度\nfunction curry(fn, length, ary) {\n    length = length || fn.length;\n    ary = ary || [];//记录所有传入的参数\n    var slice = Array.prototype.slice;\n    return function () {\n        if (arguments.length < length) {\n            Array.prototype.push.apply(ary, slice.call(arguments));//每次把参数合并到ary数组中\n            return curry(fn, length - arguments.length, ary)//把还需传参的长度和已有参数数组传入curry，递归调用\n        } else {\n            return fn.apply(this, ary.concat(slice.call(arguments))); //调用求职函数，记得把此次传入的参数合并到ary数组再计算\n        }\n    };\n}\n\nlet total = function () {\n        let total = 0;\n        [].slice.call(arguments).forEach(item => {\n            total += item;\n        });\n        return total;\n    };\n let fn = curry(total, 4);\n fn(1)(2)(3)(4);//10\n fn(1,2)(3)(4);//10\n```\n\n```javascript\n// 这里是无参数时开始计算所有的cost\nvar currying = function(fn){\n    var args = [];\n    \n    return function(){\n        if(arguments.length === 0){\n            return fn.apply(this, args);\n        }else{\n            [].push.apply(args, arguments);\n            return arguments.callee;\n        }\n    }\n};\nvar cost = (function(){\n    var money = 0;\n    \n    return function(){\n        for(var i = 0, l = arguments.length; i < l; i++){\n            money += arguments[i];\n        }\n        return money;\n    }\n}());\n\nvar cost = currying(cost);//转化为currying函数\n\ncost(100);//未真正求值\ncost(200);//未真正求值\ncost(300);//未真正求值\n\nconsole.log(cost());//求值并输出：600  \n```\n\n```javascript\n// 和toString().valueOf()时计算和是一样的道理\nfunction add(num){\n    var _add = function(args){\n        num+=args;\n        return arguments.callee;\n    }\n    // (function foo(args){num+=args return foo;})\n    var _add =(function foo(args){num+=args; return foo;})\n    _add.toString = _add.valueOf = function(){\n        return num;\n    }\n    return _add;\n}\n```\n\n### 为了减少函数传参，同时将一些固定参数私有化\n```javascript\nfunction curry(func) {\n  var l = func.length;\n  return function curried() {\n    var args = [].slice.call(arguments);\n    if (args.length < 1) {\n      return function () {\n        var argtsInner = [].slice.call(arguments);\n        return curried.apply(this, arrs.concat(argtsInner))\n      }\n    } else {\n      return func.apply(this, args)\n    }\n  }\n}\nvar f = function (a, b, c) {\n  return console.log([a, b, c])\n}\nvar curried = curry(f);\ncurried(1)(2)(3)\n```\n\n### 函数柯里化的优点\n1. 延迟计算 \n可以传递需要的参数，等到何时想要结果，再一并计算。\n\n2. 参数复用 \n有些参数相同，只需要传递一遍即可，不需要每次都传，太繁琐。","tags":["整理"],"categories":["知识"]},{"title":"为什么react和immutable成为了好基友","url":"%2F%E4%B8%BA%E4%BB%80%E4%B9%88react%E5%92%8Cimmutable%E6%88%90%E4%B8%BA%E4%BA%86%E5%A5%BD%E5%9F%BA%E5%8F%8B.html","content":"\n工作中，React社区推崇搭配一起使用Immutable，就像咖啡牛奶伴侣一样。众所周知React的性能优化我们可以优化组件的嵌套层级，\n\n避免不必要的重绘，以及shouldComponentUpdate来判别组件是否会因为当前属性(props)和状态(state)变化而导致组件输出变化。\n\n一提到React，大家第一时间就想到的虚拟DOM(Virtual DOM)和伴随其带来的高性能（在虚拟dom上进行节点的更改最后在反映到真实dom上）。\n\n但是React提供的是声明式的API(declarative API),好的一方面是让我们编写程序更加方便，但另一方面，却使得我们不太了解内部细节。\n\n--- \n<!-- more -->\n\n### 一致化处理(Reconciliation)\nReact采用的是虚拟DOM，每次属性(props)和状态(state)发生变化的时候，render函数返回不同的元素树，\n\nReact会检测当前返回的元素树和上次渲染的元素树之前的差异，然后找出何如高效的更新UI。即render就执行diff差异再进行重绘。\n\n### shouldComponentUpdate\n默认的shouldComponentUpdate会在props和state发生变化时返回true,表示组件会重新渲染，从而调用render函数。\n\n当然了在首次渲染的时候和使用forceUpdate的时候，是不会经过shouldComponentUpdate判断。\n\n合理地编写shouldComponentUpdate函数，从而能避免不必要的一致化处理，使得性能可以极大提高。。我们可以通过\n\n继承React.PureComponent或者通过引入PureRenderMixin模块来达到目的。但是这也存在一个问题:\n\n```javascript\n// 子组件继承PureComponent只会进行浅比较\nclass ListOfWords extends React.PureComponent {\n  render() {\n    return <div>{this.props.words.join(',')}</div>;\n  }\n}\n\nclass WordAdder extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      words: ['marklar'] // 复杂类型\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  handleClick() {\n    // 当触发点击页面并没有进行重新渲染\n    const words = this.state.words;\n    words.push('marklar');\n    this.setState({words: words});\n  }\n\n  render() {\n    return (\n      <div>\n        <button onClick={this.handleClick} />\n        <ListOfWords words={this.state.words} />\n      </div>\n    );\n  }\n}\n```\n> 共享的可变状态是万恶之源\n\nJavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。\n\n如 foo={a: 1}; bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了 2。\n\n虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。\n\n为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。\n\nImmutable 可以很好地解决这些问题。\n\n\n### Immutable Data\n\nImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。\n\nImmutable 实现的原理是 Persistent Data Structure（持久化数据结构），\n\n也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，\n\nImmutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。\n\n> Map：键值对集合，对应于 Object，ES6 也有专门的 Map 对象\n\n> List：有序可重复的列表，对应于 Array\n\n> Set：无序且不可重复的列表\n\n比较两个Immutable对象是否相同，只需要使用===就可以轻松判别。因此如果React传入的数据是Immutable Data,那么React就能高效地比较前后属性的变化，从而决定shouldComponentUpdate的返回值。\n\n```javascript\n// 原来的写法\nlet foo = {a: {b: 1}};\nlet bar = foo;\nbar.a.b = 2;\nconsole.log(foo.a.b);  // 打印 2\nconsole.log(foo === bar);  //  打印 true\n\n// 使用 immutable.js 后\nimport Immutable from 'immutable';\nfoo = Immutable.fromJS({a: {b: 1}});\nbar = foo.setIn(['a', 'b'], 2);   // 使用 setIn 赋值\nconsole.log(foo.getIn(['a', 'b']));  // 使用 getIn 取值，打印 1\nconsole.log(foo === bar);  //  打印 false\n\n// 使用  seamless-immutable.js 后\nimport SImmutable from 'seamless-immutable';\nfoo = SImmutable({a: {b: 1}})\nbar = foo.merge({a: { b: 2}})   // 使用 merge 赋值\nconsole.log(foo.a.b);  // 像原生 Object 一样取值，打印 1\nconsole.log(foo === bar);  //  打印 false\n```\n\n#### Immutable-advantage\n1. Immutable 降低了 Mutable 带来的复杂度\n```javascript\nfunction touchAndLog(touchFn) {\n  let data = { key: 'value' };\n  touchFn(data);\n  console.log(data.key);\n}\n```\n在不了解touchFn函数的代码的情况下，不知道是否对data进行了修改。而如果data为Immutable对象一切都简单了，会打印value。\n\n2. 节省内存\nImmutable.js 使用了 Structure Sharing （结构共享）会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。\n\n```javascript\nimport { Map } from 'immutable';\nlet a = Map({\n  select: 'users',\n  filter: Map({ name: 'Cam' })\n})\nlet b = a.set('select', 'people');\n\na === b; // false\na.get('filter') === b.get('filter'); // true\n// 上面 a 和 b 共享了没有变化的 filter 节点。\n```\n\n3. Undo/Redo，Copy/Paste，时间旅行等功能\n\n4. 并发安全\n\n5. 函数式编程\n\n#### Immutable-disadvantage\n1. 需要熟悉新的api\n\n2. 引入新的库有大小\n\n3. 思维的变化\nImmutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get('key')而不是 map.key，array.get(0) 而不是 array[0]。\n\n下面给出一些办法来避免类似问题发生：\n\n> 使用 Flow 或 TypeScript 这类有静态类型检查的工具\n> 约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头。\n> 使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用。\n\n另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值。\n\n#### 两个Immutable对象的比较\n1. === 全等比较内存地址性能最好\n\n2. Immutable.is() 进行值比较\n\nImmutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。\n\n由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。\n\n```javascript\nlet a = Immutable.Map({a：1})\nlet b = Immutable.Map({a：1})\na === b // false \nImmutable.is(a,b) // true \n// Object.defineProperty() // IE9\n```\n#### 与 Object.freeze、const 区别\nObject.freeze 和 ES6 中新加入的 const 都可以达到防止对象被篡改的功能，但它们是 shallowCopy 的。对象层级一深就要特殊处理了。怪不得常量const复杂类型就不行了，直接回答浅拷贝。\n\n\n#### react中使用\n```javascript\nimport { is } from 'immutable';\n\nshouldComponentUpdate: (nextProps = {}, nextState = {}) => {\n  const thisProps = this.props || {}, thisState = this.state || {};\n  // 不清楚层级 直接比较两个对象\n  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||\n      Object.keys(thisState).length !== Object.keys(nextState).length) {\n      return true;\n  }\n\n  for (const key in nextProps) {\n    if (!is(thisProps[key], nextProps[key])) {\n      return true;\n    }\n  }\n\n  for (const key in nextState) {\n    if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) {\n      return true;\n    }\n  }\n  return false;\n}\n```\n\n```javascript\nfunction diff(obj1,obj2){\n    var o1 = obj1 instanceof Object;\n    var o2 = obj2 instanceof Object;\n    if(!o1 || !o2){/*  判断不是对象  */\n        return obj1 === obj2;\n    }\n\n    if(Object.keys(obj1).length !== Object.keys(obj2).length){\n        return false;\n        //Object.keys() 返回一个由对象的自身可枚举属性(key值)组成的数组,例如：数组返回下表：let arr = [\"a\", \"b\", \"c\"];console.log(Object.keys(arr))->0,1,2;\n        //即Object.keys只适用于可枚举的属性，而Object.getOwnPropertyNames返回对象自动的全部属性名称。\n    }\n\n    for(var attr in obj1){\n        var t1 = obj1[attr] instanceof Object;\n        var t2 = obj2[attr] instanceof Object;\n        if(t1 && t2){\n            return diff(obj1[attr],obj2[attr]);\n        }else if(obj1[attr] !== obj2[attr]){\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n```javascript\nimport '_' from 'lodash';\n\nconst Component = React.createClass({\n  getInitialState() {\n    return {\n      data: { times: 0 }\n    }\n  },\n  handleAdd() {\n    let data = _.cloneDeep(this.state.data);\n    data.times = data.times + 1;\n    this.setState({ data: data });\n    // 如果上面不做 cloneDeep，下面打印的结果会是已经加 1 后的值。let data = this.state.data 指向同一内存地址\n    console.log(this.state.data.times);\n  }\n}\n\n使用 Immutable 后：\n\n  getInitialState() {\n    return {\n      data: Map({ times: 0 })\n    }\n  },\n  handleAdd() {\n    this.setState({ data: this.state.data.update('times', v => v + 1) });\n    // 这时的 times 并不会改变\n    console.log(this.state.data.get('times'));\n  }\n上面的 handleAdd 可以简写成：\n\n  handleAdd() {\n    this.setState(({data}) => ({\n      data: data.update('times', v => v + 1) })\n    });\n  }\n```\n\n#### 常用api\n```javascript\n// 声明\nImmutable.Map({a:1})\nImmutable.Map([1,2])\n\n// 原生js转换为immutable data\nImmutable.fromJS({a:1}) // immutable的 map\n\nImmutable.fromJS([1,2]) // immutable的 list\n\n// 从immutableData 回到 JavaScript 对象\nimmutableData.toJS()\n\n// 判断两个immutable数据是否一致\nImmutable.is(immutableA, immutableB)\n\n// 判断是不是map或List\nImmutable.Map.isMap(x)\n\nImmutable.List.isList(x)\n\n// 对象合并(注意是同个类型)\nimmutableMaB = immutableMapA.merge(immutableMaC)\n\n// Map的增删改查\nimmutableData.get('a') // {a:1} 得到1。\n\nimmutableData.getIn(['a', 'b']) // {a:{b:2}} 得到2。访问深层次的key\n\n// 增和改(注意不会改变原来的值，返回新的值原有的基础上扩展出分支)\nimmutableData.set('a', 2) // {a:1} 得到1。\n\nimmutableData.setIn(['a', 'b'], 3)\n\nimmutableData.update('a',function(x){return x+1})\n\nimmutableData.updateIn(['a', 'b'],function(x){return x+1})\n\n// 删\nimmutableData.delete('a')\n\nimmutableData.deleteIn(['a', 'b'])\n\n// List的增删查改如同Map，不过参数变为数字索引。比如immutableList.set(1, 2)\n```\n\n当然还有现在火热的immer.js，unstated了解一下@_@\n\n[参考文章](https://www.cnblogs.com/3body/p/6224010.html)","tags":["react"],"categories":["JS"]},{"title":"\\[1,2,3\\]是JSON吗？","url":"%2F%5B1%2C2%2C3%5D%E6%98%AFJSON%E5%90%97%EF%BC%9F.html","content":"\nA: “这个接口我传个 JSON 给你，格式是这样的 '[1, 2, 3]'”\n\nB: “等下，这不是数组吗，JSON 应该有键啊，类似这样才行'{ \"key\": [1, 2, 3] }'”\n\nA: “不，这就是 JSON 格式的数据”\n\nB: “啊，是吗？”\n你是否也有这样的疑惑？ wappalyzer chrome网页分析插件\n\n--- \n<!-- more -->\n\n## 什么是JSON\n\n**JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。**\n\n它仅仅是一种格式，就好比厨师脑中的食谱，这道菜有什么材料。而从原材料变成成品给顾客食用，这个过程食谱并没有实际参与，只是一个指导作用。\n\n所以JSON也是不存在于我们的程序中，不存在任何地方，只是一个思维，存在我们脑海里。\n\n这个思维，就是JSON这种格式应该包含哪些元素。\n\n- “名称/值”对的集合\n- 值的有序列表\n\n> 所以\"[1,2,3]\"是符合JSON格式的数据结构的\n\n> 但不能说[1, 2, 3]是一个JSON，它在javascript中可以被转换为数组，也可以在其他语言中被转换为数组（如果有这种类型）。而之所以只有这两种，是因为大部分现代计算机语言都支持。\n那[1, 2, undefined, 3]符合JSON格式吗？\n> “既然结构要是计算机语言都支持的，那结构中的值也需要吧，而undefined是javascript独有的，其他语言并没有，所以不符合JSON格式。”\n\n合法的JSON值有以下6种\n- string\n- number\n- boolean\n- null\n- object\n- array\n\n```javascript\n{\n    \"person\": {\n        \"name\": \"ltaoo\",\n        \"age\": 18,\n        \"skills\": [\"javascript\", \"html\", \"css\"]\n    },\n    \"happy\": true\n}\n```\n\n## JS中的JSON\n在JavaScript中，如果在请求接口时要传递数据，我们往往会说“传一个JSON”，从上面已经知道JSON只是一个格式，那我们传递的到底是什么？\n\n```javascript\n// 一个简单的 post 请求\nconst body = {\n    name: 'ltaoo',\n    age: 18\n};\n\nfetch('https://easy-mock.com/mock/5a1d30028e6ddb24964c2d91/business/api/login', {\n    method: 'POST',\n    body,\n})\n    .then((res) => res.json())\n    .then((data) => {\n        console.log(data);\n    });\n```\n\n> 但实际上并没有将参数传递过去，即Headers中并不存在Request Payload，需要将body使用JSON.stringify()方法转换为一个字符串后，才能成功传递。\nbody:JSON.stringify(body) or '{\"name\": 'ltaoo',\"age\": 18}'\n\n但两者还是有区别的\n\n```javascript\nconst body = {\n    name: 'ltaoo',\n    skills: undefined,\n};\nconsole.log(JSON.stringify(body)); // {\"name\":\"ltaoo\"}\n```\n\n```javascript\nconst body = {\n    name: 'ltaoo',\n    skills: [undefined],\n};\nconsole.log(JSON.stringify(body)); // {\"name\":\"ltaoo\",\"skills\":[null]}。\n```\n\n### JSON.parse\n> JSON.parse() 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。\n> 可以用来判断某个字符串是否符合JSON格式\n\n## 总结\n\nJSON是日常开发中最常使用的，但仅限于“会用”，实际上JSON的用途已经不局限在“数据交换”，NoSQL、配置文件也有JSON的身影，深入了解是有必要的，毕竟看起来这么“简单”。","tags":["知识"],"categories":["知识"]},{"title":"java -jar与nohup","url":"%2Fjava%20-jar%E4%B8%8Enohup.html","content":"\njava程序员，经常会遇到这样一个问题，打个jar包，测试或者上线生产，于是乎面临的选择来了，java –jar or nohup？\n下面我来扒一扒：\n\n## java -jar a.jar &\n直接启动jar文件，在当前会话进程中开启一个子进程来运行程序，这个子进程会随着会话进程的结束而结束。\n\n这种情况适合短时间测试用。\n\n## nohup java -jar a.jar &\nhangup ：(挂断)，终端退出时会发送 hangup 信号来通知其关闭所有子进程。\n\nnohup ：(不挂断，忽略挂断信号)。\n\nnohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上\"&\"来将命令同时放入后台运行，也可用\">filename2>&1\"来更改缺省的重定向文件名。\n\n这种情况适合在生产环境长时间运行。\n\n## nodejs应用在linux上运行\n\n### 使用场景\n\n- forever管理多个站点，每个站点访问量不大，不需要监控。\n- supervisor是开发环境用。\n- nodemon 是开发环境使用，修改自动重启。\n- pm2 网站访问量比较大,需要完整的监控界面。\n\n1. forever\n```javascript\nnpm install -g forever\nforever start index.js -o out.log -e err.log\nforever list \nforever stop index.js [id]\nforever stopall\nforever restartall\n```\n\n2. supervisor 热部署\n```javascript\nnpm install -g supervisor\nsupervisor app.js // 文件有改动会立即重启node模块\n```\n\n3. nodemon\n```javascript\nnpm install -g nodemon\nnodemon app.js\n```\n\n4. nohup\n```javascript\nnohup node index.js &\nnohup node index.js > myLog.log 2>&1 &\n```\n\nnohup问题:\n\n但是有时候在这一步会有问题，当把终端关闭后，进程会自动被关闭，查看nohup.out可以看到在关闭终端瞬间服务自动关闭。\n有个操作终端时的细节：当shell中提示了nohup成功后还需要按终端上键盘任意键退回到shell输入命令窗口，然后通过在shell中输入exit来退出终端；\n而我是每次在nohup执行成功后直接点关闭程序按钮关闭终端。所以这时候会断掉该命令所对应的session，导致nohup对应的进程被通知需要一起shutdown。\n\n5. 高大上的pm2\n\n特性：\n- 内建负载均衡（使用Node cluster 集群模块）\n- 后台运行\n- 0秒停机重载，维护升级的时候不需要停机\n- 具有Ubuntu和CentOS 的启动脚本\n- 停止不稳定的进程（避免无限循环）\n- 控制台检测\n- 提供 HTTP API\n- 远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )\n\n使用：\n\n```javascript\nnpm install -g pm2\npm2 start app.js -o out.log -e err.log\npm2 stop app.js\npm2 restart app.js\npm2 list\npm2 descibe [id]\npm2 monit // 查看cpu和内存使用\npm2 logs // 实时集中log处理\npm2 web // 浏览器查看\n```","tags":["Java"],"categories":["知识"]},{"title":"实现双向绑定","url":"%2F%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.html","content":"\n主流的双向绑定方法\n1.发布-订阅模式\n通过使用 get 和 set 的方式获取数据然后更新数据，其原理就是监听页面中某个具体元素的事件，然后将其最新的值手动 set 到 数据中，同时订阅 model 层的改变，然后触发页面的渲染更新\n\n2.脏检测\n通过对比数据是否有变更，来决定是否更新视图。最简单的可以通过定时轮询去检测数据的变动。Angular 只有在指定事件触发时进入脏检测：\n\n- DOM事件，比如用户输入文本点击按钮等（ng-click）\n- XHR响应事件\n浏览器 Location 变更\n- Timer事件\n- 执行 $digest() 或 $apply();\n\n脏检查的主要原理是在将数据绑定到 View 的时候，就在监听器列表（scope 作用域中的监听队列 watchList）中插入一条监听器，当触发 UI 事件或者 Ajax 请求时，就会触发脏检查（$digest cycle), 在 $digest 流程中，将遍历每个数据变量的 watcher，比较它的新旧值。当新旧值不同时，触发 listener 函数，执行相关的更新逻辑。这个过程将会一直重复，直到所有数据指令的新旧值都相同为止。\n\n脏检查虽然可以达到实现双向绑定，但是当页面中绑定的 watcher 过多时，就会引发性能问题。所以 angular 在进行 $digest 检测时，会限制循环检查的次数最少2次，最多10次，防止无效的检查。\n\n3.数据劫持\n通过 ES5 的 Object.defineProperty() 来劫持数据属性的 getter 和 setter， 在数据变动时触发订阅者（watcher），从而触发相应的监听回调。\n\n- Observer 对数据的所有属性进行监听其 getter 和 setter\n- Compile 是一个指令解析器，对 MVVM 实例的所有元素指令进行解析，并渲染成 model 中的绑定数据，当数据进行更新时，也能替换为更新后的值。\n- Watcher 作为 Compile 和 Observer 的桥梁，能够订阅数据属性的更新，然后执行相应的监听回调\n- Deps 用于存放监听器数组，主要用来保存 Watcher\n- Updater 执行更新操作，针对不同的指令进行不同的更新操作，如 v-model, v-class, v-html 等类型的指令。\n- MVVM 作为入口函数，整合以上所有的功能。\n\nObserver 劫持了所有数据属性的 getter 和 setter，当数据发生改变时，就会通知 deps 中所有 watcher 的更新操作，进而触发页面的重新渲染，这是修改 Model 层从而引发 View 层的重新渲染。\n在 Compile 中监听可输入元素的事件，然后将新值更新到 model 的数据中，这是修改 View 层触发的 Model 层的修改。\n\n- 用户名或者邮箱跟github没有关联上， github认为不是你提交的， 不统计。\n- fork 的项目， 不统计\n- 没有在版本库的master【默认分支】上提交\n\n[解读](https://github.com/SunShinewyf/issue-blog/issues/46)\n\n---\n<!--more-->\n\n## defineProperty实现\n\n目前支持双向绑定的Vue中的实现就是这种方法。但是这种方法不太好的地方就是对于数组之类的对象，类似修改数组的length，直接用索引设置元素如items[0] = {}，以及数组的push，pop等变异方法是无法触发setter的。针对这些，vue中的实现是在Object和Array的原型添加了定制方法来处理这些特殊操作，可以实现上述要求。\n\n```js\n/**\n  * bind\n  * @param {object} target \n  * @param {object} dom \n  * @param {object} map \n  */\nconst bind = (target, dom, map) =>\n  Object.keys(map || target).forEach(key =>\n    Object.defineProperty(target, key, {\n      set(value) {\n        const domKey = map ? map[key] : key\n        dom[domKey] = value\n      },\n      get() {\n        const domKey = map ? map[key] : key\n        return dom[domKey]\n      }\n    }))\nwindow._alternate = {}\n\nconst p = document.getElementById('p')\n\nbind(_alternate, p, {\n  'value': 'innerHTML'\n})\n```\n\n## proxy实现\n\n怎么理解reflect\nreflect 是es6新增的一个全局对象。顾名思义，反射，类似于Java里面的反射机制。在Java里面，反射是个很头疼的概念。简单理解为：通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。对于Java来说，程序中一般的对象的类型都是在编译期就确定下来的，而Java反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。\n\n```js\n/**\n  * bind\n  * @param {object} model \n  * @param {object} map \n  */\nconst bind = (model, map) => new Proxy(map || model, {\n  get(_, key) {\n    const mkey = map ? map[key] : key\n    return Reflect.get(model, mkey)\n  },\n  set(_, key, value) {\n    const mkey = map ? map[key] : key\n    return Reflect.set(model, mkey, value)\n  }\n})\n\nwindow.__alternate = bind(document.getElementById('p'), {\n  'value': 'innerHTML'\n})\n```","tags":["整理"],"categories":["JS"]},{"title":"深浅拷贝","url":"%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D.html","content":"\n## 深浅拷贝概念\n\n深拷贝和浅拷贝只针对象 Object, Array 这样的复杂对象（引用类型）的。\n\n复制引用（引用类型）的拷贝方法称之为浅拷贝，也因为直接复制引用类型，导致新旧对象共用一块内存地址，会互相影响。\n\n深拷贝就是指完全的拷贝一个对象，将原对象的各个属性递归复制下来。这样即使嵌套了对象，两者也相互分离。\n\n## 浅拷贝 对基本类型拷贝值，引用类型拷贝引用\n\n```javascript\nvar shallowCopy = function(obj) {\n    if (typeof obj !== 'object') return;      // 只拷贝对象\n    var newObj = obj instanceof Array ? [] : {};     // 根据obj的类型判断是新建一个数组还是对象\n    for (var key in obj) {      // 遍历obj，并且判断是obj的属性才拷贝\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = obj[key];\n        }\n    }\n    return newObj;\n}\n\nfunction shallowCopy2(source) {\n  if (source === null || typeof source !== 'object') return source;\n  const copy = Array.isArray(source) ? [] : {};\n\n  Object.keys(source).forEach(key => {\n    copy[key] = source[key];\n  });\n  return copy;\n}\n\nvar obj = { a:1, arr: [2,3] };\nvar shallowObj = shallowCopy(obj);\nshallowObj.arr[1] = 5;\nconsole.log(obj.arr[1])  // 5 互相影响 指向了同一块内存地址\nshallowObj.a = 5;\nconsole.log(obj.a) // 1 \n```\n\n## 深拷贝\n```javascript\nvar deepCopy = function(obj) {\n    if (typeof obj !== 'object') return;\n    var newObj = obj instanceof Array ? [] : {};\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];\n        }\n    }\n    return newObj;\n}\n\nvar obj = { a:1, arr: [2,3] };\nvar shallowObj = shallowCopy(obj);\nshallowObj.arr[1] = 5;\nconsole.log(obj.arr[1])  // 3 没有影响 重新拷贝了新数据\nshallowObj.a = 5;\nconsole.log(obj.a) // 1 \n```\n\n```js\n// 不考虑循环引用\nconst clone = function(data){\n    if(typeof data !== 'object'){\n        return data;\n    }\n    let keys = Object.keys(data);\n    let result = Array.isArray(data) ? [] : {};\n    keys.forEach(key=>{\n        if(typeof data[key] === 'object'){\n            result[key] = clone(data[key]);\n        }else{\n            result[key] = data[key];\n        }\n    })\n    return result;\n}\n```\n\n```js\n// 考虑循环引用\nconst clone = function(data){\n    let map = new WeakMap(); // 这里用WeakMap弱引用，会自动回收，不需要手动处理置为null\n    function dp(obj){\n        if(typeof obj !== 'object'){\n            return obj;\n        }\n        let o = map.get(obj);\n        if(o){\n            return o;\n        }\n        let result = Array.isArray(obj) ? [] : {};\n        map.set(obj,result);\n        let keys = Object.keys(obj);\n        keys.forEach(key=>{\n            if(typeof obj[key] === 'object'){\n                result[key] = dp(obj[key]);\n            }else{\n                result[key] = obj[key];\n            }\n        })\n        return result;\n    }\n    return dp(data);\n}\n```\n\n\n\n尽管使用深拷贝会完全的克隆一个新对象，不会产生副作用，但是深拷贝因为使用递归，性能会不如浅拷贝，在开发中，还是要根据实际情况进行选择。","tags":["整理"],"categories":["知识"]},{"title":"js判断数据类型","url":"%2Fjs%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html","content":"\n## typeof\n> typeof一般只能返回如下几个结果：number,boolean,string,function,object,undefined字符串\n\n> 对于Array,null等特殊对象使用typeof一律返回object，这正是typeof的局限性。\n\n> 在判断除Object类型的对象(基本类型)时比较方便。\n\n```javascript\nvar fn = new Function ('a', 'b', 'return a + b')\n\ntypeof fn // function\n```\n\n## instanceof \n> instanceof适用于检测对象，它是基于原型链运作的。\n\n> instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。换种说法就是如果左侧的对象是右侧对象的实例， 则表达式返回true, 否则返回false 。\n\n> instanceof对基本数据类型检测不起作用，因为基本数据类型没有原型链。\n\n```javascript\n[1, 2, 3] instanceof Array // true \n/abc/ instanceof RegExp // true \n({}) instanceof Object // true \n(function(){}) instanceof Function // true\n```\n\n## Object.prototype.toString.call\n\n可以检测各种数据类型，推荐使用。\n\n```javascript\nObject.prototype.toString.call([]); // => [object Array] \nObject.prototype.toString.call({}); // => [object Object] \nObject.prototype.toString.call(''); // => [object String] \nObject.prototype.toString.call(new Date()); // => [object Date] \nObject.prototype.toString.call(1); // => [object Number] \nObject.prototype.toString.call(function () {}); // => [object Function] \nObject.prototype.toString.call(/test/i); // => [object RegExp] \nObject.prototype.toString.call(true); // => [object Boolean] \nObject.prototype.toString.call(null); // => [object Null] \nObject.prototype.toString.call(); // => [object Undefined]\n```\n\n```javascript\nvar isType = function( type ){ \n    return function( obj ){ \n        return Object.prototype.toString.call( obj ) === '[object '+ type +']'; \n    } \n};\n\nvar isString = isType( 'String' ); \nvar isArray = isType( 'Array' ); \nvar isNumber = isType( 'Number' );\n\nconsole.log( isArray( [ 1, 2, 3 ] ) ); //true\n```","tags":["整理"],"categories":["知识"]},{"title":"js创建对象实现继承","url":"%2Fjs%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF.html","content":"\n今天10月31日，万圣节前夜。希望ff的病早点好，身体健康。\n\n## 创建对象\n```javascript\nvar obj = {} // 字面量 \nvar obj = new Object()\nvar obj = Object.create(null) // 以xx为原型创建对象\nvar obj = Object.assign({})   // 复制到目标对象\n// Object.assign()还可以去除多余的参数覆盖\nObject.assign({ a: 1, b: 2 }, { b: 3, c: 3 })\nconst newObj = { ...{ a: 1, b: 2 }, ...{ b: 3, c: 3 } }\n// {a: 1, b: 3, c: 3}\n// Object() ==> {}\n```\n\n---\n<!--more-->\n\n### 复制一个对象\n```javascript\nvar obj = { a: 1 };\nvar copy = Object.assign({}, obj);\nconsole.log(copy); // { a: 1 }\n```\n\n### 浅拷贝\n\nObject.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。\n\n```javascript\nlet obj1 = { a: 0 , b: { c: 0}};\nlet obj2 = Object.assign({}, obj1);\nconsole.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}\n\nobj1.a = 1;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}\nconsole.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}\n\nobj2.a = 2;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}\nconsole.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}\n\nobj2.b.c = 3;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}\nconsole.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}\n\n// Deep Clone\nobj1 = { a: 0 , b: { c: 0}};\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 4;\nobj1.b.c = 4;\nconsole.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}\n```\n\n### 合并对象\n```javascript\nvar o1 = { a: 1 };\nvar o2 = { b: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。\n```\n\n### 合并相同属性的对象\n```javascript\nvar o1 = { a: 1, b: 1, c: 1 };\nvar o2 = { b: 2, c: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign({}, o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\n```\n\n## 工厂模式\n\n在一个函数内创建一个空对象，给空对象添加属性和属性值，return这个对象。然后调用这个函数并传入参数来使用。\n\n```javascript\nfunction createPerson(name, age, job){ \n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.sayName = function(){ alert(this.name); }; \n    return o;\n}\nvar person1 = createPerson(\"cosyer\", 23); \nconsole.log(person1.name) //cosyer\nconsole.log(person1.sayName()) //cosyer\n```\n优点：解决了创建多个相似对象的问题\n缺点：没有解决对象识别的问题（即怎样知道一个对象的类型）\n\n## 构造函数模式\n\n创建一个构造函数，然后用new 创建构造函数的实例。\n\n```javascript\nfunction Person(name, age, job){\n    this.name = name; \n    this.age = age; \n    this.sayName = function(){ \n        console.log(this.name); \n    }; \n}\n\nvar person1 = new Person(\"cosyer\", 22); \nconsole.log(person1.name) //cosyer\nconsole.log(person1.sayName()) //cosyer\n```\n\n优点：\n\n1. 子类型构造函数中可向超类型构造函数传递参数。\n2. 方法都在构造函数中定义，对于属性值是引用类型的就可通过在每个实例上重新创建一遍，避免所有实例的该属性值指向同一堆内存地址，一个改其他也跟着改。\n原始 复杂(引用) \n缺点：\n对于一些可共用的属性方法（比如这边的this.sayName）没必要都在每个实例上重新创建一遍，占用内存。(无法复用)\n\n## 原型模式\n\n创建一个函数，给函数原型对象赋值。利用函数的prototype属性指向函数的原型对象，从而在原型对象添加所有实例可共享的属性和方法。\n\n```javascript\nfunction Person(){ }\nPerson.prototype.name = \"cosyer\"; \nPerson.prototype.age = 23; \nPerson.prototype.sayName = function(){\n     console.log(this.name); \n};\nvar person1 = new Person();\nconsole.log(person1.name) //cosyer\nconsole.log(person1.sayName()) //cosyer\n```\n优点：\n可以让所有对象实例共享它所包含的属性和方法(复用性)。\n缺点：\n\n1. 在创建子类型的实例时，不能向超类型的构造函数中传递参数。\n2. 如果包含引用类型值的属性，那一个实例改了这个属性（引用类型值），其他实例也跟着改变。\n\n## 组合模式\n\n构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。简单来说就是属性值是引用类型的就用构造函数模式，方法和属性能共享的就用原型模式，取精去糟。\n\n```javascript\nfunction Person(name, age){ //构造函数模式\n    this.name = name; \n    this.age = age; \n    this.friends = [\"aa\", \"bb\"]; \n}\nPerson.prototype = {  //原型模式\n    constructor : Person, \n    sayName : function(){ \n        console.log(this.name); \n    }\n}\nPerson.prototype.hobby = {exercise:\"ball\"}; //原型模式\n\nvar person1 = new Person(\"cosyer\", 23);\nvar person2 = new Person(\"cuby\", 27)\nperson1.friends.push(\"cc\");   \nconsole.log(person1.friends);   //\"aa,bb,cc\"\nconsole.log(person2.friends);   //\"aa,bb\"\nperson1.sayName = function(){console.log(this.age)};\nperson1.sayName();  //22\nperson2.sayName();  //cuby\nperson1.hobby.exercise = \"running\";\nconsole.log(person1.hobby);  //{exercise: \"running\"}\nconsole.log(person2.hobby); //{exercise: \"running\"}\n```\n\n## 动态原型模式\n```javascript\nfunction Person(name, age){ //构造函数模式\n    this.name = name; \n    this.age = age; \n    this.friends = [\"aa\", \"bb\"]; \n    if(typeof Person.prototype.hobby !== 'object'){\n        // 只写入1次\n        Person.prototype.hobby = {exercise:\"ball\"};  \n    }\n}\n```\n\n## 构造函数继承\n```javascript\nfunction SuperType(){ \n    this.colors = [\"red\", \"blue\", \"green\"]; \n}\nfunction SubType(){ //继承了 SuperType \n    SuperType.call(this); \n}\n\nvar instance1 = new SubType(); \ninstance1.colors.push(\"black\"); \nconsole.log(instance1.colors); //\"red,blue,green,black\"\nvar instance2 = new SubType(); \nconsole.log(instance2.colors); //\"red,blue,green\"\n```\n\n## 原型链继承\n```javascript\nfunction SuperType(){ \n    this.colors = [\"red\", \"blue\", \"green\"];\n}\nfunction SubType(){};\nSubType.prototype = new SuperType();\n\nvar instance1 = new SubType();\nvar instance2 = new SubType(); \nconsole.log(instance1.colors); //[\"red\", \"blue\", \"green\"]\nconsole.log(instance2.colors);//[\"red\", \"blue\", \"green\"]\n\ninstance1.colors.push(\"black\"); \nconsole.log(instance1.colors);//[\"red\", \"blue\", \"green\", \"black\"]\nconsole.log(instance2.colors);//[\"red\", \"blue\", \"green\", \"black\"]\n```\n\n## 组合继承\n```javascript\nfunction SuperType(name){  //父类（构造函数）\n    this.name = name;\n}\n\nSuperType.prototype.sayName = function(){  //父类的原型添加一个方法\n    console.log(this.name);\n}\n\nfunction SubType(name, age){  //借用构造函数来实现对实例属性的继承 \n    SuperType.call(this, name);    //继承实例属性 这边继承this.name = name;\n    this.age = age;     //自己的属性\n}\n\nSubType.prototype = new SuperType();    //使用原型链实现对原型属性和方法的继承  这边是继承\nSubType.prototype.constructor = SubType;\nSubType.prototype.sayAge = function(){ \n    alert(this.age); \n};\nvar instance1 = new SubType(\"cosyer\", 23);\nconsole.log(instance1.age)   //23\nconsole.log(instance1.name)  //cosyer\ninstance1.sayName(); //cosyer\ninstance1.sayAge(); //23\n```\n\n- 对象字面量vs构造函数创建对象对比\n\n字面量的优势：\n\n1. 代码量更少，更易读；\n\n2. 可以强调对象就是一个简单的可变的散列表，而不必一定派生自某个类；\n\n3. 对象字面量运行速度更快，因为它们可以在解析的时候被优化：它们不需要作用域解析(scope resolution)；因为存在我们创建了一个同名的构造函数Object()的可能，当我们调用Object()的时候，解析器需要顺着作用域链从当前作用域开始查找，如果在当前作用域找到了名为Object()的函数就执行，如果没找到，就继续顺着作用域链往上照，直到找到全局Object()构造函数为止；\n\n4. Object()构造函数可以接收参数，通过这个参数可以把对象实例的创建过程委托给另一个内置构造函数，并返回另外一个对象实例，而这往往不是你想要的。\n\n`Happy Halloween!`","tags":["整理"],"categories":["知识"]},{"title":"实现jsonp","url":"%2F%E5%AE%9E%E7%8E%B0jsonp.html","content":"\n作为常用的跨域解决方案，怎么能不用原生实现一下呢！\n\njsonp跨域其实也是JavaScript设计模式中的一种代理模式。\n在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。\n一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信。\n\n```javascript\n// 实现目标\nJSONP(url, {\n  data: {\n    key1: value1\n  },\n  callback: function (data) {\n    // data 是服务端返回的数据\n  }\n})\n```\n\n--- \n<!-- more -->\n\n```javascript\nconst JSONP = (url, jsonpObj) => {\n  // 属性名 \n  let cbName = \"cb\" + JSONP.count++\n  // 回调函数 \n  let cbQuery = \"JSONP.\" + cbName\n  let paramsToQuery = obj => {\n    let query = '?'\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        query += `${k}=${obj[k]}&`\n      }      \n    }\n    return query\n  }\n  JSONP[cbName] = data => {\n    try {\n      jsonpObj.callback(data)\n    } finally {\n      delete JSONP[cbName]\n      document.body.removeChild(script)\n    }   \n  }\n  let queryStr = paramsToQuery(jsonpObj.data) + 'callback=' + cbQuery\n  let script = document.createElement('script')\n  script.src = url + encodeURIComponent(queryStr)\n  document.body.appendChild(script)\n}\nJSONP.count = 0\n```","tags":["知识"],"categories":["知识"]},{"title":"高逼格的JS代码","url":"%2F%E9%AB%98%E9%80%BC%E6%A0%BC%E7%9A%84JS%E4%BB%A3%E7%A0%81.html","content":"\n黑科技JS代码整理 是不是很void 666\n\n### 一行代码实现评级\n```javascript\n\"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate);定义一个变量rate是1到5的值\n```\n\n### SB、NB、Hello World\n```javascript\n(!(~+[])+{})[--[~+\"\"][+[]]*[~+[]] + ~~!+[]]+({}+[])[[~!+[]]*~+[]]\n\n([][[]]+[])[+!![]]+([]+{})[!+[]+!![]]\n\n([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[+[]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()([][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+{})[+[]])[+[]]+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+([]+{})[+!![]]+(!![]+[])[+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()([][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+{})[+[]])[+[]]+(!+[]+!![]+[])+(+!![]+[]))\n```\n\n### 错误处理的正确方法\n```javascript\ntry {\n    something\n} catch (e) {\n    window.location.href =\n        \"http://stackoverflow.com/search?q=[js]+\" +\n        e.message;\n}\n// 百度版\ntry {\n    something\n} catch (e) {\n    window.location.href =\n        \"https://www.baidu.com/s?wd=\" +\n        e.message;\n}\n```\n\n--- \n\n<!-- more -->\n\n### 标记区域的范围\n```javascript\n[].forEach.call($$(\"*\"),function(a){\n    a.style.outline=\"1px solid #\"+(~~(Math.random()*(1<<24))).toString(16)\n})\n// 等价于\nArray.prototype.forEach.call(document.querySelectorAll('*'), \ndom => dom.style.outline = `1px solid #${parseInt(Math.random() * \nMath.pow(2,24)).toString(16)}`)\n```\n\n### 获取随机字符串\n```javascript\nMath.random().toString(16).substring(2) \nMath.random().toString(36).substring(2) \n```\n\n### 这样的判断你能做对吗\n```javascript\n(10)[\"toString\"]() === \"10\" // true\n\nconsole.log(10..toString());//10\nconsole.log(10.toString());//SyntaxError: Unexpected token ILLEGAL\n// 在JavaScript中，数字后面的\".\"操作符是的意义是不确定。因为它既可能是一个浮点数的标志，又可能是取一个对象的属性的运算符。但是JavaScript的解释器把他当做了浮点数的标志\n// 等价于 \nconsole.log((10.).toString());\nconsole.log((10.)toString())\n```\n\n### 匿名函数自执行方法\n```javascript\n( function() {}() );\n( function() {} )();\n[ function() {}() ];\n\n~ function() {}();\n! function() {}();\n+ function() {}();\n- function() {}();\n\ndelete function() {}();\ntypeof function() {}();\nvoid function() {}();\nnew function() {}();\nnew function() {};\n\nvar f = function() {}();\n\n1, function() {}();\n1 ^ function() {}();\n1 > function() {}();\n```\n\n### 终于到 void 666\n```javascript\n// 以下都是undefined\nvar a; \nvar a = undefined \nvoid 0\nvoid 666\nvoid(0)\nvoid (0)\n```\n\n### 金钱格式化\n```javascript\n// api\n(156589822366).toLocaleString() // \"156,589,822,366\"\n\n// 正则就完事了\nvar test1 = '1234567890'\nvar format = test1.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\nconsole.log(format) // 1,234,567,890\n\n// 非正则\n function formatCash(str) {\n       return str.split('').reverse().reduce((prev, next, index) => {\n            return ((index % 3) ? next : (next + ',')) + prev\n       })\n}\nconsole.log(formatCash('1234567890')) // 1,234,567,890\n```\n\n### 逗号运算符\n```javascript\nvar a = 0;\nvar b = (a++,99);\n// a 1 b 99\n```\n\n### 交换两个数的值\n```javascript\n// 加减运算 缺点也很明显，整型数据溢出，对于32位字符最大表示数字是2147483647，如果是2147483645和2147483646交换就失败了。\nvar a=1,b=2;\na += b;\nb = a - b;\na -= b;\n\n// 第三个临时变量\nvar a=1,b=2;\nvar temp = a;\na = b;\nb= temp;\n\n// 位运算\nlet a=3,b=4;\na^=b;\nb^=a;\na^=b;\n\n// es6\nlet a = 1, b = 2;\n[a, b] = [b, a];\n```\n\n### JSON数据的深拷贝\n```javascript\nvar a = {\n    a: 1,\n    b: { c: 1, d: 2 }\n}\nvar b=JSON.parse(JSON.stringify(a))\n// Number parseInt parseFloat\n```\n局限性：\n- 会忽略 undefined\n- 不能序列化函数，会被忽略\n- 不能解决循环引用的对象\n\n### 长度为6值为8的数组\n```javascript\nArray(6).fill(8)\n```\n\n### 脚本永不报错\n```javascript\nwindow.onerror = function(m, f, l){ return true }\n```\n\n### 生活常识\n36.3℃～37.2℃(口腔)、36.1℃～37℃(腋窝)\n\n60～100次/分\n\n1500ml\n\n2500大卡\n\n90mmHg<收缩压<140mmHg、60mmHg<舒张压<90mmHg\n\n## 使用Boolean过滤数组中的假值\n双否运算符(~~)\n```js\nconst compact = arr => arr.filter(Boolean)\ncompact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]) // // [ 1, 2, 3, 'a', 's', 34 ] \n```\n\n## 惰性载入函数\n```js\njsfunction foo(){\n    if(a !== b){\n        console.log('aaa')\n    }else{\n        console.log('bbb')\n    }\n}\n \n// 优化后\nfunction foo(){\n    if(a != b){\n        foo = function(){\n            console.log('aaa')\n        }\n    }else{\n        foo = function(){\n            console.log('bbb')\n        }\n    }\n    return foo();\n}\n```\n那么第一次运行之后就会覆写这个方法，下一次再运行的时候就不会执行判断了。当然现在只有一个判断，如果判断很多，分支比较复杂，那么节约的资源还是可观的。\n\n## 字符串比较时间大小\n```js\nvar a = \"2014-08-08\";\nvar b = \"2014-09-09\";\n \nconsole.log(a>b, a<b); // false true\nconsole.log(\"21:00\"<\"09:10\");  // false\nconsole.log(\"21:00\"<\"9:10\");   // true   时间形式注意补0\n```\n字符串比较大小是按照字符串从左到右每个字符的charCode来的，但所以特别要注意时间形式注意补0\n\n```js\nvar a = [1,2,3]\na.join = a.toString = a.shift\na == 1 && a == 2 && a == 3 // true 隐式类型转换\n'选择'>'努力' // true\n```\n\n## 数字补0操作\n```js\nconst addZero1 = (num, len = 2) => (`0${num}`).slice(-len)\nconst addZero2 = (num, len = 2) => (`${num}`).padStart( len   , '0')\naddZero1(3) // 03\n \naddZero2(32,4)  // 0032\n```\n\n## es6的八进制表示\n```js\n035            // 8进制29      原来的方式\n0o35            // 8进制29     es6的方式\n```\n\n## Math.round实现的精确保留指定位数的函数(toFixed不完善)\n```js\nconst round = (n, decimals = 0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`)\nround(1.345, 2)                 // 1.35\nround(1.345, 1)                 // 1.3\n\n// 不太完善 round(1.2,2) 为1.2没有补0\nfunction addZ(num,len=2){ \n    num=num.toString() \n    if(!num.includes('.')) num=num+'.' \n    if(!Object.is(Number(num),NaN)){ \n        num= Number(num).toFixed(len)    \n    } \n    else if(num.includes(',')){ \n        if(!Object.is(Number(num.replace(/,/g,'')),NaN)){ \n        len=num.indexOf('.')+Number(len)+1 \n        num= num.length<len? num.padEnd(len,'0'):num; \n        } \n    } \n    return num \n}\n```\n\n## 统计相同项(reduce)\n```js\nvar str = a.split('').reduce((p,k)=>(p[k]++||(p[k]=1),p),{})\n\n\njsvar cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'];\nvar carsObj = cars.reduce(function (obj, name) {\n  obj[name] = obj[name] ? ++obj[name] : 1;\n  return obj;\n}, {});\ncarsObj; // => { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 }\n```\n\n## 两个数值的交换\n```js\nvar temp = a; a = b; b = temp            \nb = [a, a = b][0]                     \na = a + b; b = a - b; a = a - b \n// es6 解构赋值\nlet x = 1;\nlet y = 2;\n[x, y] = [y, x];\n```\n\n## 多判断\n```js\nif ( foo === 'bar' || foo === 'foobar' || foo === 'foo' )\n{\n//...\n}\n\n就可以写成：\nif ( foo in { 'bar':'', 'foobar':'', 'foo':'' } )\n{\n//...\n}\n```\n\n## shell压缩解压\n```shell\ntar -zcvf newfilename.tar.gz filename\ntar -zxvf newfilename.tar.gz\n```\n\n## banana\n```js\n('b'+'a'+ +'a'+'a').toLowerCase()\n// banana\n```\n","tags":["整理"],"categories":["JS"]},{"title":"babel的.babelrc配置","url":"%2Fbabel%E7%9A%84.babelrc%E9%85%8D%E7%BD%AE.html","content":"\n一个基本的.babelrc配置:\n\n```javascript\n{\n  \"presets\": [\n    \"env\",\n    \"stage-0\"\n  ],\n  \"plugins\": [\"transform-runtime\"]\n}\n```\n\n--- \n<!-- more -->\n\n### presets env\n\npresets 是babel的一个预设，使用的时候需要安装对应的插件，对应babel-preset-xxx，例如下面的配置，需要npm install babel-preset-env\n\n> 每年每个 preset 只编译当年批准的内容。 而 babel-preset-env 相当于 es2015 ，es2016 ，es2017 及最新版本。\n\n```javascript\n{\n  \"presets\": [\"env\"]\n}\n```\n\n### presets stage\nstage 代表着ES提案的各个阶段，一共有5个阶段，存在依赖关系。也就是说stage-1是包括stage-0的，以此类推：\n- Stage 0 - 稻草人: 只是一个想法，可能是 babel 插件。\n- Stage 1 - 提案: 初步尝试。\n- Stage 2 - 初稿: 完成初步规范。\n- Stage 3 - 候选: 完成规范和浏览器初步实现。\n- Stage 4 - 完成: 将被添加到下一年度发布。\n\n### plugins\npresets，是plugins的预设，起到方便设置的作用。如果不采用presets，可以使用plugins\n```javascript\n{\n  \"plugins\": [\"transform-es2015-arrow-functions\"] // 也可以预设babel-preset-es2015\n}\n``` \n\n### 自定义预设和插件\n3种方式设置都ok\n\n```javascript\n\"plugins\": [\"babel-plugin-myPlugin\"]\n\"plugins\": [\"myPlugin\"]\n\"plugins\": [\"./node_modules/asdf/plugin\"]。\n// presets同理。\n```\n\n### plugins/presets排序\n- plugins 会运行在 presets 之前。\n- plugins 会从第一个开始顺序执行。\n- presets 的顺序则刚好相反(从最后一个逆序执行)。\n\n### babel-polyfill\n`babel`本身只提供预发的转换，当我们使用一些箭头函数这样的新的语法，其实在babel看来，更像是一种语法糖。\n但是babel不能转义一些ES6、ES7...的新的全局属性，例如 Promise 、新的原生方法如 String.padStart (left-pad) 等。\n这个时候我们就需要使用babel-polyfill。","tags":["整理"],"categories":["知识"]},{"title":"实现trim的3种方法","url":"%2F%E5%AE%9E%E7%8E%B0trim%E7%9A%843%E7%A7%8D%E6%96%B9%E6%B3%95.html","content":"\ntrim 方法 (字串) (JavaScript) 移除字串前后的空白字元以及行结束字元。\n- 用法\nstring.trim()\n\n1. 递归截取(不推荐)\n```javascript\nfunction trim(str){\n// 加入类型判断 \nif(str[0]===' '||str[str.length-1]===' '){\n    if(str[0]===' '){\n      str=str.substring(1,str.length)\n    }\n    if(str[str.length-1]===' '){\n      str=str.substring(0,str.length-1)\n    }\n    trim(str)\n  }else{\n    console.log(str)\n    return str\n  }\n}\n```\n\n2. 2次遍历记录不为空格的索引，最后截取\n```javascript\nfunction trim(str) {\n    let start, end // 开始和结束为止 遍历记录不为空格的索引\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] !== ' ') {\n            start = i\n            break\n        }\n    }\n    for (let i = str.length - 1; i > 0; i--) {\n        if (str[i] !== ' ') {\n            end = i\n            break\n        }\n    }\n    return str.substring(start, end + 1)\n}\n```\n\n3. 正则替换\n```javascript\nfunction trim(str) {\n    return str.replace(/(^\\s*)|(\\s*$)/g, \"\")\n}\n\n// 1. value.toString()\n// 2. String('123213') \n// 3. '' + value\n```","tags":["整理"],"categories":["知识"]},{"title":"正则总结","url":"%2F%E6%AD%A3%E5%88%99%E6%80%BB%E7%BB%93.html","content":"\n创建正则表达式\n\n```javascript\nvar expression = /pattern/flags ;\n```\n\n其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、 向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。 正则表达式的匹配模式支持下列 3 个标志。\n\n- g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；\n- i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；\n- m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。\n\n## 两种使用方式\n```js\nvar a1 = /\\+d/g; // 字面形式\nvar a2 = new RegExp('\\\\+d','g') // 构造函数\n```\n\n在JavaScript中建议使用字面形式的正则表达式，因为不需要担心字符串中的转义字符。比如上面示例代码中字面形式使用\\d而构造函数使用的是\\\\d；\n\n```javascript\nvar text = \"aaa \"; \nvar pattern1 = /\\s$/; //匹配字符串末尾的空格 \npattern1.exec(text);\n```\n---\n<!-- more -->\n\n正则定义了很多特殊意义的字符，有名词，量词，谓词等\n\n## 简单字符\n没有特殊意义的字符都是简单字符，简单字符就代表自身，绝大部分字符都是简单字符，举个例子。\n\n```javascript\n/abc/ // 匹配 abc\n/123/ // 匹配 123\n/-_-/ // 匹配 -_-\n```\n## 转义字符\n\\是转义字符，其后面的字符会代表不同的意思，转义字符主要有三个作用：\n\n1. 是为了匹配不方便显示的特殊字符，比如换行，tab符号等\n\n2. 正则中预先定义了一些代表特殊意义的字符，比如\\w等\n\n3. 在正则中某些字符有特殊含义(比如下面说到的)，转义字符可以让其显示自身的含义\n\n|常用转义字符|意义|\n|:---|:---|\n|\\n\t|匹配换行符 （newline）|\n|\\r\t|匹配回车符 （return）|\n|\\t\t|匹配制表符，也就是tab键|\n|\\v\t|匹配垂直制表符|\n|\\x20\t|20是2位16进制数字，代表对应的字符|\n|\\u002B\t|002B是4位16进制数字，代表对应的字符|\n|\\u002B\t|002B是4位16进制数字，代表对应的字符|\n|\\w\t|匹配任何一个字母或者数字或者下划线 单子字符 (word)|\n|\\W\t|匹配任何一个字母或者数字或者下划线以外的字符 非单子字符|\n|\\s\t|匹配空白字符，如空格，tab等 （space）|\n|\\S\t|匹配非空白字符|\n|\\d\t|匹配数字字符，0~9 （digit）\n|\\D\t|匹配非数字字符|\n|\\b\t|匹配单词的边界 (boundary)|\n|\\B\t|匹配非单词边界|\n|\\ |匹配\\本身|\n\n## 字符集合\n```javascript\n// 有时我们需要匹配一类字符，字符集可以实现这个功能，字符集的语法用[]分隔，下面的代码能够匹配a或b或c\n[abc]\n\n// 如果要表示字符很多，可以使用-表示一个范围内的字符，下面两个功能相同\n[0123456789]\n[0-9]\n\n// 在前面添加^，可表示非的意思，下面的代码能够匹配abc之外的任意字符\n[^abc]\n```\n其实正则还内置了一些字符集，在上面的转义字符有提到，下面给出内置字符集对应的自定义字符集\n\n```javascript\n// 匹配除了换行符（\\n）以外的任意一个字符 = [^\\n]\n\\w = [0-9a-zA-Z_]\n\\W = [^0-9a-zA-Z_]\n\\s = [ \\t\\n\\v]\n\\S = [^ \\t\\n\\v]\n\\d = [0-9]\n\\D = [^0-9]\n```\n\n## 量词\n如果需要匹配多次某个字符，正则也提供了量词的功能，正则中的量词有多个，如?、+、*、{n}、{m,n}、{m,}\n\n{n}匹配n次，比如a{2}，匹配aa\n\n{m, n}匹配m-n次，优先匹配n次，比如a{1,3}，可以匹配aaa、aa、a\n\n{m,}匹配m-∞次，优先匹配∞次，比如a{1,}，可以匹配aaaa...\n\n?匹配0次或1次，优先匹配1次，相当于{0,1}\n\n+匹配1-n次，优先匹配n次，相当于{1,}\n\n*匹配0-n次，优先匹配n次，相当于{0,}\n\n正则默认和人心一样是贪婪的，也就是常说的贪婪模式，凡是表示范围的量词，都优先匹配上限而不是下限\n\n```javascript\n// a{1, 3} 匹配字符串'aaa'的话，会匹配aaa而不是a\nvar text = \"aaa\"; \nvar pattern1 = /a{1,3}/;\npattern1.exec(text); //[\"aaa\", index: 0, input: \"aaa\"] // index input为属性\n```\n\n有时候这不是我们想要的结果，可以在量词后面加上?，就可以开启非贪婪模式\n\n```javascript\nvar text = \"aaa\"; \nvar pattern1 = /a{1,3}?/;\npattern1.exec(text); //[\"a\", index: 0, input: \"aaa\"]\n```\n\n## 字符边界\n^在[]外表示匹配开头的意思\n^abc // 可以匹配abc，但是不能匹配aabc\n\n$表示匹配结尾的意思\nabc$ // 可以匹配abc，但是不能匹配abcc\n上面提到的\\b表示单词的边界\n\n\\b表示匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。\nabc\\b // 可以匹配 abc ，但是不能匹配 abcc；\n/\\bm/匹配“moon”中得‘m’；\n/oo\\b/并不匹配\"moon\"中得'oo'，因为'oo'被一个“字”字符'n'紧跟着。\n/oon\\b/匹配\"moon\"中得'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。\n/\\w\\b\\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。\n\n## 选择表达式\n有时我们想匹配x或者y，如果x和y是单个字符，可以使用字符集，[abc]可以匹配a或b或c，如果x和y是多个字符，字符集就无能为力了，此时就要用到分组\n\n正则中用|来表示分组，a|b表示匹配a或者b的意思\n\n```javascript\n123|456|789 // 匹配 123 或 456 或 789\n```\n\n## 分组与引用\n分组是正则中非常强大的一个功能，可以让上面提到的量词作用于一组字符，而非单个字符，分组的语法是圆括号包裹(xxx)\n\n```javascript\n(abc){2} // 匹配abcabc\n```\n分组不能放在[]中，分组中还可以使用选择表达式\n```javascript\n(123|456){2} // 匹配 123123、456456、123456、456123\n```\n\n和分组相关的概念还有一个捕获分组和非捕获分组，分组默认都是捕获的，在分组的(后面添加?:可以让分组变为非捕获分组，非捕获分组可以提高性能和简化逻辑\n\n```javascript\n'123'.match(/(?:123)/) // 返回 ['123']\n'123'.match(/(123)/)  // 返回 ['123', '123']\n// 和分组相关的另一个概念是引用，比如在匹配html标签时，通常希望<xxx></xxx>后面的xxx能够和前面保持一致\n```\n\n引用的语法是\\数字，数字代表引用前面第几个捕获分组，注意非捕获分组不能被引用\n\n```javascript\n<([a-z]+)><\\/\\1> // 可以匹配 `<span></span>` 或 `<div></div>`等\n```\n\n## 预搜索\n\n如果你想匹配xxx前不能是yyy，或者xxx后不能是yyy，那就要用到预搜索\n\njs只支持正向预搜索，也就是xxx后面必须是yyy，或者xxx后面不能是yyy\n\n```javascript\n1(?=2) // 可以匹配12，不能匹配22\n1(?!2) // 可有匹配22，不能匹配12\n```\n\n## 修饰符\n默认正则是区分大小写，这可能并不是我们想要的，正则提供了修饰符的功能，修复的语法如下\n\n```javascript\n/xxx/gi // 最后面的g和i就是两个修饰符\n```\ng正则遇到第一个匹配的字符就会结束，加上全局修复符，可以让其匹配到结束\n\ni正则默认是区分大小写的，i可以忽略大小写\n\nm正则默认情况下，^和$只能匹配字符串的开始和结尾，m修饰符可以让^和$匹配行首和行尾，不理解就看例子\n\n```javascript\n/jing$/ // 能够匹配 'yanhaijing，不能匹配 'yanhaijing\\n'\n/jing$/m // 能够匹配 'yanhaijing， 能够匹配 'yanhaijing\\n'\n\n/^jing/ // 能够匹配 'jing'，不能匹配 '\\njing'\n/^jing/m // 能够匹配 'jing'，能够匹配 '\\njing'\n```\n\n## js使用正则表达式的方法\n正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法\n\n|方法|描述|\n|:---|:---|\n|exec\t|一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。|\n|test\t|一个在字符串中测试是否匹配的RegExp方法，它返回true或false。|\n|match\t|一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。|\n|search\t|一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。|\n|replace\t|一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。|\n|split\t|一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。|\n\n\n当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用test或search方法；想得到更多的信息（但是比较慢）则可以使用exec或match方法。如果你使用exec或match方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。如果匹配失败，那么exec方法返回null（也就是false）。\n\n```javascript\nvar text = \"cat, bat, sat, fat\"; var pattern1 = /.at/;\n\nvar matches = pattern1.exec(text);\nconsole.log(matches) //[\"cat\", index: 0, input: \"cat, bat, sat, fat\"]\n```","tags":["redux"],"categories":["JS"]},{"title":"动手实现redux","url":"%2F%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0redux.html","content":"\n概念：\n- 一个app有一个store，一个store管理着一个全局state\n- createStore 传入reducer，返回getState, dispatch, subscribe\n- action是一个至少有type这个键的对象，可以写一个creactActioner 函数去return生成action对象\n- createStore.dispatch(action) 根据action这个对象去更新state\n- dispatch是一个函数，内部有将执行reducer函数\n- reducer也是一个函数，传入state,action, 输出一个新的state . (switch case return…)\n\n---\n<!-- more -->\n\n```html\n<div id = 'title'></div>\n<input type=\"button\" id = \"changeTheme\" value=\"变成蓝色主题\">\n```\n\n```javascript\n// 实现createStore 传入reducer\nfunction createStore(reducer){\n    // 存储数据\n    let state = null\n    // 订阅列表\n    const listenerList=[]\n    // 增加订阅\n    const subscribe=(listener)=>listenerList.push(listener)\n    // 返回state\n    const getState=()=>state \n    // dispatch\n    const dispatch=(action)=>{\n      // 新的state\n      state=reducer(state,action)\n      // 遍历执行\n      listenerList.forEach(item)=>item()\n    }\n    // 初始化state\n    dispatch({})\n    return {getState,subscribe,dispatch}\n}\n\n// 实现reducer\nfunction(state,action){\n  if(!state){\n    return {\n      title:'红色',\n      color:'red'\n    }\n  }\n  switch(action.type){\n    case 'UPDATE_TITLE':\n    return {...state,title:action.title}\n    case 'UPDATE_COLOR':\n    return {...state,color:action.color}\n    default:return state\n  }\n}\n\n// 传入reducer生成store\nconst store =createStore(reducer)\n\n// 渲染代码\nfunction renderDom(state){\n  const titleDOM = document.getElementById('title');\n  titleDOM.innerHTML = state.title;\n  titleDOM.style.color = state.color;\n}\n\n// 监听数据变化重新渲染页面\nstore.subscribe(() => renderApp(store.getState()));// 让每次dispatch时都会执行传入的这个函数，渲染页面\n\n// 首次渲染页面\nrenderApp(store.getState());\n\n// action\nconst updateThemeName = () => ({\n  type: 'UPDATE_TITLE',\n  title: '蓝色'\n});\nconst updateThemeColor = () => ({\n  type: 'UPDATE_COLOR',\n  color: 'blue'\n});\n\n// 绑定事件\ndocument.getElementById('changeTheme').onclick = () => {\n  store.dispatch(updateThemeName());\n  store.dispatch(updateThemeColor());\n};\n```","tags":["redux"],"categories":["JS"]},{"title":"人一生必须要去的3个地方","url":"%2F%E4%BA%BA%E4%B8%80%E7%94%9F%E5%BF%85%E9%A1%BB%E5%8E%BB%E7%9A%843%E4%B8%AA%E5%9C%B0%E6%96%B9.html","content":"\n通常有人说一个人一生最好经常去三个地方看看，人生感悟会提高一个档次，人生观，价值观乃至世界观，都会有一个质的飞跃。这三个地方就是：托儿所、殡仪馆、监狱。 常去托儿所，看到天真烂漫、童真无邪、活泼可爱的孩子们，会更加的体会到生命的重要和可爱，从而更加珍惜生命，热爱生活，激发出更多积极向上的人生志向。 常去殡仪馆，看到撒手人寰逝去的人们，会感受到，人赤条条来，赤条条去，人为财死，鸟为食亡，是多么的狭隘和自私，心胸会豁然开朗，，不会在为鸡毛蒜皮的小事斤斤计较，退一步海阔天空，让三分心平气和。会更加的领会人生的价值所在，让人生更具异彩。 常去监狱，看到无论是过去高官还是贫民百姓，进到监狱没有了姓名，只有号码，一律囚服，进出报告，极大的限制了人身自由，天高任鸟飞，海阔凭鱼跃的现实已经成为梦中的理想。自古就有人犯王法身无主，因此也就会更加的洁身自好，以人为镜，严于律己。守法度者为幸福，世上本没有绝对的自由，遵守了，习惯了，适应了也就自由了。\n\n---\n<!--more-->\n\n中国的人实在是太多了，人均资源少，而且分配不均，旱死的旱死涝死的涝死。小时候奶奶经常说我爸生下来多么瘦小，为了生存还去卖过血。我爸也是从无到有的打拼。我是努力了，但我拼命努力了么？没有！！！是需要有那种不成功便成仁的决心和坚持到底的毅力。是的，我自己什么都将可以牺牲的！要想得到什么必须付出同等的代价。新中国成立解放了人民，同样也诞生了新的剥削阶级。文革各个组织间的利益冲突。中国还是那个中国，似曾相识的中央集权，人民当家做主恩恩，当好韭菜，接收被剥削收割的命运。\n\n自古以来的人情社会，不送礼办不成事，贪污落马的大老虎们一批接一批。拉帮结派、结党营私、官官相护。\n\n- 退休年龄将来目标是65岁退休，现在国人平均寿命接近75岁，10年能拿回多少退休金？- 养老个人部分退休可以逐年领回，但只算本金，按本国多年通货膨胀率测算，退休时相当于多少实际购买力？\n- 社保里有些险种可能多数人用不到，比如失业险，多交了很多人也没得益，算下这种会占多少？\n- 最后，要看是公司单独给员工交满额还是全社会所有公司都交满额。这也有关系？是的，公司是盈利组织，多支付了成本就要想办法收回来。\n\n近些年的社保制度，要知道以前的公寓都是不交养老保险的。现在他们推向还能拿到不菲的养老金。是谁的缴纳的呢？这样的庞氏骗局能持续多久呢？\n\n妈妈的胃结石、奶奶的甲亢、爷爷的骨刺。身体健康最重要，讨厌医院里消毒水和中药的味道。这里的氛围代凯莱达。以前一老以为自己有绝症重病，什么后脑勺的突起，坐摩托车时的心悸，不敢去做刺激性的娱乐项目，以前去方特都只是去坐坐旋转木马，有心脏病。这就是我的极限吗？！\n\n科室真的好赚钱，医生好闲。\n\n努力努力，不想当韭菜了。保护好自己的家人，努力地活下去！！！\n\n一点精神都没有~早知道去苏宁了，果然还是想啥都干外包公司只能温饱，发财是没有希望的。只能去互联网公司。\n不是什么病真是太好了，但是要考公务员。可能会离很远。我为了离得近选择了外包公司，处于鄙视链下，学习受限。接私活。可能去sn这种大公司镀个金也是个好选择吧！大平台之间跳转的重要性。\n\n一天到晚没什么精神，让人好担心。10.3一起煮饭吃了。对菜价什么的也有了大概的了解，生活的丰富多彩。2年不到15k，大城市的高薪真是个诱惑，家里还和我说买车位emmm。\n\nangularjs写的好难受，一个 controller 文件大几千行看的脑胀==。现在经济下行，南京这边没什么的好公司啊。hw桌面云用起来也不太爽，基本有问题一个拉一个最后一堆人定位问题，国际化的多个局点特性也很麻烦，全是业务层面和环境部署。\n\nemmm又得搞讲座，混不过去啊，人多紧张忘词。又不好把问题全贴PPT上，尴尬。全是语法内容其实也没什么好讲的😂搞得Switch都落灰了。\n\n996珍惜时间充分利用时间，不做无效劳动。\n\ngive me fire\n\n1. revenage/respect/insult/limit edu/compare\n2. protect family/stress\n3. enjoy life/interest/enthusiastic\n4. fk fair/breakthrough\n5. strong\n6. death\n7. house/physical desire\n\n1. remember packet/jokes\n2. 情绪管理/神经衰弱\n3. 不分场合 dependency=>excuse\n4. selfish 手臂 hug\n5. tourism house\n6. naive 独立思考\n7. 道德绑架 key\n8. lazy/累 做不到的话就别说\n9. 双方父母支持\n10. seisei的身材\n\n1. 不去做的话永远也做不到。\n2. 要想得到什么，必须付出同等的代价。\n3. 我的钻头可是突破天际的钻头啊！\n4. 学习就是不断重复与抄袭的一个过程。\n\n活着，即使怎么样也要活着，为自己活着，自残就自残，没人关心只是他们不理解，也不愿意了解。那些什么都不知道的人凭什么劝你为别人活？凭什么觉得自残只是想证明什么？可笑！一个人遇到无论如何都无法解决又不能对抗的痛苦，那他除了找一个能够发泄的途径还能干什么？只是不要做让自己后悔的事，后悔的事情很难挽回。我不知道死能不能让我解脱，但我一定会后悔。凭什么活的这么痛苦了，还要去死呢？那之前的痛苦还有意义吗？甘心吗？我不甘心。一生最美好的，对我来说，就是死的时候，还能发自内心的微笑着去死。现在呢？难道就带着脑子里那些折磨人的东西，结束这一生？总之，不要做让自己后悔的事，即便满身伤痛，也请微笑着活到最后吧！(◦˙▽˙◦)","tags":["杂谈"],"categories":["杂谈"]},{"title":"toFixed方法注意点","url":"%2FtoFixed%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9.html","content":"\n### 遇到的问题:\n\njs的浮点数运算不准确，(a + b).toFixed(2)能解决一部分问题，但并不完美。\n\n```javascript\n0.1 + 0.2 //0.30000000000000004\n(0.1 + 0.2).toFixed(2) // 0.30\n0.815 + 0.1 // 0.9149999999999999\n(0.815 + 0.1).toFixed(2) // 0.91，错误！期望0.92\n// toFixed并不是我们通常理解的“四舍五入”，而是“四舍六入五留双”\n// 简单来说就是：四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为奇应舍去，五前为偶要进一。\n(0.225).toFixed(2) // 0.23\n(0.235).toFixed(2) // 0.23，错误！期望0.24\n```\n---\n<!-- more -->\n\n### 解决方案\n\n网络上有很多种解决方案，可以修正toFixed方法，也可以重新定义四则运算。重新定义四则运算，最为规范，但使用麻烦，故我最终选择了修正toFixed。\n声明：源码来源于网络，本文只是添加了注释和分析。\n\n```javascript\n// 直接替换原型链上的方法，方便使用\nNumber.prototype.toFixed = function (n) {\n  // n为期望保留的位数，超过限定，报错！\n  if (n > 20 || n < 0) {\n    throw new RangeError('toFixed() digits argument must be between 0 and 20');\n  }\n  // 获取数字\n  const number = this;\n  // 如果是NaN,或者数字过大，直接返回'NaN'或者类似'1e+21'的科学计数法字符串\n  if (isNaN(number) || number >= Math.pow(10, 21)) {\n    return number.toString();\n  }\n  // 默认保留整数\n  if (typeof (n) == 'undefined' || n == 0) {\n    return (Math.round(number)).toString();\n  }\n\n  // 先获取字符串\n  let result = number.toString();\n  // 获取小数部分\n  const arr = result.split('.');\n\n  // 整数的情况，直接在后面加上对应个数的0即可\n  if (arr.length < 2) {\n    result += '.';\n    for (let i = 0; i < n; i += 1) {\n      result += '0';\n    }\n    return result;\n  }\n\n  // 整数和小数\n  const integer = arr[0];\n  const decimal = arr[1];\n  // 如果已经符合要求位数，直接返回\n  if (decimal.length == n) {\n      return result;\n  }\n  // 如果小于指定的位数，补上\n  if (decimal.length < n) {\n    for (let i = 0; i < n - decimal.length; i += 1) {\n      result += '0';\n    }\n    return result;\n  }\n  // 如果到这里还没结束，说明原有小数位多于指定的n位\n  // 先直接截取对应的位数\n  result = integer + '.' + decimal.substr(0, n);\n  // 获取后面的一位\n let last = decimal.substr(n, 1);\n if (/^\\d(9){5,}[89]$/.test(decimal.substr(n))) {\n    last += last + 1;\n  }\n  // 大于等于5统一进一位\n  if (parseInt(last, 10) >= 5) {\n    // 转换倍数，转换为整数后，再进行四舍五入\n    const x = Math.pow(10, n);\n    // 进一位后，转化还原为小数\n    result = (Math.round((parseFloat(result) * x)) + 1) / x;\n    // 再确认一遍\n    result = result.toFixed(n);\n  }\n\n  return result;\n};\n```","tags":["知识"],"categories":["JS"]},{"title":"js判断浏览器类型和访问来源","url":"%2Fjs%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%BF%E9%97%AE%E6%9D%A5%E6%BA%90.html","content":"\n`userAgent` 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。\n\n一般来讲，它是在 `navigator.appCodeName` 的值之后加上斜线和 `navigator.appVersion` 的值构成的。\n\n例如：Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; SV1; .NET CLR 1.1.4322)。\n\n注：用户代理头：user-agent header。\n\n--- \n<!-- more -->\n\n## 判断浏览器类型\n```javascript\n//判断当前浏览类型 \n function BrowserType() \n { \n   var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 \n   var isOpera = userAgent.indexOf(\"Opera\") > -1; //判断是否Opera浏览器 \n   var isIE = userAgent.indexOf(\"compatible\") > -1 && userAgent.indexOf(\"MSIE\") > -1 && !isOpera; //判断是否IE浏览器 \n   var isEdge = userAgent.indexOf(\"Windows NT 6.1; Trident/7.0;\") > -1 && !isIE; //判断是否IE的Edge浏览器 \n   var isFF = userAgent.indexOf(\"Firefox\") > -1; //判断是否Firefox浏览器 \n   var isSafari = userAgent.indexOf(\"Safari\") > -1 && userAgent.indexOf(\"Chrome\") == -1; //判断是否Safari浏览器 \n   var isChrome = userAgent.indexOf(\"Chrome\") > -1 && userAgent.indexOf(\"Safari\") > -1; //判断Chrome浏览器 \n \n   if (isIE)  \n   { \n      var reIE = new RegExp(\"MSIE (\\\\d+\\\\.\\\\d+);\"); \n      reIE.test(userAgent); \n      var fIEVersion = parseFloat(RegExp[\"$1\"]); \n      if(fIEVersion == 7) \n      { return \"IE7\";} \n      else if(fIEVersion == 8) \n      { return \"IE8\";} \n      else if(fIEVersion == 9) \n      { return \"IE9\";} \n      else if(fIEVersion == 10) \n      { return \"IE10\";} \n      else if(fIEVersion == 11) \n      { return \"IE11\";} \n      else \n      { return \"0\"}//IE版本过低 \n    }//isIE end \n     \n    if (isFF) { return \"FF\";} \n    if (isOpera) { return \"Opera\";} \n    if (isSafari) { return \"Safari\";} \n    if (isChrome) { return \"Chrome\";} \n    if (isEdge) { return \"Edge\";} \n  }\n```\n\n## 判断浏览器访问来源\n### 方法1\n```javascript\nwindow.location.href = /Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent) ? \"https://www.baidu.com/\" :  \"http://news.baidu.com/\";\n```\n\n### 方法2\n```javascript\nfunction IsPC() {\n    var userAgentInfo = navigator.userAgent;\n    var Agents = [\"Android\", \"iPhone\",\n                \"SymbianOS\", \"Windows Phone\",\n                \"iPad\", \"iPod\"];\n    var flag = true;\n    for (var v = 0; v < Agents.length; v++) {\n        if (userAgentInfo.indexOf(Agents[v]) > 0) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}\n```\n\n### 方法3\n```javascript\nfunction browserRedirect() {\n    var sUserAgent = navigator.userAgent.toLowerCase();\n    var bIsIpad = sUserAgent.match(/ipad/i) == \"ipad\";\n    var bIsIphoneOs = sUserAgent.match(/iphone os/i) == \"iphone os\";\n    var bIsMidp = sUserAgent.match(/midp/i) == \"midp\";\n    var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == \"rv:1.2.3.4\";\n    var bIsUc = sUserAgent.match(/ucweb/i) == \"ucweb\";\n    var bIsAndroid = sUserAgent.match(/android/i) == \"android\";\n    var bIsCE = sUserAgent.match(/windows ce/i) == \"windows ce\";\n    var bIsWM = sUserAgent.match(/windows mobile/i) == \"windows mobile\";\n    if (!(bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) ){\n        window.location.href=B页面;\n    }\n}\nbrowserRedirect();\n```","tags":["知识"],"categories":["JS"]},{"title":"实现网页顶部加载条loading","url":"%2F%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E9%A1%B6%E9%83%A8%E5%8A%A0%E8%BD%BD%E6%9D%A1loading.html","content":"\n### 为什么要加loading的效果\n\n一款好的产品，都需要有一个漂亮的loading界面。lodaing界面不仅能给用户带来良好的体验，而且有效的消除了程序加载等待过程中的枯躁感。loading进度条更是对当前加载进度的一个良好反馈。从0%-100%的加载进度可以有效的告知用户还有多久即可打开页面。带有进度条的loading界面在程序中并不罕见，但是在web中呢？到目前为止浏览器并没有提供有效的浏览器对象来反馈页面的加载进度，所以无法直接、便捷的获得页面加载进度的反馈。\n\n---\n<!-- more -->\n\n### jquery实现\n```html\n<div id=\"progress\"> \n   <span></span> \n</div> \n```\n\n```css\nbody{ \n      margin:0; \n  } \n  #progress { \n      position:fixed; \n      height: 2px; \n      background:#6bc30d; \n      transition:opacity 500ms linear \n  } \n  #progress.done { \n      opacity:0 \n  } \n  #progress span { \n      position:absolute; \n      height:2px; \n      -webkit-box-shadow:#6bc30d 1px 0 6px 1px; \n      -webkit-border-radius:100%; \n      opacity:1; \n      width:150px; \n      right:-10px; \n      -webkit-animation:pulse 2s ease-out 0s infinite; \n  } \n \n  @-webkit-keyframes pulse { \n      30% { \n          opacity:.6 \n      } \n      60% { \n          opacity:0; \n      } \n      100% { \n          opacity:.6 \n      } \n} \n```\n\n```javascript\n$({property: 0}).animate({property: 100}, { \n    duration: 2000, \n    step: function() { \n        var percentage = Math.round(this.property); \n \n        $('#progress').css('width',  percentage+\"%\"); \n \n         if(percentage == 100) { \n                $(\"#progress\").addClass(\"done\");//完成，隐藏进度条 \n            } \n    } \n}); \n```\n\n### tip\n- 这种方法简单明了，但兼容性不是太好。主流的浏览器肯定没有问题，但如果考虑IE兼容性的，就不要用此方法了。\n- duration是设置时间的。默认是2秒。换算代码：2000=2秒\n- 请引入jquery库文件。否则程序不会运行\n\n","tags":["知识"],"categories":["JS"]},{"title":"Sass学习笔记","url":"%2Fsass.html","content":"\n### 简介\nSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。\n\n---\n<!--more-->\n\n### 导入\n```javascript\n@import \"reset.css\"; // css\n@import \"index\"; // sass\n```\n\n### 变量\n```javascript\n// 普通变量\n$fontSize:16px;\n\n// 默认变量\n$baseLineHeight: 1.5 !default;\n\n// 覆盖默认变量，需要写在 !default 前面\n$baseLineHeight: 1.7;\n$baseLineHeight: 1.5 !default;\n\n// 一维 list\n$px: (5px 10px 20px 30px);\n\n// 二维 list\n$px: (5px 10px)\n     (20px 30px);\n// 或者\n$pxs: 5px 10px, 20px 30px;\n\n// Map 类似对象\n$heading: (\n    h1: 2em,\n    h2: 1.5em,\n    h3: 1.2em\n);\n```\n\n### 插值\n插值使用 #{}\n\n```javascript\n// Variables\n$mySelector: banner;\n\n// .banner\n.#{mySelector} {\n    font-weight: bold;\n    line-height: 40px;\n    margin: 0 auto;\n}\n```\n\n### 跳出嵌套\n@at-root (without: rule| all | media)\n\n```javascript\n// 跳出普通的嵌套\n.demo {\n    animation: motion 3s infinite;\n\n    @at-root {\n        @keyframes motion {\n          ...\n        }\n    }\n}\n\n// 跳出 media 嵌套\n@media print {\n    .parent2{\n        color:#f00;\n\n        @at-root (without: media) {\n            .child2 {\n                width:200px;\n            }\n        }\n    }\n}\n```\n\n### 混合(mixin)\n使用 @mixin 声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。\n@mixin 通过 @include 来调用。\n混合器中不仅可以包含属性，也可以包含 css 规则，包含选择器和选择器中的属性，也可以使用 & 上下文。\n\n为便于书写，@mixin 可以用 = 表示，而 @include 可以用 + 表示\n\n```javascript\n// 无参数\n@mixin block {\n    display: block;\n}\n\n// css 规则，注意上下文\n@mixin no-bullets {\n    list-style: none;\n    li {\n        list-style-image: none;\n        list-style-type: none;\n        margin-left: 0px;\n    }\n}\n\n// 带参数\n@mixin opacity($opacity: 50) {\n    opacity: $opacity / 100;\n    filter: alpha(opacity=$opacity);\n}\n\n// 多个参数\n@mixin horizontal-line($border: 1px dashed #ccc, $padding: 10px){\n    border-bottom: $border;\n    padding-top: $padding;\n    padding-bottom: $padding;\n}\n\n@include horizontal-line($padding: 15px);\n\n// 多组值参数\n@mixin box-shadow($shadow...) {\n    -webkit-box-shadow:$shadow;\n    box-shadow:$shadow;\n}\n\n@include box-shadow(\n    0 2px 2px rgba(0, 0, 0, 0.3),\n    0 3px 3px rgba(0, 0, 0, 0.2)\n);\n```\n\n#### @Content\n@content 它可以使 @mixin 接受一整块样式，接受的样式从 @content 开始。\n\n```javascript\n@mixin max-screen($res) {\n    @media only screen and ( max-width: $res ) {\n        @content; // body { color: red }\n    }\n}\n\n@include max-screen(480px) {\n    body { color: red } // 这里就i @content 引用的内容\n}\n```\n\n## 继承\n选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend，后面紧跟需要继承的选择器。\n继承可以继承默认的元素属性，比如让一个div继承a，那么这 div 看起来就好像 a 一样。\n\n```javascript\n// 继承现有的标签，或类\nh1{\n    border: 4px solid #ff9aa9;\n}\n.speaker{\n    @extend h1;\n    border-width: 2px;\n}\n```\n\n## 占位选择器%\n可以定义占位选择器 %，如果不调用则不会有任何多余的 css 代码。\n\n```javascript\n%block {\n    display: block;\n}\n\n.box {\n    @extend %block;\n}\n```\n\n## 函数\nsass定义了很多函数可供使用，当然你也可以自己定义函数，以@fuction开始。\n\n使用最多的是颜色函数：\n颜色函数中又以 lighten 减淡和 darken 加深为最，\n其调用方法为 lighten($color, $amount) 和 darken($color, $amount)\n它们的第一个参数都是颜色值，第二个参数都是百分比。\n\n```javascript\n@function pxToRem($px) {\n    @return $px / $baseFontSize * 1rem;\n}\nbody {\n    color: lighten($gray, 10%); // 直接使用\n}\ndiv {\n    font-size: pxToRem(16px);\n    color: darken($gray, 10%);\n}\n```\n\n## @if判断\n@if 可一个条件单独使用，也可以和 @else 结合多条件使用\n\n```javascript\n$big: false;\np {\n    @if $big == false {\n        margin: 10px;\n    }\n    @else {\n        margin: 10px auto;\n    }\n}\n```\n\n## 三目判断\n语法为：if($condition, $if_true, $if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值。\n\n```javascript\n$min: 20;\np {\n    color: if($min > 10, red, blue); // blue\n}\n```\n\n## for循环\nfor 循环有两种形式，分别为：@for $var from [start] through [end] 和 @for $var from [start] to [end]。\n关键字through表示包括end这个数，而to则不包括end这个数。\n\n```javascript\n@for $i from 1 through 3 {\n    .item-#{$i} { width: 2em * $i; }\n}\n```\n\n## @each 循环\n语法为：@each $var in [list or map]\n\n```javascript\n$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);\n@each $header, $size in $headings {\n    #{$header} {\n        font-size: $size;\n    }\n}\n```\n","tags":["Sass"],"categories":["CSS"]},{"title":"如何练就超强的学习能力","url":"%2F%E5%A6%82%E4%BD%95%E7%BB%83%E5%B0%B1%E8%B6%85%E5%BC%BA%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%83%BD%E5%8A%9B.html","content":"\n### 学习开始前的准备\n\n心态我认为世界上没有“困难”的内容，只有“简单但是不完整”的内容。爱因斯坦说：“如果你不能让一个五岁小孩理解你的概念，那就意味着你对这个概念不够了解。”这句话的含义很丰富。首先，为什么一个五岁小孩具备可以理解所有概念的能力？因为所有概念本质上都是一个逻辑链条，一环接一环。只要把每一个环节的逻辑理解了，那你对这个概念本身就理解透了。这个逻辑链条上的每一环都不困难，所以一个五岁小孩都能理解。理解一个概念最困难的地方在于填补一个断裂的逻辑链条。很多时候，教科书里会说：“因为A，所以C。” 然而那个概念其实是“因为A，所以B，所以C。”在这个时候我们就会头大：看不懂A和C之间的联系啊，难道是因为A所以D所以C？还是因为A所以E所以C？困难就是在这个过程中出现的。我们都曾有过这个经历：自己苦苦思索了许久的难题，在别人一两句话的点拨下就豁然开朗。这种经历的本质就是对方告诉了你：“A和C之间缺失的那个部分是B。”从A到B到C的逻辑不难，难的是修补A和C之间断裂的逻辑链条。因此，我再次重复：世界上没有“困难”的内容，只有“简单但是不完整”的内容。当你在学习上感到气馁时，记住上面这句话，它将会给你继续探索的信心和勇气。\n\n---\n<!-- more -->\n\n### 痴迷（obsession）\n\n“痴迷”是我用过的最有效的方法。当我学到一个新概念时，如果我不能马上理解它，我就会一整天反复在脑中思索这个概念：走路时、吃饭时、坐车时都在思考。其实就是把别人看手机的时间拿来思考概念了。但是“痴迷”和常见的“利用碎片时间”有一个根本性的不同。利用碎片时间是被动的，是“因为我有这些时间，所以我要利用好它”；而痴迷是主动的，是“我对这个内容很好奇，所以我要弄懂它。”换句话说，利用碎片时间的重点在于“利用时间”，而痴迷的重点在于“你很好奇”。当你用“痴迷”的方法想通一个概念时，你就会把这个概念记得特别牢固，因为1）你花了很多时间反复思考它，这本身就是一个记忆的过程；2）你对这个概念会有自己的理解，知其然并知其所以然，而不是单纯把教科书背了下来。“知其然并知其所以然”意味着当你对这个概念的记忆变得模糊时，你脑里将有更多关于这个概念的内容来“提示”你将其记起来。\n\n### 有效率的学习策略\n\n当你遇到一道数学难题时，你会怎么做？查答案？自己苦苦思索？开始玩手机逃避？我的做法是在有答案的情况下先查答案，不浪费时间在解题过程上，而是把时间都花在理解概念上。这样才可以把时间的效用最大化，因为难题都是树的叶子，而题目考察的概念是树的主干。一棵树只有一个主干，但是可以有茫茫多的叶子。如果你每个难题都自己思索的话，你大概率得学到猴年马月了。因此，应对难题最好的方法不是硬刚，而是找答案。","tags":["杂谈"],"categories":["杂谈"]},{"title":"选择","url":"%2F%E9%80%89%E6%8B%A9.html","content":"\n{% centerquote %} \n没有方向的船，任何方向都是逆风。\n{% endcenterquote %} \n\n{% centerquote %} \n拼命活下去，发现更大的世界。\n{% endcenterquote %} \n\n选择比努力更加重要。在中国这个有着特殊国情的国家里，个人的位置是很难找准定位的。混的差了，被人鄙夷。混的好了招人记恨。人就是喜欢互相比较，每个人的学习产出比是不一样的。不满足于现状，总想着明天一定比今天的自己强。\n\n--- \n<!--more-->\n\n每个人的格局和所谓的幸福度都是不一样的，nj1年10k看上去已经不错了，比上不足比下有余。有很多老家的年轻人拿着微薄的薪水过着随遇而安的生活，而有自尊心希望受到别人的肯定，努力地活下去。去外包就去外包吧，钱给足也是可以的。福利待遇有不错。就是估计要上sn和tn的黑名单了，发了offer都不去。。。也有需要重新租房等一系列问题。就是技术单一，工作环境差，内网环境。不管怎样都不能懈怠，不会这么一直干下去。但是福利待遇还是不错的，不断充实自己的技能。存量与增量\n\n风味人间真好看，流口水=3=\n2018.11.20又让我想起了revenge，生活是需要`passion`，`enthusastic`，`motion`,`stress`。\n\n制定计划，时间管理。做一个好看的todoList。区别于其他人，自主思考、甄别是非的能力。\n\n`成功男士` --- 自身的强大\n- 教育\n- 私活\n- 店面\n- 营养师\n- 理财","tags":["杂谈"],"categories":["杂谈"]},{"title":"console控制台优化","url":"%2Fconsole%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3.html","content":"\n熟悉前端的不会对console和alert陌生，两者在调试的时候可谓是法宝级别的工具，但是关于console，其实远远不止于console.log这一个简单的命令，它能做的事情有很多，那么让我们来一起了解一下，它有哪些冷门功能吧。\n\n---\n<!--more-->\n### 显示信息的命令\n```javascript\nconsole.log('hello world');\nconsole.info('信息');\nconsole.debug('调试');\nconsole.error('错误');\nconsole.warn('警告');\n```\n\n### 占位符\n​ console上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）\n\n```javascript\nconsole.log(\"%d年%d月%d日\",2016,11,11);\n```\n\n### 信息分组\n```javascript\nconsole.group(\"第一组信息\");\nconsole.log(\"第一组第一条:何问起(http://hovertree.com)\");\nconsole.log(\"第一组第二条:柯乐义(http://keleyi.com)\");\nconsole.groupEnd();\nconsole.group(\"第二组信息\");\nconsole.log(\"第二组第一条:HoverClock 一个jQuery时钟插件\");\nconsole.log(\"第二组第二条:欢迎使用\");\nconsole.groupEnd();\n```\n\n### 对象信息\n```javascript\nvar obj={\n    id:1,\n    name:123\n}\nconsole.dir(obj)\n```\n\n### 显示网页节点\n```javascript\nconsole.dirxml()用来显示网页的某个节点（node）所包含的html/xml代码\nvar info = document.getElementById('info');\nconsole.dirxml(info);\n```\n\n### 判断变量是否为真\n​console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。\n\n```javascript\nconsole.assert(1 == 1); \nconsole.assert(1 == 2); // Assertion failed: console.assert\n```\n\n### 追踪函数的调用踪迹\n```javascript\nfunction add(a,b){\nconsole.trace();\nreturn a+b;\n}\nvar x = add3(1,1);\nfunction add3(a,b){return add2(a,b);}\nfunction add2(a,b){return add1(a,b);}\nfunction add1(a,b){return add(a,b);}\n// add add1 add2 add3\n```\n\n### 计时功能\nconsole.time()和console.timeEnd()，用来显示代码的运行时间。\n\n```javascript\nconsole.time(\"控制台计时器一\");\nfor(var i=0;i<10000;i++){\nfor(var j=0;j<1000;j++){}\n}\nconsole.timeEnd(\"控制台计时器一\");\n```","tags":["优化"],"categories":["知识"]},{"title":"JavaScript性能优化","url":"%2Fjs%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html","content":"\n### 评估局部变量\n主要针对IE而言，由于局部变量的查找是从最特定作用域到最大作用域，且可以通过多个域\n层级，所以这种查找会导致查询到通用的结果。在定义函数作用域的时候，如果一个局部变\n量在之前没有进行过var变量声明， 那么此处一定要在变量名前加上var关键字以定义其当\n前的作用域和防止查询，从而提高代码的速度。\n\n---\n<!--more-->\n\n### 除非必要，否则不要使用嵌套循环\n减少不必要的循环，例如 for 和 while 循环，以保持 JavaScript 的线性，并避免需要遍历数千个对象。无用的循环可能会导致浏览器处理代码时更困难，从而减缓速度。\n\n### 缓存对象以提高性能\n很多时候，会重复使用脚本来访问某个对象。 将重复访问的对象存储在用户定义的变量中，并且之后在引用该对象时使用此变量，可以立刻实现性能提升。\n\n### 使用.js文件来缓存脚本\n使用这种技术可以实现性能提升，因为它允许浏览器只加载脚本一次，当页面被重新加载或重新访问时只需要从缓存中调用脚本即可。\n\n### 使用Gzip压缩文件\n使用 GZip 可以明显地降低 JavaScript 文件的大小，节省带宽，并加快响应时间。 有时 JavaScript 文件非常大，如果没有经过压缩，它可能会造成网站瘫痪。较小的文件能提供更快、更令人满意的网页体验。\n\n### 尽量减少对HTTP的请求\n通过结合外部文件和直接在 XHTML 页面中嵌入 JavaScript 来尽量减少对 HTTP 返回页面的请求。 每一个特定的 HTTP 请求传输至服务器端都会导致大量的时延。\n\n### 不要重复使用相同的脚本\n复的脚本对性能会造成显著的影响。重复的脚本会创建不需要的HTTP请求，尤其是在IE浏览器中。在HTML页面中使用脚本标签，可以帮助避免意外地生成重复的脚本。\n\n### 缩短作用域链\n全局作用域通常较慢，因为每次执行函数的时候，它会引发创建一个临时的调用作用域，JavaScript 会在作用域链中搜索第一个对象，如果找不到该变量，则会遍历链直到搜索到全局对象。\n\n### 使用函数内联\n函数内联有助于减少函数调用的成本，并用被调用的函数体替换函数调用。 在 JavaScript 中执行函数调用是一个高成本的操作，因为需要执行几个准备步骤：为参数分配空间，复制参数以及解析函数名称。\n\n### 尽量不要使用全局变量\n由于脚本引擎需要搜索作用域，所以当从函数内部或其他作用域内引用全局变量时，如果局部作用域丢失，全局变量将被销毁。如果全局作用域中的变量并不一直存在于脚本的生命周期，则可以提升性能。\n\n### 不要一直保留对其他文档的引用\n当脚本结束后不再保留对其他文档的引用可以实现更快的性能。因为对其他文档中的对象进行的任何引用不会被保存在整个 DOM 树中，并且脚本环境也不会一直保留在内存中。 因此文档本身不用再被加载。\n\n### 不要误用 for-in Object.hasOwnProperty()只遍历当前对象\n由于“for-in”循环需要脚本引擎构建包含所有可枚举属性的列表，因此 for 循环内的代码是不会修改这个列表的。 在 for 循环内部，预先计算出列表的长度并赋给变量 len，然后进行迭代。\n","tags":["性能优化"],"categories":["JS"]},{"title":"classNames在react上的应用","url":"%2FclassNames%E5%9C%A8react%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8.html","content":"\n### 前言\n\n在 Vue 里有一个动态的 class 语法，很好的根据条件动态设置 class。例如：\n\n```javascript\n<div class=\"button\" :class=\"{ active: show }\"></div>\n```\n就是当 show 为 true 时，此标签被赋予 active 样式。\n\n在 React 要实现这样功能，可能会这样做：\n\n```javascript\n<div className={`button ${show ? 'active' : ''}`}></div>\n```\n注意到，这里只有一个属性判断，如果有多个时会显得非常麻烦，那么现在使用 [ClassNames](https://github.com/JedWatson/classnames) 这个库来解决这个问题。\n\n---\n<!-- more -->\n\n### 基本使用\n`ClassNames` 是一个高性能、简便的用户根据条件动态设置 `className` 的 `Javascript` 库。\n\n它的使用非常简单，来看看下面的几种使用方式。（自己也可以开发一个类似的库，不过没必要再造轮子）\n\n```javascript\nimport classNames from 'classnames';\n\nclassNames('foo', 'bar');                   // => 'foo bar'\nclassNames('foo', { bar: true });           // => 'foo bar'\nclassNames({ 'foo-bar': true });            // => 'foo-bar'\nclassNames({ 'foo-bar': false });           // => ''\nclassNames({ foo: true }, { bar: true });   // => 'foo bar'\nclassNames({ foo: true, bar: true });       // => 'foo bar'\n\n// 多级嵌套，多参数\nclassNames('foo', { bar: true, duck: false }, 'baz', { quux: true });\n// => 'foo bar baz quux'\n\n// !! 为 false 的将被忽略\nclassNames(null, false, 'bar', undefined, 0, 1, { baz: null }, '');\n// => 'bar 1'\n```\n\n### 动态属性名\n在 ES6 下，可以使用模板语法，来设置跟强大的动态 `className`。\n\n```javascript\nconst buttonType = 'primary';\nclassNames({ [`btn-${buttonType}`]: true });\n```\n\n### 去重功能dedupe\n使用 dedupe 版本的 classNames 可以正确地对类进行重复数据删除，并确保在后面的参数中指定的错误类从结果集中排除。dedupe 会慢（约5倍），因此它是作为选择提供的（在默认是不会去重的）。\n\n```javascript\nimport classNames from 'classnames/dedupe';\n\nclassNames('foo', 'foo', 'bar');                // => 'foo bar'\nclassNames('foo', { foo: false, bar: true });   // => 'bar'\n```\n### 映射bind\n如果您使用 css-modules 或类似的方法来抽象类“名称”以及 className 实际输出到 DOM 的真实值，那么要使用 bind 版本。\n\n```javascript\nimport classNames from 'classnames/bind';\n// 映射关系\nconst styles = {\n    foo: 'abc',\n    bar: 'def',\n    baz: 'xyz'\n};\n\nconst cx = classNames.bind(styles);\nconst className = cx('foo', ['bar'], { baz: true });  //（1） => \"abc def xyz\"\n// const className = cx('abc', ['def'], { xyz: true }); （2）\n```\n这里什么意思呢？实际上就是把 foo 与 abc 产生映射，也就是说 （1） 和 （2） 两条语句是等效的，好处就像是定义一些常量一样。\n\n### 在React上使用\n如antd上的源码，prefix定义class\n\n```javascript\nconst prefixCls = 'alter';\n\nconst classs = classNames(prefixCls, {\n    [`${prefixCls}-${type}`]: true,\n    [`${prefixCls}-close`]: !this.state.closing,\n    [`${prefixCls}-with-description`]: !!description,\n    [`${prefixCls}-no-icon`]: !showIcon,\n    [`${prefixCls}-banner`]: !!banner,\n}, className);\n```\n\n### 参考资料\n- https://github.com/JedWatson/classnames\n- https://www.npmjs.com/package/classcat","tags":["react"],"categories":["JS"]},{"title":"generator生成器","url":"%2Fes6generator.html","content":"\n生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字，有意思的是函数会在每个yield后暂停。\n\n这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。\n\n--- \n<!-- more -->\n\nOK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。\n\n- function 关键字与函数名之间有一个星号；\n- 函数体内部使用 yield表达式，定义不同的内部状态；\n- next 指针移向下一个状态\n\n```javascript\n// 生成器 最大的特点是可以交出函数的执行权\nfunction *createGenerator(){\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\n// 迭代器\nlet iterator=createGenerator()\nconsole.log(iterator.next().value) // 1\nconsole.log(iterator.next().value) // 2\nconsole.log(iterator.next().value) // 3\n```\n\n那生成器和迭代器又有什么用处呢？\n\n围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。\n\n生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。\n\n那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的：\n\n```javascript\nfunction run(taskDef){\n  // 创建迭代器，让它在别处可用\n  let task=taskDef();\n\n  // 启动任务\n  let result=task.next();\n\n  // 递归使用函数来保持对next()的调用\n  function step(){\n      // 如果还有更多要做的\n      if(!result.done){\n        result=task.next();\n        step();\n      }\n  }\n\n  // 开始处理过程\n  step();\n}\n```\n生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。可以不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 `yield` 来等待异步操作结束。\n\n\nes6引入了 async 函数，使得异步操作变得更加方便。\n\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。\n\n```javascript\nfunction timeout(ms){\n  return new Promise((resolve)=>{\n      setTimeout(resolve,ms)\n  });\n}\n\nasync function asyncPrint(value,ms){\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world',50)\n```\n\n一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\nasync函数对 Generator 函数的改进，体现在以下四点：\n- 内置执行器\n- 更好的语义\n- 更广的适用性\n- 返回值是Promise\n","tags":["es6"],"categories":["JS"]},{"title":"移动端web问题总结（长期更新）","url":"%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFweb%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html","content":"\n### meta基础知识\n#### H5页面窗口自动调整到设备宽度，并禁止用户缩放页面\n```javascript\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```","tags":["知识"],"categories":["知识"]},{"title":"react组件实现按需加载","url":"%2Freact%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD.html","content":"\n第一种：ReactTraining/react-router 介绍的基于 webpack, babel-plugin-syntax-dynamic-import, 和 react-loadable.\n\n主要是利用了react-loadable这个高级组件，他是专门用来异步加载（也可以预加载）组件的。\n\nhttps://github.com/ReactTraining/react-router/blob/master/packages/react-router-dom/docs/guides/code-splitting.md\n\n ---\n <!-- more --> \n\n第二种：SF网友介绍的Bundle组件配合webpack组件bundle-loader\n\nbundle-loader效用其实和require.ensure()一样，把组件分片成单独的chunk，在Bundle组件中引入\n\nhttps://segmentfault.com/a/1190000009539836\n\n \n\n但是我尝试的时候发现总是报错说不要在import中引入webpack的loader。。。\n\n然后我继续查，发现第三种实现\n\n \n\n第三种：简书AlienZHOU介绍的同样基于create-react-app的方式，在Bundle组件中props入一个()=>import('path')函数\n\nhttp://www.jianshu.com/p/547aa7b92d8c\n\n \n\n第四种，create-react-app文档给的react-router按需加载实现：用一个类Bundle组件的异步函数\n\nhttps://serverless-stack.com/chapters/code-splitting-in-create-react-app.html\n\n这种方式我试了下，确实能分片，但是讨论里有人指出性能上不如Bundle组件，那个人好像还是Create-react-app的主要贡献者\n\n \n\n四种方式我都试过，期间。。这个过程略痛苦。。。不过结论是：第三种是目前我认为最好的，基于create-react-app，且实现最简单。\n\n但是较大的项目，一般我们都会eject出来自己配置webpack啦，其实影响也不大。\n\n","tags":["react"],"categories":["JS"]},{"title":"css绘制几何图形","url":"%2Fcss%E7%BB%98%E5%88%B6%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2.html","content":"\nCSS能够生成各种形状。正方形和矩形很容易，因为它们是 web 的自然形状。添加宽度和高度，就得到了所需的精确大小的矩形。添加边框半径，你就可以把这个形状变成圆形，足够多的边框半径，你就可以把这些矩形变成圆形和椭圆形。\n\n我们还可以使用 CSS 伪元素中的 `::before` 和 `::after`，这为我们提供了向原始元素添加另外两个形状的可能性。通过巧妙地使用定位、转换和许多其他技巧，我们可以只用一个 HTML 元素在 CSS 中创建许多形状。\n\n虽然我们现在大都使用字体图标或者svg图片，似乎使用 CSS 来做图标意义不是很大，但怎么实现这些图标用到的一些技巧及思路是很值得我们学习。\n\n---\n<!--more-->\n\n### 圆\n```css\ndiv {\nwidth: 100px;\nheight: 100px;\nborder-radius: 50px; \n/* 注意宽高相同圆角为一半 50%/100%都可以*/\n}\n```\n\n### 四个不同方向的半圆\n```css\n.top\n{\n  width: 100px;\n  height: 50px;\n  border-radius: 50px 50px 0 0;\n}\n.right {\n  width: 50px;\n  height: 100px;\n  border-radius: 0 50px 50px 0;\n}\n.bottom {\n  width: 100px;\n  height: 50px;\n  border-radius: 0 0 50px 50px;\n}\n.left {\n  width: 50px;\n  height: 100px;\n  border-radius: 50px 0 0 50px;\n}\n```\n\n--- \n<!-- more -->\n\n### 四分之一圆\n```css\n{\n  width:50px;\n  height:50px;\n  border-radius:50px 0 0 0;\n}\n```\n\n## 椭圆\n```css\n{\n  width: 150px;\n  height: 100px;\n  border-radius: 50%; \n}\n```\n\n### 菱形\n```css\n.quarter-ellipse{\n    width: 100px;\n    height: 50px;\n    background: pink;\n    transform: skew(-20deg);\n    text-align: center;\n    line-height: 50px;\n}\n```\n\n### 三角形 尖端朝向\n```css\n#triangle-up {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid lightblue;\n}\n#triangle-down {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-top: 100px solid lightblue;\n}\n#triangle-left {\n    width: 0;\n    height: 0;\n    border-top: 50px solid transparent;\n    border-right: 100px solid lightblue;\n    border-bottom: 50px solid transparent;\n}\n#triangle-right {\n    width: 0;\n    height: 0;\n    border-top: 50px solid transparent;\n    border-left: 100px solid lightblue;\n    border-bottom: 50px solid transparent;\n}\n#triangle-topleft {\n    width: 0;\n    height: 0;\n    border-top: 100px solid lightblue;\n    border-right: 100px solid transparent;\n}\n#triangle-topright {\n    width: 0;\n    height: 0;\n    border-top: 100px solid lightblue;\n    border-left: 100px solid transparent; \n}\n#triangle-bottomleft {\n    width: 0;\n    height: 0;\n    border-bottom: 100px solid lightblue;\n    border-right: 100px solid transparent;\n}\n#triangle-bottomright {\n    width: 0;\n    height: 0;\n    border-bottom: 100px solid lightblue;\n    border-left: 100px solid transparent;\n}\n```\n\n### 箭头\n```css\n#curvedarrow {\n  position: relative;\n  width: 0;\n  height: 0;\n  border-top: 9px solid transparent;\n  border-right: 9px solid red;\n  transform: rotate(10deg);\n}\n#curvedarrow:after {\n  content: \"\";\n  position: absolute;\n  border: 0 solid transparent;\n  border-top: 3px solid red;\n  border-radius: 20px 0 0 0;\n  top: -12px;\n  left: -9px;\n  width: 12px;\n  height: 12px;\n  transform: rotate(45deg);\n}\n```\n\n### 梯形\n```css\n#trapezoid {\n  border-bottom: 100px solid red;\n  border-left: 25px solid transparent;\n  border-right: 25px solid transparent;\n  height: 0;\n  width: 100px;\n}\n```\n\n### 六角星\n```css\n#star-six {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid red;\n  position: relative;\n}\n#star-six:after {\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 100px solid red;\n  position: absolute;\n  content: \"\";\n  top: 30px;\n  left: -50px;\n}\n```\n\n### 五角星\n```css\n#star-five {\n  margin: 50px 0;\n  position: relative;\n  display: block;\n  color: red;\n  width: 0px;\n  height: 0px;\n  border-right: 100px solid transparent;\n  border-bottom: 70px solid red;\n  border-left: 100px solid transparent;\n  transform: rotate(35deg);\n}\n#star-five:before {\n  border-bottom: 80px solid red;\n  border-left: 30px solid transparent;\n  border-right: 30px solid transparent;\n  position: absolute;\n  height: 0;\n  width: 0;\n  top: -45px;\n  left: -65px;\n  display: block;\n  content: '';\n  transform: rotate(-35deg);\n}\n#star-five:after {\n  position: absolute;\n  display: block;\n  color: red;\n  top: 3px;\n  left: -105px;\n  width: 0px;\n  height: 0px;\n  border-right: 100px solid transparent;\n  border-bottom: 70px solid red;\n  border-left: 100px solid transparent;\n  transform: rotate(-70deg);\n  content: '';\n}\n```\n\n### 五边形\n```css\n#pentagon {\n  position: relative;\n  width: 54px;\n  box-sizing: content-box;\n  border-width: 50px 18px 0;\n  border-style: solid;\n  border-color: red transparent;\n}\n#pentagon:before {\n  content: \"\";\n  position: absolute;\n  height: 0;\n  width: 0;\n  top: -85px;\n  left: -18px;\n  border-width: 0 45px 35px;\n  border-style: solid;\n  border-color: transparent transparent red;\n}\n```\n\n### 六边形\n```css\n#hexagon {\n  width: 100px;\n  height: 55px;\n  background: red;\n  position: relative;\n}\n#hexagon:before {\n  content: \"\";\n  position: absolute;\n  top: -25px;\n  left: 0;\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 25px solid red;\n}\n#hexagon:after {\n  content: \"\";\n  position: absolute;\n  bottom: -25px;\n  left: 0;\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-top: 25px solid red;\n}\n```\n\n### 八边形\n```css\n#octagon {\n  width: 100px;\n  height: 100px;\n  background: red;\n  position: relative;\n}\n#octagon:before {\n  content: \"\";\n  width: 100px;\n  height: 0;\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-bottom: 29px solid red;\n  border-left: 29px solid #eee;\n  border-right: 29px solid #eee;\n}\n#octagon:after {\n  content: \"\";\n  width: 100px;\n  height: 0;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  border-top: 29px solid red;\n  border-left: 29px solid #eee;\n  border-right: 29px solid #eee;\n}\n```\n\n### 爱心💗\n```css\n#heart {\n  position: relative;\n  width: 100px;\n  height: 90px;\n}\n#heart:before,\n#heart:after {\n  position: absolute;\n  content: \"\";\n  left: 50px;\n  top: 0;\n  width: 50px;\n  height: 80px;\n  background: red;\n  border-radius: 50px 50px 0 0;\n  transform: rotate(-45deg);\n  transform-origin: 0 100%;\n}\n#heart:after {\n  left: 0;\n  transform: rotate(45deg);\n  transform-origin: 100% 100%;\n}\n```\n\n### 无穷大（莫比乌斯环）\n```css\n#infinity {\n  position: relative;\n  width: 212px;\n  height: 100px;\n  box-sizing: content-box;\n}\n#infinity:before,\n#infinity:after {\n  content: \"\";\n  box-sizing: content-box;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 60px;\n  height: 60px;\n  border: 20px solid red;\n  border-radius: 50px 50px 0 50px;\n  transform: rotate(-45deg);\n}\n#infinity:after {\n  left: auto;\n  right: 0;\n  border-radius: 50px 50px 50px 0;\n  transform: rotate(45deg);\n}\n```\n\n### 钻石\n```css\n#cut-diamond {\n  border-style: solid;\n  border-color: transparent transparent red transparent;\n  border-width: 0 25px 25px 25px;\n  height: 0;\n  width: 50px;\n  box-sizing: content-box;\n  position: relative;\n  margin: 20px 0 50px 0;\n}\n#cut-diamond:after {\n  content: \"\";\n  position: absolute;\n  top: 25px;\n  left: -25px;\n  width: 0;\n  height: 0;\n  border-style: solid;\n  border-color: red transparent transparent transparent;\n  border-width: 70px 50px 0 50px;\n}\n```\n\n### 吃豆人\n```css\n#pacman {\n  width: 0px;\n  height: 0px;\n  border-right: 60px solid transparent;\n  border-top: 60px solid red;\n  border-left: 60px solid red;\n  border-bottom: 60px solid red;\n  border-top-left-radius: 60px;\n  border-top-right-radius: 60px;\n  border-bottom-left-radius: 60px;\n  border-bottom-right-radius: 60px;\n}\n```\n\n### 对话泡泡\n```css\n#talkbubble {\n  width: 120px;\n  height: 80px;\n  background: red;\n  position: relative;\n  -moz-border-radius: 10px;\n  -webkit-border-radius: 10px;\n  border-radius: 10px;\n}\n#talkbubble:before {\n  content: \"\";\n  position: absolute;\n  right: 100%;\n  top: 26px;\n  width: 0;\n  height: 0;\n  border-top: 13px solid transparent;\n  border-right: 26px solid red;\n  border-bottom: 13px solid transparent;\n}\n```\n\n### 太极\n```css\n#yin-yang {\n  width: 96px;\n  box-sizing: content-box;\n  height: 48px;\n  background: #eee;\n  border-color: red;\n  border-style: solid;\n  border-width: 2px 2px 50px 2px;\n  border-radius: 100%;\n  position: relative;\n}\n#yin-yang:before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 0;\n  background: #eee;\n  border: 18px solid red;\n  border-radius: 100%;\n  width: 12px;\n  height: 12px;\n  box-sizing: content-box;\n}\n#yin-yang:after {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  background: red;\n  border: 18px solid #eee;\n  border-radius: 100%;\n  width: 12px;\n  height: 12px;\n  box-sizing: content-box;\n}  \n```\n\n### 放大镜\n```css\n#magnifying-glass {\n  font-size: 10em;\n  display: inline-block;\n  width: 0.4em;\n  box-sizing: content-box;\n  height: 0.4em;\n  border: 0.1em solid red;\n  position: relative;\n  border-radius: 0.35em;\n}\n#magnifying-glass:before {\n  content: \"\";\n  display: inline-block;\n  position: absolute;\n  right: -0.25em;\n  bottom: -0.1em;\n  border-width: 0;\n  background: red;\n  width: 0.35em;\n  height: 0.08em;\n  transform: rotate(45deg);\n}\n```\n\n### 月亮\n```css\n#moon {\n  width: 80px;\n  height: 80px;\n  border-radius: 50%;\n  box-shadow: 15px 15px 0 0 red;\n}  \n```","tags":["布局"],"categories":["CSS"]},{"title":"Http请求概述","url":"%2Fhttp%E8%AF%B7%E6%B1%82%E6%A6%82%E8%BF%B0.html","content":"\n超文本传输协议（HTTP, HyperText Transfer Protocol）是一种无状态的协议，它位于OSI七层模型的传输层。HTTP客户端会根据需要构建合适的HTTP请求方法，而HTTP服务器会根据不同的HTTP请求方法做出不同的响应。\n\n--- \n<!-- more -->\n\n## HTTP版本\n在HTTP的发展过程中，出现了很多HTTP版本，其中的大部分协议都是向下兼容的。在进行HTTP请求时，客户端在请求时会告诉服务器它采用的协议版本号，而服务器则会在使用相同或者更早的协议版本进行响应。\n- HTTP/0.9\n这是HTTP最早大规模使用的版本，现已过时。在这个版本中 只有GET一种请求方法，在HTTP通讯也没有指定版本号，也不支持请求头信息。该版本不支持POST等方法，因此客户端向服务器传递信息的能力非常有限。HTTP/0.9的请求只有如下一行：\nGET www.baidu.com\n\n- HTTP/1.0\n这个版本是第一个在HTTP通讯中指定版本号的协议版本，HTTP/1.0至今仍被广泛采用，特别是在代理服务器中。该版本支持：GET、POST、HEAD三种HTTP请求方法。\n- HTTP/1.1\n\nHTTP/1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。\n\n- HTTP/2\n这个版本是最新发布的版本，于今年5月（2015年5月）做HTTP标准正式发布。HTTP/2通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。\n\n## HTTP请求方法\n\n### HTTP/1.1\n协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。\n\n#### GET\nGET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。\n\n#### HEAD\nHEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。\n\n#### POST\nPOST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被 包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。\n\n#### PUT\nPUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。\n\n#### DELETE\nDELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。\n\n#### CONNECT\nCONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。\n\n#### OPTIONS\nOPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用 * 来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。\n\n#### TRACE\nTRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。\n\n### HTTP/1.1之后增加的方法\n在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是PATCH 方法:\n\n#### PATCH\nPATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：\n1.PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。\n2.当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。\n\n### 请求头和响应头\n\n1)请求(客户端->服务端[request]) \n    GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) \n    Accept: */*(客户端能接收的资源类型) \n    Accept-Language: en-us(客户端接收的语言类型) \n    Connection: Keep-Alive(维护客户端和服务端的连接关系) \n    Host: localhost:8080(连接的目标主机和端口号) \n    Referer: http://localhost/links.asp(告诉服务器我来自于哪里) \n    User-Agent: Mozilla/4.0(客户端版本号的名字) \n    Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) \n    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  \n    Cookie(客户端暂存服务端的信息) \n    Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)\n\n\n2)响应(服务端->客户端[response])\n    HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)\n    Location: http://www.baidu.com(服务端需要客户端访问的页面路径) \n    Server:apache tomcat(服务端的Web服务端名)\n    Content-Encoding: gzip(服务端能够发送压缩编码类型) \n    Content-Length: 80(服务端发送的压缩数据的长度) \n    Content-Language: zh-cn(服务端发送的语言类型) \n    Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)\n    Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)\n    Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)\n    Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)\n    Transfer-Encoding: chunked(分块传递数据到客户端）  \n    Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)\n    Expires: -1//3种(服务端禁止客户端缓存页面数据)\n    Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  \n    Pragma: no-cache(服务端禁止客户端缓存页面数据)   \n    Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  \n    Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)\n在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。\n\n## 状态码\n\n|   | 类别                          | 原因短语\n:---|:----------                   |:---------\n1XX | Informational（信息性状态码）   | 接收的请求正在处理\n2XX | Success（成功状态码）           | 请求正常处理完毕\n3XX | Redirection（重定向状态码）     | 需要进行附加操作以完成请求\n4XX | Client Error（客户端错误状态码） | 服务器无法处理请求\n5XX | Server Error（服务器错误状态码） | 服务器处理请求出错\n- 2XX\n  * 200 OK \n    <details>\n      <summary>成功处理</summary>\n      表示从客户端发来的请求在服务器端被正常处理了\n    </details>\n  * 204 No Content\n    <details>\n      <summary>成功处理，但无报文实体的主体返回</summary>\n      该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。\n    </details>\n  * 206 Partial Content\n    <details>\n      <summary>范围请求</summary>\n      该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。\n    </details>\n- 3XX\n  * 301 Moved Permanently\n    <details>\n      <summary>永久性重定向</summary>\n      该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。\n    </details>\n  * 302 Found\n    <details>\n      <summary>临时性重定向</summary>\n      该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。\n    </details>\n  * 303 See Other\n    <details>\n      <summary>同302，但此处因采用GET\b方法</summary>\n      该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。\n    </details>\n  * 304 Not Modified\n    <details>\n      <summary>协商缓存</summary>\n      该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。(附带条件的请求是指采用 GET方法的请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。)\n    </details>\n  * 307 Temporary Redirect\n    <details>\n      <summary>临时重定向</summary>\n      该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。\n    </details>\n- 4XX 客户端错误\n  * 400 Bad Request\n    <details>\n      <summary>报文中存在语法错误</summary>\n      该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。\n    </details>\n  * 401 Unauthorized\n    <details>\n      <summary>未认证</summary>\n      该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\n    </details>\n  * 403 Forbidden\n    <details>\n      <summary>未认证</summary>\n      该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。\n    </details>\n  * 404 Not Found\n    <details>\n      <summary>未找到请求的资源</summary>\n      该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。\n    </details>\n* 5XX\n  * 500 Internal Server Error\n    <details>\n      <summary>服务器端在执行请求时发生了错误</summary>\n      该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。\n    </details>\n  * 503 Service Unavailable\n    <details>\n      <summary>服务器暂时无响应</summary>\n      该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户端。\n    </details>","tags":["http"],"categories":["知识"]},{"title":"获取浏览器url参数方法总结","url":"%2F%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8url%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html","content":" \n1. 正则(xxx?typeId=1)\n```javascript\nfunction getQueryString(name) {\n    var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');\n    var r = window.location.search.substr(1).match(reg);\n    if (r != null) {\n        // return unescape(r[2]); // 中文会乱码\n        return decodeURI(r[2]);\n    }\n    return null;\n}\ngetQueryString(\"typeId\") // \"2\"\n```\n\n---\n<!-- more -->\n\n2. split拆分\n```javascript\nfunction getQueryString() {\n    var url = location.search; //获取url中\"?\"符后的字串\n    var theRequest = new Object();\n    if (url.indexOf(\"?\") != -1) {\n        var str = url.substr(1);\n        strs = str.split(\"&\");\n        for(var i = 0; i < strs.length; i ++) {\n            theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]);\n        }\n    }\n    return theRequest;\n}\ngetQueryString(\"typeId\") // {typeId:\"2}\n```\n\n3. 正则获值 和1一样\n```javascript\nfunction getQueryString(name) {  \n    var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");  \n    var r = window.location.search.substr(1).match(reg);  //获取url中\"?\"符后的字符串并正则匹配\n    var context = \"\";  \n    if (r != null)  \n         context = r[2];  \n    reg = null;  \n    r = null;  \n    return context == null || context == \"\" || context == \"undefined\" ? \"\" : context;  \n}\n```\n\n4. 单参数获取(?1)获取？后面的数据\n```javascript\nvar url=window.location.href\nurl.substring(url.indexOf('?') + 1)\n// url.substr(url.indexOf('?') + 1)\n\nvar url=window.location.search\nurl.substring(1)\n// url.substr(1)\n```\n\n5. 获取所有参数的对象\n```js\nfunction getQueryStringObject() {\n    var reg = /([^?&=]+)=([^&]+)/g;\n    var q = {};\n    location.search.replace(reg, (m, k, v) => q[k] = v);\n    return q;\n}\n```","tags":["知识"],"categories":["知识"]},{"title":"单页应用优缺点分析","url":"%2Fspa.html","content":"\n单页Web应用（single page web application，SPA），就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。\n\n--- \n<!--more-->\n\n## 优点：\n1、分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；前后台分离开发模式。\n\n2、减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；\n\n3、同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；\n\n4. 服务器压力变小，后台不需要负责模板渲染，输出页面工作。ajax实现页面刷新，不需要重新加载整个页面。\n\n## 缺点：\n1、SEO问题，现在可以通过Prerender等技术解决一部分；\n\n2、前进、后退、地址栏等，需要自行实现；\n\n3、初次加载时间较多；\n","tags":["知识"],"categories":["知识"]},{"title":"https加密通信流程解析","url":"%2Fhttps%E5%8A%A0%E5%AF%86%E9%80%9A%E4%BF%A1.html","content":"\nhttps其实是有两部分组成：http + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。\n\nhttps比http要占用更多的资源，http使用TCP 三次握手建立连接，客户端和服务器需要交换3个包，https除了 TCP 的三个包，还要加上 ssl握手需要的9个包，所以一共是12个包。\n\n---\n\n<!-- more -->\n\n## 流程解析\n\n### 客户端发起HTTPS请求\n\n用户在浏览器里输入一个https网址，然后连接到server的443端口。\n\n### 服务端的配置\n\n采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。\n\n### 传送证书\n\n这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。\n\n### 传送加密信息\n\n这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。\n\n### 服务端解密信息\n\n服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。\n\n### 传输加密后的信息\n\n这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。\n\n### 客户端解密信息\n\n客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。\n\n- GET / HEAD / OPTIONS方法           \n只从服务端获取资源 并不对服务器进行修改 因此相对安全。\n对于客户端来说是不安全的 请求参数会显示在URL中。 \n\n- TRACE方法（两端安全）\n用于诊断诊断服务器 仅记录路径信息 是安全的。\n\n- POST方法\n会影响服务器端的资源。","tags":["http"],"categories":["知识"]},{"title":"网页埋点相关知识","url":"%2F%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF.html","content":"\n埋点的需求：一个网站上线,开发者除了保证网站功能正常,体验优好之外,还有一项重要的工作是数据收集,通过收集用户的行为数据可以帮助了解网站的功能是否满足用户的需求,导流方式是否有效,新功能上线后是否效果是否达到设计初衷,根据数据指引有效优化产品体验以及发现新的产品方向是产品经理的必备技能,而如何采集准确并且足够的网站数据则应该是开发者的责任.在大数据处理能力越来越强下,以及机器学习等依赖数据哺育的工具进化下,采集足够多的数据往往是网站向着良性方向进化的必备条件\n\n---\n\n<!-- more -->\n\n## 常见工具\n\n网站的数据采集有很多现成的工具,如google Analytics, 百度统计, 友盟+等,往往通过在页面上接入js SDK代码。\n\n而在实际采集过程中,数据是如何传递过去的呢,,我们随便打开一个埋有百度统计的网站, 打开chrome的开发者工具,勾选Preserve log,\n可以发现在页面点击一个链接或者做一些其他操作,在Networking tab下可以看到hm.gif的网络请求, 这里由于统计的数据发送涉及到第三方网址,涉及跨域问题,而图片请求天然是跨域的,所以业界的通用做法是构造一个空的gif用于向第三方网站, 而真正需要统计的参数往往是通过url进行传递。\n\n## 数据采集(生成图片Url参数挂在?上)\n\n- 基本的发送函数，创建Img发送统计请求导数据采集后台。\n```javascript\nfunction sendUrl(url) {\n    let img = new Image();  // 创建一个img对象\n    let key = 'project_log_' // 为本次数据请求创建一个唯一id\n        + Math.floor(Math.random() * 2147483648).toString(36); \n \n    window[key] = img;   // 用一个数组维护img对象\n \n    img.onload = img.onerror = img.onabort = function () {\n        img.onload = img.onerror = img.onabort = null;  // 清除img元素\n        window[key] = null;\n        img = null;  \n    };\n    img.src = url;  // img对象赋值url后自动发送请求,无需插入到页面元素中去\n}\n```\n\n- 数据格式约定\n```javascript\n数据格式规则,如:1.gif?q=xxx&fr=xxx&refer=xxx&p=xxxx&xxxxx\nq表示页面搜索词; fr表示页面的上游页面时什么, refer是指从来源页面, p表示事件类型等;\n```\n\n## 访问时长的计算\n```javascript\nvar st = new Date().getTime();  // 在页面加载运行js时记录当前时间\n\n$(window).on('beforeunload', function () {\n    var et = new Date().getTime();\n    var stayTime = et - st;\n    \n}); // 在页面要unload触发'beforeunload'事件时进行时间差计算得到访问时长\n```\n\n## 关键指标\n### PV pageview\n\n传统意义上每次页面刷新代表着一次新的pv, 也就是每次统计js执行时都+1, 而现在页面很多都用到了ajax技术来进行无刷新获取展现页面来替代翻页,如瀑布流页面通过下来加载新的页面,这时候页面不重新刷新,因此可以在ajax请求接口处进行埋点进行pv累加;\n\n### 单项PV\n\n页面上部分元素有单独统计pv的需要,有些页面元素不是页面展现都展现,或者需要统计类似于某一广告的展现次数,这种需要需要在url里单独定义参数来标识;\n\n### 聚焦时间\n\n与访问时长不同,由于页面可以通过tab切换导致虽然页面没有unload但实际处于失去焦点状态, 因此需要订阅focusIn与focusOut两个事件,在focusIn时开始计时, 在focusOut时停止计时,在页面unload时将focus时间进行累加得到聚焦时间;","tags":["知识"],"categories":["知识"]},{"title":"export/export default/import的区别以及用法","url":"%2Fes6export.html","content":"\nES6模块主要有两个功能：export和import\n\nexport用于对外输出本模块（一个文件可以理解为一个模块）变量的接口\n\nimport用于在一个模块中加载另一个含有export接口的模块。\n\n也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。\n\n---\n<!-- more -->\n\n## export和import（一个导出一个导入）\n```javascript\n// a 文件 \nexport var name=\"cosyer\" // 导出单个变量\n\n// 引用a文件 \nimport {name} from './a'\nexport default {\n    data(){\n\n    },\n    howl:function (){\n    console.log(name) // cosyer\n    }\n}\n\n// 导出多个变量 \nlet name1='张三';\nlet name2='李四';\nexport {name1,name2}\n\n// 引用多个变量\nimport {name1,name2} from './a'\n\n// 导出函数\nfunction mini(num){\n    console.log(num)\n}\n\nexport {mini}\n\n// 引用函数\nimport {mini} from './a'\nexport default{\n    howl:function(){\n        mini(1) // 1\n    }\n}\n```\n\n## export和export default\n\n1. export与export default均可用于导出常量、函数、文件、模块等。\n\n2. 你可以在其它文件或模块中通过import + (常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用。\n\n3. 在一个文件或模块中，export、import可以有多个，export default仅有一个。\n\n```javascript\nexport name1;\nexport name2;\n```\n\n4. 通过export方式导出，在导入时要加{}，export default则不需要。\n\n其实很多时候export与export default可以实现同样的目的，但使用export default命令，为模块指定默认输出，这样就不需要知道加载模块的变量名。\n\n```javascript\nexport default name\nimport name from './a'\n```\n\n- 当用export default people导出时，就用 import people 导入（不带大括号）。\n- 一个文件里，有且只能有一个export default。但可以有多个export。\n- 当用export name 时，就用 import{name} 导入（记得带上大括号）。\n- 当一个文件里，既有一个export default people, 又有多个export name 或者 - export age时，导入就用 import people,{name,age}。\n- 当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用 import * as example。","tags":["es6"],"categories":["JS"]},{"title":"mobx -- 走进观察者模式","url":"%2Fmobx.html","content":"\n#### React是一个状态机，由开始的初始状态，通过与用户的互动，导致状态变化，从而重新渲染UI。\n#### React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。\n#### MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。\n#### redux缓存机制 时间回溯适用于撤销操作 操作状态\n\n1. 安装\n~~~\nnpm install --save mobx mobx-react\n~~~\n2. 核心概念\n- state(状态) \n状态是驱动应用的数据。\n- observable(value) && @observable \nObservable 值可以是JS基本数据类型、引用类型、普通对象、类实例、数组和映射。其修饰的state会暴露出来供观察者使用。\n- observer(观察者)\n被observer修饰的组件，将会根据组件内使用到的被observable修饰的state的变化而自动重新渲染。\n- action(动作)\n只有在 actions 中，才可以修改 Mobx 中 state 的值。\naction-->state-->view\n- computed \n计算值(computed values)是可以根据现有的状态或其它计算值衍生出的值。(可以看成公式)\ngetter：获得计算得到的新state并返回。\nsetter： 不能用来直接改变计算属性的值，但是它们可以用来作\"逆向\"衍生。\n- autorun\n这通常是当你需要从反应式代码桥接到命令式代码的情况，例如打印日志、持久化或者更新UI的代码。\n- 如果你有一个函数应该自动运行，但不会产生一个新的值，请使用autorun。 其余情况都应该使用 computed。\n- reactions\nReactions 和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新 React 组件树以修补DOM、等等。 简而言之，reactions 在 响应式编程和命令式编程之间建立沟通的桥梁。\n\n~~~javascript\n// component\nimport {inject, observer} from \"mobx-react\";\n\n// 观察者 注入store添加到属性上\n@inject(\"store\") @observer\n\nthis.props.store.xxStore.num\nthis.props.store.xxStore.plus() // num+=1\nthis.props.store.xxStore.total\n\n// homeStore\n\n@observable num;\nconstrutor(){\n    this.name=''\n    this.items=[]\n}\n\n@computed get total() {\n    return this.items.length;\n }\n  \n@action plus=()=>{\n    this.num+=1\n}\n\nautorun((e)=>{})\n\nconst homeStore =new HomeStore()\nexport {homeStore}\n~~~\n\n~~~javascript\nswitch\nrouter render={(props)=><Item {...props}/>}\nrouter component={Index}\nreact-route-dom\nwithRouter\nLinking\n// Provider 传递stores\nPrivider store={stores}\ncreate-react-app react-scripts\n~~~\n基本就这两种方法:immutable/observable\nmobx: oop\nredux: 函数式\n\nssr:流模式、字符串\n\n[demo地址](https://github.com/cosyer/mobx-demo)\n\n","tags":["状态管理"],"categories":["JS"]},{"title":"主流浏览器的内核和渲染方式解读","url":"%2F%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%92%8C%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E8%A7%A3%E8%AF%BB.html","content":"\n## 浏览器内核\n- Trident:IE，360，搜狗\n\n- Gecko：firefox\n\n- webkit:safari，旧版chrome\n\n- presto：旧版opera\n\n- blink：新版chrome，新版opera\n\n## 浏览器的渲染方式\n\n1. 构建DOM树\n浏览器请求到html代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求。\n\n2. 构建CSSOM\ncss文件加载完成，开始构建CSSOM\n\n3. 生成渲染树（Render Tree）\nCSSOM构建结束后，和DOM一起生成Render Tree\n\n4. 布局（Layout）\n有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义以及他们的从属关系。开始布局，计算出各个节点在屏幕中的位置。\n\n5. Paint绘制\n布局之后，浏览器知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置。所以接下来按照算出来的规则，通过显卡，把内容画在屏幕上。","tags":["知识"],"categories":["知识"]},{"title":"flex布局","url":"%2Fflex.html","content":"\n芮 rui 四声\n\n浏览器前缀 -webkit/chrome、safari -moz/firefox -ms/ie -o/opera\n\n弹性伸缩flexbox布局 \n\n任何一个容器都可设为display:flex\n\n行内元素 display:inline-flex\n\nwebkit内核浏览器（Safari） display:-webkit-flex; display:flex\n\n设为flex布局以后，子元素的float、clear、vertical-align属性将失效。\n\n--- \n<!-- more -->\n## 容器的属性\n### flex-direction 决定主轴的方向\n\nflex-direction:row;  /*默认：从左到右*/\n\nflex-direction:row-reverse;  /*从右到左*/\n\nflex-direction:column;  /*从上到下*/\n\nflex-direction:column-reverse;  /*从下到上*/\n\n### flex-wrap:一条轴排列不下，如何换行\n\nflex-wrap:nowrap;  /*默认:不换行*/\n\nflex-wrap:wrap;  /*换行，第一行在上方*/\n\nflex-wrap:wrap-reverse;  /*换行，第一行在下方*/\n\n### flex-flow：上面两个的简写\nflex-flow:fiex-direction flex-wrap;  /*默认 row no-wrap*/\n\n### justify-content:主轴上的对齐方式\n\njustify-content:flex-start;  /*默认：左对齐*/\n\njustify-content:flex-end;  /*右对齐*/\n\njustify-content:center;  /*居中*/\n\njustify-content:space-between;  /*两端对齐，项目之间的间隔相同，边缘项目紧贴边框*/\n\njustify-content:space-around;  /*项目两侧的间隔相同，所以，项目之间的间隔比项目与边框的间隔大一倍*/\n\n### align-items:交叉轴上如何对齐\n\nalign-items:flex-start;  /*起点对齐*/\n\nalign-items:flex-end;  /*终点对齐*/\n\nalign-items:center;  /*中点对齐*/\n\nalign-items:baseline;  /*项目的第一行文字的基线对齐*/\n\nalign-items:stretch;  /*默认：项目未设高度或auto，占满整个容器高度*/\n\n### align-content：多根轴线的对齐方式，只有一根轴线时，不起作用。\n\naling-content:flex-start;  /*与交叉轴的起点对齐*/\n\naling-content:flex-end;  /*与交叉轴的终点对齐*/\n\naling-content:center;  /*与交叉轴的中点对齐*/\n\naling-content:space-between;  /*与交叉轴两端对齐，轴线之间的间隔平均分布。*/\n\naling-content:space-around;  /*每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍*/\n\naling-content:stretch;  /*默认：轴线占满整个交叉轴*/\n\n## 项目的属性\n\n### order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\norder:1;\n\norder:99;\n\norder:-1;   \n\n/*-1 1 99的顺序排列*/\n\n### flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n\nflex-grow: <number>; /* default 0 */\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。\n\n如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### flex-shrink:定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\nflex-shrink: <number>; /* default 1 */\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。\n\n如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### flex-basis:定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\nflex-basis: <length> | auto; /* default auto */\n\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n### flex:是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\nflex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n\n### align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\nalign-self: auto | flex-start | flex-end | center | baseline | stretch;\n\n## react-native使用flex布局注意点\n\n- 样式对象需要驼峰式写法\n- React Native中的Flexbox的工作原理和web上的CSS基本一致，当然也存在少许差异。\n\n首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。\n\n## 扩展阅读：\n[w3cplus指南](http://www.w3cplus.com/css3/a-guide-to-flexbox-new.html)\n[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n[思维图](http://blog.csdn.net/magneto7/article/details/70854472)","tags":["布局"],"categories":["CSS"]},{"title":"前端工程化","url":"%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.html","content":"\n前端的工程化、模块化、组件化。\n\n1. 广义的前端工程化\n\n前端工程是软件工程的一个子类，指的是将软件工程的方法和原理运用在前端开发中, 目的是实现高效开发，有效协同，质量可控。\n\n2. 狭义的前端工程化\n\n前端工程是指将开发阶段代码转变成生产环境的代码的一系列步骤。主要包括构建，分支管理，自动化测试，部署等。\n\n前端工程化的具体内容\n\n1. 代码规范：保证团队所有成员以同样的规范开发代码。\n\n2. 分支管理：不同的开发人员开发不同的功能或组件，按照统一的流程合并到主干。\n\n3. 模块管理：一方面，团队引用的模块应该是规范的；另一方面，必须保证这些模块可以正确的加入到最终编译好的包文件中。\n\n4. 自动化测试：为了保证和并进主干的代码达到质量标准，必须有测试，而且测试应该是自动化的，可以回归的。\n\n5. 构建：主干更新以后，自动将代码编译为最终的目标格式，并且准备好各种静态资源，\n\n6. 部署：将构建好的代码部署到生产环境。","tags":["知识"],"categories":["知识"]},{"title":"服务器推送技术","url":"%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E6%8A%80%E6%9C%AF.html","content":"\n在做前端页面渲染时，经常会遇到有的组件需要跟随数据的变化而实时的变化，例如：一个线上报名系统，总人数有一定限制，所以要实时的展现已经报名的人数，应该怎么实现呢？最基本有如下3种方案：\n\n- Ajax轮询\n- Ajax长轮询(comet)\n- websocket长连接\n\n--- \n<!-- more -->\n\n## Ajax轮询\n\n### 优点\n实现简单，利用XHR,通过setInterval定时向后端发送请求。\n\n### 缺点\n会造成数据在一小段时间内不同步和大量无效的请求，增加后端处理压力.\n\n```javascript\nsetInterval(function() {\n    $.ajax({\n        url: 'https://www.baidu.com/',\n        success: function() {\n            //success code\n        }\n    });\n}, 3000);\n```\n\n## Ajax长轮询(comet)\n\n在Ajax轮询的基础上做的一点改进，在后端数据没有更新的时候不再返回空响应，而且后端一直保存连接，直到后端有数据变化，则相应请求并且关闭连接，前端收到数据，马上再次向后端发起请求，并处理刚刚收到的数据。\n\n通常的做法是，在服务器的程序中加入一个死循环，在循环中监测数据的变动。当发现新数据时，立即将其输出给浏览器并断开连接，浏览器在收到数据后，再次发起请求以进入下一个周期。\n\n```javascript\nfunction async() {\n    $.ajax({\n        url: 'http://api.3g.qq.com',\n        success: function() {\n            async();\n            //success code\n        }\n    });\n}\n```\n\n## websocket长连接\n\nWebSocket是html5出来的东西(协议)，也就是说和http协议没关系，但http是不支持长链接的，WebSocket其实是一个新协议，跟http协议基本没有关系，只是为了兼容现有浏览器的握手规范而已。\n\nWebSocket通信协议包含两个部分，一是开放性HTTP握手连接协商连接参数，二是二进制消息分帧机制（接收消息的文本和二进制数据传输）。它是一个独立完善的协议，也可以在浏览器之外实现。\n\n### HTTP升级协商\n\nWebSocket协议提供了很多强大的特性：基于消息的通信、自定义的二进制分帧层、子协议协商、可选的协议扩展，等等。即在交换数据之前，客户端必须与服务器协商适当的参数以建立连接。\n\n利用HTTP完成握手有几个好处。首先，让WebSockets与现有HTTP基础设施兼容：WebSocket服务器可以运行在80和443 端口上，这通常是对客户端唯一开放的端口。其次，让我们可以重用并扩展HTTP的Upgrade流，为其添加自定义的WebSocket首部，以完成协商。\n\n### 请求头信息\n\nConnection:Upgrade Sec-WebSocket-Key:eDCPPyPQZq7PiwRcx8SPog== Sec-WebSocket-Version:13 Upgrade:websocket \n\n### 响应头信息\n\nHTTP/1.1 101 Switching Protocols Connection:Upgrade Sec-WebSocket-Accept:/ZVAP3n6XuqDUoDp416PYUO+ZJc= Upgrade:websocket\n\n\n最后，前述握手完成后，如果握手成功，该连接就可以用作双向通信信道交换WebSocket消息。到此，客户端与服务器之间不会再发生HTTP通信，一切由WebSocket 协议接管。\n\n### 具体使用方法，本文采用node.js中的Socket.IO来进行说明：\n\n1. 服务端创建socket.io的实例\n\n```javascript\nvar app = require('express')(); \nvar http = require('http').Server(app); \nvar io = require('socket.io')(http);//创建实例 \n\napp.get('/', function(req, res){ res.sendfile('index.html'); });\n\nio.on('connection', function(socket){ \n    console.log('a user connected'); \n});// 监听前端连接 \n\nhttp.listen(3000, function(){ console.log('listening on *:3000'); });  \n```\n\n2. 数据传输\n\n```javascript\n// 前端客户端向后端发送数据：\nsocket.emit('chat message', $('#m').val()); \n\n// 后端接收数据：\n\nio.on('connection', function(socket){ socket.on('chat message', function(msg){ \n    console.log('message: ' + msg); }); \n}); \n\n// 后端向前端发送数据：\n\nio.on('connection', function(socket){ socket.on('chat message', function(msg){ \n    io.emit('chat message', msg); }); }); \n\n// 前端接收数据：\n\nsocket.on('chat message', function(msg){ console.log(msg); });\n```","tags":["知识"],"categories":["知识"]},{"title":"函数的防抖和节流","url":"%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html","content":"\n场景：事件频繁被触发，频繁执行DOM操作、资源加载等重复行为，导致UI停顿甚至浏览器崩溃。如 input 实时搜索、scrollview 滚动更新。\n\n函数防抖和节流用于限制函数的执行。是优化高频率执行js代码的一种手段。\n\n---\n<!--more-->\n\n## 函数防抖\n\n函数防抖就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。\n\n```javascript\nvar debounce = function(idle,action){\n  var last;\n  return function(){\n    var ctx = this,\n        args = arguments;\n    clearTimeout(last);\n    last = setTimeout(function(){\n      action.apply(ctx,args);\n    },idle);\n  }\n}\n\n// 返回函数连续调用时，空闲时间必须大于或等于idle，action才会执行。\n```\n\n### 实际例子\n\n当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n```javascript\nfunction debounce(fn, wait) {\n    var timeout = null;\n    return function() {\n        if(timeout !== null) \n                clearTimeout(timeout);\n        timeout = setTimeout(fn, wait);\n    }\n}\n// 处理函数\nfunction handle() {\n    console.log(Math.random()); \n}\n// 滚动事件\nwindow.addEventListener('scroll', debounce(handle, 1000));\n```\n\n当持续触发scroll事件时，事件处理函数handle只在停止滚动1000毫秒之后才会调用一次，也就是说在持续触发scroll事件的过程中，事件处理函数handle一直没有执行。\n\n函数防抖适用于连续调用函数，但只在延时后调用一次。定时器存在则销毁，第一次一定会创建并调用函数。\n\n## 函数节流\n\n每隔某个时间去执行某函数，避免函数的过多执行。\n\n如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是说会先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。\n\n```javascript\nvar throttle = function(delay,action){\n  var last ;\n  return function(){\n    var cur = +new Date();  //返回毫秒数\n    if(cur - last > = delay){\n      action.apply(this,arguments);\n      last = cur;\n    }\n  }\n}\n```\n\n### 实际例子\n函数节流主要有两种实现方法：时间戳和定时器。\n\n```javascript\nvar throttle = function(func, delay) {\n    var prev = Date.now();\n    return function() {\n        var context = this;\n        var args = arguments;\n        var now = Date.now();\n        if (now - prev >= delay) {\n            func.apply(context, args);\n            prev = Date.now();\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n```javascript\nvar throttle = function(func, delay) {\n    var timer = null;\n    return function() {\n        var context = this;\n        var args = arguments;\n        if (!timer) {\n            timer = setTimeout(function() {\n                func.apply(context, args);\n                timer = null;\n            }, delay);\n        }\n    }\n}\nfunction handle() {\n    console.log(Math.random());\n}\nwindow.addEventListener('scroll', throttle(handle, 1000));\n```\n\n函数节流适用于间接性调用函数。定时器不存在则创建调用函数，定时销毁。","tags":["知识"],"categories":["JS"]},{"title":"在去上海前的一些想法","url":"%2Fbeforehz.html","content":"\n怯懦的我终于和领导提出了离职，从8月11号入职以来，jenkins打包管理、bugatti自动化部署等等惊艳到了在上家公司还是用手动发包javac的我，学到了更正规的软件开发流程体系和产品线的迭代，KA项目的定制化。从1月开始一直用RN做相关的微应用，期间虽然也做过小程序、mui的H5、antd的中后台系统，但大多数时间还是用RN写业务应用。经过几个应用的锻炼、改造，已经封出了一些较能应付业务需求的组件。复杂的集成调用框架那边都做了，其他部分做起来没有什么技术含量了。我知道已经毕业1年的我该做出些改变了。\n\n---\n<!-- more -->\n\n面对领导们的挽留，我也只能笑着婉拒。我想在大前端的道路上迈的更远，本来就没打算活很长的时间，在短暂还算充满干劲的人生中多做点自己感到快乐的事。说来也是好笑，来了南京这么久也没出去逛过，只对公司和公寓周边熟悉一些，真是符合我的作风啊o(*￣︶￣*)o。\n\n依稀还记得刚追被去南京发展是我的内心也是非常慌乱的，陌生的城市、环境和人不停地在劝退着我，投递的简历有了回复，我不断预演这面试的场景，竟可能多的将自己的优势展现出来。将近2个小时的长途客车旅途，我到了南京南站，摸着黑上了地铁到了软件大道。9点半又误打误撞地摸到了目的地，不好意思随便进入，随即打电话确认（有人来引下路多好）。等待的过程忐忑不安，人生第一次经历三轮面试，和技术聊真的开心啊O(∩_∩)O哈哈~面试完后立即又买了车票回了家汗~~\n\n自从工作以来就没请过假，没迟过到。自尊心强烈的我很在意别人对我的看法。去年买了房，房贷没什么压力。房子让父母住，我在工作的地方租房住，这是我的规划。不想去相亲，不想被各种绑架。\n\n作为熟练的api caller，高中之前的学习是多么快乐啊，是的，做题(除了语文)学习很快乐。新思维解题都是带来很多不同的思路，课堂上有选择地去学习自己喜欢的事物。虽然被老师骂的惨，但暗地里还是支持的。没压力地考上了重点高中，进城上高中了，才感觉到差距是巨大的。城里的小孩终究是不一样的，读过的书也好，培养的兴趣爱好也好，上过的兴趣班都远超过你。学的东西都是套路化的解题，枯燥乏味。渲染了xx的气氛，表达了xx什么的情感。各种烦心、倒霉的事也接踵而来，小小的幸福被扼杀。好奇心和脖子的扭，知道的越多，越觉得绝望。见过的所谓的'真实'，都是为了利益。永远不要去试探人性。现在看来都只是可笑的借口罢了，压力抑郁到自残。人与人之间最公平的就是时间了，每个人一天都是24小时，谁也不多，谁也不少。特别佩服那些活的独立、认真的人们。他们年轻、强大、充满个性，差距真的差到天差地别，是我前进的目标和憧憬的对象。我不会再迷茫了，毕竟~~~\n\n{% centerquote %} \n不去做的话永远也做不到。\n{% endcenterquote %} \n\ns(优势):互联网氛围、大牛、技术提升\nw(劣势):房租、10m2的地下室、消费、离家远、通勤时间、异地恋\no(机会):更高的待遇天花板、未来发展\nt(威胁):陌生的城市、重新整理技术体系、面试\n\n---\n\ns:门面做的不错、近10k（南京1年经验）、双休（有时间做自己项目学习、接外包）、雨花台区（离老婆近）\nw:不融资、官网low、没核心产品（说在招人明年做、说呆1年能到13-14 0^0？？？）、着急招人（目前人数较少？）、外包园、1-3年9-12k？？？常见都是10-15k。\n\n南京这边的工资待遇真的很低，感觉像命运一样，留了最后一张简历，偏偏扇贝又在这个时候叫我去面试。面试居然还提供饮品。这边催着入职，前面的还没消息，说到底还是自己太懦弱了，如果有联系或者果断点，就不会有这样的情况出现了。不去试一试怎么会知道呢，担当起自己的responsibility。\n\n2周前投的现在认识才提醒面试是不是太迟了；虽然很想去，技术氛围浓厚。大公司就会比较选人，不会立即给你答复。可这边的工作急着让你给答复。唉就这样形成了现在的处境。努力沉淀一点再跳槽到新公司吧！！！\n\n半杯水，懂了么。自身的强大很重要，more experience 成年人 卧薪尝胆\n\n办公环境、补贴、五险一金、工资、福利待遇、氛围、大公司镀金、自身的强大。选择比努力更重要，实力和机遇。看看别人的评分98，6周年dlun这种自研的能跟着一起成长。大格局，这样会越来越迷茫找不到自己的定位，半杯水的思想。真正的效率。","tags":["杂谈"],"categories":["杂谈"]},{"title":"常见排序的JS实现","url":"%2Fsort.html","content":"\nhttps://github.com/damonare/Sorts 这位大兄弟♂总结的很好，快去看看吧！\n---\n<!-- more -->\n\n```javascript\n/**\n * 常见排序的JS实现\n */\n\nvar Sort = {\n    //快速排序(递归)\n    quick: function(arr) {\n\n        var nLength = arr.length,\n            pivotIndex = Math.floor(nLength / 2),\n            pivot = arr.splice(pivotIndex, 1)[0],\n            left = [],\n            right = [];\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] < pivot) {\n                left.push(arr[i]);\n            } else {\n                right.push(arr[i]);\n            }\n        }\n\n        return arguments.callee(left).concat([pivot], arguments.callee(right));\n    },\n\n    //冒泡排序\n    bubble: function(arr) {\n        var nLength = arr.length;\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var i = nLength - 1; i > 0; --i) {\n            for (var j = 0; j < i; ++j) {\n                if (arr[j] > arr[j + 1]) {\n                    var temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n        return arr;\n    },\n\n    //选择排序\n    selection: function(arr) {\n        var nLength = arr.length;\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var i = 0; i < nLength; i++) {\n            var index = i;\n            for (var j = i + 1; j < nLength; j++) {\n                if (arr[j] < arr[index]) {\n                    index = j;\n                }\n            }\n\n            if (i !== index) {\n                var temp = arr[i];\n                arr[i] = arr[index];\n                arr[index] = temp;\n            }\n        }\n\n        return arr;\n    },\n\n    //插入排序\n    insertion: function(arr) {\n        var nLength = arr.length;\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var i = 1; i < nLength; ++i) {\n            var j = i,\n                value = arr[i];\n\n            while (j > 0 && arr[j - 1] > value) {\n                arr[j] = arr[j - 1];\n                --j;\n            }\n\n            if (j !== i) {\n                arr[j] = value;\n            }\n        }\n\n        return arr;\n    },\n\n    //希尔排序\n    shell: function(arr) {\n        var nLength = arr.length;\n\n        if (nLength < 2) {\n            return arr;\n        }\n\n        for (var step = nLength >> 1; step > 0; step >>= 1) {\n            for (var i = 0; i < step; ++i) {\n                for (var j = i + step; j < nLength; j += step) {\n                    var k = j,\n                        value = arr[j];\n                    while (k >= step && arr[k - step] > value) {\n                        arr[k] = arr[k - step];\n                        k -= step;\n                    }\n                    arr[k] = value;\n                }\n            }\n        }\n        return arr;\n    }\n};\n```","tags":["排序"],"categories":["JS"]},{"title":"详解 Cookie、 LocalStorage 与 SessionStorage","url":"%2Fstorage.html","content":"\n## Cookie\n\nCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。\n\n## localStorage\n\nlocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。\n\n缺点：\n1. 存储容量限制，大部分浏览器应该最多5M。\n2. 仅支持字符串，如果是存对象还需要将使用JSON.stringify和JSON.parse方法互相转换，有些啰嗦。\n3. 读取都是同步的。大多数情况下，还挺好使的。但如果存储数据比较大，例如一张重要图片base64格式存储了，读取可能会有可感知的延迟时间。\n\n## sessionStorage\n\nsessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。\n\n--- \n<!-- more -->\n\n## 三者的异同\n\n|特性|Cookie|localstorage|sessionstorage|\n|:---:|:---:|:---:|\n|生命周期|一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效|除非被清除，否则永久保存|仅在当前会话下有效，关闭页面或浏览器后被清除|\n|数据大小|4K|5M|5M|\n|与服务器端通信|每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题|仅在客户端（即浏览器）中保存，不参与和服务器的通信|同上|\n|易用性|需要自己封装，原生的Cookie接口不友好|可以封装来对Object和Array有更好的支持|同上|\n\n## 安全性的考虑\n\n需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。\n\n## cookie用法\nJavaScript 可以使用 document.cookie 属性来创建 、读取、及删除 cookie。\ndocument.cookie=\"username=John Doe\";\n\n您还可以为 cookie 添加一个过期时间（以 UTC 或 GMT 时间）。默认情况下，cookie 在浏览器关闭时删除：\ndocument.cookie=\"username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT\";\n\n您可以使用 path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。\ndocument.cookie=\"username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 GMT; path=/\";\n\n```javascript\n// 设置cookie\nfunction setCookie(cname,cvalue,exdays)\n{\n  var d = new Date();\n  d.setTime(d.getTime()+(exdays*24*60*60*1000));\n  var expires = \"expires=\"+d.toGMTString();\n  document.cookie = cname + \"=\" + cvalue + \"; \" + expires;\n}\n\nfunction getCookie(name) {\n  var arr = document.cookie.replace(/\\s/g, \"\").split(\";\");\n  for (var i = 0; i < arr.length; i++) {\n    var tempArr = arr[i].split(\"=\");\n    if (tempArr[0] === name) {\n      return decodeURIComponent(tempArr[1]);\n    }\n  }\n  return \"\";\n}\n\n// 获取指定cookie\nfunction getCookie2(cname)\n{\n  var name = cname + \"=\";\n  var ca = document.cookie.split(';');\n  for(var i=0; i<ca.length; i++) \n  {\n    var c = ca[i].trim();\n    if (c.indexOf(name)==0) return c.substring(name.length,c.length);\n  }\n  return \"\";\n}\n\nfunction getCookie3(name) {\n  let v = window.document.cookie.match(\"(^|;) ?\" + name + \"=([^;]*)(;|$)\");\n  return v ? v[2] : null;\n}\n\n// 检测cookie函数\nfunction checkCookie()\n{\n  var username=getCookie(\"username\");\n  if (username!=\"\")\n  {\n    alert(\"Welcome again \" + username);\n  }\n  else \n  {\n    username = prompt(\"Please enter your name:\",\"\");\n    if (username!=\"\" && username!=null)\n    {\n      setCookie(\"username\",username,365);\n    }\n  }\n}\n```\n## localStorage和sessionStorage用法\nlocalStorage和sessionStorage类似(也可以像普通对象一样用点(.)操作符，及[]的方式进行数据存储)\n```javascript\n    static setStorage(name, data) {\n        if (typeof data === 'object') {\n            window.localStorage.setItem(name, JSON.stringify(data))\n        } else if (typeof data === 'number' || typeof data === 'string' || typeof data === 'boolean') {\n            window.localStorage.setItem(name, data)\n        } else {\n            alert('该类型不能用于本地存储~')\n        }\n    }\n\n    /**\n     * 获取localstorage\n     */\n    static getStorage(name) {\n        let data = window.localStorage.getItem(name)\n        if (data) {\n            return JSON.parse(data)\n        } else {\n            return ''\n        }\n    }\n\n    /**\n     * 删除localstorage\n     */\n    static removeStorage(name) {\n        window.localStorage.removeItem(name)\n    }\n\n    /**\n     * 清空localstorage\n     */\n    static clearStorage() {\n        window.localStorage.clear()\n    }\n```\n\n## 规避localStorage缺点---localforage\n\nlocalforage的逻辑是这样的：优先使用IndexedDB存储数据，如果浏览器不支持，使用WebSQL，浏览器再不支持，使用localStorage。\n\nlocalforage的API名称和localStorage一样，但是，在同步还是异步上却不同，localforage是异步执行的，用法示意如下。\n```javascript\nlocalforage.getItem('key', function (err, value) {\n    // 如果err不是null，则出错。否则value就是我们想要的值\n});\n```","tags":["存储"],"categories":["JS"]},{"title":"面试题整理归纳","url":"%2Finterview.html","content":"字符串扩展的方法\n- includes()：返回布尔值，表示是否找到了参数字符串。数组也可以 a[1]=1 且能判断undefined\n```javascript\nvar a=[1,2,3]\na[4]=5 // [1, 2, 3, undefined × 1, 5] empty\n// a[3]=undefined [1, 2, 3, undefined, 5] \n\na.indexOf(undefined) // -1\na.includes(undefined) // true \n```\n- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。\n```js\n// polyfill\nif (String.prototype.startsWith) {\n  String.prototype.startsWith = function (search, index) {\n    return this.substr((!index || index < 0) ? 0 : index, search.length) === search;\n  }\n}\n```\n- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。\nstr | index\n- repeat()：返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整(不四舍五入)。参数是负数或者Infinity，会报错。0/Nan返回空字符串,参数是字符串，则会先转换成数字，不传则为空字符串。\n- padStart()：头部补全。\n- padEnd()：尾部补全\n~~~\n'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n~~~\n如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。默认使用空格\n\n---\n\n<!-- more -->\n\n- 模板字符串（template string）是增强版的字符串，用反引号\\`标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\\`${表达式、变量}\\`\n- commonjs 服务器端 amd 浏览器端\n- const 必须赋值定义 let 在同一作用于无法重复命名 无法变量提升\n- split(字符串或者正则,设置长度) 字符串=>数组\n- substr(开始的索引//splice可以为负数-1则为字符串最后一个字符,length字符数)方法不同的是,substring(开始索引，结束索引+1)负的参数有区别\n只有单参数时到字符串结尾\nString exd=filePath.subString(filePath.lastIndexOf(\".\")+1,filePath.length)\n\n1. 声明函数作用提升?声明变量和声明函数的提升有什么区别?\n\n(1) 变量声明提升：变量申明在进入执行上下文就完成了。\n只要变量在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；\n\n(2) 函数声明提升：执行代码之前会先读取函数声明，意味着可以把函数申明放在调用它的语句后面。\n只要函数在代码中进行了声明，无论它在哪个位置上进行声明， js引擎都会将它的声明放在范围作用域的顶部；\n\n(3) 变量or函数声明：函数声明会覆盖变量声明，但不会覆盖变量赋值。\n同一个名称标识a，即有变量声明var a，又有函数声明function a() {}，不管二者声明的顺序，函数声明会覆盖变量声明，也就是说，此时a的值是声明的函数function a() {}。注意：如果在变量声明的同时初始化a，或是之后对a进行赋值，此时a的值变量的值。\n```javascript\neg: var a; var c = 1; a = 1; function a() { return true; } console.log(a);\n```\n\n2. 如何判断数据类型？\ntypeof返回的类型都是字符串形式，可以判断function的类型；在判断除Object类型的对象时比较方便。\n判断已知对象类型的方法： instanceof，后面一定要是对象类型，并且大小写不能错，该方法适合一些条件选择或分支。\n```javascript\ntypeof null // object null instanceof Object // false\n```\n\n3. 异步编程？\n- 方法1：回调函数，优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。\n\n- 方法2：事件监听，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n- 方法3：发布/订阅，性质与“事件监听”类似，但是明显优于后者。\n\n- 方法4：Promises对象，是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。\n\n4. 事件流？事件捕获？事件冒泡？\n    事件流：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。\n\n    IE中的事件流叫事件冒泡；事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。对于html来说，就是当一个元素产生了一个事件，它会把这个事件传递给它的父元素，父元素接收到了之后，还要继续传递给它的上一级元素，就这样一直传播到document对象（亲测现在的浏览器到window对象，只有IE8及以下不这样。\n\n    事件捕获是不太具体的元素应该更早接受到事件，而最具体的节点应该最后接收到事件。他们的用意是在事件到达目标之前就捕获它；也就是跟冒泡的过程正好相反，以html的click事件为例，document对象（DOM级规范要求从document开始传播，但是现在的浏览器是从window对象开始的）最先接收到click事件的然后事件沿着DOM树依次向下传播，一直传播到事件的实际目标；\n    ```html\n    <nav id=\"root_b\">\n      <ul id=\"first_b\">\n        <li id=\"second_b\"><a id=\"target_b\" href=\"#\">冒泡</a></li>\n      </ul>\n    </nav>\n    <nav id=\"root_c\">\n      <ul id=\"first_c\">\n        <li id=\"second_c\"><a id=\"target_c\" href=\"#\">捕获</a></li>\n      </ul>\n    </nav>\n    ```\n    ```js\n    /**\n    * listen\n    * @param {string[]} ids \n    * @param {boolean} isCatch \n    */\n    const listen = (ids, isCatch) => ids.forEach(id => document.getElementById(id).addEventListener('click', () => alert(id), isCatch))\n\n    // BubbleEvent\n    listen(['root_b', 'first_b', 'second_b', 'target_b'], false)\n\n    // CatchEvent\n    listen(['root_c', 'first_c', 'second_c', 'target_c'], true)\n    ```\n\n5. 如何添加一个dom对象到body中?innerHTML、document.write和innerText区别?\n    body.appendChild(dom元素)；  \n    innerHTML:从对象的起始位置到终止位置的全部内容,包括Html标签。\n    innerText:从起始位置到终止位置的内容, 但它去除Html标签 \n    document.write只能重绘整个页面\n    window.clearInterval()\n    window.clearTimeout()\n\n6. 简述ajax流程  \n1)客户端产生触发js的事件  \n2)创建XMLHttpRequest对象  \n```javascript \nvar client=null\n  if(window.XMLHttpRequest){\n       client = new XMLHttpRequest();\n  }else{\n        client = new ActiveXObject(\"Microsoft.XMLHTTP\");\n  }\n```\n3)对XMLHttpRequest进行配置 \n```javascript   \n  client.open(\"GET\", url);\n  client.onreadystatechange = function(e) {\n      if (request.readyState !== 4) { // client状态\n        return;\n      }\n      if (request.status === 200) { // HTTP状态码\n        console.log('success', request.responseText);\n      } else {\n        console.warn('error');\n      }\n  }; // 指定回调函数\n  client.responseType = \"json\";\n  client.setRequestHeader(\"Accept\", \"application/json;\");\n  client.setRequestHeader(\"Content-Type\", \"application/json;charset=utf-8\");\n```\n4)通过AJAX引擎发送异步请求 \n```javascript\n  client.send()\n```\n5)服务器端接收请求并且处理请求，返回html或者xml内容  \n6)XML调用一个callback()处理响应回来的内容  \n7)使用JS和DOM实现局部刷新\n\n7. 自执行函数？用于什么场景？好处？  \n    1、声明一个匿名函数  \n    2、马上调用这个匿名函数。  \n    作用：创建一个独立的作用域。  \n\n    好处：防止变量弥散到全局，以免各种js库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理。\n\n    场景：一般用于框架、插件等场景，设计私有变量和方法，封闭私有作用域。\n\n### 立即执行函数表达式(IIFE)\n#### 使用匿名函数表达式\n```javascript\nvar a = 2;\n(function IIFE(){\n\tvar a = 3;\n\tconsole.log(a);//3\n})();\nconsole.log(a);//2\n```\n#### 当作函数调用并传递参数进去\n```javascript\nvar a = 2;\n(function IIFE(global){\n\tvar a = 3;\n\tconsole.log(a);//3\n\tconsole.log(global.a);//2\n})(window);\nconsole.log(a);//2\n```\n#### 解决undefined标识符默认值被错误覆盖\n```javascript\nundefined = true;\n(function IIFE(){\n\tvar a ;\n\tif(a === undefined){\n\t\tconsole.log('Undefined is safe here!');\n\t}\n})();\n```\n#### 倒置代码运行顺序\n```javascript\nvar a = 2;\n(function IIFE(def){\n\tdef(window);\n})(function def(global){\n\tvar a = 3;\n\tconsole.log(a);//3\n\tconsole.log(global.a);//2\n});\n```\n\n```javascript\nvar i = 1;\nvar IFun = (function(){\n\tvar i = 1;\n\tconsole.log(i);\n\treturn function(){\n\t\ti++;\n\t\tconsole.log(i);\n}\n})();\nIFun();\nIFun();\n最终输出的结果为1，2，3，很多会下意识的觉得结果会有4个值，但是运用了return 返回值以及自执行函数将函数返回给IFun变量，使得在第一次操作过程后，将返回函数直接赋给IFun。\n```\n\n8. 回调函数？（传递地址，由非实现方调用）  \n回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。\n\n9. 什么是闭包?堆栈溢出有什么区别？ 内存泄漏? 那些操作会造成内存泄漏？怎么样防止内存泄漏？impression  \n    闭包：就是能够读取其他函数内部变量的函数。一般是指内层函数。(子函数在外调用，子函数所在的父函数的作用域不会被释放。) \n\n    堆栈溢出：就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据。经常会在递归中发生。\n\n    内存泄漏是指：用动态存储分配函数内存空间，在使用完毕后未释放，导致一直占据该内存单元。直到程序结束。指任何对象在您不再拥有或需要它之后仍然存在。\n\n    造成内存泄漏：\n    setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n    闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n    防止内存泄露：  \n    1、不要动态绑定事件；      \n    2、不要在动态添加，或者会被动态移除的dom上绑事件，用事件冒泡在父容器监听事件；  \n    3、如果要违反上面的原则，必须提供destroy方法，保证移除dom后事件也被移除，这点可以参考Backbone的源代码，做的比较好；  \n    4、单例化，少创建dom，少绑事件。\n\n原因：\n- 全局变量\n- 闭包\n- dom清空，事件未清除\n- 子元素存在引用\n- 计时器未删除\n\n10. html和xhtml有什么区别?\n    HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的标记语言。\n\n    1.XHTML 元素必须被正确地嵌套。\n\n    2.XHTML 元素必须被关闭。\n\n    3.标签名必须用小写字母。\n\n    4.空标签也必须被关闭。\n\n    5.XHTML 文档必须拥有根元素。\n\n11. 什么是构造函数？与普通函数有什么区别?\n\n    构造函数：是一种特殊的方法(函数、对象)、主要用来创建对象时初始化对象，总与new运算符一起使用，创建对象的语句中构造函数的函数名必须与类名完全相同。\n\n    与普通函数相比只能由new关键字调用，构造函数是类的标识。\n\n12. 通过new创建一个对象的时候，函数内部有哪些改变？\n    ```javascript\n    function Person(){}\n    Person.prototype.friend = [];\n    Person.prototype.age = 18;\n     var a = new Person();\n     a.friend[0] = '方涛'; // a.friend=['123'] 指向新对象 b.friend // []\n     a.age = 18;\n     var b = new Person();\n     b.friend // ['方涛'] \n     b.age   // 18\n    ```\n    >1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。   \n    >2、属性和方法被加入到 this 引用的对象中。  \n    >3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n\n`new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。`\n\n13. 事件委托的好处都有啥？说对了都给它=3=\n- 利用冒泡的原理，把事件加到父级上，触发执行效果  \n\n- 好处：新添加的元素还会有之前的事件；提高性能。\n\n14. 节点类型?判断当前节点类型?\n- 元素节点 \n- 属性节点 \n- 文本节点 \n- 注释节点 \n- 文档节点\n\n通过nodeObject.nodeType判断节点类型：其中，nodeObject 为DOM节点（节点对象）。该属性返回以数字表示的节点类型，例如，元素节点返回 1，属性节点返回 2 。\n\n15. 数组合并的方法？\n```javascript\n// 四种方法。\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\narr1 = arr1.concat(arr2);\nconsole.log(arr1); \n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\nArray.prototype.push.apply(arr1,arr2);\nconsole.log(arr1);\n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\nfor (var i=0; i < arr2.length; i++) {\narr1.push( arr2[i] );\n}\nconsole.log(arr1); \n\nvar arr1=[1,2,3];\nvar arr2=[4,5,6];\n\narr1.push(...arr2)\n```\n\n16. jquery和zepto有什么区别?\n- 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。\n\n- Dom操作的区别：添加id时jQuery不会生效而Zepto会生效。\n\n- zepto主要用在移动设备上，只支持较新的浏览器，好处是代码量比较小，性能也较好。\njquery主要是兼容性好，可以跑在各种pc，移动上，好处是兼容各种浏览器，缺点是代码量大，同时考虑兼容，性能也不够好。\n\n17. $(function(){})和window.onload 和 $(document).ready(function(){})\n\n- window.onload:用于当页面的所有元素，包括外部引用文件，图片等都加载完毕时运行函数内的函数。load方法只能执行一次，如果在js文件里写了多个，只能执行最后一个。\n\n- $(document).ready(function(){})和$(function(){})都是用于当页面的标准DOM元素被解析成DOM树后就执行内部函数。这个函数是可以在js文件里多次编写的，对于多人共同编写的js就有很大的优势，因为所有行为函数都会执行到。而且$(document).ready()函数在HMTL结构加载完后就可以执行，不需要等大型文件加载或者不存在的连接等耗时工作完成才执行，效率高。\n\n18. 简述下 this 和定义属性和方法的时候有什么区别?Prototype？\n\n- this表示当前对象，如果在全局作用范围内使用this，则指代当前页面对象window； 如果在函数中使用this，则this指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用apply和call两个全局方法来改变函数中this的具体指向。\n\n- prototype本质上还是一个JavaScript对象。 并且每个函数都有一个默认的prototype属性。\n\n- 在prototype上定义的属性方法为所有实例共享，所有实例皆引用到同一个对象，单一实例对原型上的属性进行修改，也会影响到所有其他实例。\n\n19. ajax和jsonp的区别？\n- 相同点：都是请求一个url\n- 不同点：ajax的核心是通过XMLHttpRequest获取内容，jsonp只能get请求\n- jsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。\n\n20. 常见的http协议状态码？\n\n```javascript\n200：请求成功\n201：请求成功并且服务器创建了新的资源\n302：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。\n304：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。\n400：服务器不理解请求的语法。\n404：请求的资源（网页等）不存在\n403：该状态表示服务器理解了本次请求但是拒绝执行该任务\n405：方法不被允许\n500：内部服务器错误\n```\n\n21. sessionStorage和localstroage与cookie之间有什么关联, cookie最大存放多少字节？\n```javascript\n三者共同点：都是保存在浏览器端，且同源的。\n\n区别:\n1、cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n\n2、存储大小限制也不同，cookie数据不能超过4k，sessionStorage和localStorage 但比cookie大得多，可以达到5M\n\n3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n\n4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面(即数据不共享)；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的( 即数据共享 )。\n```\n\n22. ajax的get与post区别？\n- get和post都是数据提交的方式。\n- get的数据是通过网址问号后边拼接的字符串进行传递的。post是通过一个HTTP包体进行传递数据的。\n- get的传输量是有限制的，post是没有限制的。(实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度)\n- get的安全性可能没有post高，所以我们一般用get来获取数据，post一般用来修改数据。\n- get就是将货品放在车顶，post放在车内\n\n23. GC机制？为什么闭包不会被回收变量和函数？\n- GC：垃圾回收机制;  \n- 外部变量没释放仍然保持着引用，所以指向的大函数内的小函数也释放不了。\n引用类型是在没有引用之后, 通过 v8 的 GC 自动回收, 值类型如果是处于闭包的情况下, 要等闭包没有引用才会被 GC 回收, 非闭包的情况下等待 v8 的新生代 (new space) 切换的时候回收。\n\n24. 面向对象？\n```javascript\n万物皆对象，把一个对象抽象成类，具体上就是把一个对象的静态特征和动态特征抽象成属性（属性名、属性值）和方法，也就是把一类事物的算法和数据结构封装在一个类之中，程序就是多个对象和互相之间的通信组成的。\n\n面向对象具有封装性，继承性，多态性。\n封装：隐蔽了对象内部不需要暴露的细节，使得内部细节的变动跟外界脱离，只依靠接口进行通信。封装性降低了编程的复杂性。通过继承，使得新建一个类变得容易，一个类从派生类那里获得其非私有的方法和公用属性的繁琐工作交给了编译器。而继承和实现接口和运行时的类型绑定机制所产生的多态，使得不同的类所产生的对象能够对相同的消息作出不同的反应，极大地提高了代码的通用性。\n\n总之，面向对象的特性提高了大型程序的重用性和可维护性。\n```\n\n25. jsonp的原理和缺点？\n- 原理：使用script标签实现跨域访问，可在url中指定回调函数，获取JSON数据并在指定的回调函数中执行jquery实现jsop。\n- 缺点：只支持GET方式的jsonp实现，是一种脚本注入行为存在一定的安全隐患。如果返回的数据格式有问题或者返回失败了，并不会报错。\n\n26. call和apply两者的区别和好处？\n- call和apply都是改变this指向的方法，区别在于call可以写多个参数，而apply只能写两个参数，第二个参数是一个数组，用于存放要传的参数。\n- 用call和apply实现更好的继承和扩展，更安全。\n\n27. 压缩合并目的？http请求的优化方式？\n- Web性能优化最佳实践中最重要的一条是减少HTTP请求。而减少HTTP请求的最主要的方式就是，合并并压缩JavaScript和CSS文件。 \n\n- CSS Sprites（雪碧图、CSS精灵）：把全站的图标都放在一个图像文件中，然后用CSS的background-image和background-position属性定位来显示其中的一小部分。\n\n优点：\n1. 减少 HTTP 请求数，极大地提高页面加载速度\n2. 增加图片信息重复度，提高压缩比，减少图片大小\n3. 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现\n\n缺点：\n\n1. 图片合并麻烦\n2. 维护麻烦，修改一个图片可能需要重新布局整个图片，样式\n\n- 合并脚本和样式表; 图片地图：利用image map标签定义一个客户端图像映射，（图像映射指带有可点击区域的一幅图像）具体看：http://club.topsage.com/thread-2527479-1-1.html \n\n- 图片js/css等静态资源放在静态服务器或CDN服时，尽量采用不用的域名，这样能防止cookie不会互相污染，减少每次请求的往返数据。 \n\n- css替代图片, 缓存一些数据 \n\n- 少用location.reload()：使用location.reload() 会刷新页面，刷新页面时页面所有资源 (css，js，img等) 会重新请求服务器。建议使用location.href=\"当前页url\" 代替location.reload() ，使用location.href 浏览器会读取本地缓存资源。\n\n- 图片懒加载 \n\n\n28. commonjs?requirejs?AMD|CMD|UMD?\n- CommonJS就是为JS的表现来制定规范，NodeJS是这种规范的实现，webpack 也是以CommonJS的形式来书写。因为js没有模块的功能，所以CommonJS应运而生。但它不能在浏览器中运行。 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)} \n\n- RequireJS 是一个JavaScript模块加载器。 RequireJS有两个主要方法(method): define()和require()。这两个方法基本上拥有相同的定义(declaration) 并且它们都知道如何加载的依赖关系，然后执行一个回调函数(callback function)。与require()不同的是， define()用来存储代码作为一个已命名的模块。 因此define()的回调函数需要有一个返回值作为这个模块定义。这些类似被定义的模块叫作AMD (Asynchronous Module Definition，异步模块定义)。 \n\n- AMD 是 RequireJS 在推广过程中对模块定义的规范化产出 AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。 适用AMD规范适用define方法定义模块。\n\n- CMD是SeaJS 在推广过程中对模块定义的规范化产出\nAMD与CMD的区别：\n（1）对于于依赖的模块，AMD 是提前执行(requirejs2.0+可以延迟执行了)，CMD 是延迟执行。\n（2）AMD 推崇依赖前置，CMD 推崇依赖就近。\n（3）AMD 推崇复用接口，CMD 推崇单用接口。\n（4）书写规范的差异。\n\n- umd是AMD和CommonJS的糅合。\nAMD 浏览器第一的原则发展 异步加载模块。\nCommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。这迫使人们又想出另一个更通用的模式UMD ( Universal Module Definition ), 希望解决跨平台的解决方案。UMD先判断是否支持Node.js的模块( exports )是否存在，存在则使用Node.js模块模式。\n\nCommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n29. js的几种继承方式？\n- 使用对象冒充实现继承\n- call、apply改变函数上下文实现继承\n- 原型链方式实现继承\n\n30. js原型、原型链，有什么特点？\n```javascript\n在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性[[prototype]],我们通常称之为原型.原型的值可以是一个对象,也可以是null.如果它的值是一个对象,则这个对象也一定有自己的原型.这样就形成了一条线性的链,我们称之为原型链. \n\n访问一个对象的原型可以使用ES5中的Object.getPrototypeOf方法,或者ES6中的__proto__属性. 原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的。\n\n类的继承\n特点：基于原型链，既是父类的实例，也是子类的实例\n缺点：无法实现多继承\n\n构造继承、组合继承、实例继承和拷贝继承...\n```\n\n31. eval是做什么的？\n- 将把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。\n- 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');\n\n32. null和undefined\n- null         表示一个对象是“没有值”的值，也就是值为“空”；\n- undefined     表示一个变量声明了没有初始化(赋值)；\n\n33. json的理解？\n- JSON（轻量级的数据交换格式），基于JS的子集，数据格式简单，易于读写，占用带宽小。\n```javascript\nJSON.parse() // 解析成JSON对象\n\nJSON.strinify() // 解析成JSON字符串\n```\n\n34. js延时加载的方式？\n- defer(仅ie支持)和async\n- 动态创建DOM\n- 按需异步加载JS\n\n35. ajax（异步的js和xml）\n- ajax是指一种创建交互式网页应用的网页开发技术。通过后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n36. 同异步的区别？\n- 同步(sync)：按顺序执行。\n- 异步(async)：不按顺序执行，可以跳过执行下面的代码。\n\n37. ajax的缺点？\n- 不支持浏览器的back按钮(事件由浏览器内核控制)\n- ajax暴露了与服务器的交互\n- 对搜索引擎的支持较弱\n- 破坏了程序的异常机制\n- 不容易调试\n\n38. 跨域问题？\n- 协议不同\n- 端口不同\n- 域名不同\n- 常用解决方案：\n1. jsonp\n> <script src=\"http://example.com/data.php?callback=do\"></script>\n2. iframe\n3. window.name\n在一个窗口中，窗口载入的所有页面共享一个window.name，每个页面都对window.name具有读写权限，可以在window.name中设置想要的数据。\n4. window.postMessage\n```javascript\niframe.contentWindow.postMessage(msg);\nwindow.onmessage = function (e) {\n    e = e || event;\n    alert(e.data);\n}\n```\n5. document.domain\n将两个页面的document.domain设置成相同域名即可，js中设置，形如：\ndocument.domain = \"\";\n6. 服务器设置代理页面/响应header配置cors access-control-allow-origin\n7. nginx反向代理\n\n39. 解决异步回调地狱有哪些方案？\npromise、generator、async/await\n\n40. 图片的预加载和懒加载？\n- 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。\n- 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。\n\n两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。\n\n41. mouseover和mouseenter的区别？\n- mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout\n\n- mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave\n\n- onmousedown 当元素上按下鼠标按钮时出发\n- onmousemove 当鼠标指针移动到元素上移动触发\n- onmouseover 当鼠标指针移动元素上时触发\n- onmouseout 当鼠标指针移出指定的对象时发生。\n- onmouseup 当在元素上释放鼠标按钮时触发\n- onmouseenter 事件在鼠标指针移动到元素上时触发。(不冒泡)\n- onmouseleave 事件在鼠标移除元素时触发。(不冒泡)\n\n42. 改变函数内部this指针的指向函数（bind，apply，call的区别）？\n- 通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2...这种形式。\n\n- 通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。\n\n43.  说说前端中的事件流\nHTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。\n什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。\n\n事件捕获阶段\n处于目标阶段\n事件冒泡阶段\n\naddEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\nIE只支持事件冒泡。\n\n44. 如何让事件先冒泡后执行？\n在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。\n\n45. 什么是事件委托？（事件代理）\n简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。\n\n举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。\n\n好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。\n\n```html\n<ul id=\"proxy\">\n  <li><button id=\"1\">1</button></li>\n  <li><button id=\"2\">2</button></li>\n  <li><button id=\"3\">3</button></li>\n</ul>\n```\n\n```js\nfunction main() {\n  const proxy = document.getElementById('proxy')\n\n  proxy.addEventListener('click', event => {\n    const currentTarget = event.target\n    const id = currentTarget.id\n    switch (id) {\n      case '1':\n        alert(`proxy: ${1}`)\n        break;\n      case '2':\n        alert(`proxy: ${2}`)\n        break;\n      case '3':\n        alert(`proxy: ${3}`)\n        break;\n      default:\n        break;\n    }\n  })\n}\n```\n45. 垂直居中\n- margin:auto法\n```css\ndiv{\n    width:200px;\n    margin:0 auto;\n}\n/* 绝对定位居中 */\ndiv {\n    position: absolute;\n    width: 300px;\n    height: 300px;\n    margin: auto;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n    background-color: pink;    /* 方便看效果 */\n}\n```\n\n- margin负值法 relative -> absolute \n```css\ndiv {\n    position: relative;        /* 相对定位或绝对定位均可 */\n    width:500px;\n    height:300px;\n    top: 50%;\n    left: 50%;\n    margin: -150px 0 0 -250px;         /* 外边距为自身宽高的一半 */\n    /* transform: translate(-50%, -50%); */\n    background-color: pink;         /* 方便看效果 */\n\n}\n```\n\n- flex布局\n```css\n.container {\n    display: flex;\n    align-items: center;         /* 垂直居中 */\n    justify-content: center;    /* 水平居中 */\n\n}\n.container div {\n    width: 100px;\n    height: 100px;\n    background-color: pink;        /* 方便看效果 */\n}  \n```\n\n- table-cell未脱离文档流 设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。\n- text-align:center 块级元素\n\n46. visibility=hidden, opacity=0，display:none\n- opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的\n- visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件。\n- display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。\n\n47. 块元素和行内元素\n- 块元素：独占一行，并且有自动填满父元素，可以设置margin和padding以及高度和宽度。\n- 行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。  \n\n48. 深拷贝\n- 深拷贝的方法 1-2适用于一般的对象和数组 4-5适用于数组 3通用\n\n```javascript\nlet obj = {\n    a: 1,\n    arr: [1, 2]\n};\nlet obj2 = deepCopy(obj);\nobj2.a = 2\nconsole.log(obj) // { a:1, arr: [1,2] };\n2.es6\nObject.assign()方法(深复制只有一层，之后为浅复制（除非再次使用Object.assign嵌套方式赋值）)\nlet obj = {\n    a: 1,\n    arr: [1, 2]\n};\nlet obj1 = Object.assign({}, obj);\nobj1.a = 2\n//不变\nconsole.log(obj) // { a:1, arr: [1,2] };\n3.immutable\n4.arr1=arr.slice(0) slice() 返回新数组\n5.arr1=arr.concat()\nvar deepCopy= function(source) { \n    var result={};\n    for (var key in source) {\n        result[key] = typeof source[key]==='object'? deepCoypy(source[key]): source[key];\n     } \n   return result; \n}\n```\n\n49. 判断一个变量是否是数组\n```javascript\nvar a = []; \n// 1.基于instanceof \na instanceof Array; \n// 2.基于constructor \na.constructor === Array; \n// 3.基于Object.prototype.isPrototypeOf \nArray.prototype.isPrototypeOf(a); \n// 4.基于getPrototypeOf \nObject.getPrototypeOf(a) === Array.prototype; \n// 5.基于Object.prototype.toString \nObject.prototype.toString.apply(a) === '[object Array]';\n// 6.Array.isArray\nArray.isArray(a); // true\n```\n以上，除了Object.prototype.toString外，其它方法都不能正确判断变量的类型。虽然Array继承自Object，也会有 toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：)😝\n\n* 由于每个iframe都有一套自己的执行环境，跨frame实例化的对象彼此是不共享原型链的，因此导致检测代码失效。\n\n举个🌰\n```js\nvar iframe = document.createElement('iframe'); //创建iframe\ndocument.body.appendChild(iframe); //添加到body中\nxArray = window.frames[window.frames.length-1].Array;\nvar arr = new xArray(1,2,3); // 声明数组[1,2,3]\nalert(arr instanceof Array); // false\nalert(arr.constructor === Array); // false\n```\n\n* 最佳写法\n```javascript\nvar arr = [1,2,3,1];\nvar arr2 = [{ abac : 1, abc : 2 }];\nfunction isArrayFn(value){\nif (typeof Array.isArray === \"function\") {\nreturn Array.isArray(value);\n}else{\nreturn Object.prototype.toString.call(value) === \"[object Array]\";\n}\n}\nconsole.log(isArrayFn(arr));// true\nconsole.log(isArrayFn(arr2));// true\n```\n\n49. 优化\n- 按需加载（懒加载）路由\n- 业务代码拆分\n- 第三方库提取vendor\n\n- 压缩文件图片，合并文件 减少http请求\n- 网络图、字体图标\n- 上cdn\n\n50. 行内、块级、空元素 \n- 行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n- 块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n- 常见空元素：即没有内容的HTML元素，例如：br、meta、hr、link、input、img\n- 不常见空元素：area、base、col、command、embed、keygen、param、source、track、wbr\n\n51. px、em、rem的区别\npx和em都是长度单位,px的只是固定的,em的值是相对的继承父类元素的字体大小。浏览器的默认字体高位16px。1em=16px;\nrem单位基于html根元素的字体大小。\n\n- vw/vh(css3) vmin(vw和vh的较小值)/vmax(vw和vh的较大值)和百分比的区别\n\n|单位|含义|\n|:---|:---|\n|%|大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)|\n|vm/vh|相对于视窗的尺寸|\n\n52. 路由权限管理\n- route render方法里进行判断 redirect or return null\n- 组件内部判断\n- 高阶组件\n- dva监听url subscription\n\n53. node中的事件循环是什么样子的?\n- event loop其实就是一个事件队列，先加入先执行，执行完一次队列，再次循环遍历看有没有新事件加入队列．执行中的叫IO events, setImmediate是在当前队列立即执行,setTimout/setInterval是把执行定时到下一个队列，process.nextTick是在当前执行完，下次遍历前执行．所以总体顺序是: IO events >> setImmediate >> setTimeout/setInterval >> process.nextTick\n\n54. 清空数组\n- 直接赋值空数组\n- splice(0,数组length)清空\n- 设置数组length=0\n\n55. 判断数组中出现次数最多的元素\n1. 临时对象数组，原数组sort排序，判断前后位是否相等。临时对象数组排序\n\n```javascript\nfunction f(arr){\n    var temp=[];//对象数组\n    var i;\n    temp[0]={value:arr[0],index:1};//保存数组元素出现的次数和值\n    arr.sort();\n    for(i=1;i<arr.length;i++){\n        if(arr[i]==arr[i-1]){\n            temp[temp.length-1].index++;\n        }else{//不相同则新增一个对象元素\n            temp.push({index:1,value:arr[i]});\n        }\n    }\n    temp.sort(function(a,b){//按照出现次数从大到小排列\n        return b.index-a.index;\n    })\n    var max=temp[0].index;\n    var maxV=temp[0].value;\n    var second=temp[1].index;\n    var secondV=temp[1].value;\n\n    return {max,maxV,second,secondV};\n}\nvar arr=[2,2,3,4,5,100,100,,3,1,4,4,100,100];\nvar {max,maxV,second,secondV}=f(arr);\nconsole.log(max,maxV,second,secondV); // 4 100 3 4\n```\n\n2. 临时对象 判断属性名存不存在 2次遍历\n```javascript\nvar arr = [1,1,2,2,2,2,2,3,3,3,4,4];\n    var obj = {};\n    for(var i = 0; i<arr.length; i++){\n        if(!obj[arr[i]]){\n            obj[arr[i]] = 1;\n        }else {\n            obj[arr[i]]++;\n        }\n    }\n    /*\n        此时的obj对象包含了所有元素出现次数的信息\n        然后再遍历obj对象就可以查询出出现次数最多/最少的元素了\n    */\n    var maxNum = 0;\n    var minNum = obj[arr[0]];  //先随意给最少的变量赋值（但保证是数组中的元素出现的次数）\n    var maxEleArr = [],minEleArr = [];\n    //第一次遍历找出出现次数最多和最少的值\n    for(var key in obj){\n        if(obj[key] > maxNum){\n            maxNum = obj[key];\n        }\n        if(obj[key] < maxNum){\n            minNum = obj[key];\n        }\n    }\n    //第二次遍历找出所有出现次数最多和最少的元素\n    for(var key in obj){\n        if(obj[key] == maxNum){\n            maxEleArr.push(key);\n        }\n        if(obj[key] == minNum){\n            minEleArr.push(key);\n        }\n    }\n    console.log(maxEleArr + \":\" + maxNum );  // 2:5\n    console.log(minEleArr + \":\" + minNum );  // 1,4:2\n```\n\n3. reduce简写\n```javascript\nvar arr = 'abcdaabc';\n\nvar info = arr\n    .split('')\n    .reduce((p, k) => (p[k]++ || (p[k] = 1), p), {});\n\nconsole.log(info); //{ a: 3, b: 2, c: 2, d: 1 }\n```\n\n4. 临时对象简便\n```js\nconst map = {}\nconst str = 'hello world'\n\nstr.split('').forEach(key => {\n  map[key] = -~map[key]\n})\n\nconsole.log(map)\n// {\" \": 1, d: 1, e: 1, h: 1, l: 3, o: 2, r: 1, w: 1}\n// ~i = -(i + 1)，~undefined = -1\n```\n\n56. 清除浮动\n清除浮动是为了清除浮动元素产生的影响。浮动元素的高度会发生坍塌，使页面后面的布局不能正常显示。\n设置成浮动后，display值会自动变成block。\n> 浮动会引起高度塌陷和文字环绕。\n- 使用空标签清除浮动clear: both （增加了无意义的标签）\n- 使用overflow: auto/hidden （使用zoom: 1兼容IE）\nzoom:1的清除浮动原理?\n清除浮动，触发hasLayout；\nZoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。\n譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。\n\n来龙去脉大概如下：\n当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。\n- 使用after伪元素清除浮动（用于非IE浏览器）\n\n```css\n.clear {\n    overflow: auto;\n    zoom: 1;\n}\n\n.clear::after {\n    display: block;\n    content: '清除浮动',\n    height: 0;\n    clear: both;\n}\n\n.clearfix::before, .clearfix::after {\n    content: \" \";\n    display: table;\n}\n```\n发现：除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。\n\n57. margin-top和padding-left根据height还是width？\nwidth\n\n58. vue的非父子组件传递\n1. vuex 2. 在同一个vue实例上调用$emit和$on\n\n59. 原生js实现拖拽\n\n60. 实现函数监听函数发布订阅模式 on emit off 方法 类似 iflux\n```javascript\nfunction event() {\n  this.elem = document.createElement('div')\n}\nevent.prototype.on = function (name, fn) {\n  this.e = new Event(name)\n  this.elem.addEventListener(name, fn.call(this, this.e, this.e.type))\n}\nevent.prototype.emit = function(name) {\n  this.elem.dispatchEvent(this.e) // 这里接受的参数必须是Event类型的，不然报错\n}\nevent.prototype.off = function (name, fn) {\n  this.e = null\n}\nvar ee = new event()\nee.on('foo', function(){console.log(110)})\nee.emit('foo') // 110\n```\n\n61. 左边固定，右边自适应布局\n1. float\n2. flex布局\n3. 通过position 父级relative\n\n62. mysql 字符转换\n```sql\n-- date转字符串\nselect date_format(now(), '%Y-%m-%d'); \n--  date转时间戳\nselect unix_timestamp(now())\n--  字符串转时间\nselect str_to_date(\"2019-01-15\",'%Y-%m-%d %H')\n-- 20190115\n-- 时间戳转时间\nselect from_unixtime(1451997924)\n-- 时间戳转字符串\nselect from_unixtime(1451997924,\"%Y-%m-%d %H\")\n```\n\n63. empty()和html(\"\")\n推荐使用empty html不会清除子组件的事件\n\n64. react、vue多个class\n## react\n方法一：ES6 模板字符串 ``\n\nclassName={title ${index === this.state.active ? 'active' : ''}}\n　　\n\n方法二：join(\"\")\n\nclassName={[\"title\", index === this.state.active?\"active\":null].join(' ')}\n\n方法三：classnames\n\n## vue\n方法一：\n:class=\"[box,shadow]\"\n方法二：\n:class=\"{box:show1,shadow:show2}\"\n\n65. vue组件通信\n```javascript\n// 父传子\n// 父组件\n<note-address :data=\"msg\"></note-address> \n\n// 子组件\n\n<div>{{ data.partment }}</div>\n\nexport default {\n  //props:['data']\n  props: {\n    data: Object\n  }\n}\n// 子传父\n// 父组件\n<note-address @new=\"addNote\"></note-address> \n\n// 子组件\n<button type=\"small\" class=\"confirm\" @click=\"add\">设为教案</button>\n\nmethods: {\n add () {\n  this.$emit('new', false)\n }\n}\n// 兄弟相传\n// 1.创建 公共bus.js\n\n//bus.js\nimport Vue from 'vue'\nexport default new Vue()\n\n// 2.父组件注册两个子组件\ncomponents:{\n    firstChild,\n    secondChild\n}\n\n// 3.firstChild组件\n\n<input type=\"button\" value=\"点击触发\" @click=\"elementByValue\">\n\n<script>\n// 引入公共的bus，来做为中间传达的工具\n  import Bus from './bus.js'\n  export default {\n      methods: {\n      elementByValue: function () {\n        Bus.$emit('val', '兄弟，收到了吗？')\n      }\n    }\n  }\n</script>\n\n// 4.secondChild组件\n\n<span>{{msg}}</span>\n\n<script>\n  import Bus from './bus.js'\n  export default {\n      mounted(){\n            let self = this;\n            Bus.$on('val', function (msg) {\n                console.log(msg)\n                self.msg = msg\n            })\n      }\n    }\n  }\n</script>\n```\n\n66. 网络七层协议\n![tcp](http://cdn.mydearest.cn/blog/images/tcp.png)\n\n- 应用层\n- 会话层\n- 传输层\n- 网络层\n- 数据链路层\n- 物理层\n- 表示层\n\n- 应用层（HTTP，FTP，NFS，SMTP）\n与其它计算机进行通讯的一个应用，它是对应应用程序的通信服务的。例如，一个没有通信功能的字处理程序就不能执行通信的代码，从事字处理工作的程序员也不关心OSI的第7层。但是，如果添加了一个传输文件的选项，那么字处理器的程序员就需要实现OSI的第7层。示例：TELNET，HTTP，FTP，NFS，SMTP等。\n\n- 表示层\n这一层的主要功能是定义数据格式及加密。例如，FTP允许你选择以二进制或ASCII格式传输。如果选择二进制，那么发送方和接收方不改变文件的内容。如果选择ASCII格式，发送方将把文本从发送方的字符集转换成标准的ASCII后发送数据。在接收方将标准的ASCII转换成接收方计算机的字符集。示例：加密，ASCII等。\n\n- 传输层（TCP，UDP，SPX）\n这层的功能包括是否选择差错恢复协议还是无差错恢复协议，及在同一主机上对不同应用的数据流的输入进行复用，还包括对收到的顺序不对的数据包的重新排序功能。示例：TCP，UDP，SPX。\n\n- 会话层（RPC，SQL）\n它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的，在某些情况下，如果表示层收到了所有的数据，则用数据代表表示层。示例：RPC，SQL等\n\n- 网络层（IP，IPX）\n这层对端到端的包传输进行定义，它定义了能够标识所有结点的逻辑地址，还定义了路由实现的方式和学习的方式。为了适应最大传输单元长度小于包长度的传输介质，网络层还定义了如何将一个包分解成更小的包的分段方法。示例：IP，IPX等。\n\n- 数据链路层（IP，IPX）\n它定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。\n\n- 物理层（Rj45，802.3）\nOSI的物理层规范是有关传输介质的特这些规范通常也参考了其他组织制定的标准。连接头、帧、帧的使用、电流、编码及光调制等都属于各种物理层规范中的内容。物理层常用多个规范完成对所有细节的定义。示例：Rj45，802.3等。\n\n67. call使用\n```js\nfunction add(a,b){\nconsole.log(a+b)\n}\n\nfunction sub(a,b){\nconsole.log(a-b)\n}\n\nadd.call(sub,3,1) // 4\n```\n\n68. css选择器的优先级\n\n标签选择器 < 类选择器 < ID选择器 < 内联style < !important\n\n69. 事件队列（eventLoop）\n```js\n// 以下是头条的类似题目，这个考得更全面\nasync function a1 () {\n    console.log('a1 start')\n    await a2()\n    console.log('a1 end')\n}\nasync function a2 () {\n    console.log('a2')\n}\nconsole.log('script start')\nsetTimeout(() => {\n    console.log('setTimeout')\n}, 0)\nPromise.resolve().then(() => {\n    console.log('promise1')\n})\na1()\nlet promise2 = new Promise((resolve) => {\n    resolve('promise2.then')\n    console.log('promise2')\n})\npromise2.then((res) => {\n    console.log(res)\n    Promise.resolve().then(() => {\n        console.log('promise3')\n    })\n})\nconsole.log('script end')\n\n// script start\n// a1 start\n// a2\n// promise2\n// script end\n// promise1\n// a1 end\n// promise2.then\n// promise3\n// setTimeout\n```\n\n70. vue中watch和computed的区别\n\n- computed，计算属性，随着依赖的数据响应式地改变，用于复杂逻辑处理\n\n- watch，命令式地监听数据变化进行操作\n\n71. 简单介绍es6\n\nES6在变量的声明和定义方面增加了let、const声明变量，有局部变量的概念，赋值中有比较吸引人的结构赋值，同时ES6对字符串、 数组、正则、对象、函数等拓展了一些方法，如字符串方面的模板字符串、函数方面的默认参数、对象方面属性的简洁表达方式，ES6也 引入了新的数据类型symbol，新的数据结构set和map,symbol可以通过typeof检测出来，为解决异步回调问题，引入了promise和 generator，还有最为吸引人了实现Class和模块，通过Class可以更好的面向对象编程，使用模块加载方便模块化编程，当然考虑到 浏览器兼容性，我们在实际开发中需要使用babel进行编译。\n\n72. js模块化\n在ES6出现之前，js没有标准的模块化概念，这也就造成了js多人写作开发容易造成全局污染的情况，以前我们可能会采用立即执行 函数、对象等方式来尽量减少变量这种情况，后面社区为了解决这个问题陆续提出了AMD规范和CMD规范，这里不同于Node.js的 CommonJS的原因在于服务端所有的模块都是存在于硬盘中的，加载和读取几乎是不需要时间的，而浏览器端因为加载速度取决于网速， 因此需要采用异步加载，AMD规范中使用define来定义一个模块，使用require方法来加载一个模块，现在ES6也推出了标准的模块 加载方案，通过export和import来导出和导入模块。\n\n73. 图片加载成功或者失败\nonload/onerror\n\n74. 递归和迭代的区别\n程序调用自身称为递归，利用变量的原值推出新值称为迭代，递归的优点 大问题转化为小问题，可以减少代码量，同时应为代码精简，可读性好， 缺点就是，递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。迭代的好处 就是代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销， 缺点就是代码不如递归简洁\n\n75. 原生JS操作DOM的方法有哪些？\n获取节点的方法getElementById、getElementsByClassName、getElementsByTagName、 getElementsByName、querySelector、querySelectorAll,对元素属性进行操作的 getAttribute、 setAttribute、removeAttribute方法，对节点进行增删改的appendChild、insertBefore、replaceChild、removeChild、 createElement等\n\n76. setTimeout和setInterval的区别，包含内存方面的分析？\nsetTimeout表示间隔一段时间之后执行一次调用，而setInterval则是每间隔一段时间循环调用，直至clearInterval结束。 内存方面，setTimeout只需要进入一次队列，不会造成内存溢出，setInterval因为不计算代码执行时间，有可能同时执行多次代码， 导致内存溢出。\n\n77. addEventListener有哪些参数？\n有三个参数，第一个是事件的类型，第二个是事件的回调函数，第三个是一个表示事件是冒泡阶段还是捕获阶段捕获的布尔值，true表示捕获，false表示冒泡\n\n78. 将静态资源放在其他域名的目的是什么？\n这样做的主要目的是在请求这些静态资源的时候不会发送cookie，节省了流量，需要注意的是cookie是会发送给子域名的（二级域名），所以这些静态资源是不会放在子域名下的， 而是单独放在一个单独的主域名下。同时还有一个原因就是浏览器对于一个域名会有请求数的限制，这种方法可以方便做CDN。\n\n79. http状态码301和302的区别\n- 301 redirect: 301 代表永久性转移(Permanently Moved) \n\n如何避免301跳转https(在response中header)\n\n- 302 redirect: 302 代表暂时性转移(Temporarily Moved)\n\n详细来说，301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。\n\n[重定向](http://cdn.mydearest.cn/blog/images/redirectCache.png)\n\n80. 在什么情况下a === a-1 ?\n- Infinity/-Infinity\n\n```js\nlet a = Infinity;\n\nconsole.log(a === a - 1); // true\n\nlet b = -Infinity;\n\nconsole.log(b === b - 1);  // true\n\nconsole.log(Infinity + Infinity); // Infinity\nconsole.log(Infinity - Infinity); // NaN\nconsole.log(Infinity * Infinity); // Infinity\nconsole.log(Infinity / Infinity); // NaN\nconsole.log(Infinity * 0); // NaN\n```\n\n- 安全数(-2 ** 53 + 1到2 ** 53 - 1) 即Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER 处理特殊情况\n\n```js\nlet a = Number.MIN_SAFE_INTEGER - 1;\nconsole.log(a === a - 1); // true\n```\n\n- a == a -1\n\n```js\nvar x = 1\nvar a = { x, valueOf: () => a.x }\nObject.defineProperty(a, 'x', { get() { return --x } })\n\nvar set = 1\nObject.defineProperty(window, \"a\", {\n  get : function(){\n    return set++\n  },\n  enumerable : true,\n  configurable : true\n});\n\nconst a = {\n times: 0,\n\n valueOf() {\n   if (this.times & 1) {\n     return 0;\n   }\n   this.times += 1;\n   return 1;\n },\n};\n```\n\n81. placeholder样式设置\n\n```css\n::-webkit-input-placeholder{}    /* 使用webkit内核的浏览器 */\n:-moz-placeholder{}                  /* Firefox版本4-18 */\n::-moz-placeholder{}                  /* Firefox版本19+ */\n:-ms-input-placeholder{}           /* IE浏览器 */\n```\n\n82. 巧用currentColor自定义checkbox样式\n```css\n/* 无法自定义checkbox样式 */\ninput[type=checkbox] {\n  background-color: red;\n  color: red;\n  border: solid red;\n}\n```\n\n```css\ninput[type=checkbox] {\n  position: relative;\n  color: inherit;\n}\n\ninput[type=checkbox]::before,\ninput[type=checkbox]::after {\n  position: absolute;\n  display: inline-block;\n  width: 12px;\n  height: 12px;\n  line-height: 12px;\n  border-radius: 3px;\n  text-align: center;\n}\n\ninput[type=checkbox]:checked::after {\n  content: 'x';\n  color: white;\n}\n\ninput[type=checkbox]::before {\n  content: ' ';\n  /* 表示将背景色设置为当前的文字颜色值。 */\n  background-color: currentColor;\n}\n```\n\n83. 增补字符不适用String.prototype.charCodeAt和String.fromCharCode\n```js\n'🀄'.length // 2\n\nconst str = '🀄';\nconsole.log(str.codePointAt(0)); // 126980\n\nconsole.log(String.fromCodePoint(126980)); // 🀄\n\nconsole.log([...\"👨‍👩‍👧‍👦\"])\n// [\"👨\", \"‍\", \"👩\", \"‍\", \"👦\", \"‍\", \"👦\"]\n```\n\n84. 三次握手、四次挥手\n- 建立连接-TCP的三次握手\n\n(1) 主机向服务器发送一个建立连接的请求\n\n(2) 服务器接到请求后发送同意连接的信号\n\n(3) 主机接到同意连接的信号后，再次向服务器发送了确认信号\n\n发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n- 断开连接-TCP的四次挥手\n(1) 主机向服务器发送一个断开连接的请求\n\n(2) 服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机)\n\n(3) 服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据)\n\n(4) 主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接\n\n> 注意：这里的四次挥手中服务器两次向主机发送消息，第一次是回复主机已收到断开的请求，第二次是向主机确认是否断开，确保数据传输完毕。\n\n85. 幂等性\n\n其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。\n\n86. src和href引入的区别\nhref 表示超文本引用（hypertext reference），在 link和a 等元素上使用。\nsrc 的内容，是页面必不可少的一部分，是引入。href 的内容，是与该页面有关联，是引用。区别就是，引入和引用。\n\n87. a.b.c.d 和 a['b']['c']['d']，哪个性能更高？\n```js\nvar obj = {\n  a:{\n      b:{\n        c:{\n          d:1\n        }\n      }\n    }\n}\nconsole.time()\nconsole.log(obj.a.b.c.d)\nconsole.timeEnd() \n// console.time()\n// console.log(obj[\"a\"][\"b\"][\"c\"][\"d\"])\n// console.timeEnd() \n// default:1.100ms 0.964ms\n```\n\n88. 对象引用\n```js\nvar a = {n: 1};\nvar b = a;\na.x = a = {n: 2};\n\nconsole.log(a.x) \t\nconsole.log(b.x)\n// undefined\n// {n:2}\n```\n首先，a和b同时引用了{n:2}对象，接着执行到a.x = a = {n：2}语句，尽管赋值是从右到左的没错，但是.的优先级比=要高，所以这里首先执行a.x，相当于为a（或者b）所指向的{n:1}对象新增了一个属性x，即此时对象将变为{n:1;x:undefined}。之后按正常情况，从右到左进行赋值，此时执行a ={n:2}的时候，a的引用改变，指向了新对象{n：2},而b依然指向的是旧对象。之后执行a.x = {n：2}的时候，并不会重新解析一遍a，而是沿用最初解析a.x时候的a，也即旧对象，故此时旧对象的x的值为{n：2}，旧对象为 {n:1;x:{n：2}}，它被b引用着。\n后面输出a.x的时候，又要解析a了，此时的a是指向新对象的a，而这个新对象是没有x属性的，故访问时输出undefined；而访问b.x的时候，将输出旧对象的x的值，即{n:2}。\n\n\n89. Doctype作用？标准模式与兼容模式各有什么区别?\n1. <!DOCTYPE>声明位于HTML文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。\n\n2. 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。\n\n90. HTML5 为什么只需要写 <!DOCTYPE HTML>？\n- HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；\n\n- 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。\n\n91. 对浏览器内核的理解？\n主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\nJS引擎则：解析和执行javascript来实现网页的动态效果。\n\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n\n\n92. html5新特性？\n- HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n绘画 canvas;\n用于媒介回放的 video 和 audio 元素;\n本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\nsessionStorage 的数据在浏览器关闭后自动删除;\n语意化更好的内容元素，比如 article、footer、header、nav、section;\n表单控件，calendar、date、time、email、url、search;\n新的技术webworker, websocket, Geolocation;\n\n- 移除的元素：\n纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n对可用性产生负面影响的元素：frame，frameset，noframes；\n\n- 支持HTML5新标签：\nIE8/IE7/IE6支持通过document.createElement方法产生的标签，\n可以利用这一特性让这些浏览器支持HTML5新标签，\n浏览器支持新标签后，还需要添加标签默认的样式。\n当然也可以直接使用成熟的框架、比如html5shim;\n\n```js\n<!--[if lt IE 9]>\n<script> src=\"http://html5shim.googlecode.com/svn/trunk/html5.js\"</script>\n<![endif]-->\n```\n\n- 如何区分HTML5： DOCTYPE声明新增的结构元素功能元素\n\n93. 对HTML语义化的理解？\n用正确的标签做正确的事情。\nhtml语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;\n即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;\n搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;\n使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。\n\n94. iframe缺点\n* iframe会阻塞主页面的Onload事件；\n* 搜索引擎的检索程序无法解读这种页面，不利于SEO;\n* iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n\n使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值。\n\n95. 多个标签页通信\nWebSocket、SharedWorker；\n也可以调用localstorge、cookies等本地存储方式；\n\nlocalstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，\n我们通过监听事件，控制它的值来进行页面信息通信；\n注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；\n\n96. CSS的盒子模型 border-sizing (border-box)\n（1）有两种， IE 盒子模型、W3C 盒子模型；\n（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n（3）区  别： IE的content部分把 border 和 padding计算了进去;\n\n97. CSS选择符有哪些？哪些属性可以继承？\n* 1.id选择器（ # myid）\n  2.类选择器（.myclassname）\n  3.标签选择器（div, h1, p）\n  4.相邻选择器（h1 + p）\n  5.子选择器（ul > li）\n  6.后代选择器（li a）\n  7.通配符选择器（ * ）\n  8.属性选择器（a[rel = \"external\"]）\n  9.伪类选择器（a:hover, li:nth-child）\n\n* 可继承的样式： font-size font-family color, UL LI DL DD DT;\n\n* 不可继承的样式：border padding margin width height ;\n\n98. css优先级算法\n* 优先级就近原则，同权重情况下样式定义最近者为准;\n* 载入样式以最后载入的定位为准;\n\n优先级为:\n同权重: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。\n!important >  id > class > tag\nimportant 比 内联优先级高\n\n99. css3新增的伪类\n举例：\np:first-of-type    选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\np:last-of-type    选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\np:only-of-type    选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\np:only-child        选择属于其父元素的唯一子元素的每个 <p> 元素。\np:nth-child(2)    选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n::after            在元素之前添加内容,也可以用来做清除浮动。\n::before            在元素之后添加内容\n:enabled          \n:disabled         控制表单控件的禁用状态。\n:checked        单选框或复选框被选中。\n\n100. display有哪些值？\nblock           块类型。默认宽度为父元素宽度，可设置宽高，换行显示。\nnone            元素不显示，并从文档流中移除。\ninline          行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。\ninline-block    默认宽度为内容宽度，可以设置宽高，同行显示。\nlist-item       象块类型元素一样显示，并添加样式列表标记。\ntable           此元素会作为块级表格来显示。\ninherit         规定应该从父元素继承 display 属性的值。\n\n101. position有哪些值？\nabsolute\n  生成绝对定位的元素，相对于值不为 static 的第一个父元素进行定位。\nfixed （老IE不支持）\n  生成绝对定位的元素，相对于浏览器窗口进行定位。\nrelative\n  生成相对定位的元素，相对于其正常位置进行定位。\nstatic\n  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。\ninherit\n  规定从父元素继承 position 属性的值。\n\n102. CSS3有哪些新特性？\n新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）\n圆角            （border-radius:8px）\n多列布局        （multi-column layout）\n阴影和反射    （Shadow\\Reflect）\n文字特效        （text-shadow、）\n文字渲染        （Text-decoration）\n线性渐变        （gradient）\n旋转             （transform）\n缩放,定位,倾斜,动画,多背景\n例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation: \n\n103. BFC规范(块级格式化上下文：block formatting context)的理解？\n\n（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）\n一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。\n\n不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的\n\n元素和外部的元素不会互相影响。\n\n- 创建规则：\n\n1. 根元素\n2. 浮动元素（float不是none）\n3. 绝对定位元素（position取值为absolute或fixed）\n4. display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素\n5. overflow不是visible的元素\n\n- 作用：\n\n1. 可以包含浮动元素\n2. 不被浮动元素覆盖\n3. 阻止父子元素的 margin 折叠\n\n104. css权重\n> 标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值\n> 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现\n\n```css\n/*权重为1*/\ndiv{\n}\n/*权重为10*/\n.class1{\n}\n/*权重为100*/\n#id1{\n}\n/*权重为100+1=101*/\n#id1 div{\n}\n/*权重为10+1=11*/\n.class1 div{\n}\n/*权重为10+10+1=21*/\n.class1 .class2 div{\n}\n```\n\n105. .gitignore说明\n```shell\n.a # 忽略所有 .a 结尾的文件\n!lib.a # 但 lib.a 除外\n/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\nbuild/ # 忽略 build/ 目录下的所有文件\ndoc/.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n```\n规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交：\n\n```shell\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```\n\n106. 外边距合并\n外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。\n[w3school介绍网址](https://www.w3school.com.cn/css/css_margin_collapsing.asp)\n\n107. 如何优化css，提高性能？\n- 使用关键选择器，过滤掉无关的规则\n- 提取项目公共样式，增强可复用性、模块化编写组件\n- 预处理器以及构建工具(postcss`后处理器`补充前缀、打包压缩、自动优雅降级)\n\n108. margin和padding分别适合什么场景使用？\nmargin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。\nmargin用于布局分开元素使元素与元素互不相干；\npadding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段\n\n109. 如何修改chrome记住密码后自动填充表单的黄色背景 ？\n```css\ninput:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {\n  background-color: rgb(250, 255, 189); /*#FAFFBD;*/\n  background-image: none;\n  color: rgb(0, 0, 0);\n}\n```\n\n110. 什么是Cookie 隔离？\n如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，\n所以不如隔离开。\n\n因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，\n这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。\n\n同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，\n提高了webserver的http请求的解析速度。\n\n111. ajax缓存问题\n1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified-Since\",\"0\")。\n\n2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no-cache\")。\n\n3、在URL后面加上一个随机数： \"fresh=\" + Math.random();。\n\n4、在URL后面加上时间戳：\"nowtime=\" + new Date().getTime();。\n\n5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。\n\n模块化开发，采用立即执行函数不暴露私有成员。\n\n112. jquery.extend 与 jquery.fn.extend的区别？\n- jquery.extend：为jquery类添加类方法，可以理解为添加静态方法\n- jquery.fn.extend: 源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数\n\n> jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。\n\n113. jquery一个对象绑定多个事件\n```js\n// 多个事件同一个函数\n$(\"div\").on(\"click mouseover\", function(){});\n\n// 多个事件不同函数\n$(\"div\").on({\nclick: function(){},\nmouseover: function(){}\n});\n```\n\n114. 如何不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标？\n```js\nArray.from(Array(100).keys())\n\n[...Array(100).keys()]\n```\n\n接着乱序排序\n```js\narr.sort( () => Math.random() > .5 ? -1 : 1 )\n```\n\n前十个数相加\n```js\nvar [a, b, c, d, e, f, g, h, i, j, ...last] = arr3;\nvar total = a + b + c + d + e + f + g + h + i + j;\n```\n\n```js\nconst foo = ((x, f = (y = x) => x + y) => {\n      let y = f();\n      x = y++;\n      return [x, y, f(y)]\n    })(2)\n// foo = [4,5,9]\n```\n\n115. link与@import的区别\n- link 是 html 方式，@import是css方式\n\n- link最大限度支持并行下载，@import过多嵌套导致串行下载\n\n- link可以通过rel=\"alternate stylesheet\"指定候选样式\n\n- 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式\n\n- @import必须在样式规则之前，可以在 css 文件中引用其他文件\n\n- 总体来说：link 优于@import\n\n116. PNG,GIF,JPG 的区别\n- GIF:\n\n8 位像素，256 色\n无损压缩\n支持简单动画\n支持 boolean 透明\n适合简单动画\n\n- JPEG：\n\n颜色限于 256\n有损压缩\n可控制压缩质量\n不支持透明\n适合照片\n\n- PNG：\n\n有 PNG8 和 truecolor PNG\nPNG8 类似 GIF 颜色上限为 256，文件小，支持 alpha 透明度，无动画\n适合图标、背景、按钮\n\n117. 什么是 FOUC?如何避免\n\nFlash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。解决方法：把样式表放到文档的head\n\n118. focus/blur 与 focusin/focusout的区别和联系\n1. focus/blur 不冒泡，focusin/focusout 冒泡\n2. focus/blur 兼容性好，focusin/focusout 在除 FireFox 外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在 FireFox 下使用事件捕获 elem.addEventListener('focus', handler, true)\n3. 可获得焦点的元素：\n- window\n- 链接被点击或键盘操作\n- 表单空间被点击或键盘操作\n- 设置tabindex属性的元素被点击或键盘操作\n\n119. == 和 === 判断相等的流程\n\n- == \n如果两个值类型相同，按照===比较方法进行比较\n如果类型不同，使用如下规则进行比较\n如果其中一个值是 null，另一个是 undefined，它们相等\n如果一个值是数字另一个是字符串，将字符串转换为数字进行比较\n如果有布尔类型，将true 转换为 1，false 转换为 0，然后用==规则继续比较\n如果一个值是对象，另一个是数字或字符串，将对象转换为原始值然后用==规则继续比较\n其他所有情况都认为不相等\n\n- ===\n如果两个值不是相同类型，它们不相等\n如果两个值都是 null 或者都是 undefined，它们相等\n如果两个值都是布尔类型 true 或者都是 false，它们相等\n如果其中有一个是NaN，它们不相等\n如果都是数值型并且数值相等，他们相等， -0 等于 0\n如果他们都是字符串并且在相同位置包含相同的 16 位值，他它们相等；如果在长度或者内容上不等，它们不相等；两个字符串显示结果相同但是编码不同==和===都认为他们不相等\n如果他们指向相同对象、数组、函数，它们相等；如果指向不同对象，他们不相等\n\n120. 对象到字符串的转换\n如果对象有 toString()方法，javascript 调用它。如果返回一个原始值（primitive value 如：string number boolean）,将这个值转换为字符串作为结果\n如果对象没有 toString()方法或者返回值不是原始值，javascript 寻找对象的 valueOf()方法，如果存在就调用它，返回结果是原始值则转为字符串作为结果\n否则，javascript 不能从 toString()或者 valueOf()获得一个原始值，此时 throws a TypeError\n\n121. 对象到数字的转换\n如果对象有valueOf()方法并且返回元素值，javascript将返回值转换为数字作为结果\n否则，如果对象有toString()并且返回原始值，javascript将返回结果转换为数字作为结果\n否则，throws a TypeError\n\n122. <,>,<=,>=的比较规则\n所有比较运算符都支持任意类型，但是比较只支持数字和字符串，所以需要执行必要的转换然后进行比较，转换规则如下:\n\n如果操作数是对象，转换为原始值：如果 valueOf 方法返回原始值，则使用这个值，否则使用 toString 方法的结果，如果转换失败则报错\n经过必要的对象到原始值的转换后，如果两个操作数都是字符串，按照字母顺序进行比较（他们的 16 位 unicode 值的大小）\n否则，如果有一个操作数不是字符串，将两个操作数转换为数字进行比较\n\n123. +运算符工作流程\n如果有操作数是对象，转换为原始值\n此时如果有一个操作数是字符串，其他的操作数都转换为字符串并执行连接\n否则：所有操作数都转换为数字并执行加法","tags":["面试"],"categories":["知识"]},{"title":"正确设置网站title、keywords、description","url":"%2Fseo.html","content":"\n---\n<!--more-->\n\nSEO：搜索引擎优化，提高网站浏览量\n\nSEM：搜索引擎营销\n\nIP：独立IP访问的用户\n\nPV：页面浏览量或点击量\n\nUV：独立访客数\n\n## title（网站标题）\n\ntitle，就是浏览器上显示的那些内容，不仅用户能看到，也能被搜索引擎检索到（搜索引擎在抓取网页时，最先读取的就是网页标题，所以title是否正确设置极其重要。）title一般不超过80个字符，而且词语间要用英文“-”隔开，因为计算机只对英语的敏感性较高，对汉语的敏感性不高。\n\n```html\n用法：<title>网站标题</title>\n```\n\n1. 首页title写法，一般是“网站名称-主关键词或一句含有主关键词的描述”。在做优化时习惯把主关键词放最前面，网站名称放后面，因为搜索引擎给予标题最前面的词比后面的高。比如，做“招聘”这个词，就这样写“企业招聘-创业公司招聘技巧-xx招聘”。\n\n2. 栏目页title写法，一般有2种：“栏目名称-网站名称”、“栏目名称栏目关键词-网站名称”。建议用“栏目名称-网站名称”。而且栏目名称最好用关键词来确定，比如企业招聘栏目最好就用企业招聘，而不要起个让人无法识别的名字如企业来人，企业看看，或企业加上一些特殊符号，这种写法虽然很有个性，但会让你的网站在优化上占了下风。\n\n3. 分类列表页title写法，一般是“分类列表页名称-栏目名称-网站名称”，这个和栏目页差不多。\n\n4. 文章页title写法，一般有3种：“文章标题-网站名称”、“内容标题-栏目名称”、“内容标题-栏目名称-网站名称”。其中，“内容标题-栏目名称-网站名称”的写法最为规范，但也相对复杂，它能给用户很好的提示，让用户知道他在访问哪篇文章，并且是在哪个网站的哪个栏目下。\n\n \n\n## keywords（关键词）\n\nkeywords，是用户不查看源代码看不到的。主要作用是告诉搜索引擎本页内容是围绕哪些词展开的。因此keywords的每个词都要能在内容中找到相应匹配，才有利于排名。keywords一般不超过3个，每个关键词不宜过长，而且词语间要用英文“,”隔开。为什么用英文上文已经说过。而且，尽量将重要的关键字靠前放，因为靠后的关键字排名较差，除非你站有很高的权重。\n\n小道消息称keywords曾被百度、谷歌、雅虎等搜索引擎剔除，将不会再影响搜索引擎的排序结果，设置一下总没坏处，还是有一些搜索引擎比较重视keywords标签的。\n\n```html\n用法：<meta name=”Keywords” Content=”关键词1,关键词2,关键词3,关键词4″>\n```\n\n1. 首页keywords写法，一般是“网站名称,主要栏目名,主要关键词”。\n\n2. 栏目页keywords写法，一般是“栏目名称,栏目关键字,栏目分类列表名称”。\n\n3. 分类列表页keywords写法，这个就比较简单了，只要将你这个栏目中的主要关键字写入即可。\n\n4. 文章页keywords写法，建议大家提取文章中的关键词，比如我的文章主要是讲SEO优化的，那么我关键词肯定是SEO优化，如果你觉得你提取关键词的能力较差，也可以选择文章中出现比较多的词来作为关键词，比如我现在写的内容是关于title、keywords、description的，那我的文章页关键词就是这3个。\n\n## description（内容摘要）\n\ndescription，和上面的keywords一样，是用户不查看源代码看不到的，而且也是对于一个网页的简要内容概况。不同的是，keywords是由几个词语的组成的，而description则是完整的一句话。description一般不超过150个字符，描述内容要和页面内容相关。\n\n```html\n用法：<meta name=”Description” Content=”你网页的简述”>\n```\n\n1. 首页description写法，一般是将首页的标题、关键词和一些特殊栏目的内容融合到里面，写成简单的介绍。\n\n2. 栏目页description写法，一般是将栏目的标题、关键字、分类列表名称融合到里面，写成简单的介绍。\n\n3. 分类列表页description，这个就比较简单了，一般只需要把分类列表的标题、关键词融合在一起，写成简单的介绍。\n\n4. 文章页description写法，一般有2种写法，标准写法就和前面的一样，将文章标题、文章中的重要内容和关键词融合在一起，写成简单的介绍。这是最好最标准的写法。但是这样写比较麻烦，可以在文章首段和标题中加入关键词，比如我这篇文章是讲title、keywords、description的，那么在文章首段和标题中就加入这些内容，然后直接将文章首段的内容复制到description中即可。\n\n**PS：3个标签按重要性来分：title＞description＞keywords**\n\n## 其他优化技巧\n\n1）标签语义化 \n2）一个页面中的H1标签只能使用一次 \n3）img标签都要设置 alt 属性，在这个属性中声明当前图片的信息（spider不能收录图片，但是可以抓取到图片alt属性的值） \n4）HTML的层级不要太深的层级，蜘蛛可能不会抓取和收录 \n5）把需要推广的关键词尽可能的在页面中曝光（最好都写在H（2~6）标签中） ","tags":["优化"],"categories":["知识"]},{"title":"JavaScript整理总结","url":"%2Fjssummary.html","content":"\nJS的相关知识点比较繁杂，特此开篇整理一波，方便回顾总结查阅。\n\n--- \n<!--more -->\n\n## 概念\nJavaScript 是一门跨平台、面向对象、基于原型的轻量级动态脚本语言。\n\n与java的对比：\n\n|JavaScript|Java|\n|:---|:---|\n|面向对象。不区分对象类型。通过原型机制继承，任何对象的属性和方法均可以被动态添加。|基于类系统。分为类和实例，通过类层级的定义实现继承。不能动态增加对象或类的属性或方法。|\n|变量类型不需要提前声明(动态类型)。|变量类型必须提前声明(静态类型)。|\n|不能直接自动写入硬盘。|可以直接自动写入硬盘。|\n\n## 变量声明\n### var(存在变量提升)\n声明一个变量，可赋一个初始化值。\n\n### let(let 同一变量在同一作用域不能同时声明)\n声明一个块作用域的局部变量，可赋一个初始化值。\n\n### const(const 声明时必须赋初始值,也不可以在脚本运行时重新声明)\n声明一个块作用域的只读的命名常量。\nconst声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。\n如const a=[1,2,3] a[1]=4; const b={} b.name=\"1\" 数组元素和对象属性不受保护。\n\n## 变量的作用域\n在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的任何其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。全区变量是全局对象的属性，在浏览器中可以用window.xx或xx来访问。\n\n```javascript\nif(true){\n    var a=5\n}\nconsole.log(a) // 5 使用let声明块级则是undefined\n```\n## 变量提升\nJavaScript 变量的另一特别之处是，你可以引用稍后声明的变量而不会引发异常。这一概念称为变量声明提升(hoisting)；\nvar ok ; let 和 const 则不会存在变量提升\n\n```javascript\n1.\nconsole.log(x === undefined); // true\nvar x = 3;\n\n2.\nvar myvar = \"my value\";\n\n(function() {\n  console.log(myvar); // undefined\n  var myvar = \"local value\";\n})();\n\n1.1 也可写作\nvar x;\nconsole.log(x === undefined); // true\nx = 3;\n\n2.1\nvar myvar = \"my value\";\n \n(function() {\n  var myvar;\n  console.log(myvar); // undefined\n  myvar = \"local value\";\n})();\n```\n\n## 函数提升\n声明函数的两种方式：\n\n```javascript\nfunction foo(){} // 函数声明 存在函数提升且大于变量提升\nvar foo=function (){} // 函数表达式 var foo=function foo1(){} 函数名可写\n```\n此时的3种递归调用自身的方式 \n- foo()\n- foo1()\n- arguments.callee() \n\n现在已经不推荐使用arguments.callee()；\n原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。\n\n## 数据类型 8种\n### 原始类型\n- Boolean\n- null\n- undefined\n- String \n- Number 标识范围 -2^53~2^53 数字均为双精度浮点类型\n- Symbol(它的实例是唯一且不可改变)\n- bigint\n\nObject 是 JavaScript 中所有对象的父对象\n数据封装类对象：Object、Array、Boolean、Number 和 String\n其他对象：Function、Arguments、Math、Date、RegExp、Error\n\n为什么 x=0.1 能得到 0.1？\n恭喜你到了看山不是山的境界。因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 \n\n9.007199254740992，这也是 JS 最多能表示的精度。它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。\n\n不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此；\n\n在JavaScript中，所有的Number都是以64-bit的双精度浮点数存储的；\n\n双精度的浮点数在这64位上划分为3段，而这3段也就确定了一个浮点数的值，64bit的划分是“1-11-52”的模式，具体来说：\n\n1.就是1位最高位（最左边那一位）表示符号位，0表示正，1表示负；\n\n2.11位表示指数部分；52位表示尾数部分，也就是有效域部分\n\n任何原始类型都有字面量形式，可以不被变量所存储。\n\nJavaScript语言有\"垃圾回收\"功能，所以在使用引用类型的时候无需担心内存分配。但是为了防止\"内存泄露\"还是应该在不实用对象的时候将该对\n\n象的引用赋值为null。让\"垃圾回收\"器在特定的时间对那一块内存进行回收。\n\n64位浮点数：1位符号位 + 52位整数位 + 11位小数位，如果符号位为1，其他各位均为0，那么这个数值会被表示成\"-0\"。同理还可以表示\"+0\"\n\n```js\n// 二进制构造-0\n// 首先创建一个8位的ArrayBuffer\nconst buffer = new ArrayBuffer(8);\n// 创建DataView对象操作buffer\nconst dataView = new DataView(buffer);\n\n// 将第1个字节设置为0x80，即最高位为1\ndataView.setUint8(0, 0x80);\n\n// 将buffer内容当做Float64类型返回\nconsole.log(dataView.getFloat64(0)); // -0\n```\n\n- 判断+-0\n```js\n0 === -0 // true\n// Object.is(-0, 0)返回false，Object.is(NaN, NaN)返回true\n// 早期es利用1/-0为-Infinity的特点来判断\nfunction isNegativeZero(num) {  \n  return num === 0 && (1 / num < 0);\n}  \n```\n\n- Object.is()方法的polyfill\n```js\nif (!Object.is) {\n  Object.is = function(x, y) {\n    // SameValue algorithm\n    if (x === y) { // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  };\n}\n```\n\n### 原始封装类型\n```js\nvar a ='qwer';\nvar firstChar = a.chatAt(0);\nconsole.log(firstChar);// q\n```\n\n在js引擎中发生了\n```js\nvar a ='qwer';\nvar temp = new String(a);\nvar firstChar = temp.chatAt(0);\ntemp =null;\nconsole.log(firstChar);// q\n```\n\n```js\n0.10000000000000000555.toPrecision(16)\n// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1\n\n// 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试：\n0.1.toPrecision(21) = 0.100000000000000005551\n```\n\n### 对象Object\n对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。\n\n只有null和undefined无法拥有方法\n\nFunction Array Number Boolean String Date Math RegExp类\n\n```javascript\ntypeof null === 'object' // true\nnull instanceof Object // false \nnull instanceof null // error\n\n// 不同的对象在底层都表示为二进制\n// 在JavaScript中二进制前三位为0的话都会被判断为object类型\n// null的二进制表示全是0，自然前三位也是0\n// 所以 typeof null === “object”\n\ntypeof Function; // 'function'\ntypeof new Function(); // 'function'\ntypeof function() {}; // 'function'\n\ntypeof Array; // 'function'\ntypeof Array(); // 'object'\ntypeof new Array(); // 'object'\ntypeof []; // 'object'\n\ntypeof Boolean; // \"function\"\ntypeof Boolean(); // \"boolean\"\ntypeof new Boolean(); // \"object\"\n\ntypeof Math; // 'object'\ntypeof Math(); // Math is not a function\ntypeof new Math(); // Math is not a constructor\n\n[]+[] // \"\"\n[]+{} // \"[object Object]\"\n{}+[] // 0\n\n!+[]+[]+![] // \"truefalse\"\n\nMath.max() // -Infinity\nMath.min() // Infinity\n```\n\n> 构造函数 Array(..) 不要求必须带 new 关键字。不带时，它会被自动补上。 因此 Array(1,2,3) 和 new Array(1,2,3) 的效果是一样的\n\n## MDN基本数据类型的定义\n> 除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的\n>（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。\n\n```javascript\nvar a = 'string'\na[0] = 'a'\nconsole.log(a)  // string\n```\n我们通常情况下都是对一个变量重新赋值，而不是改变基本数据类型的值。在 js 中是没有方法是可以改变布尔值和数字的。\n倒是有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。\n\n### 引用数据类型\n引用类型（object）是存放在堆内存中的，变量实际上是一个存放在栈内存的指针，这个指针指向堆内存中的地址。每个空间大小不一样，要根据情况开进行特定的分配。\n\n### 传值和传址\n了解了基本数据类型与引用类型的区别之后，我们就应该能明白传值与传址的区别了。\n在我们进行赋值操作的时候，基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再将值赋值到新的栈中。例如:\n\n```javascript\nvar a = 10;\nvar b = a;\n\na ++ ;\nconsole.log(a); // 11\nconsole.log(b); // 10\n```\n所以说，基本类型的赋值的两个变量是两个独立相互不影响的变量。\n\n但是引用类型的赋值是传址。只是改变指针的指向，例如，也就是说引用类型的赋值是对象保存在栈中的地址的赋值，这样的话两个变量就指向同一个对象，因此两者之间操作互相有影响。例如：\n\n```javascript\nvar a = {}; // a保存了一个空对象的实例\nvar b = a;  // a和b都指向了这个空对象\n\na.name = 'jozo';\nconsole.log(a.name); // 'jozo'\nconsole.log(b.name); // 'jozo'\n\nb.age = 22;\nconsole.log(b.age);// 22\nconsole.log(a.age);// 22\n\nconsole.log(a == b);// true\n```\n\n## 字面量\n字面量是由语法表达式定义的常量\n\n- 数组字面量(Array literals) []\n- 布尔字面量(Boolean literals) true/false\n- 浮点数字面量(Floating-point literals) 3.14\n- 整数(Intergers) 5 \n- 对象字面量(Object literals) {}\n- RegExp literals 一个正则表达式是字符被斜线（译注：正斜杠“/”）围成的表达式 /a+b/ \nRegExp.test() RegExp.exec() string.match() \n- 字符串字面量(String literals) \"1212\" '1212'\nJavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象。你也能用对字符串字面值使用类似\n\n```javascript\nString.length的属性：\nconsole.log(\"John's cat\".length)\n```\n\n```javascript\nvar obj={\n  say:funciton(){\n\n  },\n  // 简写\n  say(){\n\n  }\n}\n```\n十进制整数字面量由一串数字序列组成，且没有前缀0。\n八进制的整数以 0（或0O、0o）开头，只能包括数字0-7。\n十六进制整数以0x（或0X）开头，可以包含数字（0-9）和字母 a~f 或 A~F。\n二进制整数以0b（或0B）开头，只能包含数字0和1。\n\n## 模板字符串\n```javascript\nvar name = \"Bob\", time = \"today\";\n`Hello ${name}, how are you ${time}?`\n```\n\n## 布尔环境的假值\n* false\n* undefined\n* null\n* 0\n* NaN\n* 空字符串（\"\"）\n\n## try-catch \n如果finally块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：\n\n```javascript\nfunction f() {\n  try {\n    console.log(0);\n    throw \"bogus\";\n  } catch(e) {\n    console.log(1);\n    return true; // this return statement is suspended\n                 // until finally block has completed\n    console.log(2); // not reachable\n  } finally {\n    console.log(3);\n    return false; // overwrites the previous \"return\"\n    console.log(4); // not reachable\n  }\n  // \"return false\" is executed now  \n  console.log(5); // not reachable\n}\nf(); // console 0, 1, 3; returns false\n```\n\n## for of 和 for in循环\n```javascript\nlet arr = [3, 5, 7];\narr.foo = \"hello\";\n\nfor (let i in arr) {\n   console.log(i); // logs \"0\", \"1\", \"2\", \"foo\"\n}\n\n// 所有可枚举的属性名\nfor (let i of arr) {\n   console.log(i); // logs \"3\", \"5\", \"7\" // 注意这里没有 hello\n}\n\n// for in 的循环顺序 => 遍历首先数字的可以接着按照创建顺序遍历\n// 对象数字键名会转成字符串 对象的key值只有string和symbol类型\n// 排序规则同样适用于下列API：\n// Object.entries\n// Object.values\n// Object.keys\n// Object.getOwnPropertyNames\n// Reflect.ownKeys\n\nvar a = {1:1,name:'cosyer',2:2}\nfor (let i in a) {\n  if(a.hasOwnProperty(i)){\n      console.log(i)\n  }\n}\n// 1 2 name\n```\n\n## 嵌套函数和闭包\n一个闭包是一个可以自己拥有独立的环境与变量的的表达式。\n- 内部函数包含外部函数的作用域。\n- 内部函数只可以在外部函数中访问。\n- 内部函数可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。\n\n## 多层嵌套函数\n函数可以被多层嵌套。例如，函数A可以包含函数B，函数B可以再包含函数C。B和C都形成了闭包，所以B可以访问A，C可以访问B和A。因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域。这个称之为作用域链。\n\n```javascript\nfunction A(x) {\n  function B(y) {\n    function C(z) {\n      console.log(x + y + z);\n    }\n    C(3);\n  }\n  B(2);\n}\nA(1); // logs 6 (1 + 2 + 3)\n```\n\n在这个例子里面，C可以访问B的y和A的x。这是因为：\n\n1. B形成了一个包含A的闭包，B可以访问A的参数和变量\n2. C形成了一个包含B的闭包\n3. B包含A，所以C也包含A，C可以访问B和A的参数和变量。换言之，C用这个顺序链接了B和A的作用域\n\n反过来却不是这样。A不能访问C，因为A看不到B中的参数和变量，C是B中的一个变量，所以C是B私有的。\n\n## 作用域链解释说明\n当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。\n\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。\n当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，\n直至全局函数，这种组织形式就是作用域链。\n\n```javascript\nfunction outside() {\n  var x = 5;\n  function inside(x) {\n    return x * 2;\n  }\n  return inside;\n}\n\noutside()(10); // returns 20 instead of 10\n```\n命名冲突发生在return x上，inside的参数x和outside变量x发生了冲突。这里的作用链域是{inside, outside, 全局对象}。因此inside的x具有最高优先权，返回了20（inside的x）而不是10（outside的x）。\n\n## 闭包\nJavaScript 允许函数嵌套，并且内部函数可以访问定义在外部函数中的所有变量和函数，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一定的安全性。此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数将的生存周期比内部函数执行时间长。当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。\n\n```javascript\nvar pet = function(name) {          //外部函数定义了一个变量\"name\"\n  var getName = function() {            \n    //内部函数可以访问 外部函数定义的\"name\"\n    return name; \n  }\n  //返回这个内部函数，从而将其暴露在外部函数作用域\n  return getName;               \n};\nmyPet = pet(\"Vivie\");\n    \nmyPet();                            // 返回结果 \"Vivie\"\n```\n\n## arguments 对象\n函数的实际参数会被保存在一个类似数组的arguments对象中。\n\n```javascript\narguments[i] // 访问\n```\narguments变量只是 ”类数组对象“，并不是一个数组。称其为类数组对象是说它有一个索引编号和length属性。尽管如此，它并不拥有全部的Array对象的操作方法。\n\n## 函数参数(默认参数、剩余参数(rest))\n剩余参数语法允许将不确定数量的参数表示为数组\n\n```javascript\nfunction multiply(a, b = 1,...[1,2,3]) {\n  return a*b;\n}\n```\n\n## 箭头函数\n箭头函数总是匿名的\n引入箭头函数的原因\n\n1. 更简洁的语法\n2. 捕捉闭包上下文的this值\n```javascript\nfunction Person(){\n  this.age = 0;\n\n  setInterval(() => {\n    this.age++; // |this| properly refers to the person object\n  }, 1000);\n}\n\nvar p = new Person();\n```\n\n## 扩展语句\n适用于对象，数组\n```javascript\nfunction f(x, y, z) { }\nvar args = [0, 1, 2];\nf(...args);\n```\n## 临时对象\n你可以在String字面值上使用String对象的任何方法—JavaScript自动把String字面值转换为一个临时的String对象, 然后调用其相应方法,最后丢弃销毁此临时对象.在String字面值上也可以使用String.length属性.\n\n```javascript\nvar s1 = \"2 + 2\"; // Creates a string literal value\nvar s2 = new String(\"2 + 2\"); // Creates a String object\neval(s1); // Returns the number 4\neval(s2); // Returns the string \"2 + 2\"\nNumber(null) // 0\n```\n\n## 数组方法\n\n### concat() 连接两个数组并返回一个新的数组。\n```javascript\nvar myArray = new Array(\"1\", \"2\", \"3\");\nmyArray = myArray.concat(\"a\", \"b\", \"c\"); \n// myArray is now [\"1\", \"2\", \"3\", \"a\", \"b\", \"c\"]\n```\n\n###  join() 将数组的所有元素连接成一个字符串。\n```javascript\nvar myArray = new Array(\"Wind\", \"Rain\", \"Fire\");\nvar list = myArray.join(\" - \"); // list is \"Wind - Rain - Fire\"\n```\n\n### push() 在数组末尾添加一个或多个元素，并返回数组操作后的长度。\n```javascript\nvar myArray = new Array(\"1\", \"2\");\nmyArray.push(\"3\"); // myArray is now [\"1\", \"2\", \"3\"]\n```\n\n### pop() 从数组移出最后一个元素，并返回该元素。\n```javascript\nvar myArray = new Array(\"1\", \"2\", \"3\");\nvar last = myArray.pop(); \n// myArray is now [\"1\", \"2\"], last = \"3\"\n```\n\n### shift() 从数组移出第一个元素，并返回该元素。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nvar first = myArray.shift(); \n// myArray is now [\"2\", \"3\"], first is \"1\"\n```\n\n### unshift()在数组开头添加一个或多个元素，并返回数组的新长度。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nmyArray.unshift(\"4\", \"5\"); \n// myArray becomes [\"4\", \"5\", \"1\", \"2\", \"3\"]\n```\n\n### slice(开始索引，结束索引) 从数组提取一个片段，并作为一个新数组返回。 \n```javascript\nvar myArray = new Array (\"a\", \"b\", \"c\", \"d\", \"e\");\nmyArray = myArray.slice(1, 4); // until index 3, returning [ \"b\", \"c\", \"d\"]\n```\nslice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。只需将该方法绑定到这个对象上。 一个函数中的 arguments 就是一个类数组对象的例子。\n\n```javascript\nArray.prototype.slice.call({0:1,1:3,length:2});\n```\n\n### splice(index, count_to_remove, addElement1, addElement2, ...)从数组移出一些元素，（可选）并替换它们。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\", \"4\", \"5\");\nmyArray.splice(1, 3, \"a\", \"b\", \"c\", \"d\"); \n// myArray is now [\"1\", \"a\", \"b\", \"c\", \"d\", \"5\"]\n```\n\n### reverse() 颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。\n```javascript\nvar myArray = new Array (\"1\", \"2\", \"3\");\nmyArray.reverse(); \n// transposes the array so that myArray = [ \"3\", \"2\", \"1\" ]\n```\n\n### sort() 给数组元素排序。\n```javascript\nvar arr=[2,1,3]\narr.sort() // [1,2,3]\n```\nsort() 也可以带一个回调函数来决定怎么比较数组元素。这个回调函数比较两个值，并返回3个值中的一个：\n- 如果 a 小于 b ，返回 -1(或任何负数) 降序\n- 如果 a 大于 b ，返回 1 (或任何正数) 升序\n- 如果 a 和 b 相等，返回 0。\n\n### indexOf(searchElement[, fromIndex]) 在数组中搜索searchElement 并返回第一个匹配的索引。\n```javascript\nvar a = ['a', 'b', 'a', 'b', 'a'];\nconsole.log(a.indexOf('b')); // logs 1\n// Now try again, starting from after the last match\nconsole.log(a.indexOf('b', 2)); // logs 3\nconsole.log(a.indexOf('z')); // logs -1, because 'z' was not found\n```\n\n### lastIndexOf(searchElement[, fromIndex]) 和 indexOf 差不多，但这是从结尾开始，并且是反向搜索。\n\n### forEach() 循环数组 不定的顺序 不能用break,return false跳出循环遍历\n\n遍历都不会修改原来的基本类型（只能返回新数组）引用类型可以。\n\n### map() 循环数组返回新数组\n```javascript\nvar a1 = ['a', 'b', 'c'];\nvar a2 = a1.map(function(item) { return item.toUpperCase(); });\nconsole.log(a2); // logs A,B,C\n```\n\n### find() 找到满足条件的第一个元素\n\n### filter() 循环数组返回符合条件的元素\n```javascript\nvar a1 = ['a', 10, 'b', 20, 'c', 30];\nvar a2 = a1.filter(function(item) { return typeof item == 'number'; });\nconsole.log(a2); // logs 10,20,30\n```\n### every() 循环数组 如果全部元素满足条件则返回true 否则返回false\n\n### some() 循环数组 只要有一项满足条件则返回true 全部不满足返回false\n\n### reduce() 迭代 使用回调函数 callback(firstValue, secondValue) 把数组列表计算成一个单一值 reduceRight() 从右边开始\n```javascript\nvar a = [10, 20, 30];\nvar total = a.reduce(function(first, second) { return first + second; }, 0);\nconsole.log(total) // Prints 60\n\n[3,2,1].reduce(Math.pow) // 9\n[].reduce(Math.pow) // error\n```\n\n### 填充fill/splice\n```javascript\nvar fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\nfruits.fill(\"cosyer\", 2, 4); // 开始和结束索引\nfruits.splice(2,2,'cosyer','cosyer'); // splice方法需要手动添加多个\n// [\"Banana\", \"Orange\", \"cosyer\", \"cosyer\"]\n```\n\n### copyWithin\n```javascript\nvar fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\nfruits.copyWithin(2, 0); // Banana,Orange,Banana,Orange\n// copyWithin(target, start, end);\n```\n\n### entries 一个数组的迭代对象，该对象包含数组的键值对\n```javascript\nvar a = ['a','b','c']\nvar iterator = a.entries()\nconsole.log(iterator) // Array Iterator{}\nconsole.log(iterator.next().value) // [0,'a']\nfor(let a of iterator){\n    console.log(a)\n}\n//[0,'a']\n//[1,'b']\n//[2,'c']\n// keys返回键() values()返回值\n```\n\n## Map简单的键值对集合(字典的数字结构类似对象，键可以是各种类型的值)\n```javascript\nvar sayings = new Map();\nsayings.set('dog', 'woof');\nsayings.set('cat', 'meow');\nsayings.set('elephant', 'toot');\nsayings.size; // 3\nsayings.get('fox'); // undefined\nsayings.has('bird'); // false\nsayings.delete('dog');\nsayings.has('dog'); // false\n\nfor (var [key, value] of sayings) {\n  console.log(key + ' goes ' + value);\n}\n// \"cat goes meow\"\n// \"elephant goes toot\"\n\nsayings.clear();\nsayings.size; // 0\n```\nnew Map() 参数可以是一个数组或者其他 iterable 对象，其元素或为键值对，或为两个元素的数组。 每个键值对都会添加到新的 Map。null 会被当做 undefined。\n```js\nconst set = new Set([\n  ['foo', 1],\n  ['bar', 2]\n]);\nconst m1 = new Map(set);\nm1.get('foo') // 1\n\nconst m2 = new Map([['baz', 3]]);\nconst m3 = new Map(m2);\nm3.get('baz') // 3\n```\n\n### WeakMap（类似Map，只接受对象作为键名（null除外），WeakMap的键名所指向的对象，不计入垃圾回收机制）\n\n**Object和Map的比较**\n\n1. 一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。\n2. Object的键均为Strings类型，在Map里键可以是任意类型。\n3. 必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。\n4. Map的遍历遵循元素的插入顺序。\n5. Object有原型，所以映射中有一些缺省的键。（可以理解为map = Object.create(null)）。\n\n如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。\n如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。\n如果需要对个别元素进行操作，使用Object。\n\n## Set集合(类似数组，成员的值都是唯一且无序的)\n```javascript\nvar mySet = new Set();\nmySet.add(1);\nmySet.add(\"some text\");\nmySet.add(\"foo\");\n\nmySet.has(1); // true\nmySet.delete(\"foo\");\nmySet.size; // 2\nmySet.clear(); // 清空集合\n\nfor (let item of mySet) console.log(item);\n// 1\n// \"some text\"\n\nmySet2 = new Set([1,2,2,4]);\nArray.from(mySet2);  // [1,2,3] 常用来去重\n\n// argument对象（类数组）转成数组\n// Array.from({0:111,1:222,2:333,length:3}) [111,222,333]\n```\n\n### WeakSet（类似Set，成员都是对象，弱引用）\nWeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素。\n\n**Array和Set的比较**\n\n1. 数组中用于判断元素是否存在的indexOf 函数效率低下。\n2. Set对象允许根据值删除元素，而数组中必须使用基于下标的 splice 方法。\n3. 数组的indexOf方法无法找到NaN值。\n4. Set对象存储不重复的值，所以不需要手动处理包含重复值的情况。\n5. 数组是特殊的对象,对象是关联数组 字符串是特殊的数组\n6. 方括弧取值为动态判定[]，数字非有效的js标识符   \n\n## setter和getter (get set修饰function)\n```javascript\nvar o = {\n  a: 7,\n  get b() { \n    return this.a + 1;\n  },\n  set c(x) {\n    this.a = x / 2\n  }\n};\n\nconsole.log(o.a); // 7\nconsole.log(o.b); // 8 取b值时调用\no.c = 50;         // 给c设置值调用\nconsole.log(o.a); // 25\n-----------------------\nvar o = {\n  a: 7,\n  b:function(){ \n    return this.a + 1;\n  }\n};\n\nconsole.log(o.b()); // 8\n```\n\n## 访问所有可枚举对象属性\n1. for in 无序\n2. Object.keys() 不包括原型的属性名数组\n3. Object.getOwnPropertyNames()\n\n## Symbol(原始数据类型) 不可枚举的 符号类型\n```javascript\nvar  myPrivateMethod  = Symbol(); // 不能使用new Symbol()创建，它是一个不完整的类属于基本类型\nthis[myPrivateMethod] = function() {...};\n```\n\nfor in 和 Object.getOwnPropertyNames()访问不到，只能通过myPrivateMethod或者Object.getOwnPropertySymbols()来访问\n\n```javascript\nSymbol(\"foo\") !== Symbol(\"foo\") // true\nconst foo = Symbol()\nconst bar = Symbol()\ntypeof foo === \"symbol\" // true\ntypeof bar === \"symbol\" // true\nlet obj = {}\nobj[foo] = \"foo\"\nobj[bar] = \"bar\"\nJSON.stringify(obj) // {}\nObject.keys(obj) // []\nObject.getOwnPropertyNames(obj) // []\nObject.getOwnPropertySymbols(obj) // [ foo, bar ]\n```\n\n## Proxy 代理\n`let p= new Proxy(target,handler)`\n- target\n用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n\n- handler\n一个对象，其属性是当执行一个操作时定义代理的行为的函数。\n\n```javascript\n// 设置缺省值\nlet handler = {\n    get: function(target, name){\n        return name in target ? target[name] : 37;\n    }\n};\n\nlet p = new Proxy({}, handler);\n\np.a = 1;\np.b = undefined;\n\nconsole.log(p.a, p.b);    // 1, undefined\n\nconsole.log('c' in p, p.c);    // false, 37\n\n// 转发代理\nlet target = {};\nlet p = new Proxy(target, {});\n\np.a = 37;   // 操作转发到目标\n\nconsole.log(target.a);    // 37. 操作已经被正确地转发\n\n// demo\nlet book  = {\"name\":\"《ES6基础系列》\",\"price\":56 };\nlet proxy = new Proxy(book,{\n    get:function(target,property){\n        if(property === \"name\"){\n            return \"《入门到懵逼》\";\n        }else{\n            return target[property];\n        }\n    },\n    set:function(target,property,value){\n        if(property === 'price'){\n            target[property] = 56;\n        }\n    }\n})\n```\n\n## 生成器 generator \nfunction* 来修饰GeneratorFunction函数\n\n```javascript\nfunction* idMaker() {\n  var index = 0;\n  while(true)\n    yield index++;\n}\n\nvar gen = idMaker();\n\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\n// ...\n```\n\n对象实现迭代行为\n\n```javascript\nvar myIterable = {};\nmyIterable[Symbol.iterator] = function* () {\n    yield 1;\n    yield 2;\n    yield 3;\n};\n\nfor (let value of myIterable) { \n    console.log(value); \n}\n// 1\n// 2\n// 3\n\nor\n[...myIterable]; // [1, 2, 3]\n```\n\n## 3行实现Promise\n```javascript\nfunction Promise (fn) {\n    this.then = cb => this.cb = cb\n    this.resolve = data => this.cb(data)\n    fn(this.resolve)\n}\n// 使用\nnew Promise((resolve) => {\n    setTimeout(() => {\n        resolve(\"延时执行\")\n    }, 1000)\n}).then((data) => {\n    console.log(data)\n})\n```\n\n## 现一个函数，将一个字符串中的空格替换成“%20”\n```javascript\nfunction convertSpace2percent20(str){\n  return str.replace(/\\s+?/g,\"%20\"); //开启非贪婪模式\n}\n\nconvertSpace2percent20(\"hellow world\")\n// \"hellow%20world\"\n```\n\n## var obj = { 1: \"Hello\", 2: \"World\" }打印Hello World\n```javascript\nvar obj = {\n    1: \"Hello\",\n    2: \"World\"\n};\n\nvar str = '';\n\n// 方法1\nfor (var i = 1; i < 3; i++) {\n\tstr += obj[i] + \" \"; //注意不能使用obj.i\n}\n\n// 方法2\nfor (var key of Object.keys(obj)) {\n\tstr += obj[key] + \" \";\n}\n\n// 方法3\nfor (let i in obj) {\n  str += obj[i] + \" \"; \n}\n\n// 方法4\nObject.values(obj).join(\" \")\n```\n\n## 循环\n- while - 只要指定的条件成立，则循环执行代码块\n- do...while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环\n- for - 循环执行代码块指定的次数\n- foreach - 根据数组中每个元素来循环代码块\n### forEach等函数的第二个参数的用法\nforEach函数用得平时用得比较多，但是从来没想到forEach函数还有第二个参数。\n\n简单点来说，就是我们可以直接使用第二个参数来指定函数里的this的值，而不需要使用箭头函数或者在外面定义var that = this;等操作。\n\n```javascript\nvar obj = {\n    name: \"小明\",\n    say: function() {\n        console.log(this.name); // \"小明\"\n    },\n    think: function() {\n        var arr = [1];\n        arr.forEach(function(item) {\n            console.log(this); // window\n        })\n        console.log('---------')\n        arr.forEach(function(item) {\n            console.log(this); // obj\n        }, this)\n    }\n}\n\nobj.say();\nobj.think();\n\n[3,2,4,1].sort((a,b)=>{\n    return a > b ? 1 : -1; // return a-b\n})\n```\n\n## 数组扁平化(将多维数组展开为一维数组)\n```javascript\n//  es6\nconst flattenES6 = (arr) => {\n  let result = [];\n  arr.forEach((item, i, arr) => {\n    if (Array.isArray(item)) {\n      result = result.concat(flattenES6(item));\n    } else {\n      result.push(arr[i])\n    }\n  })\n  return result;\n};\nconsole.log(flattenES6([1, [2, [3, [4]], 5]]))\n\n// es5\nfunction flattenES5(arr) {\n  var result = [];\n  for (var i = 0, len = arr.length; i < len; i++) {\n    if (Array.isArray(arr[i])) {\n      result = result.concat(flattenES5(arr[i]))\n    } else {\n      result.push(arr[i])\n    }\n  }\n  return result;\n}\nconsole.log(flattenES5([1, [2, [3, [4]], 5]]))\n\n[1, [2, [3, [4]], 5]] // 1,2,3,4,5\n\n// toString方法\n// es6\nconst flattenES6 = (arr) => arr.toString().split(',').map((item) => +item);\nconsole.log(flattenES6([1, [2, [3, [4]], 5]]))\n\n// es5\nfunction flattenES5(arr) {\n  return arr.toString().split(',').map(function (item) {\n    return +item;\n  });\n}\nconsole.log(flattenES5([1, [2, [3, [4]], 5]]))\n\n// flat方法 返回新数组，不会改变原数组\n[1, 2, [3, 4]].flat()\n// [1, 2, 3, 4] 默认拉平一层\n\n[1, 2, [3, [4, 5]]].flat(2)\n// [1, 2, 3, 4, 5] 拉平两层的嵌套数组\n\n[1, [2, [3]]].flat(Infinity)\n// Infinity无论多少层都拉平\n\n// flatMap()方法对原数组的每个成员执行一个函数，相当于执行Array.prototype.map(),然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组\n// 相当于 [[2, 4], [3, 6], [4, 8]].flat() flatMap()只能展开一层数组\n[2, 3, 4].flatMap((x) => [x, x * 2])\n// [2, 4, 3, 6, 4, 8]\n```\n\n## 自定义错误类型\n```javascript\n// ES6\nclass CustomError extends Error {\n  constructor(message) {\n    super(message)\n    this.name = 'CustomError'\n  }\n}\n\n// ES5\nfunction CustomError(message) {\n  this.name = 'CustomError'\n  this.message = message\n  Error.captureStackTrace(this, CustomError)\n}\n\nCustomError.prototype = new Error()\nCustomError.prototype.constructor = CustomError\n\n// img标签来埋点处理错误日志\nfunction logError(msg) {\n  const img = new Image()\n  img.src = `/log?${encodeURIComponent(msg)}`\n}\n```\n\n## 命令式编程和声明式编程\n- 纯粹性：纯函数不改变除当前作用域以外的值;\n- 数据不可变性: Immutable\n\n```javascript\n// 反面示例\nlet a = 0\nconst add = (b) => a = a + b // 两次 add(1) 结果不一致\n\n// 正确示例\nconst add = (a, b) => a + b\n```\n\n- 函数柯里化 将多个入参的函数转化成1个入参的函数\n```javascript\nconst add = a => b => c => a + b + c\nadd(1)(2)(3)\n```\n\n- 偏函数 将多个入参的函数转化成两部分\n```javascript\nconst add = a => (b, c) => a + b + c\nadd(1)(2, 3)\n```\n\n- 组合函数\n```javascript\nconst add = (x) => x + x\nconst mult = (x) => x * x\n\nconst addAndMult = (x) => add(mult(x))\n```\n\n## 实现bind函数\n```javascript\n// 第一种: 借助 call/apply\nFunction.prototype.bind1 = function (context) {\n  const self = this\n  return function () {\n    return self.call(context)\n  }\n}\n\n// 测试:\nconst obj = {\n  value: 'cosyer',\n}\nfunction testBind() {\n  console.log(this.value)\n}\nconst resultBind = testBind.bind1(obj)\nresultBind() // cosyer\n\n// 第二种: 借助 arguments\nFunction.prototype.bind2 = function (context) {\n  const arr = Array.prototype.slice.call(arguments, 1)\n  const self = this\n  return function () {\n    const restArr = Array.prototype.slice.call(arguments)\n    return self.apply(context, arr.concat(restArr))\n  }\n}\n// 这种方式的实现其实是函数柯里化的变版\n\n// 比如在监听事件时可以这样子用:\n\ndom.addEventListener('click', fn.bind(this))\n// 进行如下测试:\n\nconst obj2 = {\n  value: 'cosyer',\n}\nfunction testBind2(age, gender) {\n  console.log(this.value) // cosyer\n  console.log(age)        // 23\n  console.log(gender)     // male\n}\nconst resultBind2 = testBind2.bind2(obj2, 23)\nresultBind2('male')\n\n// 第三种: 区分环境, 是普通调用还是 new 调用\nFunction.prototype.bind3 = function (context) {\n  const arr = Array.prototype.slice.call(arguments, 1)\n  const self = this\n  return function () {\n    const restArr = Array.prototype.slice.call(arguments)\n    return self.apply(this !== windows ? this : context, arr.concat(restArr))\n  }\n}\n\n// 测试: 使用 new 以后 this 会指向 newObj\nconst obj3 = {\n  value: 'cosyer',\n}\nfunction testBind3(age, gender) {\n  console.log(this.value)\n  console.log(age)\n  console.log(gender)\n}\nconst resultBind3 = testBind3.bind3(obj3, 23, 'male')\nconst newObj = new resultBind3()\n```\n\n## call函数的实现\n```javascript\n// 对象属性指向函数并调用\n// 将函数引用到对象里\n// 调用函数\n// 删除对象里的函数\nFunction.prototype.call1 = function (context) {\n  context.fn = this // this 指向实例\n  context.fn()\n  delete context.fn\n}\n\nconst obj = {\n  value: 'cosyer',\n}\n\nfunction testCall() {\n  console.log(this.value)\n}\n\nconst resultCall = testCall.call1(obj) // cosyer\n\n// 传入函数的实现\nFunction.prototype.call2 = function (context) {\n  const arr = Array.prototype.slice.call(arguments, 1)\n\n  context.fn = this // this 指向实例\n  context.fn(...arr)\n  delete context.fn\n}\n\n// 测试:\nconst obj2 = {\n  value: 'cosyer',\n}\n\nfunction testCall2(age) {\n  console.log(this.value, age) // cosyer 23\n}\n\nconst resultCall = testCall2.call2(obj2, 23)\n```\n\n## 稀疏数组\n```javascript\nvar ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) { return x === undefined;}); // []\n// 3 - 9 都是没有初始化的'坑'!, 这些索引并不存在与数组中. 在 array 的函数调用的// 时候是会跳过这些'坑'的.\n```\n\n## switch严格比较\n```javascript\nfunction showCase(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase(new String('A')); // 'Do not know!'\n// switch 是严格比较, String 实例和 字符串不一样.\n\nfunction showCase2(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase2(String('A')); // 'Case A'\n// String 不仅是个构造函数 直接调用返回一个字符串哦.\n```\n\n## 为什么JS是单线程的\n> 与用途有关，JavaScript的主要用途是与用户互动，以及操作DOM\n> 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？\n\n为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。\n\n## 去重总集篇\n1. Set\n```javascript\n[...new Set([1,1,2,3])]\nArray.from(new Set([1,1,2,3]))\n```\n\n2. filter\n```javascript\n[1,1,2,3].filter((element,index,array)=>{\n  return array.indexOf(element) === index;\n})\n```\n\n3. Map\n```javascript\nvar set =new Set()\n[1,1,2,3].filter((item)=>{\nreturn !set.has(item)&&set.add(item)\n})\n// 一个道理\nvar map =new Map();\n[1,1,2,3].filter((item,index)=>{\nreturn !map.has(item)&&map.set(item,index)\n})\n\n4. 基础\n// 不使用es6,考虑到（ie6-8）indexOf兼容性问题\nfunction unique(arr) {\n  var ret = []\n  var hash = {}\n\n  for (var i = 0; i < arr.length; i++) {\n    var item = arr[i]\n    // typeof 区分 1 与 ‘1’\n    var key = typeof(item) + item\n    if (hash[key] !== 1) {\n      ret.push(item)\n      hash[key] = 1\n    }\n  }\n  return ret\n}\n```\n\n## 2对象\n```javascript\n(2).toString() // '2'\n2 .toString() // '2'\n[(1,2,3)] // [3]\n```\n\n## 斐波那契 js 实现\n```js\nfunction* fibo()\n{\n    let [pre,curr] = [0,1];\n    for(;;)\n    {\n        yield curr;\n        [pre,curr] = [curr,pre + curr];\n    }\n}\nfor(let i of fibo())\n{\n    if(i > 10000)\n    {\n        break;\n    }\n    console.log(i);\n}\n// 实现10000以内的数列\n```","tags":["整理"],"categories":["JS"]},{"title":"redux状态传播","url":"%2Freduxstate.html","content":"\n## Redux三大概念\n> Redux 是JavaScript状态容器，提供可预测化的状态管理\n\n> action 普通的JS对象描述发生什么\n\n> reducer 只是一个接收 state 和 action，并返回新的 state 的函数\n\nStore — 数据存储中心，同时连接着Actions和Views（React Components）。\n\n1. Store需要负责接收Views传来的Action\n2. 然后，根据Action.type和Action.payload对Store里的数据进行修改\n3. 最后，Store还需要通知Views，数据有改变，Views便去获取最新的Store数据，通过setState进行重新渲染组件（re-render）。\n\n### 三大原则\n\n1. 单一数据源\n\n整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。和根级的reducer,拆成多个reducer而不是多个store。\n\n2. State 是只读的\n\n唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。\n\n3. 使用纯函数来执行修改\n\n为了描述 action 如何改变 state tree ，你需要编写 reducers。传递数据 payload规范。\n\n当 state 变化时需要返回全新的对象，而不是修改传入的参数。\n\n--- \n<!-- more -->\n\n### api\n~~~javascript\n// API 是 { subscribe, dispatch, getState }。\nlet store = createStore(counter);\n\n// 可以手动订阅更新，也可以事件绑定到视图层。\nstore.subscribe(() =>\n  console.log(store.getState())\n);\n\n// 改变内部 state 唯一方法是 dispatch 一个 action。\n// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行\nstore.dispatch({ type: 'INCREMENT' });\n// 1\nstore.dispatch({ type: 'INCREMENT' });\n// 2\nstore.dispatch({ type: 'DECREMENT' });\n// 1\n~~~ \n\n不要再reducer里做以下操作保持纯净\n\n> 修改传入参数；\n\n> 执行有副作用的操作，如 API 请求和路由跳转；\n\n> 调用非纯函数，如 Date.now() 或 Math.random()。\n\n通过reducer修改数据带来的好处\n1. 数据拆解 => 通过定义多个reducerr对数据进行拆解访问或者修改，最终再通过combineReducers函数将零散的数据拼装回去。\n\n```javascript\nimport { combineReducers } from 'redux';\n\n// 叶子reducer\nfunction aReducer(state = 1, action) {/*...*/}\nfunction cReducer(state = true, action) {/*...*/}\nfunction eReducer(state = [2, 3], action) {/*...*/}\n\nconst dReducer = combineReducers({\n  e: eReducer\n});\n\nconst bReducer = combineReducers({\n  c: cReducer,\n  d: dReducer\n});\n\n// 根reducer\nconst rootReducer = combineReducers({\n  a: aReducer,\n  b: bReducer\n});\n```\n2. 数据不可变\n组件的生命周期函数shouldComponentUpdate进行判断是否有必要进行对该组件进行更新（即，是否执行该组件render方法以及进行diff计算）\n\n#### 维持应用的 state\n\n> 提供 getState() 方法获取 state；\n\n> 提供 dispatch(action) 方法更新 state；发送通知；\n\n> 通过 subscribe(listener) 注册监听器;\n\n> 通过 unsubscribe() 返回的函数注销监听器。\n\n纯函数是这样一种函数，即相同的输入，永远会得到相同的输出。\nstore.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。\n\n中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。\n\n```javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport createLogger from 'redux-logger';\nimport rootReducer from '../reducers';\n\n// store扩展\nconst enhancer = applyMiddleware(\n  thunk,\n  createLogger()\n);\n\nconst store = createStore(rootReducer, initialState, enhancer);\n```\n\n## react-redux\nRedux 本身和React没有关系，只是数据处理中心，是React-Redux让它们联系在一起。\n\nReact-Redux提供两个方法：connect和Provider。\n\n### connect\nconnect连接React组件和Redux store。connect实际上是一个高阶函数，返回一个新的已与 Redux store 连接的组件类。\n\n```javascript\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n```\n\nTodoList是 UI 组件，VisibleTodoList就是由 react-redux 通过connect方法自动生成的容器组件。\n\nmapStateToProps：从Redux状态树中提取需要的部分作为props传递给当前的组件。\nmapDispatchToProps：将需要绑定的响应事件（action）作为props传递到组件上。\n\n### Provide\nProvider实现store的全局访问，将store传给每个组件。\n原理：使用React的context，context可以实现跨组件之间的传递。\n\n## 使用 复杂性 数据交互 结构复杂繁琐 大型\n- \"如果你不知道是否需要 Redux，那就是不需要它。\"\n- \"只有遇到 React 实在解决不了的问题，你才需要 Redux。\"\n","tags":["redux"],"categories":["JS"]},{"title":"响应式网页设计","url":"%2Fresponsive.html","content":"\n## 什么是响应式网站\n\n响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。\n\n--- \n<!--more -->\n\n## 优点\n\n- 面对不同分辨率设备灵活性强\n- 能够快捷解决多设备显示适应问题\n\n## 缺点\n\n- 兼容各种设备工作量大，效率低下\n- 代码累赘，会出现隐藏无用的元素，加载时间加长\n- 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果\n- 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况\n\n## 实战\n\n谷歌教程用HTML5以及CSS3的媒体查询完成了一个响应式布局的demo，大家可以用不同的尺寸的设备，查看不同分辨率下的表现。也可以在控制台模拟各种设备，欢迎大家提出意见。\n\n在线地址：[http://dir.mydearest.cn/responsive/](http://dir.mydearest.cn/responsive/)","tags":["响应式"],"categories":["CSS"]},{"title":"有趣的摧毁页面","url":"%2Fdestory.html","content":"\n食用方法\n\n使用【上下左右键】来控制飞行器的运动\n\n使用【空格键】来发射导弹\n\n<a href=\"javascript:var%20KICKASSVERSION='2.0'; var%20s%20=%20document.createElement('script'); s.type='text/javascript'; document.body.appendChild(s); s.src='//hi.kickassapp.com/kickass.js'; void(0);\"> 点击开始摧毁 </a>\n\n---\n<!--more -->\n\n引入JS代码\n\n```javascript\n<a href=\"javascript:var%20KICKASSVERSION='2.0'; \nvar%20s%20=%20document.createElement('script'); \ns.type='text/javascript'; document.body.appendChild(s); \ns.src='//hi.kickassapp.com/kickass.js'; void(0);\"> 点击开始摧毁 </a>\n```\n页面崩溃\n- plan A\n```javascript\nvar total = \"\"; \nfor (var i = 0; i < 10000; i++) { \n    total = total + i.toString(); \n    history.pushState(0, 0, total); \n}\n\nwhile(true){\n  console.log('hello world');\n}\n\nfunction fn(){\n  fn();\n}\nfn();\n```\n- plan B (BitInt 出现后，不用死循环也能实现 CPU 100% 的效果)\n```js\n9n ** 9n ** 9n > 0\n```\n\n转动吧，风扇！！！\n\n## localstorage撑爆电脑硬盘\nhtml5的本地存储，相信大家都不陌生。将数据以二进制文件形式存储到本地，在当前应用得非常广泛。\nwindows下的chrome，localStorage存储于C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Local Storage文件夹中。但如果任由网页无限写文件，对用户硬盘的伤害可想而知，因而浏览器对其做了大小限制。\n\n对于一个域名+端口，PC端的上限是5M-10M之间，移动端是则不大于2.5M。\n\n详情请见[作为一个前端，可以如何机智地弄坏一台电脑？](http://litten.me/2015/07/06/hack-in-localstorage/)","tags":["优化"],"categories":["JS"]},{"title":"console控制台优化","url":"%2Fconsole.html","content":"\n谷歌开发者中心上面关于谷歌浏览器控制台console.log()的文档：\n\n|格式说明符|描述|\n|:---|---:|\n|%s|将值格式化为字符串。|\n|%d?or?%i|将值格式化为整数。|\n|%f|将值格式化为浮点值。|\n|%o|将值格式化为可扩展的DOM元素（如在元素面板中）。|\n|%O|将值格式化为可扩展的JavaScript对象。|\n|%c|根据您提供的CSS样式格式化输出字符串。|\n\n\\n是换行，可以将一个字符串设置成多行\n%c标记之后的内容使用对应样式，格式如 console.log(‘%c第一个样式%c第二个样式’,’css1′,’css2′); 如此对应\n样式和普通的css效果基本一致，可以设置文字颜色，背景颜色，字体大小，间距，边距等等。还支持部分css3高级效果。\n\n---\n<!-- more -->\n\n## 3D字体效果 Text\n\n```javascript\n<script>console.log(\"%c3D Text\",\" text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em\")</script>\n```\n\n## Colorful彩色背景 CSS\n\n```javascript\n<script>console.log(\"%cColorful CSS\",\"background: rgba(252,234,187,1);background: -moz-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%,rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -webkit-gradient(left top, right top, color-stop(0%, rgba(252,234,187,1)), color-stop(12%, rgba(175,250,77,1)), color-stop(28%, rgba(0,247,49,1)), color-stop(39%, rgba(0,210,247,1)), color-stop(51%, rgba(0,189,247,1)), color-stop(64%, rgba(133,108,217,1)), color-stop(78%, rgba(177,0,247,1)), color-stop(87%, rgba(247,0,189,1)), color-stop(100%, rgba(245,22,52,1)));background: -webkit-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -o-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: -ms-linear-gradient(left, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);background: linear-gradient(to right, rgba(252,234,187,1) 0%, rgba(175,250,77,1) 12%, rgba(0,247,49,1) 28%, rgba(0,210,247,1) 39%, rgba(0,189,247,1) 51%, rgba(133,108,217,1) 64%, rgba(177,0,247,1) 78%, rgba(247,0,189,1) 87%, rgba(245,22,52,1) 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fceabb', endColorstr='#f51634', GradientType=1 );font-size:5em\")</script>\n```\n\n## Rainbow彩虹字 Text\n\n```javascript\n<script>console.log('%cRainbow Text ', 'background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;');</script>\n```\n\n## 在Chrome控制台输出图片\n```javascript\n<script>console.log(\"%c\", \"padding:50px 700px;line-height:120px;background:url('http://wx1.sinaimg.cn/large/ba098b64ly1fjz4j8pju5j20p002sgm4.jpg') no-repeat;\");</script>\n```\n\n## 示例\n```javascript\n<script>\nconsole.log(\"%c%c源码作者%ccosyer chenyu@mydearest.cn\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\nconsole.log(\"%c%c网站地址%chttps://mydearest.cn\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\nconsole.log(\"%c%cgithub%https://github.com/cosyer\", \"line-height:26px;\", \"line-height:16px;padding:2px 6px;border-radius: 5px 0px 0px 5px;background:#35495e;color:#fff;font-size:12px;\", \"padding:2px 8px;background:#0093ff;color:#fff;line-height:16px;font-size:12px;border-radius: 0px 5px 5px 0px;\");\n</script>\n```\n\n- 未曾遗忘的青春\n```js\nfunction setConsole() {\nvar text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'this is console!';\nvar isOneLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\nvar author = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '未曾遗忘的青春';\n\nif (isOneLine) {\n    console.log('');\n    console.log('%c' + text + '  ---  ' + author, 'background-image: url(\\'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4gPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkIiBncmFkaWVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeDE9IjAuMCIgeTE9IjAuNSIgeDI9IjEuMCIgeTI9IjAuNSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzY2Y2NjYyIvPjxzdG9wIG9mZnNldD0iMjAlIiBzdG9wLWNvbG9yPSIjMzM5OTk5Ii8+PHN0b3Agb2Zmc2V0PSI0MCUiIHN0b3AtY29sb3I9IiNjY2NjOTkiLz48c3RvcCBvZmZzZXQ9IjYwJSIgc3RvcC1jb2xvcj0iIzk5Y2NmZiIvPjxzdG9wIG9mZnNldD0iODAlIiBzdG9wLWNvbG9yPSIjY2NjY2ZmIi8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjZmY5OWNjIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNncmFkKSIgLz48L3N2Zz4g\\');background-size: 100%;background-image: -webkit-gradient(linear, 0% 50%, 100% 50%, color-stop(0%, #66cccc), color-stop(20%, #339999), color-stop(40%, #cccc99), color-stop(60%, #99ccff), color-stop(80%, #ccccff), color-stop(100%, #ff99cc));background-image: -moz-linear-gradient(left, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);background-image: -webkit-linear-gradient(left, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);background-image: linear-gradient(to right, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);padding:20px 40px;color:#fff;font-size:12px;');\n    console.log('');\n} else {\n    console.log('%c' + text + '  ---  ' + author, 'background-image: url(\\'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4gPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJncmFkIiBncmFkaWVudFVuaXRzPSJvYmplY3RCb3VuZGluZ0JveCIgeDE9IjAuMCIgeTE9IjAuNSIgeDI9IjEuMCIgeTI9IjAuNSI+PHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzY2Y2NjYyIvPjxzdG9wIG9mZnNldD0iMjAlIiBzdG9wLWNvbG9yPSIjMzM5OTk5Ii8+PHN0b3Agb2Zmc2V0PSI0MCUiIHN0b3AtY29sb3I9IiNjY2NjOTkiLz48c3RvcCBvZmZzZXQ9IjYwJSIgc3RvcC1jb2xvcj0iIzk5Y2NmZiIvPjxzdG9wIG9mZnNldD0iODAlIiBzdG9wLWNvbG9yPSIjY2NjY2ZmIi8+PHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjZmY5OWNjIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0idXJsKCNncmFkKSIgLz48L3N2Zz4g\\');background-size: 100%;background-image: -webkit-gradient(linear, 0% 50%, 100% 50%, color-stop(0%, #66cccc), color-stop(20%, #339999), color-stop(40%, #cccc99), color-stop(60%, #99ccff), color-stop(80%, #ccccff), color-stop(100%, #ff99cc));background-image: -moz-linear-gradient(left, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);background-image: -webkit-linear-gradient(left, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);background-image: linear-gradient(to right, #66cccc 0%, #339999 20%, #cccc99 40%, #99ccff 60%, #ccccff 80%, #ff99cc 100%);padding:0;color:#fff;font-size:12px;');\n }\n}\n```\n\n- FBI WARNING (暂只支持 Chrome)\n```js\nconsole.log(`%c                                                                            \n                                                                            \n                                                                            \n                               %c FBI WARNING %c                                \n                                                                            \n                                                                            \n%c        Federal Law provides severe civil and criminal penalties for        \n        the unauthorized reproduction,distribution, or exhibition of        \n         copyrighted motion pictures (Title 17, United States Code,         \n        Sections 501 and 508). The Federal Bureau of Investigation          \n         investigates allegations of criminal copyright infringement        \n                 (Title 17, United States Code, Section 506).               \n                                                                            \n                                                                            \n                                                                            \n`,\n'background: #000; font-size: 18px; font-family: monospace',\n'background: #f33; font-size: 18px; font-family: monospace; color: #eee; text-shadow:0 0 1px #fff',\n'background: #000; font-size: 18px; font-family: monospace',\n'background: #000; font-size: 18px; font-family: monospace; color: #ddd; text-shadow:0 0 2px #fff'\n)\n```\n[FBI](http://cdn.mydearest.cn/blog/images/FBI.png)\n\n### 设计相关\n\n- https://icomoon.io/\n\n- https://zh-cn.cooltext.com/\n\n- https://www.logaster.cn/logo/#logos\n\n- http://www.logoko.com.cn/design\n\n- http://www.beipy.com/335.html","tags":["优化"],"categories":["JS"]},{"title":"微信小程序面试题","url":"%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98.html","content":"\n\n1、简单描述下微信小程序的相关文件类型？\n答：微信小程序项目结构主要有四个文件类型,如下：\n一、WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。\n二、WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，\n二、js 逻辑处理，网络请求\n三、json 小程序设置，如页面注册，页面标题及tabBar。\n四、app.json\n必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。\n五、app.js\n必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。\n六、app.wxss\n\n---\n<!-- more -->\n\n2、你是怎么封装微信小程序的数据请求的？\n答：\n一、将所有的接口放在统一的js文件中并导出\n二、在app.js中创建封装请求数据的方法\n三、在子页面中调用封装的方法请求数据\n3、有哪些参数传值的方法？\n答：\n一、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或onload的param参数获取。但data-名称不能有大写字母和不可以存放对象\n二、设置id 的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值\n三、在navigator中添加参数传值\n\n4、你使用过哪些方法，来提高微信小程序的应用速度？\n答：\n一、提高页面加载速度\n二、用户行为预测\n三、减少默认data的大小\n四、组件化方案\n\n5、小程序与原生App哪个好？ \n答： 小程序除了拥有公众号的低开发成本、低获客成本低以及无需下载等优势，在服务请求延时与用户使用体验是都得到了较大幅度  的提升，使得其能够承载跟复杂的服务功能以及使用户获得更好的用户体验。\n\n6、简述微信小程序原理？ \n答：微信小程序采用JavaScript、WXML、WXSS三种技术进行开发，从技术讲和现有的前端开发差不多，但深入挖掘的话却又有所不同。\n\nJavaScript：首先JavaScript的代码是运行在微信App中的，并不是运行在浏览器中，因此一些H5技术的应用，需要微信App提供对应的API支持，而这限制住了H5技术的应用，且其不能称为严格的H5，可以称其为伪H5，同理，微信提供的独有的某些API，H5也不支持或支持的不是特别好。\n\nWXML：WXML微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。\n\nWXSS：WXSS具有CSS的大部分特性，但并不是所有的都支持，而且支持哪些，不支持哪些并没有详细的文档。\n\n微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。\n\n小程序分为两个部分webview和appService。其中webview主要用来展现UI，appService有来处理业务逻辑、数据及接口调用。它们在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理\n\n7、分析下微信小程序的优劣势？\n答：\n优势：\n1、无需下载，通过搜索和扫一扫就可以打开。\n2、良好的用户体验：打开速度快。\n3、开发成本要比App要低。\n4、安卓上可以添加到桌面，与原生App差不多。\n5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程， 不能通过审查的小程序是无法发布到线上的。\n劣势：\n1、限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。\n2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如：幻灯片、导航。\n3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。\n4、依托于微信，无法开发后台管理功能。\n8、微信小程序与H5的区别？\n答：\n第一条是运行环境的不同\n传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。\n第二条是开发成本的不同\n只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG\n第三条是获取系统级权限的不同\n系统级权限都可以和微信小程序无缝衔接\n第四条便是应用在生产环境的运行流畅度\n长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立\n9、怎么解决小程序的异步请求问题？\n答：\n在回调函数中调用下一个组件的函数：\napp.js\n\nsuccess: function (info) {         \n             that.apirtnCallback(info)\n }\n\nindex.js\n\n onLoad: function () {\n    app.apirtnCallback = res => {\n     console.log(res) \n    }\n｝\n\n10、小程序的双向绑定和vue哪里不一样？\n答：\n小程序直接this.data的属性是不可以同步到视图的，必须调用：\n\nthis.setData({\n          noBind:true\n   })\n\n11、常用\n```javascript\n<form bindsubmit=\"formSubmit\">\n  <input value=\"{{address.name}}\" name=\"name\" placeholder=\"姓名\"/>\n  <input type=\"number\" name=\"phone\" value=\"{{address.phone}}\" placeholder=\"电话号码\"/>\n  <input name=\"detail\" value=\"{{address.detail}}\" placeholder=\"详细地址\"/>\n  <button form-type=\"submit\">保存</button>\n</form>\n // formData=e.detail.value value.name...\n // 诸如bindinput \n```\n\n12、生命周期\n### onLoad(Object query)\n页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。\n### onShow()\n页面显示/切入前台时触发。\n### onReady()\n页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。调用接口\n### onHide()\n页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。\n### onUnload()\n页面卸载时触发。如redirectTo或navigateBack到其他页面时。\n","tags":["小程序"],"categories":["知识"]},{"title":"JavaScript停止冒泡和阻止浏览器默认行为","url":"%2Fbubble.html","content":"\n## 防止冒泡\n\nw3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true\n\nstopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。\n\n---\n<!-- more -->\n\n## 阻止默认行为\n\nw3c的方法是e.preventDefault()，IE则是使用e.returnValue = false\n\npreventDefault它是事件对象(Event)的一个方法，作用是取消一个目标元素的默认行为。既然是说默认行为，当然是元素必须有默认行为才能被取消，如果元素本身就没有默认行为，调用当然就无效了。什么元素有默认行为呢？如链接`<a>`，提交按钮`<input type=”submit”>`等。当Event 对象的 cancelable为false时，表示没有默认行为，这时即使有默认行为，调用preventDefault也是不会起作用的。\n\n```javascript\n <!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n</head>\n<body>\n<div id=\"box\" style=\"width: 300px;height: 300px;background: pink;\">\n\t<input type=\"button\" name=\"按钮\" value=\"按钮\" id=\"btn\">\n</div>\n<script type=\"text/javascript\">\n\tvar box1=document.getElementById(\"box\");\n\tvar btn1=document.getElementById(\"btn\");\n\tbtn1.onclick=function(e){\n\t\talert(\"按钮\");\n\t\t//阻止冒泡；\n\t\tvar e=e|| window.event;\n\t\t//w3c取消冒泡\n\t\te.stopPropagation();\n\t\t//ie取消冒泡\n\t\t//判断他现在的状态，然后给他赋值true，\n\t\tif(typeof e.cancelBubble=='undefined'){\n\t\t\te.stopPropagation();\n\t\t}else{\n\t\t\te.cancelBubble=true;\n\t\t}\n\t}\n\tbox1.onclick=function(){\n\t\talert(\"div\");\n\t}\n\tdocument.body.onclick=function(){\n\t\talert(\"body\");\n\t}\n\tdocument.documentElement.onclick=function(){\n\t\talert(\"html\");\n\t}\n\tdocument.onclick=function(){\n\t\talert(\"document\");\n\t}\n</script>\n</body>\n</html>\n```","tags":["冒泡"],"categories":["JS"]},{"title":"侠之大者，为国接盘","url":"%2Fhouseprice.html","content":"\n{% centerquote %} \n炒房兴邦，实业误国\n{% endcenterquote %}\n\n---\n<!-- more -->\n\n近年来，房价成为了生活中重要的谈资和话题，几乎所有的聊天场合都会聊到房子，什么谁谁谁有几套房，不用工作每月靠房租过活。坐公交车上都是听到一些阿姨手里几套房，在手里在捂一会，转手卖给有刚需的年轻人，后悔没多买几套之类的话。\n\n房价的上涨，刚需不敢不买，等下去看不到希望，掏空了一家父母的过去和年轻人的未来，面对zf的货币超发引起的通货膨胀，却又无可奈何。房价再涨个3、4倍，分分钟GDP超过美国啊。现在基本的理财方式已经赶不上通货膨胀的速度了，眼看着手里的钱越来越不值钱，人人自危，都只能通过购房来保值。被zf逼的哪怕背上几十年的贷款也要坐上这趟车，给zf当几十年的免费劳动力来消化这巨大的泡沫。\n\n这个浮躁社会的高房价，让我们这些刚毕业工作几年的年轻人，要我们的青春和汗水给你们买单。现在的年轻人，怎么可能刚毕业就能积攒到买房的首付，被逼的去‘啃老’，掏空全家人的钱包，成为房奴。2017年前yz的房价大概7000/m2，恒大在年初当了一波地王2w/m2买了邗江中专那边的地后，各个楼盘开始疯长，在年底11月份购入1w/m2后，如今短短半年已经涨到了1.3w/m2。试想以100m2为例如果不早点买，就得平白无故多交20w的韭菜钱。房价降是不可能降的，这个牵扯到太多人和行业的利益，一旦崩盘了，其他行业也会受到影响，经济陷入低迷，zf不断地增发货币来救市。一线城市政府来主导市场看上去房价跌了，这也只是杯水车薪，高额的房价不断地在驱逐这所谓的低端人口，也是啊，毕竟要实现小康社会啊，让先富带动后富，实现共同小康，还是直接消灭低端人口容易些。房价的压力让现在的中国人充满着戾气、浮躁。上了车的人在嘲讽着没上车的人，一旦买了房，两者就成了对立面，高房价改变了人们的价值观。如今人们对于成功的标准定义有几辆车，几套房。现在各个城市推行的所谓吸引人才政策，不就是为了让人来接盘去库存么。\n\n房价带来了价值观的革命，中下层把买房当成了人生目标，中产把买房当成了支付手段，政府把卖地当作经济支柱，将企业债务转化成了居民债务。房价捆绑了经济、政治、户籍、教育、爱情、事业甚至社会地位，集万千宠爱于一身。随着房价越来越高，社会阶层出现固化趋势，多少年轻人的梦想倍房价无情碾压，多少家庭为了买房背上沉重的债务，多少爱情因为房价变得支离破碎，还有的夫妻为了多买套房选择离婚。而在房价面前我们崇尚的个人奋斗，不值一文。年轻人开始选择佛系，不再憧憬爱情，坚持和努力并没有什么卵用，开始相信投机的价值。金钱至上主义横行，勤劳致富成为了笑话，炒房的人成为了羡慕对象，所谓的梦想是多么的幼稚可笑。这个xx的时代，只要你买不起房救市没出息的男人。毕竟男生在婚姻当中是向下兼容，而女生是向上兼容的。现在的知乎上现在的男生为什么不追求女生、为什么现在的女孩子活得都很潇洒，男孩子确郁郁寡欢这类的问题比比皆是。毕竟女性才是消费的主力，那些商家们为了自己的利益，各种推出什么女神节等等之类的活动和营销号无底线地讨好女性发软文毒鸡汤，恶心至极。什么公主、女王、仙女，拜拜了您！大家又不是笨蛋，看透了资本主义生产方式，不想再沦为奴隶了，工作只会使自己越来越贫穷。劳动法就是个笑话，各种被所谓的企业文化所绑架，压榨干你的劳动力。员工和公司的关系很简单，你付给我钱，我帮你工作罢了，我们并不是一家人。永远不要试探人性的底线，没有完美的人。抱歉，中国特色社会主义的大饼我吃不下了。\n\n从古至今，中国还是没有发生什么大的变化，权利还是掌握在少部分人手里，层层剥削的金字塔结构，什么人民当家作主，到头来还不是被代表了。所谓的法律还不是为了维护阶级统治的利益。我国是领导人选举能全票通过的国家，神奇不神奇呵呵。一个个大腹便便的领导们，嘴上说着服务人民，背地里作者贪污腐败的行当。这年头都希望考公务员，公务员是什么，为人民服务。一个个都争着抢着去当人民的公仆，还不是为了铁饭碗、利益。在小城市里，都是靠关系，所谓的人情社会。有些人只是想听到他们想听到的话罢了，成年人的价值观一旦成型一般是很难改变的。国家开放二胎政策还不是为了拉动内需，劳动力不足，老龄化严重。现在地区间发展不平衡，中国就只有这北上广深等一线城市罢了，很多人背井离乡去这些大城市打工，这些人是去赚钱而不是来消费的，当地的zf是很讨厌的。春运很值得骄傲吗，你以为人人都愿意远离自己的家乡，在陌生的城市中打拼吗？这些繁华都与自己无关。很久之前被教导不乱扔垃圾，可现实是如果大家都不乱扔垃圾了，那些环卫工人们是真的会失业的，资本家会让人白白领一份工资么？答案当然是不会的，他们宁可把过剩的商品都愿意倒掉销毁，也不愿意救济贫民，扰乱消费市场。中国有着最大的局域网，保护本国的互联网产品的利益，没什么创新，都是对标国外的产品。除了抄袭还是抄袭，科研没有实际的成果都只是为了骗取国家的补贴。\n\n这年头的幼儿教育也是问题不断。应试教育也就算了，再怎么培养也是考试型人才。为了不让自己的孩子输在起跑线，给孩子报了大大小小的培训班。中国大多数父母都不希望自己的孩子是个“普通学生”，而是希望孩子能像别人家的孩子一样能考进名牌大学（被国家归为 211 或者 985 的大学），但事实上每年能挤过高考独木桥考取 211/985 的孩子有多少呢？ 全国平均下来大约是 7% 。对 93% 的学生和家长来说，十几年来他们承受着巨大的压力，最后却几乎可以说在“读书”上是失败的。我们的学校除了教学生读书还教他们什么呢？\n\n不论社会如何变化动荡，大家只想守护好自己的小小幸福罢了。\n\n","tags":["房价"],"categories":["杂谈"]},{"title":"JavaScript深入之执行上下文","url":"%2Fcontext.html","content":"\n## 变量/函数提升(函数及变量的声明都将被提升到函数的最顶部，且函数声明在变量声明上边)\n\n```javascript\nif(!(\"a\" in window)){ // false\n    var a=1;\n}\nconsole.log(a) // undefined\n// if(o.x){} // 不能判断属性存不存在 假值undefine,null,false,\" \",0或NaN\n```\n\n```javascript\nfunction foo() {\n    console.log('foo1');\n}\n\nfoo();  // foo2\n\nfunction foo() {\n    console.log('foo2');\n}\n\nfoo(); // foo2\n---\nvar getName = function () { alert (4);};\nfunction getName() { alert (5);}\ngetName(); // 4\n---\nfunction getName() { alert (5);}\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\ngetName(); // 4\n```\n函数表达式执行的优先级==!主要原因是函数声明都被提前了，所以函数表达式在最后会覆盖。\n\nJavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。插槽slot\n可执行代码的类型：全局代码、函数代码、eval代码。\nJavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文\n\n--- \n<!-- more -->\n\n为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：\n\n```javascript\nECStack = [];\n```\n\n试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：\n\n```javascript\nECStack = [\n    globalContext\n];\n```\n\n现在 JavaScript 遇到下面的这段代码了：\n\n```javascript\nfunction fun3() {\n    console.log('fun3')\n}\n\nfunction fun2() {\n    fun3();\n}\n\nfunction fun1() {\n    fun2();\n}\n\nfun1();\n```\n\n当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码：\n\n```javascript\n// 伪代码\n\n// fun1()\nECStack.push(<fun1\\> functionContext);\n\n// fun1中竟然调用了fun2，还要创建fun2的执行上下文\nECStack.push(<fun2\\> functionContext);\n\n// 擦，fun2还调用了fun3！\nECStack.push(<fun3\\> functionContext);\n\n// fun3执行完毕\nECStack.pop();\n\n// fun2执行完毕\nECStack.pop();\n\n// fun1执行完毕\nECStack.pop();\n\n// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext\n```\n\n```js\nfunction a() {\n    var value = 'local scope'\n    function b() {\n        console.log(value)\n    }\n    return b()\n}\na()\nfunction a() {\n    var value = 'local scope'\n    function b() {\n        console.log(value)\n    }\n    return b\n}\na()()\n```\n分析如下👁：\n```js\n// a()执行的时候，创建执行上下文入栈\nECsatck.push(<fun\\> a)\n// 函数a遇到b可执行函数，执行b函数创建可执行上下文入栈\nECstack.push(<fun\\> b)\n// 后进先出原则b执行完出栈\nECstack.pop()\n// a执行完出栈\nECstack.pop()\n\n第二段代码\n\n// a()执行的时候，创建执行上下文入栈\nECsatck.push(<fun\\> a)\n// a执行完后返回了b函数，注意这里没有直接执行而是直接返回了b,所有没有创建b函数的上下文，a执行完直接出栈\nECstack.pop() //a出栈\n// 在外部返回的b函数被执行， 创建b的执行上下文，压入栈，\nECstack.push(<fun\\> b)\n// b执行完出栈\nECstack.pop()\n```\n\n## 三大属性\n- 变量对象\n- 作用域链\n- this\n\n## 全局对象\n{% note info %}\n\n全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。\n\n{% endnote %}\n\n{% note info %}\n\n例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。\n\n{% endnote %}\n\n```javascript\n// 在浏览器客户端 全局对象就是window对象\n// 通过this引用\nthis === window  // true\nthis.window === window // true\nthis instanceof Object // true 是通过Object构造函数实例出来的对象\nMath.random() \nthis.Math.random() // 预定义了一些函数和属性\n\n// window指向自身\nvar a=1;\na // 1\nthis.a // 1\nwindow.a // 1 \nthis.window.a // 1\n```\n\n## 函数声明>变量声明\n\n```javascript\nconsole.log(foo); // 打印函数\n\nfunction foo(){\n    console.log(\"foo\");\n}\n\nvar foo = 1;\n```\n执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。","tags":["上下文"],"categories":["JS"]},{"title":"JS执行顺序-函数声明提升、匿名函数、函数表达式","url":"%2FexecutionOrder.html","content":"\n{% centerquote %} \n JS 是按照`代码块`进行 编译、执行 的。\n{% endcenterquote %}\n\n---\n<!-- more -->\n## script标签区分代码块\n```javascript\n<script>\n  alert('代码块一');\n</script>\n<script>\n  alert('代码块二');\n</script>\n```\n\n## 关于函数(声明式函数、赋值型（函数表达式）函数、匿名函数、自执行函数)\n### 函数提升\n`声明函数与赋值函数的区别在于： 在 JS 的预编译期间，声明式函数会被先提取出来，然后才按照顺序执行 JS代码。`\n\n```javascript\nA();  // 'A '\nfunction A() {\n  console.log('A');\n}\n\nB(); // error， B is not a function\nvar B = function() {\n  console.log('B');\n}\n```\n\n### 匿名函数（没有名字的函数）\n```javascript\nfunction() {} // 匿名函数\n```\n\n### 自执行函数\n```javascript\n(function() {\n  console.log(3);\n})();\n\n// 带参数\n(function(num){\n  console.log(num);\n})(3); // 3\n\n// 没有括号会报错 如下\nfunction() {\n  console.log(3);\n}();\n```\n原因如下：\n- function {}()其实这是一个函数声明。\n- JS运行的时候，会对函数声明进行预编译，然后在执行其他语句。\n- 也就是说function(){}先被预编译了。然后JS看见了()。JS一脸懵逼，这不得报错吗。\n- 而匿名函数实际上是一个语句，正常执行。\n\n自执行函数的标识也可以是\n```javascript\n!function(){}()      (function(){})()    \n~function(){}()      void function(){}()\n```\n\n## 预编译期和执行期\n{% note info %}\nJS的解析分为两个阶段：预编译 和 执行期。\n{% endnote %}\n- 预编译期间：对本代码块中的所有声明变量和函数进行处理(类似于C语言的编译) ，但需要注意，1.此时处理函数的只是 声明式函数2.变量也只是进行了声明但是没有进行初始化和赋值\n- 编译期间：从上到下编译代码块。\n\n### 函数声明提前且后来居上覆盖\n```javascript\ngetName(); // 6\nfunction getName() { alert (5);}\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\n\n---\nvar getName = function () { alert (4);};\nfunction getName() { alert (6);}\ngetName(); // 4 函数声明都被提升了，表达式会覆盖掉\n```\n\n### 练习题\n```javascript\nfunction Foo() {\n    // 全局变量\n    getName = function () { alert (1); };\n    return this;\n}\nFoo.getName = function () { alert (2);};\nFoo.prototype.getName = function () { alert (3);};\nvar getName = function () { alert (4);};\nfunction getName() { alert (5);} // 函数提升 JavaScript永远不会有函数重载\n \n//请写出以下输出结果：\nFoo.getName(); // 2\ngetName();  // 4\nFoo().getName(); // 1 覆盖了函数表达式\ngetName(); // 1\nnew Foo.getName(); // 2 new (Foo.getName)()\nnew Foo().getName(); // 3 (new Foo()).getName();\n```\n\n## ES6之前，JS没有变量作用域。只有 函数作用域 和 全局作用域。\n```javascript\n{\n  var a = 3;\n}\nconsole.log(a); // 3\n---\n{\n  let a = 3;\n}\nconsole.log(a); // error\n```","tags":["知识"],"categories":["JS"]},{"title":"JavaScript深入之作用域","url":"%2Fscope.html","content":"\n## 作用域\n\n作用域指的是程序源代码中定义变量的区域\n\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n\nJavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。\n\n**函数的作用域在函数定义的时候就决定了，函数的作用域基于函数创建的位置。**\n\n---\n<!-- more -->\n\n```javascript\nvar value=1\nfunction print(){\n  console.log(value)\n}\nfunction foo(){\n  var value=2\n  print()\n}\nfoo() // value 1 如果是动态作用域则是2\n```\n我们再来看两道题：\n\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();\n```\n\n```javascript\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope = \"local scope\";\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();\n```\n两道题的执行结果都是 \"local scope\"\n\nJavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。\n\n```javascript\nvar name=\"999999\"\nvar b = {\nname :\"The Window\",\nobject:{\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n                return this.name\n              }\n　　　　}\n　　}\n}\nconsole.log(b.object.getNameFunc()()) // 999999\n---\nvar name=\"999999\"\nvar b = function(){\nvar name = \"The Window\";\n　　var object = {\n　　　　name : \"My Object\",\n　　　　getNameFunc : function(){\n \n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n　　　　}\n　　};\n　console.log(object.getNameFunc()())\n}\nb() // 999999\n```","tags":["作用域"],"categories":["JS"]},{"title":"JavaScript深入之从原型到原型链","url":"%2Fprototype.html","content":"\n{% centerquote %} \n 原型对象的用途是为每个实例对象存储共享的方法和属性，它仅仅是一个普通对象而已，仅有一份。\n{% endcenterquote %}\n\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，\n如果这个对象内部不存在这个属性，那么它就会去prototype里找这个属性，这个prototype又会有自己的prototype，\n于是就这样一直找下去，也就是我们平时所说的原型链的概念\n\n## 构造函数创建对象\n\n我们先使用构造函数创建一个对象：\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nperson.name = \"cosyer\";\nconsole.log(person.name); // cosyer\n```\n\n在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。\n\n---\n\n<!-- more -->\n\n很简单吧，接下来进入正题：\n\n### prototype\n\n每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：\n\n```javascript\nfunction Person() {}\n// prototype是函数才会有的属性\nPerson.prototype.name = \"cosyer\";\nvar person1 = new Person();\nvar person2 = new Person();\nconsole.log(person1.name); // cosyer\nconsole.log(person2.name); // cosyer\n```\n\n那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？\n\n其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。\n\n那什么是原型呢？你可以这样理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。\n\n让我们用一张图表示构造函数和实例原型之间的关系：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype1.png)\n\n在这张图中我们用 Object.prototype 表示实例原型。\n\n那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性：\n\n### **proto**\n\n为了证明这一点,我们可以在火狐或者谷歌中输入：\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n```\n\n于是我们更新下关系图：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype2.png)\n\n既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？\n\n### constructor\n\n指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。\n\n为了验证这一点，我们可以尝试：\n\n```javascript\nfunction Person() {}\nconsole.log(Person === Person.prototype.constructor); // true\n```\n\n所以再更新下关系图：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype3.png)\n综上我们可以得出：\n\n```javascript\nfunction Person() {}\n\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype); // true\nconsole.log(Person.prototype.constructor == Person); // true\n// 顺便学习一个ES5的方法,可以获得对象的原型 实例原型的constructor指向构造函数,构造函数的prototype指向实例原型,实例对象的__proto__指向实例原型,实例原型也是对象,它也有原型 最后的一个环节是null。访问实例对象的constructor时,也能从实例原型上去找,从而指向到构造函数。\nconsole.log(Object.getPrototypeOf(person) === Person.prototype); // true\n```\n\n## 实例与原型\n\n当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n\n举个例子：\n\n```javascript\nfunction Person() {}\n\nPerson.prototype.name = \"cosyer\";\n\nvar person = new Person();\n\nperson.name = \"Daisy\";\nconsole.log(person.name); // Daisy\n\ndelete person.name;\nconsole.log(person.name); // cosyer\n```\n\n在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。\n\n但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.\\_\\_proto\\_\\_ ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 cosyer。\n\n但是万一还没有找到呢？原型的原型又是什么呢？\n\n## 原型的原型\n\n在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：\n\n```javascript\nvar obj = new Object();\nobj.name = \"cosyer\";\nconsole.log(obj.name); // cosyer\n```\n\n其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 **proto** 指向构造函数的 prototype ，所以我们再更新下关系图：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype4.png)\n\n## 原型链\n\n那 Object.prototype 的原型呢？\n\nnull，我们可以打印：\n\n```javascript\nconsole.log(Object.prototype.__proto__ === null); // true\n```\n\n然而 null 究竟代表了什么呢？\n\n引用阮一峰老师的 《undefined 与 null 的区别》 就是：\n\nnull 表示“没有对象”，即该处不应该有值。\n\n所以 Object.prototype.**proto** 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。\n\n所以查找属性的时候查到 Object.prototype 就可以停止查找了。\n\n最后一张关系图也可以更新为：\n![prototype](http://cdn.mydearest.cn/blog/images/prototype5.png)\n\n图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。\n\n## 补充\n\n### constructor\n\n```javascript\nfunction Person() {}\nvar person = new Person();\nconsole.log(person.constructor === Person); // true\n```\n\n当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\n\n```javascript\nperson.constructor === Person.prototype.constructor;\n```\n\n### **proto**\n\n其次是 **proto** ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.**proto** 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n\n### 继承\n\n最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n\n- class 的引入只是语法糖本身还是基于原型的\n- 几乎所有 JavaScript 中的对象都是位于原型链顶端的Object的实例。\n\n```javascript\nclass Cat {\n    say() {\n        console.log(\"meow ~\");\n    }\n}\n\n// 等价于\nfunction Cat() {}\nObject.defineProperty(Cat.prototype, \"say\", {\n    value: function() { console.log(\"meow ~\"); },\n    enumerable: false,\n    configurable: true,\n    writable: true\n});\n\n// es6 class是没有静态属性的 只有静态方法\nvar cat = new Cat();\ncat.say(); // meow~\nCat.say(); // error 加上static修饰正确  \n\n// 注解\nfunction isAnimal(target) {\n    target.isAnimal = true;\n  \treturn target;\n}\n@isAnimal\nclass Cat {\n    ...\n}\n// 等价于\nCat=isAnimal(function Cat(){})\n\nconsole.log(Cat.isAnimal);    // true\n```\n\n### 描述符\n- Configurable 特性\nconfigurable 特性表示对象的属性是否可以被删除，以及除 writable 特性外的其他特性是否可以被修改。\n\n- Enumerable 特性\n属性特性 enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。\n\n- Writable 属性\n当属性特性（property attribute） writable 设置为false时，表示 non-writable，属性不能被修改。\n\n\n```javascript\nvar p = Object.create(o);\n// p是一个继承自 o 的对象\n对象的原型链\no===>Object.prototype===>null\n数组的原型链\na===>Array.prototype===>Object.prototype===>null\n函数的原型链\nf===>Function.prototype===>Object.prototype===>null\n```\n\n### 原型对象的添加属性\n```javascript\nfunction Persion(){}\nPersion.prototype.sayName=function(){\n  console.log('darling')\n}\n// Persion.prototype={\n//   sayName:function(){\n//     console.log('darling')\n//   } \n// }\nlet persion =new Persion()\npersion.sayName() // darling\n\nfunction Persion(){}\nlet persion=new Persion()\n// 这里重写了原型对象，实例对象和最初的原型对象断开了联系\n// persion的proto指向一个空对象\nPersion.prototype={\n  sayName:function(){\n    console.log('darling')\n  } \n}\npersion.sayName() // error\n```\n\n### new 操作符具体干了什么\n1. 创建空对象，并且this变量引用该对象同时继承该函数的原型\n2. 属性和方法加入到this引用的对象中\n3. 新创建的对象用this引用，并且隐式地返回this\n\n1. 创建一个新对象(\\_\\_proto\\_\\_ 指向构造函数的prototype)\n2. 把作用域（this）指给这个对象\n3. 执行构造函数的代码\n4. 返回这个对象\n\n```javascript\nfunction Base(){\n  this.id = \"base\";\n}\nvar obj = new Base();\n```\n**new干了什么？** \n\n1.var obj = {};\n\n2.obj.\\_\\_proto\\_\\_ = Base.protptype;\n\n3.Base.call(obj);\n\n- es5使用Object.create()来创建对象 new Object() 字面量写法{}\n使用Object.create()是将对象继承到__proto__属性上，\nObject.create(null)没有继承任何原型方法，也就是说它的原型链没有上一层。\n- es6使用class关键字\n\n- 构造器就是普通的函数,new来作用称为构造方法(构造函数)\n\n- 访问原型链会损耗性能,不存在的属性会遍历原型链直到最后一层\n\n- hasOwnProperty 是 JavaScript 中唯一处理属性并且不会遍历原型链的方法。通常在for in循环中使用。\n","tags":["原型链"],"categories":["JS"]},{"title":"你所不知道的前端冷门小知识(长期更新)","url":"%2Fsmallknowledge.html","content":"\n[javascript-puzzlers](http://javascript-puzzlers.herokuapp.com/)\n\n## void \nvoid其实是javascript中的一个函数，接受一个参数，返回值永远是undefined\nvoid expression\n\n```javascript\nvoid 0  \nvoid() // 报错\nvoid (0)  \nvoid \"hello\"  \nvoid (new Date())  \n// all will return undefined  \ncontext === void 666\n```\n\n---\n<!-- more -->\n\n## Element.scrollIntoViewIfNeeded\nElement.scrollIntoViewIfNeeded()方法用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。\n ```javascript\nelement.scrollIntoViewIfNeeded(); // 等同于element.scrollIntoViewIfNeeded(true) \nelement.scrollIntoViewIfNeeded(true); \nelement.scrollIntoViewIfNeeded(false);\n ```\n- 当元素已经在可视区域时，调用 Element.scrollIntoView()，无论设置什么参数，均发生滚动。\n- 当元素已经在可视区域时，调用 Element.scrollIntoViewIfNeeded()，无论设置什么参数，均不发生滚动。\n\n## JS取整数部分\n\n```javascript\n~~2.5 // 2 按位取反 -2^31~2^31-1 -2147483648~2147483647\n2147483647 >> 0; // => 2147483647\n2147483648 >> 0; // => -2147483648\n2147483649 >> 0; // => -2147483647\n\n0|3.123;// 3 或运算\n4.3|0; // 4\n4.3<<0; // 4\n```\n\n与Math.floor()的对比\n\n|区别|Math.floor|~~|\n|:---|:---:|---:|\n|NaN|NaN|0|\n|+0|+0|0|\n|-0|-0|0|\n|+Infinity|+Infinity|0|\n|-Infinity|-Infinity|0|\n|1.2|1.2|1.2|\n|-1.2|-1|-1|\n\n```javascript\n1. 位运算：~ 的结果是 int32 的有符号整数，所以肯定不可能是 NaN 和无穷 x|0 x^0 x<<0 x>>0\n\n2. Math.floor向下取整 Math.ceil向上取整 Math.trunc返回整数部分 实现：if(value>0){return Math.floor(value)}else{return Mathg.ceil(value)}\n\n3. parseInt(string, radix);\n\nparseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。\n\nparseInt 解析字符串 '-0' 会得到 -0。如果参数是数字 -0，会得到 0。\n\n4. function trunc(num) {\n  if(num >= 0) return Math.floor(num);\n  return Math.ceil(num);\n}\n\n5. function trunc(num) {\n  return num - num % 1;\n}\n```\n\n> 在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：\n> 如果字符串 string 以\"0x\"或者\"0X\"开头, 则基数是16 (16进制).\n> 如果字符串 string 以\"0\"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个\n> 基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个\n> 规定。因此，永远都要明确给出radix参数的值。\n> 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。\n\n```javascript\nparseInt(0.0000000003) // 3\n\nparseInt('2017-07-04') // 2017\n\nparseInt(\"010\");\t// 8\nparseInt(\"010\", 8);\t// 8\nparseInt(\"010\", 10); // 10\n```\n\n- parseFloat(string)\n它的规则与parseInt基本相同，但也有点区别：字符串中第一个小数点符号是有效的，另外parseFloat会忽略所有前导0，如果字符串包含一个可解析为整数的数，则返回整数值而不是浮点数值。\n```js\nparseInt(\"0xA\") // 10\nparseFloat(\"0xA\") // 0\n\nparseInt(\".1\") // NaN\nparseFloat(\".1\") // 0.1\n\n```\n\n## js取小数部分\n```js\nfunction fract(num) {\n  return num - Math.trunc(num);\n}\n\nconsole.log(fract(3.75)); // 0.75\nconsole.log(fract(-3.75)); // -0.75\n\nconsole.log(3.75 % 1); // 0.75\nconsole.log(-3.75 % 1); // -0.75\n```\n\n## JS浮点数运算(原因浮点数无法用二进制准确表示)\n\n```javascript\n0.1+0.2 // 0.30000000000000004\n1. parseFloat().toFixed() \n2. *100/100 \n```\n\n## Object.toString()\n```javascript\nvar a = {name:'cosyer'}\na.toString() // [object Object] [typeof a instanceof a]\n// 除了Object其他对象需要用call返回真正的类型信息\n```\n## 全等判断\njavascript 中 +0 完全等于 -0，那么怎么分区两者呢？\n\n```javascript\n1/0 === 1/-0 // false \n+0 === -0 // true\nObject.is(+0,-0) // false\n```\n区分NaN\n\n```javascript\nNaN !== NaN // true\nNaN === NaN // false \nObject.is(NaN,NaN) // true\n```\n\n## 判断NaN\n```js\nNumber.isNaN(); // true\nx!==x // =>NaN false\n// {}!=={} []!==[]\n```\n\n## isFinite\n判定一个数字是否是有限数字(如果参数是 NaN，正无穷大或者负无穷大，会返回false，其他返回 true)\n```js\nisFinite(Infinity);  // false\nisFinite(NaN);       // false\nisFinite(-Infinity); // false\nisFinite(0);         // true\nisFinite(2e64);      // true, 在更强壮的Number.isFinite(null)中将会得到false\nisFinite(\"0\");       // true, 在更强壮的Number.isFinite('0')中将会得到false\n```\n\n## try-catch跳出forEach循环\nforEach遍历不能保证遍历的顺序，以及不能break;一般for循环的性能是forEach的20倍\n\n```javascript \ntry {\n    [1, 2, 3].forEach(v => {\n        if (v === 2) {\n            throw new Error('my err')\n        }\n    })\n} catch (e) {\n    if (e.message === 'my err') {\n        console.log('breaked') \n    } else {\n        throw e\n    }\n}\n\n// 用some也可以在遍历中跳出循环\n[1,2,3].some((item)=>{\n\tconsole.log(item)\n  return item === 2 // 如果item等于2就跳出循环\n})\n```\n\n## fetch模拟post进行api测试\n```javascript\nfetch(apiUrl, {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({q: 1})\n}).then(async res => console.log(await res.json()))\n```\n\n## 实现var a = add(2)(3)(4) 函数柯里化\njs中console.log一个对象时，会对这个对象进行toString()操作，还有些情况会对对象进行valueOf()操作\nvauleOf优先于toString()被调用\n\n```javascript\nfunction add(num){\n    var _add = function(args){\n        num+=args;\n        return arguments.callee; //  return add(num+args);\n        // 现在已经不推荐使用arguments.callee();推荐这样写var _add = (function foo(args){num+=args return foo;})\n        // 原因：访问 arguments 是个很昂贵的操作，因为它是个很大的对象，每次递归调用时都需要重新创建。影响现代浏览器的性能，还会影响闭包。\n    }\n    _add.toString = _add.valueOf = function(){\n        return num;\n    }\n    return _add;\n}\nadd(2)(3)(4);// function 9\n+add(2)(3)(4) // 9\nadd(2)(3)(4)+'' // '9'\n```\n\n## 阶乘\n```javascript\nfunction factorial(num){    \n   if (num <=1) {         \n      return 1;     \n   } else {         \n   return num * factorial(num-1)     \n   } \n} \n// 定义阶乘函数一般都要用到递归算法；如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。 \n// 但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee\n// arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，返回正被执行的 Function 对象，\n// 也就是所指定的 Function 对象的正文，这有利于匿名函数的递归或者保证函数的封装性。 \n\nfunction factorial(num){    \n   if (num <=1) {         \n      return 1;     \n   } else {         \n   return num * arguments.callee(num-1);\n   } \n}\n\nvar trueFactorial = factorial;\nfactorial = function() {\n    return 0;\n}                \nalert(trueFactorial(5));// 120 如果没有使用arguments.callee，将返回0\n```\n\n## arguments.callee的替换方案\n```javascript\nfunction show(n) {\n    var arr = [];\n    return (function () {\n        arr.unshift(n);\n        n--;\n        if (n != 0) {\n            arguments.callee();\n        }\n        return arr;\n    })()\n}\nshow(5)//[1,2,3,4,5]\n\n// 给内部函数一个名字（当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用。）\nfunction show(n) {\n    var arr = [];\n    return (function fn() {\n        arr.unshift(n);\n        n--;\n        if (n != 0) {\n            fn();\n        }\n        return arr;\n\n    })()\n}\nshow(5)//[1,2,3,4,5]\n```\n\n## Date相关 \n\n### Date构造函数\n```javascript\n4种表示时间戳的方式\n1. Date.now()\n2. new Date().getTime()\n3. +new Date() / +new Date +相当于.valueOf();\n4. new Date().valueOf()\n5. new Date*1 / new Date()*1 \n\n解释：JavaScript中可以在某个元素前使用'+'号，这个操作是将该元素转换秤Number类型，如果转换失败，那么将得到 NaN。\n所以 +new Date 将会调用 Date.prototype 上的 valueOf 方法，而根据MDN，Date.prototype.value 方法等同于 Date.prototype.getTime()\n\nDate.parse(\"2018-06-13\") === new Date(\"2018-06-13\").getTime()\n// 浏览器之间解析时间不同 safari 解析横杠 - 会出错所以尽量用斜杠 /\n```\n### 当前时间\n```javascript\nlet d = new Date()\nlet year=d.getFullYear();\nlet month=d.getMonth()+1; // 月份索引从0开始\nlet day=d.getDate(); // getDay()用于获取星期\nlet hour=d.getHours();\nlet minute=d.getMinutes();\nlet second=d.getSeconds();\nconsole.log(`${year}-${month}-${day} ${hour}:${minute}:${second}`) // 2018-6-13 21:20:48\n// 不足2位数补0\nconsole.log([year, month, day].map((item)=>{\n        item = item.toString();\n    return item[1] ? item : \"0\" + item;\n}).join(\"-\") +\" \" +[hour, minute, second].map((item)=>{\n        item = item.toString();\n    return item[1] ? item : \"0\" + item;\n}).join(\":\"))  // 2018-06-13 21:20:48\n```\n### Date计时\n以博客存活时间为例\n\n```javascript\nvar time = new Date(); \nvar t = \"博客存活了\"+Math.floor((+new Date - 1527868800000) / (1000 * 60 * 60 * 24)) + \"天\" + time.getHours() + \"小时\" \n+ time.getMinutes() + \"分\" + time.getSeconds() + \"秒\"; \n// 博客存活了11天 21小时28分51秒 1527868800000当时的时间转的时间戳 new Date(1527868800000).toLocaleString() \"2018/6/2 上午12:00:00\"\n```\n\n### Date原型扩展方法\n```javascript\nDate.prototype.format = function (format) {\n\t\t\tvar o = {\n\t\t\t\t\t\"M+\": this.getMonth() + 1,\n\t\t\t\t\t\"d+\": this.getDate(),\n\t\t\t\t\t\"h+\": this.getHours(),\n\t\t\t\t\t\"m+\": this.getMinutes(),\n\t\t\t\t\t\"s+\": this.getSeconds(),\n\t\t\t\t\t\"q+\": Math.floor((this.getMonth() + 3) / 3),\n\t\t\t\t\t\"S\": this.getMilliseconds()\n\t\t\t};\n\t\t\tif (/(y+)/.test(format)) {\n\t\t\t\t\tformat = format.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n\t\t\t}\n\t\t\tfor (var k in o) {\n\t\t\t\t\tif (new RegExp(\"(\" + k + \")\").test(format)) {\n\t\t\t\t\t\t\tformat = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn format;\n\t};\n\n\tDate.prototype.addDays = function (d) {\n\t\t\tthis.setDate(this.getDate() + d);\n\t};\n\n\tDate.prototype.addWeeks = function (w) {\n\t\t\tthis.addDays(w * 7);\n\t};\n\n\tDate.prototype.addMonths = function (m) {\n\t\t\tvar d = this.getDate();\n\t\t\tthis.setMonth(this.getMonth() + m);\n\t\t\t//if (this.getDate() < d)\n\t\t\t//  this.setDate(0);\n\t};\n```\n\n## 页面加载时间\n```javascript\nwindow.onload = function () {\n  var loadTime = window.performance.timing.domContentLoadedEventEnd-window.performance.timing.navigationStart; \n  console.log('Page load time is '+ loadTime);\n}\n// DOMContentLoad是HTML文档被加载和解析完成后触发\n```\nonload和onready的区别：\n\n1. 执行时间\n\n　　window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 \n\n　　$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。\n\n2. 编写个数不同\n\n　　window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个。\n\n　　$(document).ready()可以同时编写多个，并且都可以得到执行。\n\n3. 简化写法\n\n　　window.onload没有简化写法。\n\n　　$(document).ready(function(){})可以简写成$(function(){});\n\n## 常用标签\n```javascript\n<meta charset=\"utf-8\">\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"Content-Type\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\">\n<link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\" />\n// seo\n<title></title>\n<meta name=\"author\" name=\"cosyer\">\n<meta name=\"keywords\" name=\"cosyer\">\n<meta name=\"description\" name=\"cosyer\">\n<link rel=\"stylesheet\" href=\"\">\n<script src=\"\"></script>\n```\n\n## 获取url参数\n```javascript\nlet reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\")\nlet r = window.location.search.substr(1).match(reg)\nif (r != null) return decodeURIComponent(r[2]) // encodeURIComponent()\nreturn null\n```\n\n## String原型方法扩展\n```javascript\n// 连字符转驼峰\nString.prototype.hyphenToHump = function () {\n\t\treturn this.replace(/-(\\w)/g, function () {\n\t\t\t\treturn arguments[1].toUpperCase()\n\t\t})\n}\n\n// 连字符转驼峰 简单版本\n// 假设分隔符有_和-两种\nfunction camel(str) {\n  let cut = ['_', '-'];\n  let ar = str.split('');\n  let l = ar.length;\n  let flag = false;\n  for(let i = 0;i < l;i++) {\n    let cur = ar[i];\n    if(cut.indexOf(cur) !== -1) {\n      ar[i] = '';\n      flag = true;\n    } else if(flag) {\n      ar[i] = ar[i].toUpperCase();\n      flag = false;\n    }\n  }\n  return ar.join('');\n}\n\n// 驼峰转连字符\nString.prototype.humpToHyphen = function () {\n\t\treturn this.replace(/([A-Z])/g, \"-$1\").toLowerCase()\n}\n```\n\n## 拦截控制台、右键和F12\n```javascript\ndocument.onkeydown = function () {\n        var e = window.event || arguments[0];\n        //屏蔽F12\n        if (e.keyCode == 123) {\n                return false;\n                //屏蔽Ctrl+Shift+I\n        } else if ((e.ctrlKey) && (e.shiftKey) && (e.keyCode == 73)) {\n                return false;\n                //屏蔽Shift+F10\n        } else if ((e.shiftKey) && (e.keyCode == 121)) {\n                return false;\n        }\n};\n//屏蔽右键单击\ndocument.oncontextmenu = function () {\n        return false;\n};\n```\n\n## 崩溃欺骗\n```javascript\nvar OriginTitle = document.title;\nvar titleTime;\ndocument.addEventListener('visibilitychange', function () {\n    if (document.hidden) {\n        $('[rel=\"icon\"]').attr('href', \"/img/TEP.ico\");\n        document.title = '╭(°A°`)╮ 页面崩溃啦 ~';\n        clearTimeout(titleTime);\n    }\n    else {\n        $('[rel=\"icon\"]').attr('href', \"/favicon.ico\");\n        document.title = '(ฅ>ω<*ฅ) 噫又好了~' + OriginTitle;\n        titleTime = setTimeout(function () {\n            document.title = OriginTitle;\n        }, 2000);\n    }\n});\n```\n\n## a标签\n```javascript\n    // 邮件\n\t<a href={'mailto:'+props.email}></a>\n\t// 下载只有 Firefox 和 Chrome 支持 download 属性。\n\t<a href=\"/images/myw3schoolimage.jpg\" download=\"w3logo\"></a>\n    // QQ\n\t<a href=\"tencent://message/?uin=535509852&Site=-&Menu=yes\" target=\"_blank\">QQ:535509852</a>\n```\n\n##  `<script>`元素放在 HTML 文件底部\n\n我们将 `<script>`元素放在 HTML 文件底部的原因是，浏览器按照代码在文件中的顺序解析 HTML。如果 JavaScript在最前面被加载，HTML还未加载，JavaScript将无法作用于HTML，所以JavaScript无效，如果 JavaScript 代码出现问题则 HTML 不会被加载。所以将 JavaScript 代码放在底部是最好的选择。\n\n## 某个字符在字符串中的个数\n```javascript\nlet str=\"11112234241\"\nconsole.log(str.split(\"1\").length-1)\n```\n\n## 数组求最大值方法汇总\n```javascript\n1. es6拓展运算符...\nMath.max(...arr)\n2. es5 apply(与方法1原理相同)\nMath.max.apply(null,arr)\n3. for循环\nlet max = arr[0];\nfor (let i = 0; i < arr.length - 1; i++) {\n    max = max < arr[i+1] ? arr[i+1] : max\n}\n4. 数组sort\narr.sort((a,b)=>{\n\treturn b-a // 降序\n})\n5. 数组reduce\narr.reduce((a,b)=>{\n\treturn a>b?a:b\n})\n```\n\n```javascript\nfunction foo(p1,p2) {\nthis.val = p1 + p2;\n}\nvar bar = foo.bind( null, \"p1\" );\nvar baz = new bar( \"p2\" );\nbaz.val; // p1p2\n```\n\n## 回到顶部\n```javascript\nfunction goback() {\n// 1.回到顶部\n// scrollTo(0, 0); // 滚动条滚动 x y \n// 2.渐渐回到顶部 距离顶部高度\n//var iScrollTop = document.body.scrollTop; //360,Chrome,\n//var iScrollTop = document.documentElement.scrollTop;  //IE8,火狐\n    var iScrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    var timer = setInterval(function () {  //定时器\n        scrollTo(0, iScrollTop -= 100);\n        console.log(iScrollTop);\n        if (iScrollTop <= 0) {\n            clearInterval(timer);  //清除定时器\n        }\n    }, 100);\n}\n```\n\n## 手机号处理中间4位替换成*\n\n### 方法1 substr方法\n```javascript\nlet phone=\"18883269663\"\nlet phone1=phone.substr(0,3)+\"****\"+phone.substr(7)\n```\n\n### 方法2 正则匹配分组\n```javascript\nlet tel = \"13122223333\";\n\nlet reg = /^(\\d{3})\\d{4}(\\d{4})$/;\n\ntel = tel.replace(reg, \"$1****$2\");\n```\n\n## 转换树形结构数据\n```javascript\nlet arr=[{\"departmentId\":\"2807369902638080\",\"departmentName\":\"四合院大数据有限公司\",\"departmentDesc\":\"四合院大数据有限公司是非常好的公司\",\"createTime\":null,\"hasChild\":false,\"parentId\":null},{\"departmentId\":\"2805950137730048\",\"departmentName\":\"产品策划部\",\"departmentDesc\":null,\"createTime\":null,\"hasChild\":true,\"parentId\":null},{\"departmentId\":\"2805949110338560\",\"departmentName\":\"研发中心\",\"departmentDesc\":null,\"createTime\":null,\"hasChild\":true,\"parentId\":null}];\n\nfunction fn(data, p_id) {\n  var result = [],\n    temp;\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].parentId == p_id) {\n      var obj = data[i];\n      obj.label = data[i].departmentName;\n      temp = fn(data, data[i].departmentId);\n      if (temp.length > 0) {\n        obj.children = temp;\n      }\n      result.push(obj);\n    }\n  }\n  return result;\n}\n\nlet treeData=fn(treeData,null) // 传入原始数据/parentId\n适用于ant design和element-ui等树形结构数据\n```\n\n## 浏览器返回上一页\n```javascript\n<a href=\"#\" onclick=\"javascript:history.back(-1);\">返回到上一页</a>\n\n<a href=\"#\" onClick=\"javascript:history.go(-1)\">返回上一页</a>\n\n// window.open(url,\"_blank\")\n// window.location.href=url\n// window.location.replace(url)\n```\n\n## 浏览器前进后退\n```javascript\nhistory.forward();//前进\nhistory.back();//后退+刷新\nhistory.back(-1)//后退,直接返回当前页的上一页，数据全部消息，是个新页面\nhistory.go(1);//前进\nhistory.go(-1);//后退也是返回当前页的上一页，不过表单里的数据全部还在\n```\n\n## 去重数组里对象相同值得key\n```javascript\nconst key = 'id'\nconst arr = [{ id: 1 }, { id: 1 }, { id: 2 }, { id: 3 }]\nconst filted = arr.reduce((finalList, obj) => {\n  if (!finalList.find(T => T[key] === obj[key])) {\n    finalList.push(obj)\n  }\n  return finalList\n}, [])\n// [{ id: 1 }, { id: 2 }, { id: 3 }]\n\nlet map =new Map()\nfor (let item of arr){\nmap.set(item[key],item)\n}\n[...map.values()]\n```\n\n## 变量声明\n```javascript\n(function() {\n      var a = b = 5; // var a=b;b=5 严格模式会报错\n  })();   \nconsole.log(b); // 5\nconsole.log(a); // Uncaught ReferenceError: a is not defined\n\nvar a=[]; a[0]=1; a[1]=2; a[2]=3; a[5]=4; \na.length // 6\nwhile不改变作用域链\n[]?true:false // true\n[]==false?true:false // true\n2==true //false\n2==false // false\n\n+new Array(017) // NaN\n\nnew Array(1,2,3) // [1,2,3]\nnew Array(1) // [empty]\nArray.of(7) // [7]\n```\n\n## with语句\nwith语句的作用是将代码的作用域设置到一个特定的对象中。\n\n利：with语句可以在不造成性能损失的情况下，减少变量的长度。很多情况下，也可以不使用with语句，而是使用一个临时变量来保存指针，来达到同样的效果。\n\n弊：with语句使得程序在查找该语句块中的所有的变量值时，都是先在该with语句指定的对象下面先寻找一遍，然后再去外面的作用域去寻找。所以尽量不要在该语句块中去使用一些不属于该对象中的变量\n\n用法\n\n```javascript\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\nwith(x){\n  console.log(name+'的小名是'+nick_name);\n}\n```\n\n相当于\n\n```javascript\nvar x = {\n  name : \"古朋\",\n  nick_name : \"gupeng\"\n};\n/*\n *这里将x对象赋值到当前局部变量中，减少不必要的指针路径解析运算\n *一般用于在在方法中将this对象局部化，比如：var this_ = this;\n */\nvar x_ = x;\nconsole.log(x_.name+'的小名是'+x_nick_name);\n```\n\n## boolean类型在进行比较时会类型转换成number\n\n```javascript\n11==true // 11==1 false\n1==true  // 1==1 true\n```\n\n## RGB到十六进制\n使用按位左移运算符(<<)和toString(16)，然后padStart(6,'0')将给定的RGB参数转换为十六进制字符串以获得6位十六进制值。\n\n```javascript\nconst rgbToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');\n// ((1<<24) + (rgb.r<<16) + (rgb.g<<8) + rgb.b).toString(16).substr(1);\n// rgbToHex(255, 165, 1) -> 'ffa501'\n```\n\n## 滚动到顶部\n使用document.documentElement.scrollTop或document.body.scrollTop获取到顶部的距离。\n\n```javascript\nconst scrollToTop = _ => {\n\n    const c = document.documentElement.scrollTop || document.body.scrollTop;\n\n    if (c > 0) {\n\n    ​ window.requestAnimationFrame(scrollToTop);\n\n    ​ window.scrollTo(0, c - c / 8);\n\n    }\n};\n\n// scrollToTop()\n```\n\n## 求和\n```javascript\nconst sum = arr => arr.reduce((acc, val) => acc + val, 0);\n\n// sum([1,2,3,4]) -> 10 累加器\n// 平均数 sum([1,2,3,4])/4\n```\n\n## 大写每个单词的首字母\n使用replace()匹配每个单词的第一个字符，并使用toUpperCase()来将其大写。\n\n```javascript\nconst capitalizeEveryWord = str => str.replace(/[a-z]/g, char => char.toUpperCase());\n// capitalizeEveryWord('hello world!') -> 'HELLO WORLD!'\n\nfunction titleCase(s) {  \n    return s.toLowerCase().replace(/\\b([\\w|']+)\\b/g, function(word) {  \n        //return word.slice(0, 1).toUpperCase() + word.slice(1);  \n        return word.replace(word.charAt(0), word.charAt(0).toUpperCase());  \n    });  \n}\n// titleCase('hello world!') -> 'Hello World!'\n```\n\n## 计算数组中某值出现的次数\n每次遇到数组中的特定值时，使用reduce()来递增计数器。\n\n```javascript\nconst countOccurrences = (arr, value) => arr.reduce((a, v) => v === value ? a + 1 : a + 0, 0);\n\n// countOccurrences([1,1,2,1,2,3], 1) -> 3\n```\n\n## 数组间的区别\n从b创建一个Set，然后在a上使用Array.filter()，只保留b中不包含的值。\n\n```javascript\nconst difference = (a, b) => { const s = new Set(b); return a.filter(x => !s.has(x)); };\n\n// difference([1,2,3], [1,2]) -> [3]\n```\n\n## 阶乘\n使用递归。如果n小于或等于1，则返回1。否则返回n和n - 1的阶乘的乘积。\n\n```javascript\nconst factorial = n => n <= 1 ? 1 : n * factorial(n - 1);\n\n// factorial(6) -> 720\n```\n\n## 获取滚动位置\n如果已定义，请使用pageXOffset和pageYOffset，否则使用scrollLeft和scrollTop，可以省略el来使用window的默认值。\n\n```javascript\nconst getScrollPos = (el = window) =>\n\n({x: (el.pageXOffset !== undefined) ? el.pageXOffset : el.scrollLeft,\ny: (el.pageYOffset !== undefined) ? el.pageYOffset : el.scrollTop});\n\n// getScrollPos() -> {x: 0, y: 200}\n```\n\n## 最大公约数\n```javascript\nconst gcd = (x, y) => !y ? x : gcd(y, x % y);\n\n// gcd (8, 36) -> 4\n1e3 // 1000\n1E3 // 1000\n```\n\n## UUID生成器\n使用crypto API生成符合RFC4122版本4的UUID。\n\n```javascript\nconst uuid = _ =>\n([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n\n// uuid() -> '7982fcfe-5721-4632-bede-6000885be57d'\n```\n\n## 检查变量是否声明\n如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个全局变量是否被声明。\n前二种写法有漏洞，如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。\n最好的方法是使用in\n\n```javascript\n// 假设变量x未定义\n\n// 写法一：报错\nif (x) { return 1; }\n\n// 写法二：不正确\nif (window.x) { return 1; }\n\n// 写法三：正确\nif ('x' in window) { return 1; }\n```\n\n## 使用对象结构代替 switch…case\nswitch…case不使用大括号，不利于代码形式的统一。此外，这种结构类似于goto语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则。\n\n```javascript\n// 反模式\nfunction doAction(action) {\n    switch (action) {\n        case 'hack':\n            // ...\n            break;\n        case 'slash':\n            // ...\n            break;\n        default:\n            throw new Error('Invalid action.');\n    }\n}\n// 好模式\nfunction doAction(action) {\n    var actions = {\n        hack: function () {\n            // ...\n        },\n        slash: function () {\n            // ...\n        },\n    };\n\n    if (typeof actions[action] !== 'function') {\n        throw new Error('Invalid action.');\n    }\n\n    return actions[action]();\n}\n```\n\n## 隐藏console打印在哪一行的信息\n```javascript\nsetTimeout(console.log.bind(console, 'Hello world'), 2000)\n```\n\n## 手机震动\n```javascript\nwindow.navigator.vibrate(200); // vibrate for 200ms\n```\n\n## [1,2,11]用sort方法进行排序\n```javascript\n[1,2,11].sort() // [1,11,2] sort方法默认根据unicode进行排序\n\n[1,undefined,null].sort() // [1, null, undefined]\n\n[1,2,11].sort((a,b)=>a-b)  // [1,2,11]\n\n// bind是函数柯里化得一种实现\n```\n\n## [1,2,3].map(parseInt)\n```javascript\n[1,2,3].map(parseInt) // [1,NaN,NaN] 这里第二个参数是map的index，3对应下标2，3没有二进制的。\n\nparseInt(\"11\",2);\t\t//返回 3 (2+1)\n```\nparseInt第二个参数\t\n> 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。\n\n> 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。\n\n> 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。\n\n## 图片上传\n1. 传统的form表单上传\n```javascript\n<form action=\"\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"file\" name=\"img\">\n</form>\n```\n\n2. 隐藏iframe模拟Ajax上传\n```javascript\n// form的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded。\n// multipart/form-data是上传二进制数据;它告诉我们传输的数据要用到多媒体传输协议\n<iframe  name=\"ajaxUpload\" style=\"display:none\"></iframe>\n<form action=\"url\" method=\"post\" enctype=\"multipart/form-data\" target=\"ajaxUpload\">\n    <input type=\"file\" name=\"img\">\n</form>\n```\n\n3. h5 ajax上传\n```javascript\n// 使用已有的form表单，来实例化FormData对象\nvar form = document.getElementById('form');\nvar formData = new FormData(form);\n\n// 可以使用append来添加更多的信息\nvar img = document.getElementById('img').files[0];\nvar formData = new FormData();\nformData.append('img',img);\n\n// 获取 \n// formData.get('img') formData.getAll('img') [img]\n\n// 设置修改\n// formData.set('img',1) // 已存在则修改，不存在则新增\n\n// 判断是否存在\n// formData.has('img')\n\n// 删除\n// formData.delete('img')\n\n// 返回迭代器\n// formData.entries()\n// formData.append(\"k1\", \"v1\");\n// formData.append(\"k1\", \"v2\");\n// formData.append(\"k2\", \"v1\");\n\n// var i = formData.entries();\n\n// i.next(); // {done:false, value:[\"k1\", \"v1\"]}\n// i.next(); // {done:fase, value:[\"k1\", \"v2\"]}\n// i.next(); // {done:fase, value:[\"k2\", \"v1\"]}\n// i.next(); // {done:true, value:undefined}\n\n// 利用XHR上传图片\nvar xhr = new XMLHttpRequest();\nxhr.open('POST',url);\nxhr.onreadystatechange = function(){};\nxhr.send(formData);\n\n// 获取上传的进度\nxhr.upload.onprogress = function(evt){\n    console.log(evt);\n    var loaded = evt.loaded; //已经上传的大小\n    var total = evt.total;//附件总大小\n    var per = Math.floor(100 * loaded / total );//已经上传的百分比\n}\n```\n\n4. 检验图片信息\n```javascript\n<input type=\"file\" id=\"img\" name=\"img\"/>\n\n// 获取file对象\nvar img = document.getElementById('img');\nvar files = img.files;\nvar file = files[0];\n```\n\n## 实现JSONP\n```javascript\n// 对象存储\nconst JSONP = (url, jsonpObj) => {\n  let cbName = \"cb\" + JSONP.count++\n  let cbQuery = \"JSONP.\" + cbName\n  let paramsToQuery = obj => {\n    let query = '?'\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        query += `${k}=${obj[k]}&`\n      }      \n    }\n    return query\n  }\n  JSONP[cbName] = data => {\n    try {\n      jsonpObj.callback(data)\n    } finally {\n      delete JSONP[cbName]\n      document.body.removeChild(script)\n    }   \n  }\n  let queryStr = paramsToQuery(jsonpObj.data) + 'callback=' + cbQuery\n  let script = document.createElement('script')\n  script.src = url + encodeURIComponent(queryStr)\n  document.body.appendChild(script)\n}\nJSONP.count = 0\n\n// 数组存储\nvar JSONP = (url, descriptor) => {\n  var script = document.createElement('script')\n  var body = document.getElementsByTagName('body')[0]\n\n  var parseParam = (paramObj) => {\n    var paramStr = '?',\n        prop = ''\n    for (prop in paramObj) {\n      if(paramObj.hasOwnProperty(prop)) {\n        paramStr += (`${prop}=${encodeURIComponent(paramObj[prop])}&`)\n      }\n    }\n\n    return paramStr\n  }\n\n  var params = parseParam(descriptor.data)\n  var callback = (data) => {\n    descriptor.callback(data)\n    body.removeChild(script)\n    delete JSONP.cbs[index]\n  }\n  var index = JSONP.cbs.push(callback) - 1\n\n  script.src = url + params + 'callback=' + encodeURIComponent(`JSONP.cbs[${index}]`)\n  body.appendChild(script)\n}\n\nJSONP.cbs = []\n```\n\n## chrome浏览器拦截多次window.open\n```javascript\n // 遍历打开页面 chrome浏览器会拦截只允许一次的请求 这里模拟点击\n[1,2,3].forEach(()=>{\n        var aDom = document.createElement('a');\n        aDom.href = 'https://nodejs.org/dist/v10.13.0/node-v10.13.0-x64.msi';\n        aDom.target = '_blank';\n        aDom.click();\n});\n```\n\n## mixed\n```javascript\n1 << 31 // 1* 2^31 \n2 >> 1  // 2/2^1\n// ---------------\ndocument.getElementById(\"#app\")\ndocument.querySelector(\"#app\") // 第一个元素\ndocument.querySelectorAll(\"#app\") // 符合的所有元素\np.example // class \na[target] // 属性\nh1,h2 // 多个选择器按照文档中的位置设置\ndocument.querySelector(\"body\").contentEditable = true //设置内容是否可编辑 子元素继承父元素\nisContentEditable // 查看是否可编辑\n<div oncontextmenu=\"myFunction()\" contextmenu=\"mymenu\"/> // 右击菜单事件\nhtml \nobj.oncontextmenu= function(){}\nobj.addEventListener(\"contextmenu\",function(){})\nonabort // 用于img加载终止 alt title onerror发生错误\nonhashchange // 路由锚点变化\nonfocusin // 支持冒泡的onfocus\noninput // input onchange失去焦点触发\nonreset // form表单被重置触发 input type=\"reset\"\nonsearch // input type search 搜索事件\nonsubmnit // form 提交 action\nonscroll // 元素滚动时触发\noncopy // 在元素上拷贝脚本\noncut // 剪切\nonpaste // 粘贴\nonafterprint // body 页面打印后触发 window.print() 对应onbeforeprint\noncanplay // 准备开始播放 设置或者返回\ndocument.getElementsByTagName() // 返回标签集合\ndocument.getElementsByClassName() // 返回类名集合\nobj.removeEventListener()\nremoveChild()\nremoveAttribute()\n```\n\n## 高度\n```javascript\nwindow.scrollY // 225\nwindow.pageYOffset // 225\nwindow.document.body.scrollTop // 0\nwindow.document.documentElement.scrollTop // 225\n// 特殊字符:~ ! @ # % ^ * - _ = + ?\n```\n\n## 自适应单位\n1. vw：1vw等于视口宽度的1%。\n\n2. vh：1vh等于视口高度的1%。\n\n3. vmin：选取vw和vh中最小的那个。\n\n4. vmax：选取vw和vh中最大的那个\n\nCSS百分比是相对于包含它的最近的父元素的高度和宽度\n\n## dom解绑事件\n\n1. attachEvent是IE有的方法，它不遵循W3C标准，而其他的主流浏览器如FF等遵循W3C标准的浏览器都使用addEventListener，所以实际开发中需分开处理。\n\n2. 多次绑定后执行的顺序是不一样的，attachEvent是后绑定先执行，addEventListener是先绑定先执行。\n\n### 为元素解绑事件\n注意:用什么方式绑定事件,就应该用对应的方式解绑事件\n* 1. 解绑事件\n* 对象.on事件名字=事件处理函数--->绑定事件\n* 对象.on事件名字=null;\n\n```javascript\n$(\"btn\").onclick=function () {\nconsole.log(\"我是绑定事件\");\n};\n$(\"btn\").onclick=null;\n};\n```\n\n* 2. 解绑事件\n* 对象.addEventListener(\"没有on的事件类型\",命名函数,false);---绑定事件 \n* 对象.removeEventListener(\"没有on的事件类型\",函数名字,false);\n\n```javascript\n$(\"btn\").addEventListener(\"click\",f1,false);\n$(\"btn\").removeEventListener(\"click\",f1,false);\n```\n\n* 3. 解绑事件(IE)\n* 对象.attachEvent(\"on事件类型\",命名函数);---绑定事件\n* 对象.detachEvent(\"on事件类型\",函数名字);\n```javascript\n$(\"btn\").attachEvent(\"onclick\",f2);\n$(\"btn\").detachEvent(\"onclick\",f1);\n```\n\n## 位运算符\n位运算符一般使用的很少，当他与数字一起使用的时候，比如~N => -(N+1),这个式子仅当 N == -1 的时候结果为0。位运算可以提高程序的运行效率。\n\n我们可以在indexof(...)函数前面加一个~来进行布尔检查，检查一个项是否存在于Array或者string中。\n```javascript\nlet userName = 'break jerry'\n\nif(~userName.indexOf(\"break\")) {\n    console.log('access denied');\n}else {\n    console.log('access granted');\n}\n\n// 奇偶性\nif(index & 1) {\n    // 1 奇数 odd \n}else{\n    // 0 偶数 even\n}\n```\n\n## 关闭当前页面\n- window.close()\n- window.open(\"about:blank\",\"_self\").close();\n\n## 字节节省写法\n```javascript\n//取整\nparseInt(a,10); \nMath.floor(a); \n~~a; //节省之后的写法\na|0; //节省之后的写法 \na<<0\n\n//四舍五入\nMath.round(a); \na+.5|0; //节省之后的写法\n\n//内置值未定义\nundefined; \nvoid 0; //节省之后的写法(快)\n0[0]; //节省之后的写法(略慢)\n\n//内置值 无穷\nInfinity;\n\n\n1/0; //节省之后的写法\n\n//布尔值短写法\ntrue; \n!0; //节省之后的写法\nfalse; \n!1; //节省之后的写法\n\n// 判断奇偶\nnum & 1 == 1 //奇数\nnum & 1 == 0 //偶数\n```\n\n## 简单计算页面FPS\n整体思路是一秒有一千毫秒，先记录当前时间作为最后一次记录fps的时间，通过 requestAnimationFrame 回调不断给累加fsp计数器，\n并且判断上次记录fps的时间是否达到1000毫秒以上，如果满足条件，就将fps累加器的值作为当前fps显示，并且重置fps累加器。\n\n```javascript\nvar showFPS = (function () {\n    // noinspection JSUnresolvedVariable, SpellCheckingInspection\n    // 函数式\n    var requestAnimationFrame =\n        window.requestAnimationFrame || //Chromium  \n        window.webkitRequestAnimationFrame || //Webkit \n        window.mozRequestAnimationFrame || //Mozilla Geko \n        window.oRequestAnimationFrame || //Opera Presto \n        window.msRequestAnimationFrame || //IE Trident? \n        function (callback) { //Fallback function \n            window.setTimeout(callback, 1000 / 60);\n        };\n    \n    var dialog;\n    var container;\n\n    var fps = 0;\n    var lastTime = Date.now(); // 时间戳\n    // 遍历修改style\n    function setStyle(el, styles) {\n        for (var key in styles) {\n            el.style[key] = styles[key];\n    }\n    }\n\nfunction init() {\n        dialog = document.createElement('dialog');\n        // 初始化赋值样式\n        setStyle(dialog, {\n            display: 'block',\n            border: 'none',\n            backgroundColor: 'rgba(0, 0, 0, 0.6)',\n            margin: 0,\n            padding: '4px',\n            position: 'fixed',\n            top: 0,\n            right: 'auto,',\n            bottom: 'auto',\n            left: 0,\n            color: '#fff',\n            fontSize: '12px',\n            textAlign: 'center',\n            borderRadius: '0 0 4px 0'\n        });\n        // container成了dom元素\n        container.appendChild(dialog);\n    }\n\n    function calcFPS() {\n        offset = Date.now() - lastTime;\n        fps += 1;\n    // 1s内的计数器\n    if (offset >= 1000) {\n            lastTime += offset; // Date.now();\n            displayFPS(fps);\n            fps = 0;\n        }\n\n        requestAnimationFrame(calcFPS);\n    };\n\n    function displayFPS(fps) {\n        var fpsStr = fps + ' FPS';\n\n        if (!dialog) {\n            init();\n        }\n\n    if (fpsStr !== dialog.textContent) {\n        // 重绘 \n        dialog.textContent = fpsStr;\n        }\n}\n\nreturn function (parent) {\n    container = parent;\n        calcFPS();\n    };\n})();\nshowFPS(document.body);\n```\n\n## 你不知道的new.target\nnew 是构造函数生成实例的命令, ES6为 new 命令引入了 new.target属性。这个属性用于确定构造函数是怎么调用的。\n用法：在构造函数中, 如果一个构造函数不是通过 new操作符调用的, new.target会返回 undefined。\n\n使用场景：\n### es5写法\n> 如果一个构造函数不通过 new 命令生成实例, 就报错提醒。\n```javascript\nfunction Shape(options) {\n    if (this instanceof Shape) {\n        this.options = options\n    } else {\n        // 要么手动给它创建一个实例并返回\n        // return new Shape(options)\n        \n        // 要么提醒\n        throw new Error('Shape 构造函数必须使用 new 操作符')\n    }\n}\n```\n\n###  es6写法\n> 子类继承父类, 那么父类构造函数中的 new.target 是子类构造函数的名称。\n```javascript\nclass Zoo {\n    constructor() {\n        if (new.target === Zoo) throw new Error('Zoo构造函数只能用于子类继承')\n    }\n}\n\nconst zoo = new Zoo()   // 报错\n\nclass Dog extends Zoo {\n    constructor() {\n        super()\n    } \n}\n\nconst dog = new Dog()  // 不报错\n```\n\n## 文件扩展名\n```javascript\nvar filePath = '21312321.mp3'\nfilePath.substring(filePath.lastIndexOf(\".\")+1,filePath.length) //'mp3'\n```\n\n## blur和click冲突\n> 场景：平时做表单验证的时候一般都有个input框和删除按钮，然后习惯性在失去焦点的时候> 去验证输入的内容是否正确，做验证，发请求等等。\n> 这个时候，那个点击删除按钮往往也就触发了input的失去焦点事件\n1. 给失去焦点的时间加上延迟时间，让blur时间在click事件后执行，这个方法固然能够解决问题，但是本人并不是很推荐，因为影响性能，不到最后不用这个方法；\n2. event.relatedTarget.id事件属性返回与事件的目标节点相关的节点。（非IE）\n3. mousedown事件替代处理click事件\n\n## object标签\nobject标签不在dom文档流里面，浏览器在解析的时候先把object放置在最上层，然后依次解析dom文档，放在下层。\n\n如果这样引用多媒体文件推荐还是不使用object，只有iframe的层级在它之上处理起来很麻烦。\n\n## escape、encodeURI、encodeURIComponent区别\n1. escape是对字符串进行编码，对URL使用不需要 encodeURI encodeURIComponent\n2. encodeURI方法不会对下列字符编码 ASCII字母、数字、!@#$&*()=:/,;?+'\n3. encodeURIComponent方法不会对下列字符编码 ASCII字母、数字、!*()'\n所以encodeURIComponent比encodeURI编码的范围更大。\n实际例子来说，encodeURIComponent会把 http:// 编码成 http%3A%2F%2F 而encodeURI却不会。\n当编码url时需要使用encodeURI，当需要编码参数时使用encodeURIComponent\n\n## 链式调用\n```javascript\n1.方法体内返回对象实例自身(this)\n\nvar Obj = {\n    a: 1,\n    func: function(){\n        this.a += 1;\n        return this\n    }\n}\nObj.func().func();\nconsole.log(Obj.a);    //3\n2.对象传入后每次调用返回函数自身\n    function show(str) {\n        console.log(str);\n        return show;\n    }\n    show(123)(456)(789);\n\n// 控制台打印结果\n// 123\n// 456\n// 789\n```\n\n## setTimeout 为不可执行的字符串时会造成内存泄露\n```javascript\nsetTimeout(\"fn()\",100)\nfunction fn(){\nconsole.log(11111111)\n}\n```\n\n## JSON.parse和JSON.stringify其他参数\n```javascript\nvar obj ={name:'cosyer',age:15}\nvar newobj = JSON.stringify(obj)\n\nJSON.parse(newobj,(key,value)=>{\nconsole.log(1111111111111,key,value);\n});\n// name cosyer \n// age 15 \n// \"\" {}\n\n// 3个参数\n// JSON.stringify(jsonObj,repalce,space)\n// replace可以是数组或者回调函数\nconst testJSON = {\n   name: 'test',\n   cities: {\n      shanghai: 1,\n   },\n};\n\nJSON.stringify(testJSON, ['name']);\n\n// \"{\"name\": 'test'}\"\n\nJSON.stringify(testJSON, ['name', 'cities']);\n \n//  \"{\"name\": 'test', \"cities\": {}}\"\n\nJSON.stringify(testJSON, ['name', 'cities', 'shanghai']);\n\n// \"{\"name\": 'test', \"cities\": {\"shanghai\": 1}}\"\n\nJSON.stringify(testJSON, (key, value) => {\n    // 遍历对象\n    if (key === 'cities') {\n       return  'cities';\n    } \n    return value; // 确认value???\n});\n\n// \"{\"name\": 'test', \"cities\": 'cities'}\"\n\nJSON.stringify(testJSON, undefined, '...');\n\n// \"{\n//    ...\"name\": 'test',\n//    ...\"city\": 'shanghai',\n//   }\"\n\nJSON.stringify(testJSON, undefined, 7);\n\n// \"{\n//          \"name\": 'test',\n//          \"city\": 'shanghai',   // 缩进7个空格\n// }\"\n\nJSON.stringify({name:123,age:24},null,'\\t')\n// \"{\n// \t\"name\": 123,\n// \t\"age\": 21\n// }\"\n```\n\n## 随机数\n```javascript\n// [0,1) 左闭右开 min-max \nMath.floor(min+Math.random()*(max-min+1))\n// toString() this is object方法 toString() valueOf\n// 随机颜色\nitem.style.backgroundColor = '#' + Math.random().toString(16).slice(2, 8);\n// \"#\" + (\"00000\" + ((Math.random() * 0x1000000) << 0).toString(16)).slice(-6)\n```\n\n## chrome浏览器跳转调试\n问题描述：在chrome里调试接口的时候发现页面跳转之后会看不到之前的接口返回，即使你将Perserve log 勾上，能看到跳转之前的接口，但是看不到返回的内容\n\n问题解决：查了一些资料，chrome之所以这么做（看不到跳转之前的接口返回）是为了节省内存开销，但是这个给调试带来了困难，然后我参照stackoverflow的解决方案， 在控制台执行 window.onunload = function() { debugger; } 为了在页面unload之前进入debug，但是尝试了还是看不到跳转之前接口返回的内容，最后的解决方案是用firefix调试，在火狐里在调试中的网络中勾选持续日志可以看到跳转之前的接口，且可以看到接口返回内容。\n\n**参考资料** \n* [Chrome dev tools fails to show response ](https://stackoverflow.com/questions/38924798/chrome-dev-tools-fails-to-show-response-even-the-content-returned-has-header-con)\n* [Chrome 开发者工具里看不到完整的 HTTP request 回应？](https://ephrain.net/chrome-chrome-%E9%96%8B%E7%99%BC%E8%80%85%E5%B7%A5%E5%85%B7%E8%A3%A1%E7%9C%8B%E4%B8%8D%E5%88%B0%E5%AE%8C%E6%95%B4%E7%9A%84-http-request-%E5%9B%9E%E6%87%89%EF%BC%9F/)\n\n## 时间\n**UTC**：世界协调时间，是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修\n\n正后的新时标以及以秒为单位的国际原子时所综合精算而成的时间。UTC比GMT更\n\n加精准，其误差值必须保持在0.9秒以内。若大于0.9秒，则由位于巴黎的国际地\n\n球自转事务中央局发布闰秒，使UTC与地球自转周期一致，所以基本上UTC的本质\n\n强调的是比GMT更为精确的世界时间标准。\n\n**GMT**：格林尼治是位于英国南郊的原格林尼治天文台所在地，也是地理经度的起\n\n始点。这里所设定的时间就叫格林尼治时间，也是世界时间参考点，全世界都根\n\n据时区的不同以格林尼治的时间作为标准来设定时间。\n\n**夏令时**：因为夏天白天时间比较长，太阳会比较早出现，某些地区就将当地的时\n\n间提早一段时间（例如一小时），以达到利用阳光节约能源的目的。 通常秋季\n\n时，此地区会将当地时间推后一段时间（例如一小时），回复正常时间。\n\nUTC和本地时间的关系：本地时间=UTC+时区+夏令时偏移量。\n\n## uuid生成\n```javascript\nfunction uuid(len, radix) {\n    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n    var uuid = [], i;\n    var radix_new = radix || chars.length;\n\n    if (len) {\n        // Compact form\n        for (i = 0; i < len; i++) {\n            uuid[i] = chars[0 | Math.random() * radix_new];\n        }\n    } else {\n        // rfc4122, version 4 form\n        var r;\n\n        // rfc4122 requires these characters\n        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n        uuid[14] = '4';\n\n        // Fill in random data. At i==19 set the high bits of clock sequence as\n        // per rfc4122, sec. 4.1.5\n        for (i = 0; i < 36; i++) {\n            if (!uuid[i]) {\n                r = 0 | Math.random() * 16;\n                uuid[i] = chars[(i === 19) ? (r & 0x3) | 0x8 : r];\n            }\n        }\n    }\n    return uuid.join('');\n};\n```\n\n## jq原生对照\n```javascript\n1、元素获取\n/*******************原生js**************************/\nvar ele = document.getElementById('idName');\nvar eleArr = document.getElementsByClassName('className');\nvar eleArr = document.getElementsByTagName('div');\nvar ele = document.querySelector('#idName');//('.className')//('tagName'); //取第一个满足条件的元素\nvar eleArr = document.querySelectorAll('.className');//('tagName');\n/*******************jQuery**************************/\nvar ele = $('#idName');\nvar ele = $('.className:eq(0)'); //取第一个元素\nvar eleArr = $('tagName');\n2、class选择器操作\n/*******************原生js**************************/\n//className 属性\nele.className = 'newClassName';\n//classList操作\nele.classList.contains('className'); //是否含有该类\nele.classList.add('newClassName1,newClassName2...'); //添加类\nele.classList.remove('oldClassName1,newClassName2...'); //删除类\nele.classList.toggle('className'); //如果元素中有该className，则删除并返回false，否则添加并返回true\n\n/*******************jQuery**************************/\nele.hasClass(className);\nele.addClass('newClassName1,newClassName2...');\nele.removeClass('newClassName1,newClassName2...'); // 元素本身remove()\nele.toggleClass('className');\n3、元素节点操作\n/*******************原生js**************************/\n//创建节点\n    var newNode = ele.createElement('<div>创建</div>');\n//插入节点\n    ele.appendChild(newNode); //在ele的子节点的末尾插入newNode\n    ele.insertBefore(newNode,targetNode); //在ele的子节点targetNode前面插入newNode\n//删除节点\n    ele.removeChild(ele.childNodes[i]); //删除ele第i+1个子节点\n//替换节点\n    ele.replaceChild(newNode, oldNode); //替换ele中的子节点\n//克隆节点\n    var copyNode = ele.cloneNode(deep); //deep为true时，深拷贝（包括其子孙节点），为false时只复制本身节点\n\n/*******************jQuery**************************/\n//创建节点\n    var newNode = $('<div>创建</div>');\n//插入节点\n    //在元素子节点末尾插入\n    ele.append(newNode); //在ele的子节点的末尾插入newNode\n    newNode.appendTo(ele); //在ele的子节点的末尾插入newNode\n    //在元素子节点前端插入\n    ele.prepend(newNode); //在ele的子节点的前端插入newNode\n    newNode.prependTo(ele); //在ele的子节点的前端插入newNode\n\n    //在元素后面添加\n    ele.after(newNode);\n    newNode.insertAfter(ele);\n    //在元素前面添加\n    ele.before(newNode);\n    newNode.insertBefore(ele);\n\n//删除节点\n    ele.remove(); //移除ele及其所有文本、子孙节点、数据和事件\n    ele.detach(); //移除ele及其所有文本、子孙节点，但是保留数据和事件\n    ele.empty(); //清除ele所有的内容和子孙元素，但是ele节点本身和其属性事件等还在\n\n//替换节点\n    ele.replaceWith(newNode); //替换ele为新的内容(可以是html元素，dom元素，jQuery元素)\n    newNode.replaceAll(ele); //替换ele为新的html元素\n//克隆节点\n    ele.clone(deep); //deep为true时，深拷贝（包括其事件处理函数），为false时只复制本身，默认false\n4、元素节点遍历\n/*******************原生js**************************/\n// 子节点\nvar eleArr = ele.childNodes; // 所有子节点\nvar eleArr = ele.children; //所有子节点数组，用得较多\n\nvar firstEle = ele.firstChild; //第一个子节点 低版本浏览器firstElementChild\nvar lastEle = ele.lastChild; //最后一个子节点 低版本浏览器lastElementChild\n// 父节点\nvar parentEle = ele.parentNode;\n// 兄弟节点\nvar nextEle = ele.nextSibling; //下一个节点\nvar previousEle = ele.previousSibling; //上一个节点\n\n/*******************jQuery**************************/\n// 子节点\nvar eleArr = ele.children(); //所有子节点数组\n\nvar firstEle = ele.first(); //第一个子节点\nvar lastEle = ele.last(); //最后一个子节点\n// 父节点\nvar parentEle = ele.parent(); //直接父元素\nvar parentEleArr = ele.parents(); //所有祖先元素\nvar parentEle = ele.offsetParent(); // 第一个有定位的父元素\nvar parentEleArr = ele.parentsUntil(stop, filter); // 满足条件之间的父节点\n\n// 兄弟节点\nvar nextEle = ele.next(); //下一个节点\nvar nextEleArr = ele.nextAll(); //ele后面所有同级节点\nvar previousEle = ele.prev(); //上一个节点\nvar previousEle = ele.prevAll(); //ele之前所有同级节点\nvar siblingsArr = ele.siblings(); //所有同级元素节点\n5、属性操作\n/*******************原生js**************************/\n// 属性数组\nvar attrArr = ele.attributes;\n// 判断属性\nvar bool = ele.hasAttribute('attrName'); //是否有指定属性\nvar bool = ele.hasAttributes(); //是否有属性\n// 获取属性值\nvar attrValue = ele.getAttribute('attrName');\n// 设置属性值\nele.setAttribute('attrName','attrValue');\n// 删除属性\nele.removeAttribute('attrName');\n/*******************jQuery**************************/\n//在设置disabled、selected、checked等这些Boolean类型自带属性时，我们需要用prop()方法；\n// 其他字符串类型自带属性时，我们使用attr()方法即可;DOM节点可见的自定义属性我们也使用attr()方法。\n// 获取属性值\nvar attrValue = ele.attr('attrName');\nvar propValue = ele.prop('propName');//\n// 设置属性值\nele.attr('attrName','attrValue'); //自定义的一些属性\nele.prop('propName','propValue'); //disabled等一些属性，HTML元素的固有属性\n// 删除属性\nele.removeAttr('attrName');\n6、事件\n/*******************原生js**************************/\n//事件绑定及解绑\nele.addEventListener('click',func,false);\nele.removeEventListener('click',func,false);\nele.onclick = func;\nele.onclick = null;\nele.attachEvent('onclick',func); //ie8以下\nele.detachEvent('onclick',func); //ie8以下\n/*******************jQuery**************************/\n/*多种事件绑定和解绑方法*/\n/**方法1\n * 1、直接绑定事件方法mouseenter()...等等\n * 2、这样的方式，下面两个事件不会被层叠，都会执行\n * 3、只能一个一个绑定\n */\n$(\"div:eq(0)\").click(function () {\n    alert(1);\n});\n$(\"div:eq(0)\").click(function () {\n    alert(2);\n});\n\n/**方法2\n * 1、bind(\"event1 event2 ... eventx\",fn)\n * 2、同时绑定多个事件触发条件，执行同一个函数\n */\n$(\"div:eq(1)\").bind(\"click mouseenter\",function () {\n    alert(\"bind绑定法\");\n});\n//解绑\n$(\"div:eq(1)\").unbind(\"click\"); //解绑指定的\n//$(\"div:eq(1)\").unbind();  //解绑所有的\n\n/**方法3\n * 1、delegate(\"selector\",\"event1 event2 ... eventx\",fn)\n * 2、可以绑定父盒子里的子盒子触发事件，执行函数\n */\n$(\"div:eq(2)\").delegate(\"button\",\"click mouseleave\",function () {\n    alert(\"delegate绑定法\");\n});\n//解绑\n$(\"div:eq(2)\").undelegate();\n/**方法4\n * 重点使用！！！\n * 1、on(\"event1 event2 ... eventx\",\"selector\",data,fn)\n * 2、可以绑定父盒子里的后代盒子触发事件，执行函数\n * 3、参数data由event.data带入函数中\n */\n\n$(\"div:eq(3)\").on(\"click mouseleave\",\"button\",{\"name\":\"mjm\",\"age\":24},function (event) {\n    alert(\"on绑定法\"+event.data.name);\n\n});\n//解绑\n$(\"div:eq(3)\").off();\n```\n\n## 实现复制tiny\n```javascript\n// 复制连接地址\nwindow.copyLink = function (str) {\n    if (window.clipboardData) {\n        // 兼容ie11以下浏览器\n        window.clipboardData.setData('Text', str);\n    } else {\n        var $input = document.createElement('input');\n        var body = document.querySelector(\"body\")\n        $input.value=str;\n        body.appendChild($input);\n        $input.select();\n        document.execCommand('copy');\n        // $input.remove();\n        body.remove($input)\n    }\n};\n```\n\n## scrollbar滚动条样式优化\n```css\n::-webkit-scrollbar-corner {\n  background-color: transparent;\n}\n\n::-webkit-scrollbar-button {\n  width: 0;\n  height: 0;\n  display: none;\n}\n\n::-webkit-scrollbar-thumb {\n  width: 7px;\n  background-color: #b4babf;\n  border-radius: 7px;\n}\n\n::-webkit-scrollbar {\n  width: 7px;\n  height: 7px;\n}\n\n::-webkit-scrollbar-track {\n  width: 15px;\n}\n\n::-webkit-scrollbar:hover {\n  background-color: transparent;\n}\n```\n\n##  内网ip段\n内网段10.0.0.0—10.255.255.255，172.16.0.0—172.31.255.255，192.168.0.0—192.168.255.255\n\n## 获取当前鼠标坐标\n```javascript\nvar getCoordInDocumentExample = function () {\n  var coords = document.getElementById(\"colorPanel\");\n  coords.onmousemove = function (e) {\n    var pointer = getCoordInDocument(e);\n    var coord = document.getElementById(\"colorText\");\n    coord.innerHTML = \"X,Y=(\" + pointer.x + \", \" + pointer.y + \")\";\n  }\n}\n\nvar getCoordInDocument = function (e) {\n  e = e || window.event;\n  var x = e.pageX || (e.clientX +\n    (document.documentElement.scrollLeft ||\n      document.body.scrollLeft));\n  var y = e.pageY || (e.clientY +\n    (document.documentElement.scrollTop ||\n      document.body.scrollTop));\n  return {\n    'x': x,\n    'y': y\n  };\n}\n\nwindow.onload = function () {\n  getCoordInDocumentExample();\n};\n```\n\n## 类数组对象转数组\n```javascript\nfunction func(){\n    // 类数组对象转数组\n    console.log(arguments) // {0:1,1:2,2:3,length:3}\n    console.log([].slice.call(arguments))\n    console.log(Array.prototype.slice.call(arguments))\n    console.log(Array.from(arguments))\n    console.log([...arguments])\n}\nfunc(1,2,3)\n```\n\n## 页面滚动条到底判断\n```javascript\n//获取网页的总高度，主要是考虑兼容性所以把Ie支持的documentElement也写了，这个方法至少支持IE8\nvar htmlHeight = document.body.scrollHeight || document.documentElement.scrollHeight;\n//clientHeight是网页在浏览器中的可视高度，\nvar clientHeight = document.body.clientHeight || document.documentElement.clientHeight;\n//scrollTop是浏览器滚动条的top位置，\nvar scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n//通过判断滚动条的top位置与可视网页之和与整个网页的高度是否相等来决定是否加载内容；\nif (scrollTop + clientHeight == htmlHeight) {\n    // 滚动条到底\n}\n```\n\n## yield函数\n```javascript\n// 传入匿名函数\nfunction* fibonacci() {\n    let [prev, curr] = [0, 1];\n    while (true) {\n    [prev, curr] = [curr, prev + curr];\n    yield curr;\n    }\n}\n// 含有迭代器iterate\nfor (let n of fibonacci()) {\n    if (n >= 1000) {\n    break;\n    }\n    console.log(n);\n}\n// 1 2 3 5 8 \n```\n\n### 复制添加版权申明\n```javascript\nif (window.clipboardData) {\n    // IE\n    document.body.oncopy = function(){\n        event.returnValue = false;\n        var t=document.selection.createRange().text;\n        var s=\" 原文链接：\"+location.href;\n        clipboardData.setData('Text',t+'\\r\\n'+s);\n    };\n} else {\n    function addLink(){\n        var body_element = document.getElementsByTagName('body')[0];\n        var selection;\n        selection = window.getSelection();\n        var pagelink = \" 原文链接：\"+location.href;\n        var copytext = selection + pagelink;\n\n        var newdiv = document.createElement('div');\n        newdiv.style.position='absolute';\n        newdiv.style.left='-99999px';\n        body_element.appendChild(newdiv);\n        newdiv.innerHTML = copytext;\n        selection.selectAllChildren(newdiv);\n        window.setTimeout(function(){body_element.removeChild(newdiv);},0);\n    }\n    document.oncopy = addLink;\n}\n```\n\n## 包版本号\n一个包的版本号基本由三位数字构成 x.x.x, 它们分别是主版本号, 次版本号, 修订号。\n\n- *: 升级主版本号 + 次版本号 + 修订号;\n- ^: 升级次版本号 + 修订号;\n- ~: 升级修订号;\n\nnpm使用 a.b.c 的版本号来管理安装包，a大达版本号，有重大api改变，一般不向下兼容，b为小版本号，新增功能，向下兼容，c为补丁号，通常修复一些bug。\n\n## script标签关键字\n- defer 并发下载 顺序执行 渲染完再执行\n- async 并发下载 异步执行谁先下载完 谁先执行\n\n## 防止对象篡改\n* Object.preventExtensions(obj): obj 不能添加属性\n* Object.seal(obj): obj 不能添加/删除属性\n* Object.freeze(obj): obj 不能添加/删除/修改属性\n\n## module.exports和exports\nmodule.exports才是真正的接口，exports只不过是它的一个辅助工具。　最终返回给调用的是module.exports而不是exports。\n所有的exports收集到的属性和方法，都赋值给了Module.exports。当然，这有个前提，就是module.exports本身不具备任何属性和方法。\n\n1. 最好分别定义module.exports和exports\n\n2. 建议导出对象用module.exports,导出多个方法和变量用exports\n\n## meta自动跳转\n```javascript\n<meta http-equiv=\"Refresh\" content=\"1; url=http://www.baidu.com\"/>\n```\n\n## 前端生成文件并下载\nBlob对象简要介绍\n\nBlob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据。File 接口基于Blob，继承了 Blob 的功能并将其扩展使其支持用户系统上的文件。\n> const aBlob = new Blob( array, options );\n参数说明\n\n- array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。\n- options 是一个可选的BlobPropertyBag字典，它可能会指定如下两个属性：\ntype，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。\nendings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。 它是以下两个值中的一个： “native”，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 “transparent”，代表会保持blob中保存的结束符不变\n\n```javascript\n// const debug = {hello: \"world\"};\n// const blob = new Blob([JSON.stringify(debug, null, 2)],{type : 'application/json'});\nfunction createAndDownloadFile(fileName, filePath) {\n    const aTag = document.createElement('a');\n    const blob = new Blob([filePath]);\n    aTag.download = `${fileName}.json`;\n    aTag.href = URL.createObjectURL(blob);\n    aTag.click();\n    URL.revokeObjectURL(blob);\n}\n```\n\n## 防止frame嵌套\n```javascript\nif(top != self){\n    location.href = ”about:blank”;\n}\n```\n\n## 取反运算简化indexOf判断\n```javascript\nif(~[1,2,3].indexOf(1)){\n    // 存在\n}else{\n    // 不存在\n}\n[(1,2,3)] // 3\n```\n\n## 已知年月，求当月多少天\n- 先判断该年份是否是闰年，来处理 2 月份情况，闰年 2 月共 29 天，非闰年 2 月共 28 天\n- 再判断其他月份，如 1 月共 31 天，4 月共 30 天\n\n**更简便的方法**\n```javascript\n// Date API 处理日期溢出时，会自动往后推延响应时间\nfunction getMonthCountDay (year, month) {\n  return 32 - new Date(year, month-1, 32).getDate();\n  // 32 - (32-当月天数) = 当月天数\n}\n// better\nfunction getMonthCountDay (year, month) {\n  return new Date(year, month , 0).getDate();\n}\n```\n\n## 日期格式转化 2019/3/19 => 2019-3-19\n1. 正则\n```js\nlet date = new Date()\nlet dateStr = date.toLocaleDateString().replace(/\\//g,'-')\n```\n\n2. 数组计算\n```js\nlet date = new Date()\nlet arr = date.toLocaleDateString().split('/')\narr = arr.map((item) => {\nreturn parseInt(item) < 10 ? '0' + item : item\n})\nlet dateStr = arr.join('-')\n```\n\n## 求数值的n次幂\n```js\nMath.pow(2,10); //1024\n2**10 // 1024 es7\n2<<9 //1024\n```\n\n## 分号的重要性\n```js\nconst luke = {}\nconst leia = {}\n[luke, leia].forEach(jedi => jedi.father = 'vader');\n\nfunction foo() {\n  return\n    'search your feelings, you know it to be foo'\n} // undefined\n```\n\n## 前端h5 download属性下载文件(appendChild兼容firefox)\n```js\nfunction downFile(content, filename) {\n    // 创建隐藏的可下载链接\n    var eleLink = document.createElement('a');\n    eleLink.download = filename;\n    eleLink.style.display = 'none';\n    // 字符内容转变成blob地址\n    var blob = new Blob([content]);\n    eleLink.href = URL.createObjectURL(blob);\n    // 触发点击\n    document.body.appendChild(eleLink);\n    eleLink.click();\n    // 然后移除\n    document.body.removeChild(eleLink);\n};\n```\n\n## 禁止滚动条滚动\n```js\nvar keys = [37, 38, 39, 40];\n\nfunction preventDefault(e) {\n  e = e || window.event;\n  if (e.preventDefault)\n      e.preventDefault();\n  e.returnValue = false;  \n}\n\nfunction keydown(e) {\n    for (var i = keys.length; i--;) {\n        if (e.keyCode === keys[i]) {\n            preventDefault(e);\n            return;\n        }\n    }\n}\n\nfunction wheel(e) {\n  preventDefault(e);\n}\n\nfunction disable_scroll() {\n  if (window.addEventListener) {\n      window.addEventListener('DOMMouseScroll', wheel, false);\n  }\n  window.onmousewheel = document.onmousewheel = wheel;\n  document.onkeydown = keydown;\n}\n\nfunction enable_scroll() {\n    if (window.removeEventListener) {\n        window.removeEventListener('DOMMouseScroll', wheel, false);\n    }\n    window.onmousewheel = document.onmousewheel = document.onkeydown = null;  \n}\n```\n\n## map等遍历注意事项\n```js\nvar it = []\nit.map((item)=>{\n    console.log(111111111111)\n})\n// 压根就不会执行\n```\n\n## 符合密码学要求的随机值\n```js\nfunction getRandomNumbers(min, max) {\n    var minValue = min || '';\n    var maxValue = max || '';\n    var cryptoObj = window.crypto || window.msCrypto;\n    var array = new Uint32Array(1);\n    cryptoObj && cryptoObj.getRandomValues(array);\n    var result = 0;\n    if (minValue || maxValue) {\n        if (!maxValue) {\n            minValue = 0;\n            maxValue = min;\n        }\n        result = parseInt(minValue, 10) + (array[0] % (parseInt(maxValue, 10) - parseInt(minValue, 10)));\n    } else {\n        result = array[0];\n    }\n    return result;\n}\n```\n\n## base64编码和解码\n```js\nlet encodedData = window.btoa(\"Hello, world\"); // 编码\nlet decodedData = window.atob(encodedData); // 解码\n```\n\n## 字符串反转\n如果需要支持UTF-16或其他多字节字符的解决方案，请注意此函数将给出无效的Unicode字符串或看起来很有趣的有效字符串。[需要注意](https://stackoverflow.com/questions/958908/how-do-you-reverse-a-string-in-place-in-javascript/16776621#16776621)\n\n![有意思的图](http://cdn.mydearest.cn/blog/images/reverse.jpg)\n\n```js\nfunction reverse(str) {\n    return str.split().reverse().join();\n    // Array.from(str).reverse().join('')\n}\n\n// 使用递归\nfunction reverseString(str) {\n  return (str === '') ? '' : reverseString(str.substr(1)) + str.charAt(0);\n}\n\nfunction reverse([h, ...t]) {\n    return h ? reverse(t) + h : '';\n}\n\nfunction reverse(str){\n    var s ='';\n    for (let i = str.length;i > 0; i--) {\n        s += str[i-1]; // charAt substring substr\n    }\n    return s;\n}\n```\n\n## delete varible\n```js\ndelete xxx // true\ndelete window //false\n```\n\n## jquery指定元素滚动到视图中间\n```js\nfunction scrollToViewCenter($element) {\n    if (!$element) {\n        return;\n    }\n    var winOffsetHeight = document.body.offsetHeight; // 浏览器窗口可视区域高度\n    var eleOffsetTop = $element.offset().top;\n    var top = eleOffsetTop - (winOffsetHeight / 2);\n    window.scrollTo(0, top);\n}\n```\n\n## new Array()\n```js\nvar myArray = Array();\nmyArray['A'] = \"Athens\";\nmyArray['B'] = \"Berlin\";\nmyArray['0'] = 1;\n// length 1 只统计数字索引\n// length范围 0~2**32-1\n```\n\n## 构造函数scope-safe模式\n```js\nfunction Book(name){\n    console.log(1111,this)\n    if(!(this instanceof Book)){\n        return new Book(name);\n    }\n    this.name=name;\n}\nvar bookone = Book('harry-potter');\n\nfunction a(b){\n  alert(b);\n  function b(){\n    alert(b);\n  }\n  b();\n}\na();\n```\n\n## jquery设置!important\n```js\n$(\"#container\").css(\"top\");\n$(\"#container\").css(\"top\",\"15px\");\n$(\"#container\").css(\"cssText\",\"overflow:auto !important;\")\n```\n\n## :empty 选择器区分样式\n> :empty 选择器匹配没有子元素（包括文本节点）的每个元素。\n\n这里举个小红点的例子：\n![empty](http://cdn.mydearest.cn/blog/images/empty.png)\n\n如图所示，小红点有内容以及无内容的样式差异，按照常规的处理方式，我们一般是通过类名区分，但是我们可以简单通过:empty选择器区分开。\n```html\n<div class=\"jd\"><i>3</i></div>\n```\n\n```css\n.jd i:empty {\n    // 无内容的小红点样式\n}\n.jd i:not(:empty) {\n    // 有内容的小红点样式\n}\n```\n\n## arr.reduce(callback[, initialValue])\n- reduce接受两个参数, 一个回调, 一个初始值\n- 回调函数接受四个参数 previousValue, currentValue, currentIndex, array\n\n> 第一个表达式等价于 Math.pow(3, 2) => 9; Math.pow(9, 1) =>9\n\n> 第二个表达式异常 Uncaught TypeError: Reduce of empty array with no initial value\n\n## 变量提升\n在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。\n```js\nvar name = 'World!';\n(function () {\n    if (typeof name === 'undefined') {\n        var name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n// Goodbye Jack\n```\n\n## 最大安全数 + 1值没有变化 会导致循环\n```js\nvar END = Math.pow(2, 53);\nvar START = END - 100;\nvar count = 0;\nfor (var i = START; i <= END; i++) {\n    count++;\n}\nconsole.log(count); // 循环\n```\n\n## 稀疏数组\n没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.\n```js\nvar ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) { return x === undefined;});\n// []\n\nvar ary = Array(3);\nary[0]=2\nary.map(function(elem) { return '1'; });\n// [\"1\", undefined × 2]\n```\n\n## 一个鲜为人知的实事: Array.prototype => []\n```js\t\nArray.isArray( Array.prototype )\n// true\n```\n\n## arguments在es6有初始值时不同\n```js\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n// 10 + 1 + 10 = 21\n\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c=3) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n// 1 + 1 + 10 = 12\n```\n\n## reverse返回调用者\n```js\nvar x = [].reverse;\nx();\n// window\n```\n\n## Number.MIN_VALUE > 0\n```js\nNumber.MIN_VALUE > 0\n// 5e-324 true\n```\n\n## 抽象相等\n```js\nvar a = [0];\nif ([0]) {\n  console.log(a == true);\n} else {\n  console.log(\"wut\");\n}\n// false\n```\n![equality](http://cdn.mydearest.cn/blog/images/equality.png)\n\n## 隐式类型转换\n```js\n[1 < 2 < 3, 3 < 2 < 1]\n\n// 1 < 2 => true < 3 => 1 < 3 true\n// 3 < 2 => false < 1 => 0 < 1 true\n// [true,true]\n\n2 == [[[2]]] // true\n```\n\n## number + .\n```js\n3.toString() // error (3).toString()\n3..toString() // '3'\n3...toString() // error\n```\n\n## automatic global\n```js\n(function(){\n  var x = y = 1;\n})();\nconsole.log(y); // 1\nconsole.log(x); // x is not defined\n```\n\n## regexp expression\n```js\nvar a = /123/,\n    b = /123/;\na == b\na === b\n// false false\n```\n\n## function name is readonly\n```js\nfunction foo() { }\nvar oldName = foo.name;\nfoo.name = \"bar\";\n[oldName, foo.name]\n// 'foo' 'foo'\n```\n\n## parseInt 坑\n```js\n\"1 2 3\".replace(/\\d/g, parseInt)\n// [1, 0], [2, 2], [3, 4]\n// \"1 NaN 3\"\n\nparseInt(3, 8) // 3\nparseInt(3, 2) // NaN\nparseInt(3, 0) // 3\n```\n\n## function prototype\n```js\nfunction f() {}\nvar parent = Object.getPrototypeOf(f);\nf.name // f\nparent.name // empty\ntypeof eval(f.name) // function\ntypeof eval(parent.name) //  error\n```\n\n## regexp translate\n```js\nvar lowerCaseOnly =  /^[a-z]+$/;\n[lowerCaseOnly.test(null), lowerCaseOnly.test()]\n// 转化成'null' 'undefined'\n// true true\n```\n\n## [,,,].join(\", \")\n```js\n[,,,].join(\", \")\n// \", , \"\n```\n\n## function length\n```js\nvar a = Function.length,\n    b = new Function().length\na === b\n// 1 === 0 false\n```\n\n## Date equal\n```js\nvar a = Date(0);\nvar b = new Date(0);\nvar c = new Date();\n[a === b, b === c, a === c]\n// false false false\n```\n\n## function scope param\n```js\nfunction foo(a) {\n    var a;\n    return a;\n}\nfunction bar(a) {\n    var a = 'bye';\n    return a;\n}\n[foo('hello'), bar('hello')]\n// [\"hello\", \"bye\"]\n```\n\n## nodejs Event模块的简单实现\n```js\nfunction Event() {\n    this.on = function (eventName, callback) {\n        if (!this.handlers) {\n            this.handlers = {};\n        }\n        if (!this.handlers[eventName]){\n            this.handlers[eventName] = [];\n        }\n        this.handlers[eventName].push(callback);\n    }\n\n    this.emit = function (eventName, data) {\n        if (this.handlers[eventName]) {\n            this.handlers[eventName].forEach((item)=>{\n                item(data);\n            });\n        }\n    }\n    return this;\n}\n```\n\n## 实现超链接显示A网站实际跳转B网站\n```html\n<a href=\"//www.tmall.com\" onclick=\"host='jd.com'\">tmall</a>\n```\n\n## nodejs 恶作剧：给系统创建一个叫 node_modules 的用户，然后 npm install 就无法使用了\n\n## 最简单的方式实现`console.log(1)`返回0\n```js\nconsole = Math;\nconsole.log(1); // 0\n```","tags":["知识"],"categories":["知识"]},{"title":"快速了解React 16新特性","url":"%2Freact16.html","content":"\n## Error Boundary\n\nError Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）\n\n---\n<!-- more -->\n\n```javascript\n//最佳实践：将ErrorBoundary抽象为一个公用的组件类\n \nimport React, { Component } from 'react'\n \nexport default class ErrorBoundary extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  componentDidCatch(err, info) {\n    this.setState({ hasError: true })\n    //sendErrorReport(err,info)\n  }\n  render(){\n    if(this.state.hasError){\n      return <div>Something went wrong!</div>\n    }\n    return this.props.children\n  }\n}\n```\n\n```javascript\n// 使用方式 包裹容易出错的组件\nrender(){\n  return (\n    <div>\n      <ErrorBoundary>\n        <Profile user={this.state.user} />\n      </ErrorBoundary>\n      <button onClick={this.onClick}>Update</button>\n    </div>\n  )\n}\n```\n## render方法新增返回类型\n在React 16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。\n\n```javascript\n//string\nrender(){\n  return 'hello,world'\n}\n \n//number\nrender(){\n  return 12345\n}\n \n//boolean\nrender(){\n  return isTrue?true:false\n}\n \n//null\nrender(){\n  return null\n}\n \n//fragments，未加key标识符，控制台会出现warning\nrender(){\n  return [\n    <div>hello</div>,\n    <span>world</span>,\n    <p>oh</p>\n  ]\n}\n```\n以上各种类型现在均可以直接在render中返回，不需要再在外层包裹一层容器元素，不过在返回的数组类型中，需要在每个元素上加一个唯一且不变的key值，否则控制台会报一个warning。\n\n## 使用createPortal将组件渲染到当前组件树之外\n\n## 支持自定义DOM属性\n在之前的版本中，React会忽略无法识别的HTML和SVG属性，自定义属性只能通过data-*形式添加，现在它会把这些属性直接传递给DOM（这个改动让React可以去掉属性白名单，从而减少了文件大小）。\n\n## setState传入null时不会再触发更新\n\n## 更好的服务器端渲染\nReact 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。\n\n## 新的打包策略\n新的打包策略中去掉了process.env检查。\nReact 16的体积比上个版本减小了32%（30% post-gzip），文件尺寸的减小一部分要归功于打包方法的改变。\n\n## React 16采用了新的核心架构React Fiber。官方解释是“React Fiber是对核心算法的一次重新实现”","tags":["react"],"categories":["JS"]},{"title":"React 16新特性context api","url":"%2Fcontextapi.html","content":"\nReact 16.3带来了正式版的context API。让我们来看看有哪些改变，在那些地方可以取代redux吧！\n\n--- \n<!-- more -->\n\n我当前依赖的版本\n\n```javascript\n\"dependencies\": {\n    \"react\": \"^16.4.0\",\n    \"react-dom\": \"^16.4.0\"\n}\n```\n## 创建context实例\n```javascript\n// 创建context实例\nconst ThemeContext = React.createContext({\n  background: 'red',\n  color: 'white'\n});\n\nconst {Provider,Consumer} = ThemeContext\n```\n\n## Provider 组件 \n**Provider组件用于将context数据传给该组件树下的所有组件 value属性是context的内容。**\n\n```javascript\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider value={{ text: 'hello react!' }}>\n        <Comp1 />\n        <Comp2 />\n      </Provider>\n    );\n  }\n}\n```\n## Consumer 组件\n**Consumer消费Provider传递的数据**\n\n```javascript\n// 函数式\nconst Comp1 = () => (\n  <Consumer>\n    {context => <p>{context.text}</p>}\n  </Consumer>\n);\n// 类\nclass Comp2 extends React.Component {\n  render() {\n    return (\n      <Consumer>\n        {context => <p>{context.text}</p>}\n      </Consumer>\n    );\n  }\n}\n```\n如果你没有将Consumer作为Provider的子组件，那么Consumer将使用创建context时的参数作为context。","tags":["context api"],"categories":["JS"]},{"title":"如何理解JS闭包","url":"%2Fclosure.html","content":"\n{% centerquote %} \nJavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。\n{% endcenterquote %} \n\n在JS中函数作为普通对象进行传递\n\n--- \n<!-- more -->\n## 什么是闭包?\n简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。(函数和声明该函数的词法环境的组合)\n\n## 为什么需要闭包？\n使用闭包主要是为了设计私有的变量和方法。闭包的优点可以避免全局变量的污染，缺点是会常驻内存，增大内存的使用\n量，使用不当会造成内存泄漏。\n\n## 特点\n1. 定义外层函数，封装被保护的局部变量。 \n2. 定义内层函数，执行对外部函数变量的操作。 \n3. 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。\n\n## 特性\n1. 函数嵌套函数，内层函数被返回。\n2. 函数内部可以引用外部的参数和变量，以及外部函数能访问的所有变量和函数。但是，外部函数却不能够访问定义在内部函数中的变量和函数。\n3. 参数和变量不会被垃圾回收机制回收。\n\n## 实例\n```javascript\nvar add = (function () {\n    var counter = 0;\n    return function () {return counter += 1;}\n})();\nadd();\nadd();\nadd();\n// add()调用过后应当销毁其变量，但其内层函数被返回了，并且还保留着对变量的引用，所以没有销毁还保留在内存当中。\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(i)\n},i*1000)\n}\n// 打印3次3 执行setTimeout时for循环已经结束此时的i的值为3\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\n// 匿名闭包 封闭每个变量\n(function(index){\n  setTimeout(function(){\n  console.log(arr[index])\n},index*1000)\n})(i)\n} \n// one two three\n```\n\n避免使用过多的闭包，可以用let关键词，每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。\n\n```javascript\nvar arr=['one','two','three']\nfor(let i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(arr[i])\n},i*1000)\n}\n```\n\n```javascript\n// setTimeout(code, milliseconds, param1, param2, ...)\n// setTimeout(function, milliseconds, param1, param2, ...)\nvar i = 0\nwhile (i++ < 3) {\n  setTimeout(console.log, 0, i)\n}\n// 1 2 3 这个也是闭包\n```\n","tags":["闭包"],"categories":["JS"]},{"title":"使用 Async/Await 让你的代码更简洁","url":"%2Fes7async.html","content":"\nAsync/Await是一种允许我们像构建没有回调函数的普通函数一样构建Promise的新语法。以往的异步方法无外乎回调函数和`Promise`。但是Async/Await建立于[Promise](https://mydearest.cn/createPromise.html)之上。\n\n---\n<!-- more -->\n\n## Async/Await语法\n### async关键字(放置在一个函数前面)。\n\n```javascript\nasync function f() {\n    return 1\n    // return Promise.resolve(1)\n}\nf().then(value) // 1\n```\n\nasync修饰过的函数总是返回一个promise，如果代码中有return <非promise>语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。\n### await关键字(只能在async函数内部使用)\n关键词await可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行。\n\n```javascript\nfunction timeout(ms) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n### 错误处理(使用try-catch捕获)\n```javascript\nasync function f() {\n    try {\n        let response = await fetch('http://no-such-url')\n    } catch (err) {\n        alet(err) // TypeError: failed to fetch 也能捕获多行语句 类似链式Promise最后的单个catch函数\n    }\n}\nf()\n```\n\n如果我们不使用try-catch，然后async函数f()的调用产生的promise变成reject状态的话，我们可以添加.catch去处理它：\n\n```javascript\nasync function f() {\n    let response = await fetch('http://no-such-url')\n}\n// f()变成了一个rejected的promise\nf().catch(alert) // TypeError: failed to fetch\n```\n\n### 结合Promise.all\nasync/await能够与Promise.all友好的协作，当我们需要等待多个promise时，我们可以将他们包装在Promise.all中然后使用await：\n\n```javascript\n// 直到数组全部返回结果\nlet results = await Promise.all([\n   fetch(url1),\n   fetch(url2),\n   ...\n])\n```\n## 总结\n\n随着单页JavaScript web程序的兴起和对NodeJS的广泛采用，如何优雅的处理并发对于JavaScript开发人员来说比任何以往的时候都显得更为重要。Async/Await缓解了许多因为控制流问题而导致bug遍地的这个困扰着JavaScript代码库数十年的问题，并且几乎可以保证让任何异步代码块变的更精炼，更简单，更自信。","tags":["Async/Await"],"categories":["JS"]},{"title":"从 for 循环入手优化性能","url":"%2Fforloop.html","content":"\n今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？\n\n---\n<!-- more -->\n\n从最简单的遍历数组说起。\n\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet i = 0;\nlet arr = [];\nwhile (i < 50) {\n    arr.push(i);\n    i++;\n}\n```\n\n如果我们想从数组 arr 中取出数据，就必须要进行遍历，普遍的做法是：\n\n```javascript\nfor (let i = 0; i < arr.length; i++) {\n    // arr[i]\n}\n```\n\n但其实这样的写法遍历是最慢的，他要经过两次迭代，第一次是 i 的迭代，每次都要判断 i 是否小于 arr.length，第二次是 arr 的迭代，每次循环 arr 都会调用底层的迭代器，对长度进行计算，这样循环的效率非常低，时间空间复杂度为 O[n^2]。\n\n下面进行优化，看看两者到底有什么区别：\n\n```javascript\nfor (let i = 0, len = arr.length; i < len; i++) {\n    // arr[i]\n}\n```\n\n区别就是，整个循环当中，我们预存了 len 来保存数组的长度，这样不需要每次循环都调用底层迭代器，调用一次即可，这样的时间空间复杂度为 O[n+1]。\n\n但是这并不是最完美的，因为会多了一次迭代操作，那么该如何进行优化呢？\n\n```javascript\nfor (let i = 0, item; item = arr[i++];) {\n    // item\n}\n```\n这次迭代的时间空间复杂度为 O[n] ，完美做到了每次一迭代没有通过长度进行判断，而是直接通过下标进行取值的方式映射到了循环体内部。\n\n最后用5万条数据进行测试各种方式的循环时间：\n\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet index = 0;\nlet arr = [];\nwhile (index < 50000) {\n    arr.push(index);\n    index++;\n}\n\nconsole.time('one');\nfor (let i = 0; i < arr.length; i++) {\n\n}\nconsole.timeEnd('one');\n\nconsole.time('two');\nfor (let i = 0, len = arr.length; i < len; i++) {\n\n}\nconsole.timeEnd('two');\n\nconsole.time('three');\nfor (let i = 0, item; item = arr[i++];) {\n\n}\nconsole.timeEnd('three');\n\n// es6的数组遍历\nconsole.time('four');\nfor (let i of arr) {\n\n}\nconsole.timeEnd('four');\n// 会访问可枚举属性和原型的遍历，数组不推荐使用\nconsole.time('five');\nfor (let i in arr) {\n\n}\nconsole.timeEnd('five');\n// one: 0.711ms\n// two: 4.508ms\n// three: 0.006ms\n// four: 3.255ms\n// five: 11.144ms\n```\n在数据量大的情况下，第三种循环方式效果显而易见。","tags":["性能优化"],"categories":["JS"]},{"title":"es6函数新特性","url":"%2Fes6function.html","content":"\n1. 设置函数默认值 \n2. 结合解构赋值默认值使用\n3. 利用rest(...变量名)传入任意参数\n\n---\n<!-- more -->\n\n## ...rest和扩展运算符\nrest参数（…变量名），用于获取函数的多余参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入其中。\n```javascript\nfunction foo(...y){\n    console.log(y)  // [1,2,3,4]\n}\nfoo(1,2,3,4)\n```\n## 利用扩展运算符（…数组）替代数组的apply方法\n在es5中，需要用apply将数组转化为函数参数，在es6中就不需要这种方式了，可以使用…来代替\n```javascript\nfunction f(x, y, z) {\n    console.log(x + ' ' + y + ' ' + z);\n}\nvar args = [1, 2, 3];\n// f.apply(null, args)\nf(...args)\n```\n\n数组push的例子：\n```javascript\nvar arr1 = [0, 1, 2]\nvar arr2 = [3, 4, 5]\nvar arr3 = arr1.concat(arr2)\nconsole.log(arr3) //[ 0, 1, 2, 3, 4, 5 ]\n\nvar arr4 = arr1.push(arr2)\nconsole.log(arr1) //[ 0, 1, 2, [ 3, 4, 5 ] ]\n```\n\n如果想使用arr1.push方法的话，就需要用apply传arr2了\n```javascript\nvar arr4 = Array.prototype.push.apply(arr1, arr2) //[ 0, 1, 2, 3, 4, 5 ]\n```\n\n如果使用扩展运算符的话，就简单一些了\n```javascript\nvar arr4 = arr1.push(...arr2)\n```\n\n## name属性\n函数的name属性可以返回函数名\n```javasctrpt\nfunction abc(){\n    console.log(abc.name)\n}\nabc() // 'abc'\n```\n\n## 函数的静态变量和函数\n```javascript\nfunction Box(){}\n\nBox.num = 12;  //静态变量\nBox.fn = function(){};  //静态函数\n\nconsole.log(Box.num);  //12\nconsole.log(Box.fn);  //function(){}\nconsole.log(typeof Box.fn);  //function\n\nvar t = new Box();\nconsole.log(t.num);  //undefined\nconsole.log(t.fn);  //undefined\nconsole.log(typeof t.fn);//undefined\n```\n\n静态变量和静态函数是Box对象的属性和方法，不属于实例。\n\n## 函数的实例函数和变量\n```javascript\nfunction Box(){\n  this.a = [];  //实例变量\n  this.fn = function(){};  //实例方法\n}\n\nconsole.log(Box.a);  //undefined\nconsole.log(Box.fn);  //undefined\nconsole.log(typeof Box.fn);  //undefined\n\nvar t = new Box();\nvar t2 = new Box();\n\nconsole.log(t.a);  //[]\nconsole.log(t2.a);  //[]\nt.a.push(1);   // t.a [1]\nconsole.log(t2.a);  //[]\n\nconsole.log(typeof t.fn);\n```\n每个实例都有一套实例属性和实例方法，互不影响。\n\n原型上的属性和方法，是实例共用的。\n\n## 函数传参\n\n### 基本类型 (基本类型的变量复制)\n```javascript\nvar count = 10;\nfunction num(num1){\n   num1 = 1;\n   return num1;\n}\nvar result = num(count);\nconsole.log(result);//1\nconsole.log(count);//10，并未变成1\n```\n### 引用类型\n```javascript\nvar person  = {\n    name : \"Tom\"\n};\nfunction obj(peo){\n    peo.name = \"Jerry\";\n    return peo;\n}\nvar result = obj(person);\nconsole.log(result.name);// Jerry\nconsole.log(person.name);// Jerry\n```\n\n```javascript\nvar person = {\n    name : \"Tom\"\n}; \nfunction obj(peo){\n    peo = {\n       name : \"Jerry\"\n    };\n    return peo;\n}\nvar result = obj(person);\nconsole.log(result.name);// Jerry\nconsole.log(person.name);// Tom\n```\nperson传递给函数中的peo，但在函数内部peo又指向了一个新对象，所以result.name是新对象的值，person还是指向原对象，所以并没有改变。\n\nECMAScript中所有函数的参数都是按值传递的。 ——《JS高程》\n\n我们可以把ECMAScript函数的参数想象成局部变量，在向参数传递基本类型的值时，被传递的值被复制给一个局部变量。\n\n在向函数传递引用类型时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。\n\n即使在函数内部修改了参数的值，但原始的引用仍然保持未变。\n\n## 尾调用优化\n\n### 介绍\n尾调用指某个函数的最后一步是调用另一个函数。\n### demo\n```javascript\nfunction f(x) {\n    let y = g(x);\n    return y\n}//不是尾调用，因为最后一步返回了y，不是调用函数\n\nfunction f(x) {\n    return g(x) + 1\n}//不是尾调用，因为最后一步是加一，不是调用函数\n\nfunction f(x) {\n    g(x)\n}//不是尾调用，因为函数的最后一步是一个默认的return undefined；\n\nfunction f(x) {\n    return g(x)\n}//是尾调用\n```\n\n### 为什么尾调用\n函数调用会在内存形成一个“调用记录”，又称“调用帧”。每形成一个调用帧就会占用一定的内存，假如有一个函数A里面调用了函数B，函数B里面又调用了函数C，以此类推。\n\n在不是尾调用的情况下，因为js是单线程同步的，所以只有当函数B执行完毕才会执行函数A的return语句（函数没写return会有一个默认的return undefiend；），此时函数B的调用帧才会消失。但事实上，只有当函数B执行到return语句时才会执行完毕，而在函数B执行return之前会先调用函数C，所以当这种函数调用越来越多的时候，形成的调用帧也会越来越多占用的内存就会越来越大。俗话说精满自溢，内存也会有溢出的时候是吧，这就不行了！所以要用尾调用！\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n\n比如在执行递归的时候就可以利用尾调用达到优化内存的目的。函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n```javascript\n// 递归 计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) \nfunction factorial(n) {\n    if (n === 1) return 1;\n    return n * factorial(n - 1)\n}\nfactorial(5) //120\n\n// 改成尾递归，只保留一个调用记录，复杂度 O(1) \nfunction factorial(n, total) {\n    if (n === 1) return total;\n    return factorial(n - 1, n * total)\n}\nfactorial(5, 1) //120\n```\n\n## 函数声明覆盖\n```javascript\nfunction foo(){\nconsole.log(\"foo\");\n}\n\nvar foo = 1;\n// 1 如果foo不赋值 则打印函数\n```","tags":["es6"],"categories":["JS"]},{"title":"JavaScript 中 this 的详解","url":"%2Fjsthis.html","content":"\n## this 的指向\n\n`this` 是 js 中定义的关键字， 它的指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。在实际应用中，`this`的指向大致可以分为以下四种情况。\n\n> this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象;\n\n---\n<!-- more -->\n### 作为普通函数调用(直接调用)：函数名()\n当函数作为一个普通函数被调用，`this`指向全局对象。在浏览器里，全局对象就是 window。\n\n```javascript\nwindow.name = 'cosyer';\nfunction getName(){\n    console.log(this.name);\n}\ngetName();                   // cosyer\n```\n可以看出，此时`this`指向了全局对象 window。(NodeJS的全部对象是global)\n在ECMAScript5的严格模式下，这种情况`this`已经被规定不会指向全局对象了，而是undefined。\n\n```javascript\n'use strict';\nfunction fun(){\n    console.log(this);\n}\nfun();                      // undefined\n```\n### 作为对象的方法调用\n当函数作为一个对象里的方法被调用，`this`指向该对象\n\n```javascript\nvar obj = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\n\nobj.getName();              // cosyer\n```\n如果把对象的方法赋值给一个变量，再调用这个变量：\n\n```javascript\nvar obj = {\n    fun1 : function(){\n        console.log(this);\n    }\n}\nvar fun2 = obj.fun1;\nfun2();                     // window\n```\n此时调用 fun2 方法 输出了 window 对象，说明此时`this`指向了全局对象。给 fun2 赋值，其实是相当于：\n\n```javascript\nvar fun2 = function(){\n    console.log(this);\n}\n```\n可以看出，此时的`this`已经跟 obj 没有任何关系了。这时 fun2 是作为普通函数调用。\n\n### 作为构造函数调用\njs中没有类，但是可以从构造器中创建对象，并提供了`new`运算符来进行调用该构造器。构造器的外表跟普通函数一样，大部分的函数都可以当做构造器使用。当构造函数被调用时，`this`指向了该构造函数实例化出来的对象。\n\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n}\nvar obj = new Person();\nconsole.log(obj.name);      // cosyer\n```\n如果构造函数显式的返回一个对象(function或者object)，那么`this`则会指向该对象。\n\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n    return {\n        name : 'chenyu'\n    }\n}\nvar obj = new Person();\nconsole.log(obj.name);      // chenyu\n```\n如果该函数不用`new`调用，当作普通函数执行，那么`this`依然指向全局对象。\n\n### call() 或 apply() 调用 Function.prototype.bind()将当前函数绑定到指定对象绑定返回新函数之后再进行调用\n通过调用函数的 call() 或 apply() 方法可动态的改变`this`的指向。\n\n```javascript\nvar obj1 = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\nvar obj2 = {\n    name : 'chenyu'\n}\n\nobj1.getName();             // cosyer\nobj1.getName.call(obj2);    // chenyu\nobj1.getName.apply(obj2);   // chenyu\n```\n**简单的实现bind方法**\n\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 自定义的函数，模拟 bind() 对 this 的影响\nfunction myBind(func, target) {\n    return function() {\n        return func.apply(target, arguments); // 第一个参数为函数运行的this指向\n    };\n}\n\nconst testObj = myBind(test, obj);\ntest();     // false\ntestObj();  // true\n```\n从上面的示例可以看到，首先，通过闭包，保持了 target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this。\n\n不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行\n\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 绑定到一个新对象，而不是 obj\nconst testObj = test.bind({});\ntest.apply(obj);    // true\n\n// 期望 this 是 obj，即输出 true\n// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\ntestObj.apply(obj); // false\n```\n\n## 一道this练习题\n```javascript\nvar length = 10;\nfunction fn() {\n    console.log(this.length)\n};\nvar obj = {\n    length: 5, \n    method: function (fn) {\n        fn();\n        arguments[0](); // this被绑定到arguments上，而arguments确实存在一个length属性，并且值为2\n        fn.call(obj, 12);\n    }\n};\nobj.method(fn, 1);\n// 10 2 5\n```\n\n1. 默认绑定\n2. 隐式绑定\n3. 显示绑定\n4. new绑定\n> 默认绑定就是什么都匹配不到的情况下，非严格模式this绑定到全局对象window或者global,严格模式绑定到undefined;\n> 隐式绑定就是函数作为对象的属性，通过对象属性的方式调用，这个时候this绑定到对象;\n> 显示绑定就是通过apply和call调用的方式;\n> new绑定就是通过new操作符时将this绑定到当前新创建的对象中，它们的匹配有限是是从小到大的。\n\n## 箭头函数 \n{% note info %}\n箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对`this`的词法解析。\n在箭头函数出现之前，每个新定义的函数都有其自己的`this`值（例如，构造函数的`this`指向了一个新的对象；严格模式下的函数的`this`值为 undefined；如果函数是作为对象的方法被调用的，则其`this`指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。\n{% endnote %}\n\n### ES6 的箭头函数 ()=>，指向与一般function定义的函数不同，比较容易绕晕，箭头函数`this`的定义：箭头函数中的`this`是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的`this`，它的`this`是派生而来的。箭头函数会捕获其所在上下文的`this`值，作为自己的`this`值，即指向所在上下文的执行环境(直接外层函数)。\n\n### 基础语法\n```javascript\n// 等价于: => { return expression; } \n(param1, param2, …, paramN) => { statements }\n(param1, param2, …, paramN) => expression\n\n// 如果只有一个参数，圆括号是可选的:\n(singleParam) => { statements }\nsingleParam => { statements }\n\n// 无参数或者多参数的箭头函数需要使用圆括号或者下划线:\n() => { statements } _ => { statements }\n```\n### 高级语法\n```javascript\n// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:\nparams => ({foo: bar})\n\n// 支持 Rest parameters 和 default parameters:\n(param1, param2, ...rest) => { statements }\n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }\n\n// 支持参数列表中的解构赋值\nvar f = ([a, b] = [1, 2], c=3 ) => a + b + c;\nf(); // 6\n```\n\n### 箭头函数不可以使用arguments对象，\narguments对象在函数体内不存在，如果要用的话，可以用rest参数代替\n\n### 箭头函数没有原型\n```javascript\nvar Foo = () => {};\n\nconsole.log(Foo.prototype); // undefined\n```\n### 箭头函数无法构造函数\n```javascript\nvar Foo = () => {};\n\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n### 箭头函数无法使用yield\nyield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。\n\n### 箭头函数或者组件上绑定事件的时候this.xxx.bind(this)，这样会生成新函数，推荐constructor里bind() garbage collection(垃圾回收机制)，除非使用purecomponent只进行浅比较。\n","tags":["this指向"],"categories":["JS"]},{"title":"react面试题记录","url":"%2FreactInterview.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/reactInterview.jpeg , reactInterview, React%}\n---\n<!-- more -->\n\n## React面试问题\n下面是一个常用的关于 React 的面试问题列表：\n\n#### React 的工作原理\nReact 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diff\" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用`diff`的结果来更新真实DOM。虚拟DOM作为一种缓存机制优化了UI渲染减少昂贵的DOM变化的数量。\n\n#### 使用 React 有何优点\n* 只需查看 `render` 函数就会很容易知道一个组件是如何被渲染的\n* JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的\n* 支持服务端渲染，这可以改进 SEO 和性能\n* 易于测试\n* React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用\n\n#### 展示组件(Presentational component)和容器组件(Container component)之间有何不同\n展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\n\n容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 `Flux actions`，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。\n\n#### 类组件(Class component)和函数式组件(Functional component)之间有何不同\n* 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 `store` 并维持状态\n* 当组件仅是接收 `props`，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n\n#### (组件的)状态(state)和属性(props)之间有何不同\n`State` 是一种数据结构，用于组件挂载时所需数据的默认值。`State` 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\n\n`Props`(properties 的简写)则是组件的配置。`props` 由父组件传递给子组件，并且就子组件而言，`props` 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\n\n#### 指出(组件)生命周期方法的不同\n* `componentWillMount` -- 多用于根组件中的应用程序配置\n* `componentDidMount` -- 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成\n* `componentWillReceiveProps` -- 这个周期函数作用于特定的 prop 改变导致的 state 转换\n* `shouldComponentUpdate` -- 如果你担心组件过度渲染，`shouldComponentUpdate` 是一个改善性能的地方，因为如果组件接收了新的 `prop`， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染\n* `componentWillUpdate` -- 很少使用。它可以用于代替组件的 `componentWillReceiveProps` 和 `shouldComponentUpdate`(但不能访问之前的 props)\n* `componentDidUpdate` -- 常用于更新 DOM，响应 prop 或 state 的改变\n* `componentWillUnmount` -- 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器\n\n#### 应该在 React 组件的何处发起 Ajax 请求\n在 React 组件中，应该在 `componentDidMount` 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 `componentDidMount` 中发起网络请求将保证这有一个组件可以更新了。\n\n#### 何为受控组件(controlled component)\n在 HTML 中，类似 `<input>`, `<textarea>` 和 `<select>` 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 `onChange` 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。\n\n#### 在 React 中，refs 的作用是什么\nRefs 可以用于获取一个 DOM 节点或者 React 组件(组件实例)的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。\n\n#### 何为高阶组件(higher order component)\n高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 `connect` 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\n装饰器@decoration\n练习\n\n#### 高阶函数就是接受函数作为参数并且/或者返回函数作为输出的函数\n\n<hr />\n\n* 写一个反转其输入的 HOC\n* 写一个从 API 提供数据给传入的组件的 HOC\n* 写一个实现 shouldComponentUpdate 来避免 reconciliation 的 HOC\n* 写一个通过 `React.Children.toArray` 对传入组件的子组件进行排序的 HOC\n\n#### 使用箭头函数(arrow functions)的优点是什么\n* 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 `this` 值(在构造函数中是新对象；在严格模式下，函数调用中的 `this` 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 `this` 值。\n* 简单：箭头函数易于阅读和书写\n* 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 `this` 的值\n\n#### 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象\n因为 `this.props` 和 `this.state` 的更新可能是异步的，不能依赖它们的值去计算下一个 state。setState在生命周期里是异步的，第二个参数是组件重新渲染完成后的回调。\n\n#### 除了在构造函数中绑定 `this`，还有其它方式吗\n你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\n\n#### 怎么阻止组件的渲染\n在组件的 `render` 方法中返回 `null` 并不会影响触发组件的生命周期方法\n\n#### 当渲染一个列表时，何为 key？设置 key 的目的是什么\nKeys 会有助于 React 识别哪些 `items` 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 `items` 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 `items` 可以重新排序，就会导致 `re-render` 变慢。在map遍历是能唯一地标识元素item，时的处理列表更加高效。\n\n#### (在构造函数中)调用 super(props) 的目的是什么\n在 `super()` 被调用之前，子类是不能使用 `this` 的，在 ES2015 中，子类必须在 `constructor` 中调用 `super()`。传递 `props` 给 `super()` 的原因则是便于(在子类中)能在 `constructor` 访问 `this.props`。\n\n#### 何为 JSX\nJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就编程了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。\n\n缺点：b&& 强转成boolean类型 否则如果b=0渲染出0\n\n#### 怎么用 React.createElement 重写下面的代码\n\nQuestion：\n\n```js\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n\nAnswer：\n\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n#### 何为 `Children`\n在JSX表达式中，一个开始标签(比如`<a>`)和一个关闭标签(比如`</a>`)之间的内容会作为一个特殊的属性`props.children`被自动传递给包含着它的组件。\n\n这个属性有许多可用的方法，包括 `React.Children.map`，`React.Children.forEach`， `React.Children.count`， `React.Children.only`，`React.Children.toArray`。\n\n#### 在 React 中，何为 state\nState 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。\n\n#### 你为何排斥 create-react-app\n在你排斥之前，你并不能去配置 webpack 或 babel presets。\n\n#### 何为 redux\nRedux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。\n\n#### 在 Redux 中，何为 store\nStore 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：\n\n* 允许通过 `getState()` 访问 state\n* 运行通过 `dispatch(action)` 改变 state\n* 通过 `subscribe(listener)` 注册 listeners\n* 通过 `subscribe(listener)` 返回的函数处理 listeners 的注销\n\n#### 何为 action\nActions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。\n\n#### 何为 reducer\n一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。\n\n#### Redux Thunk 的作用是什么\nRedux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。\n\n#### 何为纯函数(pure function)\n一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。\n\n#### redux有哪些中间件，作用？\n中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。\n\nredux-logger：提供日志输出\n\nredux-thunk：处理异步操作\n\nredux-promise：处理异步操作，actionCreator的返回值是promise\n\n#### 示例项目\n* [React Spotify](https://github.com/Pau1fitz/react-spotify)\n* [React Soundcloud](https://github.com/andrewngu/sound-redux)\n\n#### 虚拟dom 普通的js对象\n虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。具体实现步骤如下：用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。插入新组件有了key可以帮助react找到映射。\n\n#### 事件委托\n每个setState重新渲染整个子树标记为dirty。 如果要压缩性能，请尽可能调用 setState，并使用shouldComponentUpdate 来防止重新渲染大型子树。把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的key属性，方便比较。pureComponent(浅比较)+immutable 替换成preact\n\n#### diff算法 \n把树形结构按照层级分解，只比较同级元素。\n\n给列表结构的每个单元添加唯一的key属性，方便比较。\n\nReact 只会匹配相同 class 的 component（这里面的class指的是组件的名字）\n\n合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.\n\n选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。\n\ndiff的只是html tag，并没有diff数据。\n\n#### setState的理解\n- setState 只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。\n- setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。\n- setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。\n\n#### 替换的属性\n\n- class/className for/htmlFor\n\n#### 插入html文本\n```javascript\ndangerouslySetInnerHTML={{__html: content}}\n```","tags":["面试"],"categories":["JS"]},{"title":"搭建VPS科学上网","url":"%2FscienceInternet.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/shadowsocks.jpg, Shadowsocks, Shadowsocks %}\n---\n<!-- more -->\n\n{% note info %}\n\n快速搭建Shadowsocks\n\n{% endnote %}\n\n## [购买Vultr服务器](https://www.vultr.com/)\n\n### Vultr服务器价格\n\nVultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题。\n\n最低价格的服务器是512M的内存，每个月500G的流量，只能说99%的情况下完全够用了！\n\n![introduce](http://cdn.mydearest.cn/blog/images/vultr.png)\n\n## 买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令\n\n```javascript\n\nwget --no-check-certificate -O shadowsocks.sh\nhttps://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n \nchmod +x shadowsocks.sh\n \n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n\n```\n\n接着按照提示输入密码，端口和加密方式，如下图：\n\n![ss1](http://cdn.mydearest.cn/blog/images/ss1.png)\n\n![ss2](http://cdn.mydearest.cn/blog/images/ss1.png)\n\n选择加密方式7(aes-256-cfb)。\n\n然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息。\n\n## 安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。\n\nWindows客户端(代理端口默认1080)\nhttps://github.com/shadowsocks/shadowsocks-windows/releases\n\nUbuntu \nsudo add-apt-repository ppa:hzwhuang/ss-qt5 \nsudo apt-get update \nsudo apt-get install shadowsocks-qt5\n\nMac客户端(代理端口默认1086)\n\nhttps://github.com/shadowsocks/ShadowsocksX-NG/releases\n\nAndroid客户端\n\nhttps://github.com/shadowsocks/shadowsocks-android/releases","tags":["vultr"],"categories":["工具"]},{"title":"Promise诞生记","url":"%2FcreatePromise.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/promise.png, Promise, Promise %}\n\n前端近年的兴起，有大部分是因为 `NodeJS` 的诞生，而 `NodeJS` 是个适用于 **异步IO** 密集型的语言，一些基于 `NodeJS` 的框架，比如 *KOA2、Adonis* 就有大量的 `async` 和 `await` 语法，`async`的函数的返回值就是 `Promise` 对象，我们可以用 `async` 和 `await` 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。\n\n## Promise 概念\n`Promise`是一种对异步操作的封装，主流的规范是Promise/A+。\n`Promise`可以使得异步代码层次清晰，便于理解，且更加容易维护。\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n生成实例时回执信作为参数的函数；<Br/> \n`resolve`函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n`reject`函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n---\n<!-- more -->\n\n```javascript\n// 执行顺序\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise'); // 新建后立即执行\n  resolve();\n  console.log(111)\n  return 0\n});\npromise.then(function() {\n  console.log('resolved.'); // 同步任务执行完成后才会执行\n});\nconsole.log('Hi!');\n// Promise\n// 111\n// Hi!\n// resolved\n```\n接下来我们就用`Promise`结合ajax来使用\n\n```javascript\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send(params);\n  });\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n这里我们会渐进式的来创建一个 `Promise` 的实现，如果，你还不了解 `Promise` ，赶快移步 [Promise](http://es6.ruanyifeng.com/#docs/promise) 了解学习，当然这个实现会符合 [Promise/A+](https://promisesaplus.com) 规范，`JavaScript` 中有很多第三方的 `Promise` 库，[bluebird](http://bluebirdjs.com/docs/getting-started.html) 就是一个第三方 `Promise` 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。\n\n---\n\n废话不多说，直接开干。。。 😠\n\n## 定义 Promise 类型\n\n一个简单 `Promise` 语法，如下\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... doSomething\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure 第二个函数可选\n});\n```\n\n### 实现 resolve 和 then\n\n首先我们以上 👆 的语法，自己定义一个 `Promise` 实例\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    callback(value);\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n一个简单的实例写好了，然后，来用一下，看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n\n```\n{% note info %}\n\n执行结果是：`callback is not a function`\n\n{% endnote %}\n\n### 改进1：延时resolve，修改 callback 为异步\n\n**这里就遇到一个问题： **  \n\n** 目前的Promise有一个bug，假如fn中所包含的是同步代码，则resolve会立即执行，`callback` 还是 `null` ，我们的代码是同步的，而不是异步的。</br> 如是，想办法解决掉这个问题，就是利用 `setTimeout` , 把 `callback` 加入异步队列** \n\n代码如下 👇\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    // 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法\n    setTimeout(function(){\n      callback(value);\n    },0)\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n\n### 改进2：注册多个回调函数，并实现then的链式调用\n\n```javascript\nfunction Promise(fn) {\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    callbackList.push(cb);\n    // 实现链式调用\n    return this\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       // 遍历callbackList数组依次执行\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n### 改进3：引入状态\n\n```javascript\nfunction Promise(fn) {\n  let state='pending'\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    if(state=='pending'){\n      // pending加入队列\n      callbackList.push(cb);\n      return this\n    }\n    if(state=='fulfilled'){\n      // fulfilled立即执行\n      cb(value)\n      return this\n    }\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n\n**手动实现一个Promise：**\n\n```javascript\nclass Promise(){\n  construtor(fn){\n       // 执行队列\n       this._wathcList=[]\n       // 成功\n       this._success_res=null\n       // 失败\n       this._error_res=null\n       this._status=\"success\"\n       fn((...args))=>{\n          // 保存成功数据\n          this._success_res=args\n          this._status='success'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn1(...args);\n          });\n       },(...args)=>{\n          // 保存失败数据\n          this._error_res=args\n          this._status='error'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn2(...args);\n          });\n       }\n  }\n  // then 函数\n  then(fn1, fn2) {\n      if (this._status === \"success\") {\n          fn1(...this._success_res);\n      } else if (this._status === \"error\") {\n          fn2(...this._error_res);\n      } else {\n          this._watchList.push({\n              fn1,\n              fn2\n          })\n      }\n  }\n}\n```\n**实现Promise.all**\n\n```javascript\nPromise1.all = function(arr) {\n    // 存放结果集\n    let result = [];\n    return Promise1(function(resolve, reject) {\n        let i = 0;\n        // 进行迭代执行\n        function next() {\n            arr[i].then(function(res) {\n                // 存放每个方法的返回值\n                result.push(res);\n                i++;\n                // 若全部执行完\n                if (i === result.length) {\n                    // 执行then回调\n                    resolve(result);\n                } else {\n                    // 继续迭代\n                    next();\n                }\n            }, reject)\n        }\n    })\n}\n```\n### 嵌套使用\nPromise可以嵌套使用，这样可以是多个任务有条不紊地进行，假设p1是一个Promise对象而p2、p3都是能够产生Promise对象的方法(如果直接new那么Promise将会被直接执行)，那么你可以这样写，使得他们按照顺序执行，并且可以一次性处理他们产生的错误。\n\n```javascript\nlet p1 = new Promise((resolve, reject) => {\n    console.log('p1');\n    setTimeout(() => {\n        resolve('p2');\n    }, 1000)\n});\n\nlet p2 = (result) => new Promise((resolve, reject) => {\n    console.log(result);\n    setTimeout(() => {\n        resolve('p3');\n    }, 2000);\n});\n\nlet p3 = (result) => new Promise((resolve, reject) => {\n    console.log(result);\n    setTimeout(() => {\n        resolve('over');\n    }, 3000);\n});\n\np1\n    .then(p2)\n    .then(p3)\n    .then((result) => {\n        console.log(result);\n    })\n    .catch((error) => {\n        console.log(error);\n    });\n```\n\n## lite Promise\n```js\nfunction isFunction(target) {\n  return Object.prototype.toString.call(target) === \"[object Function]\";\n}\n\nclass _Promise {\n  constructor(executor) {\n    this.status = \"pending\";\n    this.onResolveCallbacks = [];\n    this.onRejectCallbacks = [];\n\n    let handlerGenerator = status => data => {\n      this.data = data;\n      this.status = status;\n\n      let dict = {\n        resolve: \"onResolveCallbacks\",\n        reject: \"onRejectCallbacks\"\n      };\n\n      executeCallback(this[dict[status]]);\n    };\n\n    let executeCallback = cbs => {\n      for (let cb of cbs) {\n        cb(this.data);\n      }\n    };\n\n    let resolve = handlerGenerator(\"resolve\").bind(this);\n    let reject = handlerGenerator(\"reject\").bind(this);\n\n    executor(resolve, reject);\n  }\n\n  _funcPoly(data) {\n    return data;\n  }\n\n  _PromiseGenerator(onResolved, onRejected) {\n    let self = this;\n\n    return new _Promise((resolve, reject) => {\n      let body = () => {\n        let status = self.status;\n\n        try {\n          let result =\n            status === \"resolve\"\n              ? onResolved(self.data)\n              : status === \"reject\"\n              ? onRejected(self.data)\n              : undefined;\n\n          if (result instanceof _Promise) {\n            return resolvedResult.then(resolve, reject);\n          }\n\n          if (status === \"resolve\") {\n            resolve(result);\n          }\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      if (self.status === \"pending\") {\n        self.onResolveCallbacks.push(body);\n        self.onRejectCallbacks.push(body);\n      } else {\n        body(self.status);\n      }\n    });\n  }\n\n  then(onResolved = this._funcPoly, onRejected = this._funcPoly) {\n    return this._PromiseGenerator(onResolved, onRejected);\n  }\n\n  catch(onRejected) {\n    this.then(null, onRejected);\n  }\n}\n\nnew _Promise(function(resolve){\n  console.log(1)\n  resolve()\n}).then(console.log(2))\nconsole.log(3)\n```\n\n## Promise使用注意点\n1. 一般来说，调用`resolve`或`reject`以后，`Promise`的使命就完成了，后继操作应该放到`then`方法里面，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。\n\n2. `Promise`实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为`Promise`实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即then方法后面再调用另一个`then`方法。\n\n3. `Promise.prototype.catch`方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。`getJSON`方法返回一个`Promise`对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n4. 一般来说，不要在then方法里面定义`reject`状态的回调函数（即then的第二个参数），总是使用`catch`方法。\n\n5. 跟传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应，`Promise`会吃掉错误。\n","tags":["Promise"],"categories":["JS"]},{"title":"如何使用 markdown 语法写博客","url":"%2FmarkdownGrammar.html","content":"\n{% fi http://cdn.mydearest.cn/blog/images/markdown.png, Markdown, Markdown %}\n\n{% note info %}\n\n{% endnote %}\n\n{% centerquote %} \n\n{% endcenterquote %}\n\n# 标题1\n## 标题2\n*斜体*\n**粗体**\n***粗斜体***<br/>\n~~删除线~~\n<u>下划线文本</u>\n\n1. I\n2. Love \n3. You\n\n- 点\n\n+ Foo\n+ Bar\n---\n<!-- more -->\n\n分隔线\n***\n--- \n___\n\n* * *\n>一级引用\n>>二级引用\n\n`#include<iostream>`\n```\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n```\n~~~\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n~~~\n|标题|标题|标题|\n|:---|:---:|---:|\n|居左测试文本|居中测试文本|居右测试文本|\n|居左测试文本1|居中测试文本2|居右测试文本3|\n|居左测试文本11|居中测试文本22|居右测试文本33|\n|居左测试文本111|居中测试文本222|居右测试文本333|\n\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n### 反斜杠\n\n`Markdown` 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n```\n\\*literal asterisks\\*\n```\n效果如下：\n\n\\*literal asterisks\\*\n\n`Markdown` 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```\n  \\   反斜线\n  `   反引号\n  *   星号\n  _   底线\n  {}  花括号\n  []  方括号\n  ()  括弧\n  #   井字号\n  +   加号\n  -   减号\n  .   英文句点\n  !   惊叹号\n```\n登录[百度](http://www.baidu.com)\n![Teddy Bear](http://img2.everychina.com/img/d7/f7/1b580dfa9315111397ef93fd24ea-250x250c1-77f7/love_valentine_plush_teddy_bear.jpg)\n","tags":["markdown"],"categories":["工具"]},{"title":"Hello World - 热爱编程的普通人，顺便以此为生。","url":"%2Fhello-world.html","content":"\n之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n---\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n如果说人生是自我编写的程序，\n\n那么青春就是其中意味深长的代码。\n\n或简单，\n\n分解成彼此独立的字符；\n\n或复杂，\n\n拼凑一连串神秘的语句。\n\n我们尝试着不断调试，\n\n不断优化，\n\n无论编译的结果如何，\n\n过程才是最美。\n\n如果说这段代码不能复制，\n\n那么我愿意用一生去续写….\n\n           —— 献给我们那可以肆意挥洒的青春，一直青春下去。","tags":["吐槽"],"categories":["杂谈"]}]