[{"title":"快速了解React 16新特性","url":"%2Freact16.html","content":"\n## Error Boundary\nError Boundary可以看作是一种特殊的React组件，新增了componentDidCatch这个生命周期函数，它可以捕获自身及子树上的错误并对错误做优雅处理，包括上报错误日志、展示出错提示，而不是卸载整个组件树。（注：它并不能捕获runtime所有的错误，比如组件回调事件里的错误，可以把它想象成传统的try-catch语句）\n```javascript\n//最佳实践：将ErrorBoundary抽象为一个公用的组件类\n \nimport React, { Component } from 'react'\n \nexport default class ErrorBoundary extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  componentDidCatch(err, info) {\n    this.setState({ hasError: true })\n    //sendErrorReport(err,info)\n  }\n  render(){\n    if(this.state.hasError){\n      return <div>Something went wrong!</div>\n    }\n    return this.props.children\n  }\n}\n```\n\n```javascript\n// 使用方式 包裹容易出错的组件\nrender(){\n  return (\n    <div>\n      <ErrorBoundary>\n        <Profile user={this.state.user} />\n      </ErrorBoundary>\n      <button onClick={this.onClick}>Update</button>\n    </div>\n  )\n}\n```\n## render方法新增返回类型\n在React 16中，render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级。\n\n```javascript\n//string\nrender(){\n  return 'hello,world'\n}\n \n//number\nrender(){\n  return 12345\n}\n \n//boolean\nrender(){\n  return isTrue?true:false\n}\n \n//null\nrender(){\n  return null\n}\n \n//fragments，未加key标识符，控制台会出现warning\nrender(){\n  return [\n    <div>hello</div>,\n    <span>world</span>,\n    <p>oh</p>\n  ]\n}\n```\n以上各种类型现在均可以直接在render中返回，不需要再在外层包裹一层容器元素，不过在返回的数组类型中，需要在每个元素上加一个唯一且不变的key值，否则控制台会报一个warning。\n\n## 使用createPortal将组件渲染到当前组件树之外\n\n## 支持自定义DOM属性\n在之前的版本中，React会忽略无法识别的HTML和SVG属性，自定义属性只能通过data-*形式添加，现在它会把这些属性直接传递给DOM（这个改动让React可以去掉属性白名单，从而减少了文件大小）。\n\n## setState传入null时不会再触发更新\n\n## 更好的服务器端渲染\nReact 16的SSR被完全重写，新的实现非常快，接近3倍性能于React 15，现在提供一种流模式streaming，可以更快地把渲染的字节发送到客户端。\n\n## 新的打包策略\n新的打包策略中去掉了process.env检查。\nReact 16的体积比上个版本减小了32%（30% post-gzip），文件尺寸的减小一部分要归功于打包方法的改变。\n\n## React 16采用了新的核心架构React Fiber。官方解释是“React Fiber是对核心算法的一次重新实现”","tags":["react"],"categories":["JS"]},{"title":"React 16新特性context api","url":"%2Fcontextapi.html","content":"\nReact 16.3带来了正式版的context API。让我们来看看有哪些改变，在那些地方可以取代redux吧！\n\n我当前依赖的版本\n```javascript\n\"dependencies\": {\n    \"react\": \"^16.4.0\",\n    \"react-dom\": \"^16.4.0\"\n}\n```\n## 创建context实例\n```javascript\n// 创建context实例\nconst ThemeContext = React.createContext({\n  background: 'red',\n  color: 'white'\n});\n\nconst {Provider,Consumer} = ThemeContext\n```\n\n## Provider 组件 \n**Provider组件用于将context数据传给该组件树下的所有组件 value属性是context的内容。**\n```javascript\nclass App extends React.Component {\n  render() {\n    return (\n      <Provider value={{ text: 'hello react!' }}>\n        <Comp1 />\n        <Comp2 />\n      </Provider>\n    );\n  }\n}\n```\n## Consumer 组件\n**Consumer消费Provider传递的数据**\n```javascript\n// 函数式\nconst Comp1 = () => (\n  <Consumer>\n    {context => <p>{context.text}</p>}\n  </Consumer>\n);\n// 类\nclass Comp2 extends React.Component {\n  render() {\n    return (\n      <Consumer>\n        {context => <p>{context.text}</p>}\n      </Consumer>\n    );\n  }\n}\n```\n如果你没有将Consumer作为Provider的子组件，那么Consumer将使用创建context时的参数作为context。","tags":["context api"],"categories":["JS"]},{"title":"如何理解JS闭包","url":"%2Fclosure.html","content":"\n{% centerquote %} \nJavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里。\n{% endcenterquote %} \n\n在JS中函数作为普通对象进行传递\n--- \n<!-- more -->\n## 什么是闭包?\n简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。\n\n## 为什么需要闭包？\n使用闭包主要是为了设计私有的变量和方法。闭包的优点可以避免全局变量的污染，缺点是会常驻内存，增大内存的使用\n量，使用不当会造成内存泄漏。\n\n## 特点\n1. 定义外层函数，封装被保护的局部变量。 \n2. 定义内层函数，执行对外部函数变量的操作。 \n3. 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。\n\n## 特性\n1. 函数嵌套函数。\n2. 函数内部可以引用外部的参数和变量。\n3. 参数和变量不会被垃圾回收机制回收。\n\n## 实例\n```javascript\nvar add = (function () {\n    var counter = 0;\n    return function () {return counter += 1;}\n})();\nadd();\nadd();\nadd();\n// add()调用过后应当销毁其变量，但其内层函数被返回了，并且还保留着对变量的引用，所以没有销毁还保留在内存当中。\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(arr[i])\n},i*1000)\n}\n// 打印3次3 执行setTimeout时for循环已经结束此时的i的值为3\n```\n\n```javascript\nvar arr=['one','two','three']\nfor(var i =0;i<arr.length;i++){\n// 匿名闭包\n(function(index){\n  setTimeout(function(){\n  console.log(arr[index])\n},index*1000)\n})(i)\n}\n```\n\n避免使用过多的闭包，可以用let关键词，每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。\n```javascript\nvar arr=['one','two','three']\nfor(let i =0;i<arr.length;i++){\nsetTimeout(function(){\n  console.log(arr[i])\n},i*1000)\n}\n```\n","tags":["闭包"],"categories":["JS"]},{"title":"使用 Async/Await 让你的代码更简洁","url":"%2Fes7async.html","content":"\nAsync/Await是一种允许我们像构建没有回调函数的普通函数一样构建Promise的新语法。以往的异步方法无外乎回调函数和`Promise`。但是Async/Await建立于[Promise](https://mydearest.cn/createPromise.html)之上。\n\n---\n<!-- more -->\n\n## Async/Await语法\n### async关键字(放置在一个函数前面)。\n\n```javascript\nasync function f() {\n    return 1\n    // return Promise.resolve(1)\n}\nf().then(value) // 1\n```\n\nasync修饰过的函数总是返回一个promise，如果代码中有return <非promise>语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。\n### await关键字(只能在async函数内部使用)\n关键词await可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行。\n\n```javascript\nfunction timeout(ms) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, ms);\n    });\n}\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world', 50);\n```\n\n### 错误处理(使用try-catch捕获)\n```javascript\nasync function f() {\n    try {\n        let response = await fetch('http://no-such-url')\n    } catch (err) {\n        alet(err) // TypeError: failed to fetch 也能捕获多行语句 类似链式Promise最后的单个catch函数\n    }\n}\nf()\n```\n\n如果我们不使用try-catch，然后async函数f()的调用产生的promise变成reject状态的话，我们可以添加.catch去处理它：\n```javascript\nasync function f() {\n    let response = await fetch('http://no-such-url')\n}\n// f()变成了一个rejected的promise\nf().catch(alert) // TypeError: failed to fetch\n```\n\n### 结合Promise.all\nasync/await能够与Promise.all友好的协作，当我们需要等待多个promise时，我们可以将他们包装在Promise.all中然后使用await：\n\n```javascript\n\n// 直到数组全部返回结果\nlet results = await Promise.all([\n   fetch(url1),\n   fetch(url2),\n   ...\n])\n```\n## 总结\n\n随着单页JavaScript web程序的兴起和对NodeJS的广泛采用，如何优雅的处理并发对于JavaScript开发人员来说比任何以往的时候都显得更为重要。Async/Await缓解了许多因为控制流问题而导致bug遍地的这个困扰着JavaScript代码库数十年的问题，并且几乎可以保证让任何异步代码块变的更精炼，更简单，更自信。","tags":["Async/Await"],"categories":["JS"]},{"title":"从 for 循环入手优化性能","url":"%2Fforloop.html","content":"\n今天要说的是最简单的 for 循环，一个简单的 for 循环看似没有任何优化的意义，但实质上优化前后差距挺大的，那么该如何优化呢？\n\n---\n<!-- more -->\n\n从最简单的遍历数组说起。\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet i = 0;\nlet arr = [];\nwhile (i < 50) {\n    arr.push(i);\n    i++;\n}\n```\n\n如果我们想从数组 arr 中取出数据，就必须要进行遍历，普遍的做法是：\n```javascript\nfor (let i = 0; i < arr.length; i++) {\n    // arr[i]\n}\n```\n\n但其实这样的写法遍历是最慢的，他要经过两次迭代，第一次是 i 的迭代，每次都要判断 i 是否小于 arr.length，第二次是 arr 的迭代，每次循环 arr 都会调用底层的迭代器，对长度进行计算，这样循环的效率非常低，时间空间复杂度为 O[n^2]。\n\n下面进行优化，看看两者到底有什么区别：\n```javascript\nfor (let i = 0, len = arr.length; i < len; i++) {\n    // arr[i]\n}\n```\n\n区别就是，整个循环当中，我们预存了 len 来保存数组的长度，这样不需要每次循环都调用底层迭代器，调用一次即可，这样的时间空间复杂度为 O[n+1]。\n\n但是这并不是最完美的，因为会多了一次迭代操作，那么该如何进行优化呢？\n```javascript\nfor (let i = 0, item; item = arr[i++];) {\n    // item\n}\n```\n这次迭代的时间空间复杂度为 O[n] ，完美做到了每次一迭代没有通过长度进行判断，而是直接通过下标进行取值的方式映射到了循环体内部。\n\n最后用5万条数据进行测试各种方式的循环时间：\n```javascript\n// 定义一个数组arr（假设是从后台返回的数据）\nlet index = 0;\nlet arr = [];\nwhile (index < 50000) {\n    arr.push(index);\n    index++;\n}\n\nconsole.time('one');\nfor (let i = 0; i < arr.length; i++) {\n\n}\nconsole.timeEnd('one');\n\nconsole.time('two');\nfor (let i = 0, len = arr.length; i < len; i++) {\n\n}\nconsole.timeEnd('two');\n\nconsole.time('three');\nfor (let i = 0, item; item = arr[i++];) {\n\n}\nconsole.timeEnd('three');\n\n// es6的数组遍历\nconsole.time('four');\nfor (let i of arr) {\n\n}\nconsole.timeEnd('four');\n// 会访问可枚举属性和原型的遍历，数组不推荐使用\nconsole.time('five');\nfor (let i in arr) {\n\n}\nconsole.timeEnd('five');\n// one: 0.711ms\n// two: 4.508ms\n// three: 0.006ms\n// four: 3.255ms\n// five: 11.144ms\n```\n在数据量大的情况下，第三种循环方式效果显而易见。\n\n","tags":["性能优化"],"categories":["JS"]},{"title":"es6函数新特性","url":"%2Fes6function.html","content":"\n1. 设置函数默认值 \n2. 结合解构赋值默认值使用\n3. 利用rest(...变量名)传入任意参数\n\n---\n<!-- more -->\n\n## ...rest和扩展运算符\nrest参数（…变量名），用于获取函数的多余参数，rest参数搭配的变量是一个数组，该变量将多余的参数放入其中。\n```javascript\nfunction foo(...y){\n    console.log(y)  // [1,2,3,4]\n}\nfoo(1,2,3,4)\n```\n## 利用扩展运算符（…数组）替代数组的apply方法\n在es5中，需要用apply将数组转化为函数参数，在es6中就不需要这种方式了，可以使用…来代替\n```javascript\nfunction f(x, y, z) {\n    console.log(x + ' ' + y + ' ' + z);\n}\nvar args = [1, 2, 3];\n// f.apply(null, args)\nf(...args)\n```\n\n数组push的例子：\n```javascript\nvar arr1 = [0, 1, 2]\nvar arr2 = [3, 4, 5]\nvar arr3 = arr1.concat(arr2)\nconsole.log(arr3) //[ 0, 1, 2, 3, 4, 5 ]\n\nvar arr4 = arr1.push(arr2)\nconsole.log(arr1) //[ 0, 1, 2, [ 3, 4, 5 ] ]\n```\n\n如果想使用arr1.push方法的话，就需要用apply传arr2了\n```javascript\nvar arr4 = Array.prototype.push.apply(arr1, arr2) //[ 0, 1, 2, 3, 4, 5 ]\n```\n\n如果使用扩展运算符的话，就简单一些了\n```javascript\nvar arr4 = arr1.push(...arr2)\n```\n\n## name属性\n函数的name属性可以返回函数名\n```javasctrpt\nfunction abc(){\n    console.log(abc.name)\n}\nabc() // 'abc'\n```","tags":["es6"],"categories":["JS"]},{"title":"JavaScript 中 this 的详解","url":"%2Fjsthis.html","content":"\n## this 的指向\n\n`this` 是 js 中定义的关键字， 它的指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。在实际应用中，`this`的指向大致可以分为以下四种情况。\n\n---\n<!-- more -->\n### 作为普通函数调用(直接调用)：函数名()\n当函数作为一个普通函数被调用，`this`指向全局对象。在浏览器里，全局对象就是 window。\n```javascript\nwindow.name = 'cosyer';\nfunction getName(){\n    console.log(this.name);\n}\ngetName();                   // cosyer\n```\n可以看出，此时`this`指向了全局对象 window。(NodeJS的全部对象是global)\n在ECMAScript5的严格模式下，这种情况`this`已经被规定不会指向全局对象了，而是undefined。\n```javascript\n'use strict';\nfunction fun(){\n    console.log(this);\n}\nfun();                      // undefined\n```\n### 作为对象的方法调用\n当函数作为一个对象里的方法被调用，`this`指向该对象\n```javascript\nvar obj = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\n\nobj.getName();              // cosyer\n```\n如果把对象的方法赋值给一个变量，再调用这个变量：\n```javascript\nvar obj = {\n    fun1 : function(){\n        console.log(this);\n    }\n}\nvar fun2 = obj.fun1;\nfun2();                     // window\n```\n此时调用 fun2 方法 输出了 window 对象，说明此时`this`指向了全局对象。给 fun2 赋值，其实是相当于：\n```javascript\nvar fun2 = function(){\n    console.log(this);\n}\n```\n可以看出，此时的`this`已经跟 obj 没有任何关系了。这时 fun2 是作为普通函数调用。\n\n### 作为构造函数调用\njs中没有类，但是可以从构造器中创建对象，并提供了`new`运算符来进行调用该构造器。构造器的外表跟普通函数一样，大部分的函数都可以当做构造器使用。当构造函数被调用时，`this`指向了该构造函数实例化出来的对象。\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n}\nvar obj = new Person();\nconsole.log(obj.name);      // cosyer\n```\n如果构造函数显式的返回一个对象，那么`this`则会指向该对象。\n```javascript\nvar Person = function(){\n    this.name = 'cosyer';\n    return {\n        name : 'chenyu'\n    }\n}\nvar obj = new Person();\nconsole.log(obj.name);      // chenyu\n```\n如果该函数不用`new`调用，当作普通函数执行，那么`this`依然指向全局对象。\n\n### call() 或 apply() 调用 Function.prototype.bind()将当前函数绑定到指定对象绑定返回新函数之后再进行调用\n通过调用函数的 call() 或 apply() 方法可动态的改变`this`的指向。\n```javascript\nvar obj1 = {\n    name : 'cosyer',\n    getName : function(){\n        console.log(this.name);\n    }\n}\nvar obj2 = {\n    name : 'chenyu'\n}\n\nobj1.getName();             // cosyer\nobj1.getName.call(obj2);    // chenyu\nobj1.getName.apply(obj2);   // chenyu\n```\n**简单的实现bind方法**\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 自定义的函数，模拟 bind() 对 this 的影响\nfunction myBind(func, target) {\n    return function() {\n        return func.apply(target, arguments); // 第一个参数为函数运行的this指向\n    };\n}\n\nconst testObj = myBind(test, obj);\ntest();     // false\ntestObj();  // true\n```\n从上面的示例可以看到，首先，通过闭包，保持了 target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this。\n\n不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行\n```javascript\nconst obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n// 绑定到一个新对象，而不是 obj\nconst testObj = test.bind({});\ntest.apply(obj);    // true\n\n// 期望 this 是 obj，即输出 true\n// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\ntestObj.apply(obj); // false\n```\n\n## 箭头函数 \n{% note info %}\n箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对`this`的词法解析。\n在箭头函数出现之前，每个新定义的函数都有其自己的`this`值（例如，构造函数的`this`指向了一个新的对象；严格模式下的函数的`this`值为 undefined；如果函数是作为对象的方法被调用的，则其`this`指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。\n{% endnote %}\n\n### ES6 的箭头函数 ()=>，指向与一般function定义的函数不同，比较容易绕晕，箭头函数`this`的定义：箭头函数中的`this`是在定义函数的时候绑定，而不是在执行函数的时候绑定。本质来说箭头函数没有自己的`this`，它的`this`是派生而来的。箭头函数会捕获其所在上下文的`this`值，作为自己的`this`值，即指向所在上下文的执行环境(直接外层函数)。\n\n### 基础语法\n```javascript\n// 等价于: => { return expression; } \n(param1, param2, …, paramN) => { statements }\n(param1, param2, …, paramN) => expression\n\n// 如果只有一个参数，圆括号是可选的:\n(singleParam) => { statements }\nsingleParam => { statements }\n\n// 无参数或者多参数的箭头函数需要使用圆括号或者下划线:\n() => { statements } _ => { statements }\n```\n### 高级语法\n```javascript\n// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来:\nparams => ({foo: bar})\n\n// 支持 Rest parameters 和 default parameters:\n(param1, param2, ...rest) => { statements }\n(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }\n\n// 支持参数列表中的解构赋值\nvar f = ([a, b] = [1, 2], = ) => a + b + c;\nf(); // 6\n```\n\n### 箭头函数不可以使用arguments对象，\narguments对象在函数体内不存在，如果要用的话，可以用rest参数代替\n\n### 箭头函数没有原型\n```javascript\nvar Foo = () => {};\n\nconsole.log(Foo.prototype); // undefined\n```\n### 箭头函数无法构造函数\n```javascript\nvar Foo = () => {};\n\nvar foo = new Foo(); // TypeError: Foo is not a constructor\n```\n### 箭头函数无法使用yield\nyield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。\n\n### 箭头函数或者组件上绑定事件的时候this.xxx.bind(this)，这样会生成新函数，推荐constructor里bind()\n","tags":["this指向"],"categories":["JS"]},{"title":"react面试题记录","url":"%2FreactInterview.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/reactInterview.jpeg , reactInterview, React%}\n---\n<!-- more -->\n\n## React面试问题\n下面是一个常用的关于 React 的面试问题列表：\n\n* [React 的工作原理](#react-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)?\n* [使用 React 有何优点](#%E4%BD%BF%E7%94%A8-react-%E6%9C%89%E4%BD%95%E4%BC%98%E7%82%B9)？\n* [展示组件(Presentational component)和容器组件(Container component)之间有何不同](#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6presentational-component%E5%92%8C%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6container-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [类组件(Class component)和函数式组件(Functional component)之间有何不同](#%E7%B1%BB%E7%BB%84%E4%BB%B6class-component%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6functional-component%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [(组件的)状态(state)和属性(props)之间有何不同](#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81state%E5%92%8C%E5%B1%9E%E6%80%A7props%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C)？\n* [指出(组件)生命周期方法的不同](#%E6%8C%87%E5%87%BA%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C)？\n* [应该在 React 组件的何处发起 Ajax 请求](#%E5%BA%94%E8%AF%A5%E5%9C%A8-react-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%95%E5%A4%84%E5%8F%91%E8%B5%B7-ajax-%E8%AF%B7%E6%B1%82)？\n* [何为受控组件(controlled component)](#%E4%BD%95%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6controlled-component)？\n* [在 React 中，refs 的作用是什么](#%E5%9C%A8-react-%E4%B8%ADrefs-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为高阶组件(higher order component)](#%E4%BD%95%E4%B8%BA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6higher-order-component)？\n* [使用箭头函数(arrow functions)的优点是什么](#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0arrow-functions%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [为什么建议传递给 setState 的参数是一个 callback 而不是一个对象](#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BC%A0%E9%80%92%E7%BB%99-setstate-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA-callback-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1)？\n* [除了在构造函数中绑定 `this`，还有其它方式吗](#%E9%99%A4%E4%BA%86%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%91%E5%AE%9A-this%E8%BF%98%E6%9C%89%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E5%90%97)？\n* [怎么阻止组件的渲染](#%E6%80%8E%E4%B9%88%E9%98%BB%E6%AD%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93)？\n* [当渲染一个列表时，何为 key？设置 key 的目的是什么](#%E5%BD%93%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%E6%97%B6%E4%BD%95%E4%B8%BA-key%E8%AE%BE%E7%BD%AE-key-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [(在构造函数中)调用 super(props) 的目的是什么](#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8-superprops-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为 JSX](#%E4%BD%95%E4%B8%BA-jsx)？\n* [怎么用 React.createElement 重写下面的代码](#%E6%80%8E%E4%B9%88%E7%94%A8%20React.createElement%20%E9%87%8D%E5%86%99%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81)？\n* [何为 `Children`](#%E4%BD%95%E4%B8%BA-children)？\n* [在 React 中，何为 state](#%E5%9C%A8-react-%E4%B8%AD%E4%BD%95%E4%B8%BA-state)？\n* [你为何排斥 create-react-app](#%E4%BD%A0%E4%B8%BA%E4%BD%95%E6%8E%92%E6%96%A5-create-react-app)？\n* [何为 redux](#%E4%BD%95%E4%B8%BA-redux)？\n* [在 Redux 中，何为 store](#%E5%9C%A8-redux-%E4%B8%AD%E4%BD%95%E4%B8%BA-store)？\n* [何为 action](#%E4%BD%95%E4%B8%BA-action)？\n* [何为 reducer](#%E4%BD%95%E4%B8%BA-reducer)？\n* [Redux Thunk 的作用是什么](#redux-thunk-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)？\n* [何为纯函数(pure function)](#%E4%BD%95%E4%B8%BA%E7%BA%AF%E5%87%BD%E6%95%B0pure-function)？\n* [你喜欢 React 的哪些方面](#%E4%BD%A0%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2)？\n* [你不喜欢 React 的哪些方面](#%E4%BD%A0%E4%B8%8D%E5%96%9C%E6%AC%A2-react-%E7%9A%84%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2)？\n* [示例项目](#%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE)\n\n#### React 的工作原理\nReact 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diff\" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。\n\n#### 使用 React 有何优点\n* 只需查看 `render` 函数就会很容易知道一个组件是如何被渲染的\n* JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的\n* 支持服务端渲染，这可以改进 SEO 和性能\n* 易于测试\n* React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用\n\n#### 展示组件(Presentational component)和容器组件(Container component)之间有何不同\n展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。\n\n容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 `Flux actions`，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。\n\n#### 类组件(Class component)和函数式组件(Functional component)之间有何不同\n* 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 `store` 并维持状态\n* 当组件仅是接收 `props`，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件\n\n#### (组件的)状态(state)和属性(props)之间有何不同\n`State` 是一种数据结构，用于组件挂载时所需数据的默认值。`State` 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。\n\n`Props`(properties 的简写)则是组件的配置。`props` 由父组件传递给子组件，并且就子组件而言，`props` 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。\n\n#### 指出(组件)生命周期方法的不同\n* `componentWillMount` -- 多用于根组件中的应用程序配置\n* `componentDidMount` -- 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成\n* `componentWillReceiveProps` -- 这个周期函数作用于特定的 prop 改变导致的 state 转换\n* `shouldComponentUpdate` -- 如果你担心组件过度渲染，`shouldComponentUpdate` 是一个改善性能的地方，因为如果组件接收了新的 `prop`， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染\n* `componentWillUpdate` -- 很少使用。它可以用于代替组件的 `componentWillReceiveProps` 和 `shouldComponentUpdate`(但不能访问之前的 props)\n* `componentDidUpdate` -- 常用于更新 DOM，响应 prop 或 state 的改变\n* `componentWillUnmount` -- 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器\n\n#### 应该在 React 组件的何处发起 Ajax 请求\n在 React 组件中，应该在 `componentDidMount` 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 `componentDidMount` 中发起网络请求将保证这有一个组件可以更新了。\n\n#### 何为受控组件(controlled component)\n在 HTML 中，类似 `<input>`, `<textarea>` 和 `<select>` 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 `onChange` 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。\n\n#### 在 React 中，refs 的作用是什么\nRefs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。\n\n#### 何为高阶组件(higher order component)\n高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 `connect` 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。\n装饰器@decoration\n练习\n\n<hr />\n\n* 写一个反转其输入的 HOC\n* 写一个从 API 提供数据给传入的组件的 HOC\n* 写一个实现 shouldComponentUpdate 来避免 reconciliation 的 HOC\n* 写一个通过 `React.Children.toArray` 对传入组件的子组件进行排序的 HOC\n\n#### 使用箭头函数(arrow functions)的优点是什么\n* 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 `this` 值(在构造函数中是新对象；在严格模式下，函数调用中的 `this` 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 `this` 值。\n* 简单：箭头函数易于阅读和书写\n* 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 `this` 的值\n\n#### 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象\n因为 `this.props` 和 `this.state` 的更新可能是异步的，不能依赖它们的值去计算下一个 state。\n\n#### 除了在构造函数中绑定 `this`，还有其它方式吗\n你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。\n\n#### 怎么阻止组件的渲染\n在组件的 `render` 方法中返回 `null` 并不会影响触发组件的生命周期方法\n\n#### 当渲染一个列表时，何为 key？设置 key 的目的是什么\nKeys 会有助于 React 识别哪些 `items` 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 `items` 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 `items` 可以重新排序，就会导致 `re-render` 变慢。\n\n#### (在构造函数中)调用 super(props) 的目的是什么\n在 `super()` 被调用之前，子类是不能使用 `this` 的，在 ES2015 中，子类必须在 `constructor` 中调用 `super()`。传递 `props` 给 `super()` 的原因则是便于(在子类中)能在 `constructor` 访问 `this.props`。\n\n#### 何为 JSX\nJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就编程了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。\n\n#### 怎么用 React.createElement 重写下面的代码\n\nQuestion：\n\n```js\nconst element = (\n  <h1 className=\"greeting\">\n    Hello, world!\n  </h1>\n);\n```\n\nAnswer：\n\n```js\nconst element = React.createElement(\n  'h1',\n  {className: 'greeting'},\n  'Hello, world!'\n);\n```\n\n#### 何为 `Children`\n在JSX表达式中，一个开始标签(比如`<a>`)和一个关闭标签(比如`</a>`)之间的内容会作为一个特殊的属性`props.children`被自动传递给包含着它的组件。\n\n这个属性有许多可用的方法，包括 `React.Children.map`，`React.Children.forEach`， `React.Children.count`， `React.Children.only`，`React.Children.toArray`。\n\n#### 在 React 中，何为 state\nState 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。\n\n#### 你为何排斥 create-react-app\n在你排斥之前，你并不能去配置 webpack 或 babel presets。\n\n#### 何为 redux\nRedux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。\n\n#### 在 Redux 中，何为 store\nStore 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：\n\n* 允许通过 `getState()` 访问 state\n* 运行通过 `dispatch(action)` 改变 state\n* 通过 `subscribe(listener)` 注册 listeners\n* 通过 `subscribe(listener)` 返回的函数处理 listeners 的注销\n\n#### 何为 action\nActions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。\n\n#### 何为 reducer\n一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。\n\n#### Redux Thunk 的作用是什么\nRedux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。\n\n#### 何为纯函数(pure function)\n一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。\n\n#### 你喜欢 React 的哪些方面\n...\n\n#### 你不喜欢 React 的哪些方面\n...\n\n#### 示例项目\n* [React Spotify](https://github.com/Pau1fitz/react-spotify)\n* [React Soundcloud](https://github.com/andrewngu/sound-redux)\n\n#### 虚拟dom 普通的js对象\n插入新组件有了key可以帮助react找到映射\n\n#### 事件委托\n每个setState重新渲染整个子树。 如果要压缩性能，请尽可能调用 setState，并使用shouldComponentUpdate 来防止重新渲染大型子树。","tags":["面试"],"categories":["JS"]},{"title":"搭建VPS科学上网","url":"%2FscienceInternet.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/shadowsocks.jpg, Shadowsocks, Shadowsocks %}\n---\n<!-- more -->\n\n{% note info %}\n\n快速搭建Shadowsocks\n\n{% endnote %}\n\n## [购买Vultr服务器](https://www.vultr.com/)\n\n### Vultr服务器价格\n\nVultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题。\n\n最低价格的服务器是512M的内存，每个月500G的流量，只能说99%的情况下完全够用了！\n\n![introduce](http://p33v4b0bc.bkt.clouddn.com/vultr.png)\n\n## 买好中意的地区节点服务器之后，windows系统可以用Xshell ssh连接到服务器，并执行以下搭建ss脚本命令\n\n```javascript\n\nwget --no-check-certificate -O shadowsocks.sh\nhttps://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh\n \nchmod +x shadowsocks.sh\n \n./shadowsocks.sh 2>&1 | tee shadowsocks.log\n\n```\n\n接着按照提示输入密码，端口和加密方式，如下图：\n\n![ss1](http://p33v4b0bc.bkt.clouddn.com/ss1.png)\n\n![ss2](http://p33v4b0bc.bkt.clouddn.com/ss1.png)\n\n然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息。\n\n## 安装ss客户端，配置好上面的服务器配置信息，就可以开心地玩耍了。Chrome插件推荐使用Proxy SwitchySharp来管理和切换代理配置非常好用。\n\nWindows客户端(代理端口默认1080)\nhttps://github.com/shadowsocks/shadowsocks-windows/releases\n\nUbuntu \nsudo add-apt-repository ppa:hzwhuang/ss-qt5 \nsudo apt-get update \nsudo apt-get install shadowsocks-qt5\n\nMac客户端(代理端口默认1086)\n\nhttps://github.com/shadowsocks/ShadowsocksX-NG/releases\n\nAndroid客户端\n\nhttps://github.com/shadowsocks/shadowsocks-android/releases","tags":["vultr"],"categories":["工具"]},{"title":"Promise诞生记","url":"%2FcreatePromise.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/promise.png, Promise, Promise %}\n\n前端近年的兴起，有大部分是因为 `NodeJS` 的诞生，而 `NodeJS` 是个适用于 **异步IO** 密集型的语言，一些基于 `NodeJS` 的框架，比喻 *KOA2、Adonis* 就有大量的 `async` 和 `await` 语法，`async`的函数的返回值就是 `Promise` 对象，我们可以用 `async` 和 `await` 语法，写出优雅的异步代码，来替换难看且难维护的回调函数。\n\n## Promise 概念\n`Promise`是一种对异步操作的封装，主流的规范是Promise/A+。\n`Promise`可以使得异步代码层次清晰，便于理解，且更加容易维护。\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n生成实例时回执信作为参数的函数；<Br/> \n`resolve`函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n`reject`函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n---\n<!-- more -->\n\n```javascript\n// 执行顺序\nlet promise = new Promise(function(resolve, reject) {\n  console.log('Promise'); // 新建后立即执行\n  resolve();\n});\npromise.then(function() {\n  console.log('resolved.'); // 同步任务执行完成后才会执行\n});\nconsole.log('Hi!');\n// Promise\n// Hi!\n// resolved\n```\n接下来我们就用`Promise`结合ajax来使用\n```\nconst getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send(params);\n  });\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\n\n这里我们会渐进式的来创建一个 `Promise` 的实现，如果，你还不了解 `Promise` ，赶快移步 [Promise](http://es6.ruanyifeng.com/#docs/promise) 了解学习，当然这个实现会符合 [Promise/A+](https://promisesaplus.com) 规范，`JavaScript` 中有很多第三方的 `Promise` 库，[bluebird](http://bluebirdjs.com/docs/getting-started.html) 就是一个第三方 `Promise` 类库，相比其它第三方类库或标准对象来说，其有以下优点：功能更齐全而不臃肿、浏览器兼容性更好,大家可以了解下。\n\n---\n\n废话不多说，直接开干。。。 😠\n\n## 定义 Promise 类型\n\n一个简单 `Promise` 语法，如下\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... doSomething\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure 第二个函数可选\n});\n```\n\n### 实现 resolve 和 then\n\n首先我们以上 👆 的语法，自己定义一个 `Promise` 实例\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    callback(value);\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n一个简单的实例写好了，然后，来用一下，看看 👀 结果如何\n\n```javascript\nconst p = new Promise(function(resolve){\n  resolve(66);\n});\n\np.then(function(value){\n  console.log(value);\n});\n\n```\n{% note info %}\n\n执行结果是：`callback is not a function`\n\n{% endnote %}\n\n### 改进1：延时resolve，修改 callback 为异步\n\n**这里就遇到一个问题： **  \n\n** 目前的Promise有一个bug，假如fn中所包含的是同步代码，则resolve会立即执行，`callback` 还是 `null` ，我们的代码是同步的，而不是异步的。</br> 如是，想办法解决掉这个问题，就是利用 `setTimeout` , 把 `callback` 加入异步队列** \n\n代码如下 👇\n\n```javascript\nfunction Promise(fn) {\n  let callback = null;\n  //实现 then 方法 , 先一步一步来，实现传一个参数 -- resolve\n  this.then = function(cb) {\n    callback = cb;\n  };\n\n  //实现 resolve , value:异步操作的最终值\n  function resolve(value) {\n    // 用 setTimeout 把 callback 加入到异步队列，这样就会，先执行 then() 方法\n    setTimeout(function(){\n      callback(value);\n    },0)\n  }\n  //执行 function 参数\n  fn(resolve);\n}\n```\n\n### 改进2：注册多个回调函数，并实现then的链式调用\n\n```javascript\nfunction Promise(fn) {\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    callbackList.push(cb);\n    // 实现链式调用\n    return this\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       // 遍历callbackList数组依次执行\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n### 改进3：引入状态\n\n```javascript\nfunction Promise(fn) {\n  let state='pending'\n  let value = null\n  let callbackList = [];\n  this.then = function(cb) {\n    if(state=='pending'){\n      // pending加入队列\n      callbackList.push(cb);\n      return this\n    }\n    if(state=='fulfilled'){\n      // fulfilled立即执行\n      cb(value)\n      return this\n    }\n  };\n\n  function resolve(newValue) {\n    value = newValue\n    setTimeout(function(){\n       callbackList.forEach((callback)=>{\n         callback(value)\n       })\n    },0)\n  }\n  fn(resolve);\n}\n```\n\n**手动实现一个Promise：**\n```javascript\nclass Promise(){\n  construtor(fn){\n       // 执行队列\n       this._wathcList=[]\n       // 成功\n       this._success_res=null\n       // 失败\n       this._error_res=null\n       this._status=\"success\"\n       fn((...args))=>{\n          // 保存成功数据\n          this._success_res=args\n          this._status='success'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn1(...args);\n          });\n       },(...args)=>{\n          // 保存失败数据\n          this._error_res=args\n          this._status='error'\n          // 若为异步则回头执行then成功方法\n          this._watchList.forEach(element => {\n              element.fn2(...args);\n          });\n       }\n  }\n  // then 函数\n  then(fn1, fn2) {\n      if (this._status === \"success\") {\n          fn1(...this._success_res);\n      } else if (this._status === \"error\") {\n          fn2(...this._error_res);\n      } else {\n          this._watchList.push({\n              fn1,\n              fn2\n          })\n      }\n  }\n}\n```\n**实现Promise.all**\n```javascript\nPromise1.all = function(arr) {\n    // 存放结果集\n    let result = [];\n    return Promise1(function(resolve, reject) {\n        let i = 0;\n        // 进行迭代执行\n        function next() {\n            arr[i].then(function(res) {\n                // 存放每个方法的返回值\n                result.push(res);\n                i++;\n                // 若全部执行完\n                if (i === result.length) {\n                    // 执行then回调\n                    resolve(result);\n                } else {\n                    // 继续迭代\n                    next();\n                }\n            }, reject)\n        }\n    })\n}\n```\n\n## Promise使用注意点\n1. 一般来说，调用`resolve`或`reject`以后，`Promise`的使命就完成了，后继操作应该放到`then`方法里面，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。\n\n2. `Promise`实例具有`then`方法，也就是说，`then`方法是定义在原型对象`Promise.prototype`上的。它的作用是为`Promise`实例添加状态改变时的回调函数。前面说过，`then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。`then`方法返回的是一个新的`Promise`实例（注意，不是原来那个`Promise`实例）。因此可以采用链式写法，即then方法后面再调用另一个`then`方法。\n\n3. `Promise.prototype.catch`方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。`getJSON`方法返回一个`Promise`对象，如果该对象状态变为`resolved`，则会调用`then`方法指定的回调函数；如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。\n\n4. 一般来说，不要在then方法里面定义`reject`状态的回调函数（即then的第二个参数），总是使用`catch`方法。\n\n5. 跟传统的`try/catch`代码块不同的是，如果没有使用`catch`方法指定错误处理的回调函数，`Promise`对象抛出的错误不会传递到外层代码，即不会有任何反应，`Promise`会吃掉错误。\n","tags":["Promise"],"categories":["JS"]},{"title":"如何使用 markdown 语法写博客","url":"%2FmarkdownGrammar.html","content":"\n{% fi http://p33v4b0bc.bkt.clouddn.com/markdown.png, Markdown, Markdown %}\n\n# 标题1\n## 标题2\n*斜体*\n**粗体**\n***粗斜体***<br/>\n~~删除线~~\n<u>下划线文本</u>\n\n1. I\n2. Love \n3. You\n\n- 点\n\n+ Foo\n+ Bar\n---\n<!-- more -->\n\n分隔线\n***\n--- \n___\n\n* * *\n>一级引用\n>>二级引用\n\n`#include<iostream>`\n```\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n```\n~~~\n#include <iostream>\nint main()\n{\nreturn 0;\n}\n~~~\n|标题|标题|标题|\n|:---|:---:|---:|\n|居左测试文本|居中测试文本|居右测试文本|\n|居左测试文本1|居中测试文本2|居右测试文本3|\n|居左测试文本11|居中测试文本22|居右测试文本33|\n|居左测试文本111|居中测试文本222|居右测试文本333|\n\n- [x] 已完成事项\n- [ ] 待办事项1\n- [ ] 待办事项2\n\n### 反斜杠\n\n`Markdown` 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 `<em>` 标签），你可以在星号的前面加上反斜杠：\n```\n\\*literal asterisks\\*\n```\n效果如下：\n\n\\*literal asterisks\\*\n\n`Markdown` 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```\n  \\   反斜线\n  `   反引号\n  *   星号\n  _   底线\n  {}  花括号\n  []  方括号\n  ()  括弧\n  #   井字号\n  +   加号\n  -   减号\n  .   英文句点\n  !   惊叹号\n```\n登录[百度](http://www.baidu.com)\n![Teddy Bear](http://img2.everychina.com/img/d7/f7/1b580dfa9315111397ef93fd24ea-250x250c1-77f7/love_valentine_plush_teddy_bear.jpg)\n","tags":["markdown"],"categories":["工具"]},{"title":"Hello World - 热爱编程的普通人，顺便以此为生。","url":"%2Fhello-world.html","content":"\n之前一直在博客园写博客，但随着技术的发展，博客园的样式和自定义内容远远不能达到我所期望。故此决定迁移博客，希望能总结归纳好自己的技术体系，拓宽拓深技术栈，重新开坑O(∩_∩)O哈哈~。\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n---\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["杂谈"],"categories":["杂谈"]}]